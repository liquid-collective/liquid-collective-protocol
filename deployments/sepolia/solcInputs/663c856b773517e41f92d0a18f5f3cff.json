{
  "language": "Solidity",
  "sources": {
    "contracts/src/Administrable.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\nimport \"./interfaces/IAdministrable.sol\";\n\nimport \"./libraries/LibAdministrable.sol\";\nimport \"./libraries/LibSanitize.sol\";\n\n/// @title Administrable\n/// @author Alluvial Finance Inc.\n/// @notice This contract handles the administration of the contracts\nabstract contract Administrable is IAdministrable {\n    /// @notice Prevents unauthorized calls\n    modifier onlyAdmin() {\n        if (msg.sender != LibAdministrable._getAdmin()) {\n            revert LibErrors.Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    /// @notice Prevents unauthorized calls\n    modifier onlyPendingAdmin() {\n        if (msg.sender != LibAdministrable._getPendingAdmin()) {\n            revert LibErrors.Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    /// @inheritdoc IAdministrable\n    function getAdmin() external view returns (address) {\n        return LibAdministrable._getAdmin();\n    }\n\n    /// @inheritdoc IAdministrable\n    function getPendingAdmin() external view returns (address) {\n        return LibAdministrable._getPendingAdmin();\n    }\n\n    /// @inheritdoc IAdministrable\n    function proposeAdmin(address _newAdmin) external onlyAdmin {\n        _setPendingAdmin(_newAdmin);\n    }\n\n    /// @inheritdoc IAdministrable\n    function acceptAdmin() external onlyPendingAdmin {\n        _setAdmin(LibAdministrable._getPendingAdmin());\n        _setPendingAdmin(address(0));\n    }\n\n    /// @notice Internal utility to set the admin address\n    /// @param _admin Address to set as admin\n    function _setAdmin(address _admin) internal {\n        LibAdministrable._setAdmin(_admin);\n        emit SetAdmin(_admin);\n    }\n\n    /// @notice Internal utility to set the pending admin address\n    /// @param _pendingAdmin Address to set as pending admin\n    function _setPendingAdmin(address _pendingAdmin) internal {\n        LibAdministrable._setPendingAdmin(_pendingAdmin);\n        emit SetPendingAdmin(_pendingAdmin);\n    }\n\n    /// @notice Internal utility to retrieve the address of the current admin\n    /// @return The address of admin\n    function _getAdmin() internal view returns (address) {\n        return LibAdministrable._getAdmin();\n    }\n}\n"
    },
    "contracts/src/components/ConsensusLayerDepositManager.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\nimport \"../interfaces/components/IConsensusLayerDepositManager.1.sol\";\nimport \"../interfaces/IDepositContract.sol\";\n\nimport \"../libraries/LibBytes.sol\";\nimport \"../libraries/LibUint256.sol\";\n\nimport \"../state/river/DepositContractAddress.sol\";\nimport \"../state/river/WithdrawalCredentials.sol\";\nimport \"../state/river/DepositedValidatorCount.sol\";\nimport \"../state/river/BalanceToDeposit.sol\";\nimport \"../state/river/CommittedBalance.sol\";\nimport \"../state/river/KeeperAddress.sol\";\n\n/// @title Consensus Layer Deposit Manager (v1)\n/// @author Alluvial Finance Inc.\n/// @notice This contract handles the interactions with the official deposit contract, funding all validators\n/// @notice Whenever a deposit to the consensus layer is requested, this contract computed the amount of keys\n/// @notice that could be deposited depending on the amount available in the contract. It then tries to retrieve\n/// @notice validator keys by calling its internal virtual method _getNextValidators. This method should be\n/// @notice overridden by the implementing contract to provide [0; _keyCount] keys when invoked.\nabstract contract ConsensusLayerDepositManagerV1 is IConsensusLayerDepositManagerV1 {\n    /// @notice Size of a BLS Public key in bytes\n    uint256 public constant PUBLIC_KEY_LENGTH = 48;\n    /// @notice Size of a BLS Signature in bytes\n    uint256 public constant SIGNATURE_LENGTH = 96;\n    /// @notice Size of a deposit in ETH\n    uint256 public constant DEPOSIT_SIZE = 32 ether;\n\n    /// @notice Handler called to retrieve the internal River admin address\n    /// @dev Must be Overridden\n    function _getRiverAdmin() internal view virtual returns (address);\n\n    /// @notice Handler called to change the committed balance to deposit\n    /// @param newCommittedBalance The new committed balance value\n    function _setCommittedBalance(uint256 newCommittedBalance) internal virtual;\n\n    /// @notice Internal helper to retrieve validator keys ready to be funded\n    /// @dev Must be overridden\n    /// @param _keyCount The amount of keys (or less) to return.\n    function _getNextValidators(uint256 _keyCount)\n        internal\n        virtual\n        returns (bytes[] memory publicKeys, bytes[] memory signatures);\n\n    /// @notice Initializer to set the deposit contract address and the withdrawal credentials to use\n    /// @param _depositContractAddress The address of the deposit contract\n    /// @param _withdrawalCredentials The withdrawal credentials to apply to all deposits\n    function initConsensusLayerDepositManagerV1(address _depositContractAddress, bytes32 _withdrawalCredentials)\n        internal\n    {\n        DepositContractAddress.set(_depositContractAddress);\n        emit SetDepositContractAddress(_depositContractAddress);\n\n        WithdrawalCredentials.set(_withdrawalCredentials);\n        emit SetWithdrawalCredentials(_withdrawalCredentials);\n    }\n\n    function _setKeeper(address _keeper) internal {\n        KeeperAddress.set(_keeper);\n    }\n\n    /// @inheritdoc IConsensusLayerDepositManagerV1\n    function getCommittedBalance() external view returns (uint256) {\n        return CommittedBalance.get();\n    }\n\n    /// @inheritdoc IConsensusLayerDepositManagerV1\n    function getBalanceToDeposit() external view returns (uint256) {\n        return BalanceToDeposit.get();\n    }\n\n    /// @inheritdoc IConsensusLayerDepositManagerV1\n    function getWithdrawalCredentials() external view returns (bytes32) {\n        return WithdrawalCredentials.get();\n    }\n\n    /// @inheritdoc IConsensusLayerDepositManagerV1\n    function getDepositedValidatorCount() external view returns (uint256) {\n        return DepositedValidatorCount.get();\n    }\n\n    /// @inheritdoc IConsensusLayerDepositManagerV1\n    function getKeeper() external view returns (address) {\n        return KeeperAddress.get();\n    }\n\n    /// @inheritdoc IConsensusLayerDepositManagerV1\n    function depositToConsensusLayerWithDepositRoot(uint256 _maxCount, bytes32 _depositRoot) external {\n        if (msg.sender != KeeperAddress.get()) {\n            revert OnlyKeeper();\n        }\n\n        if (IDepositContract(DepositContractAddress.get()).get_deposit_root() != _depositRoot) {\n            revert InvalidDepositRoot();\n        }\n\n        uint256 committedBalance = CommittedBalance.get();\n        uint256 keyToDepositCount = LibUint256.min(committedBalance / DEPOSIT_SIZE, _maxCount);\n\n        if (keyToDepositCount == 0) {\n            revert NotEnoughFunds();\n        }\n\n        // it's up to the internal overriden _getNextValidators method to provide two array of the same\n        // size for the publicKeys and the signatures\n        (bytes[] memory publicKeys, bytes[] memory signatures) = _getNextValidators(keyToDepositCount);\n\n        uint256 receivedPublicKeyCount = publicKeys.length;\n\n        if (receivedPublicKeyCount == 0) {\n            revert NoAvailableValidatorKeys();\n        }\n\n        if (receivedPublicKeyCount > keyToDepositCount) {\n            revert InvalidPublicKeyCount();\n        }\n\n        bytes32 withdrawalCredentials = WithdrawalCredentials.get();\n\n        if (withdrawalCredentials == 0) {\n            revert InvalidWithdrawalCredentials();\n        }\n\n        for (uint256 idx = 0; idx < receivedPublicKeyCount;) {\n            _depositValidator(publicKeys[idx], signatures[idx], withdrawalCredentials);\n            unchecked {\n                ++idx;\n            }\n        }\n        _setCommittedBalance(committedBalance - DEPOSIT_SIZE * receivedPublicKeyCount);\n        uint256 currentDepositedValidatorCount = DepositedValidatorCount.get();\n        DepositedValidatorCount.set(currentDepositedValidatorCount + receivedPublicKeyCount);\n        emit SetDepositedValidatorCount(\n            currentDepositedValidatorCount, currentDepositedValidatorCount + receivedPublicKeyCount\n        );\n    }\n\n    /// @notice Deposits 32 ETH to the official Deposit contract\n    /// @param _publicKey The public key of the validator\n    /// @param _signature The signature provided by the operator\n    /// @param _withdrawalCredentials The withdrawal credentials provided by River\n    function _depositValidator(bytes memory _publicKey, bytes memory _signature, bytes32 _withdrawalCredentials)\n        internal\n    {\n        if (_publicKey.length != PUBLIC_KEY_LENGTH) {\n            revert InconsistentPublicKeys();\n        }\n\n        if (_signature.length != SIGNATURE_LENGTH) {\n            revert InconsistentSignatures();\n        }\n        uint256 value = DEPOSIT_SIZE;\n\n        uint256 depositAmount = value / 1 gwei;\n\n        bytes32 pubkeyRoot = sha256(bytes.concat(_publicKey, bytes16(0)));\n        bytes32 signatureRoot = sha256(\n            bytes.concat(\n                sha256(LibBytes.slice(_signature, 0, 64)),\n                sha256(bytes.concat(LibBytes.slice(_signature, 64, SIGNATURE_LENGTH - 64), bytes32(0)))\n            )\n        );\n\n        bytes32 depositDataRoot = sha256(\n            bytes.concat(\n                sha256(bytes.concat(pubkeyRoot, _withdrawalCredentials)),\n                sha256(bytes.concat(bytes32(LibUint256.toLittleEndian64(depositAmount)), signatureRoot))\n            )\n        );\n\n        uint256 targetBalance = address(this).balance - value;\n\n        IDepositContract(DepositContractAddress.get()).deposit{value: value}(\n            _publicKey, abi.encodePacked(_withdrawalCredentials), _signature, depositDataRoot\n        );\n        if (address(this).balance != targetBalance) {\n            revert ErrorOnDeposit();\n        }\n    }\n}\n"
    },
    "contracts/src/components/OracleManager.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\nimport \"../interfaces/components/IOracleManager.1.sol\";\nimport \"../interfaces/IRedeemManager.1.sol\";\n\nimport \"../libraries/LibUint256.sol\";\n\nimport \"../state/river/LastConsensusLayerReport.sol\";\nimport \"../state/river/OracleAddress.sol\";\nimport \"../state/river/CLValidatorTotalBalance.sol\";\nimport \"../state/river/CLValidatorCount.sol\";\nimport \"../state/river/DepositedValidatorCount.sol\";\nimport \"../state/river/LastOracleRoundId.sol\";\n\n/// @title Oracle Manager (v1)\n/// @author Alluvial Finance Inc.\n/// @notice This contract handles the inputs provided by the oracle\n/// @notice The Oracle contract is plugged to this contract and is in charge of pushing\n/// @notice data whenever a new report has been deemed valid. The report consists in two\n/// @notice values: the sum of all balances of all deposited validators and the count of\n/// @notice validators that have been activated on the consensus layer.\nabstract contract OracleManagerV1 is IOracleManagerV1 {\n    uint256 internal constant ONE_YEAR = 365 days;\n    /// @notice Size of a deposit in ETH\n    uint256 public constant _DEPOSIT_SIZE = 32 ether;\n\n    /// @notice Handler called if the delta between the last and new validator balance sum is positive\n    /// @dev Must be overridden\n    /// @param _profits The positive increase in the validator balance sum (staking rewards)\n    function _onEarnings(uint256 _profits) internal virtual;\n\n    /// @notice Handler called to pull the Execution layer fees from the recipient\n    /// @dev Must be overridden\n    /// @param _max The maximum amount to pull inside the system\n    /// @return The amount pulled inside the system\n    function _pullELFees(uint256 _max) internal virtual returns (uint256);\n\n    /// @notice Handler called to pull the coverage funds\n    /// @dev Must be overridden\n    /// @param _max The maximum amount to pull inside the system\n    /// @return The amount pulled inside the system\n    function _pullCoverageFunds(uint256 _max) internal virtual returns (uint256);\n\n    /// @notice Handler called to retrieve the system administrator address\n    /// @dev Must be overridden\n    /// @return The system administrator address\n    function _getRiverAdmin() internal view virtual returns (address);\n\n    /// @notice Overridden handler called whenever the total balance of ETH is requested\n    /// @return The current total asset balance managed by River\n    function _assetBalance() internal view virtual returns (uint256);\n\n    /// @notice Pulls funds from the Withdraw contract, and adds funds to deposit and redeem balances\n    /// @param _skimmedEthAmount The new amount of skimmed eth to pull\n    /// @param _exitedEthAmount The new amount of exited eth to pull\n    function _pullCLFunds(uint256 _skimmedEthAmount, uint256 _exitedEthAmount) internal virtual;\n\n    /// @notice Pulls funds from the redeem manager exceeding eth buffer\n    /// @param _max The maximum amount to pull\n    /// @return The amount pulled\n    function _pullRedeemManagerExceedingEth(uint256 _max) internal virtual returns (uint256);\n\n    /// @notice Use the balance to redeem to report a withdrawal event on the redeem manager\n    function _reportWithdrawToRedeemManager() internal virtual;\n\n    /// @notice Requests exits of validators after possibly rebalancing deposit and redeem balances\n    /// @param _exitingBalance The currently exiting funds, soon to be received on the execution layer\n    /// @param _depositToRedeemRebalancingAllowed True if rebalancing from deposit to redeem is allowed\n    function _requestExitsBasedOnRedeemDemandAfterRebalancings(\n        uint256 _exitingBalance,\n        uint32[] memory _stoppedValidatorCounts,\n        bool _depositToRedeemRebalancingAllowed,\n        bool _slashingContainmentModeEnabled\n    ) internal virtual;\n\n    /// @notice Skims the redeem balance and sends remaining funds to the deposit balance\n    function _skimExcessBalanceToRedeem() internal virtual;\n\n    /// @notice Commits the deposit balance up to the allowed daily limit\n    /// @param _period The period between current and last report\n    function _commitBalanceToDeposit(uint256 _period) internal virtual;\n\n    /// @notice Prevents unauthorized calls\n    modifier onlyAdmin_OMV1() {\n        if (msg.sender != _getRiverAdmin()) {\n            revert LibErrors.Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    /// @notice Set the initial oracle address\n    /// @param _oracle Address of the oracle\n    function initOracleManagerV1(address _oracle) internal {\n        OracleAddress.set(_oracle);\n        emit SetOracle(_oracle);\n    }\n\n    /// @notice Initializes version 1.1 of the oracle manager\n    /// @param _epochsPerFrame The amounts of epochs in a frame\n    /// @param _slotsPerEpoch The slots inside an epoch\n    /// @param _secondsPerSlot The seconds inside a slot\n    /// @param _genesisTime The genesis timestamp\n    /// @param _epochsToAssumedFinality The number of epochs before an epoch is considered final on-chain\n    /// @param _annualAprUpperBound The reporting upper bound\n    /// @param _relativeLowerBound The reporting lower bound\n    function initOracleManagerV1_1(\n        uint64 _epochsPerFrame,\n        uint64 _slotsPerEpoch,\n        uint64 _secondsPerSlot,\n        uint64 _genesisTime,\n        uint64 _epochsToAssumedFinality,\n        uint256 _annualAprUpperBound,\n        uint256 _relativeLowerBound\n    ) internal {\n        CLSpec.set(\n            CLSpec.CLSpecStruct({\n                epochsPerFrame: _epochsPerFrame,\n                slotsPerEpoch: _slotsPerEpoch,\n                secondsPerSlot: _secondsPerSlot,\n                genesisTime: _genesisTime,\n                epochsToAssumedFinality: _epochsToAssumedFinality\n            })\n        );\n        emit SetSpec(_epochsPerFrame, _slotsPerEpoch, _secondsPerSlot, _genesisTime, _epochsToAssumedFinality);\n        ReportBounds.set(\n            ReportBounds.ReportBoundsStruct({\n                annualAprUpperBound: _annualAprUpperBound,\n                relativeLowerBound: _relativeLowerBound\n            })\n        );\n        emit SetBounds(_annualAprUpperBound, _relativeLowerBound);\n\n        IOracleManagerV1.StoredConsensusLayerReport memory storedReport;\n        storedReport.epoch = uint256(LastOracleRoundId.get());\n        storedReport.validatorsBalance = CLValidatorTotalBalance.get();\n        storedReport.validatorsSkimmedBalance = 0;\n        storedReport.validatorsExitedBalance = 0;\n        storedReport.validatorsExitingBalance = 0;\n        storedReport.validatorsCount = uint32(CLValidatorCount.get());\n        storedReport.rebalanceDepositToRedeemMode = false;\n        storedReport.slashingContainmentMode = false;\n        LastConsensusLayerReport.set(storedReport);\n    }\n\n    /// @inheritdoc IOracleManagerV1\n    function getOracle() external view returns (address) {\n        return OracleAddress.get();\n    }\n\n    /// @inheritdoc IOracleManagerV1\n    function getCLValidatorTotalBalance() external view returns (uint256) {\n        return LastConsensusLayerReport.get().validatorsBalance;\n    }\n\n    /// @inheritdoc IOracleManagerV1\n    function getCLValidatorCount() external view returns (uint256) {\n        return LastConsensusLayerReport.get().validatorsCount;\n    }\n\n    /// @inheritdoc IOracleManagerV1\n    function getExpectedEpochId() external view returns (uint256) {\n        CLSpec.CLSpecStruct memory cls = CLSpec.get();\n        uint256 currentEpoch = _currentEpoch(cls);\n        return LibUint256.max(\n            LastConsensusLayerReport.get().epoch + cls.epochsPerFrame,\n            currentEpoch - (currentEpoch % cls.epochsPerFrame)\n        );\n    }\n\n    /// @inheritdoc IOracleManagerV1\n    function isValidEpoch(uint256 _epoch) external view returns (bool) {\n        return _isValidEpoch(CLSpec.get(), _epoch);\n    }\n\n    /// @inheritdoc IOracleManagerV1\n    function getTime() external view returns (uint256) {\n        return block.timestamp;\n    }\n\n    /// @inheritdoc IOracleManagerV1\n    function getLastCompletedEpochId() external view returns (uint256) {\n        return LastConsensusLayerReport.get().epoch;\n    }\n\n    /// @inheritdoc IOracleManagerV1\n    function getCurrentEpochId() external view returns (uint256) {\n        return _currentEpoch(CLSpec.get());\n    }\n\n    /// @inheritdoc IOracleManagerV1\n    function getCLSpec() external view returns (CLSpec.CLSpecStruct memory) {\n        return CLSpec.get();\n    }\n\n    /// @inheritdoc IOracleManagerV1\n    function getCurrentFrame() external view returns (uint256 _startEpochId, uint256 _startTime, uint256 _endTime) {\n        CLSpec.CLSpecStruct memory cls = CLSpec.get();\n        uint256 currentEpoch = _currentEpoch(cls);\n        _startEpochId = currentEpoch - (currentEpoch % cls.epochsPerFrame);\n        _startTime = _startEpochId * cls.slotsPerEpoch * cls.secondsPerSlot;\n        _endTime = (_startEpochId + cls.epochsPerFrame) * cls.slotsPerEpoch * cls.secondsPerSlot - 1;\n    }\n\n    /// @inheritdoc IOracleManagerV1\n    function getFrameFirstEpochId(uint256 _epochId) external view returns (uint256) {\n        return _epochId - (_epochId % CLSpec.get().epochsPerFrame);\n    }\n\n    /// @inheritdoc IOracleManagerV1\n    function getReportBounds() external view returns (ReportBounds.ReportBoundsStruct memory) {\n        return ReportBounds.get();\n    }\n\n    /// @inheritdoc IOracleManagerV1\n    function getLastConsensusLayerReport() external view returns (IOracleManagerV1.StoredConsensusLayerReport memory) {\n        return LastConsensusLayerReport.get();\n    }\n\n    /// @inheritdoc IOracleManagerV1\n    function setOracle(address _oracleAddress) external onlyAdmin_OMV1 {\n        OracleAddress.set(_oracleAddress);\n        emit SetOracle(_oracleAddress);\n    }\n\n    /// @inheritdoc IOracleManagerV1\n    function setCLSpec(CLSpec.CLSpecStruct calldata _newValue) external onlyAdmin_OMV1 {\n        CLSpec.set(_newValue);\n        emit SetSpec(\n            _newValue.epochsPerFrame,\n            _newValue.slotsPerEpoch,\n            _newValue.secondsPerSlot,\n            _newValue.genesisTime,\n            _newValue.epochsToAssumedFinality\n        );\n    }\n\n    /// @inheritdoc IOracleManagerV1\n    function setReportBounds(ReportBounds.ReportBoundsStruct calldata _newValue) external onlyAdmin_OMV1 {\n        ReportBounds.set(_newValue);\n        emit SetBounds(_newValue.annualAprUpperBound, _newValue.relativeLowerBound);\n    }\n\n    /// @notice Structure holding internal variables used during reporting\n    struct ConsensusLayerDataReportingVariables {\n        uint256 preReportUnderlyingBalance;\n        uint256 postReportUnderlyingBalance;\n        uint256 lastReportExitedBalance;\n        uint256 lastReportSkimmedBalance;\n        uint256 exitedAmountIncrease;\n        uint256 skimmedAmountIncrease;\n        uint256 timeElapsedSinceLastReport;\n        uint256 availableAmountToUpperBound;\n        uint256 redeemManagerDemand;\n        ConsensusLayerDataReportingTrace trace;\n    }\n\n    /// @inheritdoc IOracleManagerV1\n    function setConsensusLayerData(IOracleManagerV1.ConsensusLayerReport calldata _report) external virtual {\n        // only the oracle is allowed to call this endpoint\n        if (msg.sender != OracleAddress.get()) {\n            revert LibErrors.Unauthorized(msg.sender);\n        }\n\n        CLSpec.CLSpecStruct memory cls = CLSpec.get();\n\n        // we start by verifying that the reported epoch is valid based on the consensus layer spec\n        if (!_isValidEpoch(cls, _report.epoch)) {\n            revert InvalidEpoch(_report.epoch);\n        }\n\n        ConsensusLayerDataReportingVariables memory vars;\n\n        {\n            IOracleManagerV1.StoredConsensusLayerReport storage lastStoredReport = LastConsensusLayerReport.get();\n\n            vars.lastReportExitedBalance = lastStoredReport.validatorsExitedBalance;\n\n            // we ensure that the reported total exited balance is not decreasing\n            if (_report.validatorsExitedBalance < vars.lastReportExitedBalance) {\n                revert InvalidDecreasingValidatorsExitedBalance(\n                    vars.lastReportExitedBalance, _report.validatorsExitedBalance\n                );\n            }\n\n            // we compute the exited amount increase by taking the delta between reports\n            vars.exitedAmountIncrease = _report.validatorsExitedBalance - vars.lastReportExitedBalance;\n\n            vars.lastReportSkimmedBalance = lastStoredReport.validatorsSkimmedBalance;\n\n            // we ensure that the reported total skimmed balance is not decreasing\n            if (_report.validatorsSkimmedBalance < vars.lastReportSkimmedBalance) {\n                revert InvalidDecreasingValidatorsSkimmedBalance(\n                    vars.lastReportSkimmedBalance, _report.validatorsSkimmedBalance\n                );\n            }\n\n            // we ensure that the reported validator count is not decreasing\n            if (\n                _report.validatorsCount > DepositedValidatorCount.get()\n                    || _report.validatorsCount < lastStoredReport.validatorsCount\n            ) {\n                revert InvalidValidatorCountReport(\n                    _report.validatorsCount, DepositedValidatorCount.get(), lastStoredReport.validatorsCount\n                );\n            }\n\n            // we compute the new skimmed amount by taking the delta between reports\n            vars.skimmedAmountIncrease = _report.validatorsSkimmedBalance - vars.lastReportSkimmedBalance;\n\n            vars.timeElapsedSinceLastReport = _timeBetweenEpochs(cls, lastStoredReport.epoch, _report.epoch);\n        }\n\n        // we retrieve the current total underlying balance before any reporting data is applied to the system\n        vars.preReportUnderlyingBalance = _assetBalance();\n\n        // if we have new exited / skimmed eth available, we pull funds from the consensus layer recipient\n        if (vars.exitedAmountIncrease + vars.skimmedAmountIncrease > 0) {\n            // this method pulls and updates ethToDeposit / ethToRedeem accordingly\n            _pullCLFunds(vars.skimmedAmountIncrease, vars.exitedAmountIncrease);\n        }\n\n        {\n            // we update the system parameters, this will have an impact on how the total underlying balance is computed\n            IOracleManagerV1.StoredConsensusLayerReport memory storedReport;\n\n            storedReport.epoch = _report.epoch;\n            storedReport.validatorsBalance = _report.validatorsBalance;\n            storedReport.validatorsSkimmedBalance = _report.validatorsSkimmedBalance;\n            storedReport.validatorsExitedBalance = _report.validatorsExitedBalance;\n            storedReport.validatorsExitingBalance = _report.validatorsExitingBalance;\n            storedReport.validatorsCount = _report.validatorsCount;\n            storedReport.rebalanceDepositToRedeemMode = _report.rebalanceDepositToRedeemMode;\n            storedReport.slashingContainmentMode = _report.slashingContainmentMode;\n            LastConsensusLayerReport.set(storedReport);\n        }\n\n        ReportBounds.ReportBoundsStruct memory rb = ReportBounds.get();\n\n        // we compute the maximum allowed increase in balance based on the pre report value\n        uint256 maxIncrease = _maxIncrease(rb, vars.preReportUnderlyingBalance, vars.timeElapsedSinceLastReport);\n\n        // we retrieve the new total underlying balance after system parameters are changed\n        vars.postReportUnderlyingBalance = _assetBalance();\n\n        // we can now compute the earned rewards from the consensus layer balances\n        // in order to properly account for the balance increase, we compare the sums of current balances, skimmed balance and exited balances\n        // we also synthetically increase the current balance by 32 eth per new activated validator, this way we have no discrepency due\n        // to currently activating funds that were not yet accounted in the consensus layer balances\n        if (vars.postReportUnderlyingBalance >= vars.preReportUnderlyingBalance) {\n            // if this happens, we revert and the reporting process is cancelled\n            if (vars.postReportUnderlyingBalance > vars.preReportUnderlyingBalance + maxIncrease) {\n                revert TotalValidatorBalanceIncreaseOutOfBound(\n                    vars.preReportUnderlyingBalance,\n                    vars.postReportUnderlyingBalance,\n                    vars.timeElapsedSinceLastReport,\n                    rb.annualAprUpperBound\n                );\n            }\n\n            // we update the rewards based on the balance delta\n            vars.trace.rewards = vars.postReportUnderlyingBalance - vars.preReportUnderlyingBalance;\n\n            // we update the available amount to upper bound (the amount of eth we can still pull and stay below the upper reporting bound)\n            vars.availableAmountToUpperBound = maxIncrease - vars.trace.rewards;\n        } else {\n            // otherwise if the balance has decreased, we verify that we are not exceeding the lower reporting bound\n\n            // we compute the maximum allowed decrease in balance\n            uint256 maxDecrease = _maxDecrease(rb, vars.preReportUnderlyingBalance);\n\n            // we verify that the bound is not crossed\n            if (\n                vars.postReportUnderlyingBalance\n                    < vars.preReportUnderlyingBalance - LibUint256.min(maxDecrease, vars.preReportUnderlyingBalance)\n            ) {\n                revert TotalValidatorBalanceDecreaseOutOfBound(\n                    vars.preReportUnderlyingBalance,\n                    vars.postReportUnderlyingBalance,\n                    vars.timeElapsedSinceLastReport,\n                    rb.relativeLowerBound\n                );\n            }\n\n            // we update the available amount to upper bound to be equal to the maximum allowed increase plus the negative delta due to the loss\n            vars.availableAmountToUpperBound =\n                maxIncrease + (vars.preReportUnderlyingBalance - vars.postReportUnderlyingBalance);\n        }\n\n        // if we have available amount to upper bound after the reporting values are applied\n        if (vars.availableAmountToUpperBound > 0) {\n            // we pull the funds from the execution layer fee recipient\n            vars.trace.pulledELFees = _pullELFees(vars.availableAmountToUpperBound);\n            // we update the rewards\n            vars.trace.rewards += vars.trace.pulledELFees;\n            // we update the available amount accordingly\n            vars.availableAmountToUpperBound -= vars.trace.pulledELFees;\n        }\n\n        // if we have available amount to upper bound after the execution layer fees are pulled\n        if (vars.availableAmountToUpperBound > 0) {\n            // we pull the funds from the exceeding eth buffer of the redeem manager\n            vars.trace.pulledRedeemManagerExceedingEthBuffer =\n                _pullRedeemManagerExceedingEth(vars.availableAmountToUpperBound);\n            // we update the available amount accordingly\n            vars.availableAmountToUpperBound -= vars.trace.pulledRedeemManagerExceedingEthBuffer;\n        }\n\n        // if we have available amount to upper bound after pulling the exceeding eth buffer, we attempt to pull coverage funds\n        if (vars.availableAmountToUpperBound > 0) {\n            // we pull the funds from the coverage recipient\n            vars.trace.pulledCoverageFunds = _pullCoverageFunds(vars.availableAmountToUpperBound);\n            // we do not update the rewards as coverage is not considered rewards\n            // we do not update the available amount as there are no more pulling actions to perform afterwards\n        }\n\n        // if our rewards are not null, we dispatch the fee to the collector\n        if (vars.trace.rewards > 0) {\n            _onEarnings(vars.trace.rewards);\n        }\n\n        _requestExitsBasedOnRedeemDemandAfterRebalancings(\n            _report.validatorsExitingBalance,\n            _report.stoppedValidatorCountPerOperator,\n            _report.rebalanceDepositToRedeemMode,\n            _report.slashingContainmentMode\n        );\n\n        // we use the updated balanceToRedeem value to report a withdraw event on the redeem manager\n        _reportWithdrawToRedeemManager();\n\n        // if funds are left in the balance to redeem, we move them to the deposit balance\n        _skimExcessBalanceToRedeem();\n\n        // we update the committable amount based on daily maximum allowed\n        _commitBalanceToDeposit(vars.timeElapsedSinceLastReport);\n\n        // we emit a summary event with all the reporting details\n        emit ProcessedConsensusLayerReport(_report, vars.trace);\n    }\n\n    /// @notice Retrieve the current epoch based on the current timestamp\n    /// @param _cls The consensus layer spec struct\n    /// @return The current epoch\n    function _currentEpoch(CLSpec.CLSpecStruct memory _cls) internal view returns (uint256) {\n        return ((block.timestamp - _cls.genesisTime) / _cls.secondsPerSlot) / _cls.slotsPerEpoch;\n    }\n\n    /// @notice Verifies if the given epoch is valid\n    /// @param _cls The consensus layer spec struct\n    /// @param _epoch The epoch to verify\n    /// @return True if valid\n    function _isValidEpoch(CLSpec.CLSpecStruct memory _cls, uint256 _epoch) internal view returns (bool) {\n        return (\n            _currentEpoch(_cls) >= _epoch + _cls.epochsToAssumedFinality\n                && _epoch > LastConsensusLayerReport.get().epoch && _epoch % _cls.epochsPerFrame == 0\n        );\n    }\n\n    /// @notice Retrieves the maximum increase in balance based on current total underlying supply and period since last report\n    /// @param _rb The report bounds struct\n    /// @param _prevTotalEth The total underlying supply during reporting\n    /// @param _timeElapsed The time since last report\n    /// @return The maximum allowed increase in balance\n    function _maxIncrease(ReportBounds.ReportBoundsStruct memory _rb, uint256 _prevTotalEth, uint256 _timeElapsed)\n        internal\n        pure\n        returns (uint256)\n    {\n        return (_prevTotalEth * _rb.annualAprUpperBound * _timeElapsed) / (LibBasisPoints.BASIS_POINTS_MAX * ONE_YEAR);\n    }\n\n    /// @notice Retrieves the maximum decrease in balance based on current total underlying supply\n    /// @param _rb The report bounds struct\n    /// @param _prevTotalEth The total underlying supply during reporting\n    /// @return The maximum allowed decrease in balance\n    function _maxDecrease(ReportBounds.ReportBoundsStruct memory _rb, uint256 _prevTotalEth)\n        internal\n        pure\n        returns (uint256)\n    {\n        return (_prevTotalEth * _rb.relativeLowerBound) / LibBasisPoints.BASIS_POINTS_MAX;\n    }\n\n    /// @notice Retrieve the number of seconds between two epochs\n    /// @param _cls The consensus layer spec struct\n    /// @param _epochPast The starting epoch\n    /// @param _epochNow The current epoch\n    /// @return The number of seconds between the two epochs\n    function _timeBetweenEpochs(CLSpec.CLSpecStruct memory _cls, uint256 _epochPast, uint256 _epochNow)\n        internal\n        pure\n        returns (uint256)\n    {\n        return (_epochNow - _epochPast) * (_cls.secondsPerSlot * _cls.slotsPerEpoch);\n    }\n}\n"
    },
    "contracts/src/components/SharesManager.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\nimport \"../interfaces/components/ISharesManager.1.sol\";\n\nimport \"../libraries/LibSanitize.sol\";\n\nimport \"../state/river/Shares.sol\";\nimport \"../state/river/SharesPerOwner.sol\";\nimport \"../state/shared/ApprovalsPerOwner.sol\";\n\n/// @title Shares Manager (v1)\n/// @author Alluvial Finance Inc.\n/// @notice This contract handles the shares of the depositor and the ERC20 interface\nabstract contract SharesManagerV1 is ISharesManagerV1 {\n    /// @notice Internal hook triggered on the external transfer call\n    /// @dev Must be overridden\n    /// @param _from Address of the sender\n    /// @param _to Address of the recipient\n    function _onTransfer(address _from, address _to) internal view virtual;\n\n    /// @notice Internal method to override to provide the total underlying asset balance\n    /// @dev Must be overridden\n    /// @return The total asset balance of the system\n    function _assetBalance() internal view virtual returns (uint256);\n\n    /// @notice Modifier used to ensure that the transfer is allowed by using the internal hook to perform internal checks\n    /// @param _from Address of the sender\n    /// @param _to Address of the recipient\n    modifier transferAllowed(address _from, address _to) {\n        _onTransfer(_from, _to);\n        _;\n    }\n\n    /// @notice Modifier used to ensure the amount transferred is not 0\n    /// @param _value Amount to check\n    modifier isNotZero(uint256 _value) {\n        if (_value == 0) {\n            revert NullTransfer();\n        }\n        _;\n    }\n\n    /// @notice Modifier used to ensure that the sender has enough funds for the transfer\n    /// @param _owner Address of the sender\n    /// @param _value Value that is required to be sent\n    modifier hasFunds(address _owner, uint256 _value) {\n        if (_balanceOf(_owner) < _value) {\n            revert BalanceTooLow();\n        }\n        _;\n    }\n\n    /// @inheritdoc ISharesManagerV1\n    function name() external pure returns (string memory) {\n        return \"Liquid Staked ETH\";\n    }\n\n    /// @inheritdoc ISharesManagerV1\n    function symbol() external pure returns (string memory) {\n        return \"LsETH\";\n    }\n\n    /// @inheritdoc ISharesManagerV1\n    function decimals() external pure returns (uint8) {\n        return 18;\n    }\n\n    /// @inheritdoc ISharesManagerV1\n    function totalSupply() external view returns (uint256) {\n        return _totalSupply();\n    }\n\n    /// @inheritdoc ISharesManagerV1\n    function totalUnderlyingSupply() external view returns (uint256) {\n        return _assetBalance();\n    }\n\n    /// @inheritdoc ISharesManagerV1\n    function balanceOf(address _owner) external view returns (uint256) {\n        return _balanceOf(_owner);\n    }\n\n    /// @inheritdoc ISharesManagerV1\n    function balanceOfUnderlying(address _owner) public view returns (uint256) {\n        return _balanceFromShares(SharesPerOwner.get(_owner));\n    }\n\n    /// @inheritdoc ISharesManagerV1\n    function underlyingBalanceFromShares(uint256 _shares) external view returns (uint256) {\n        return _balanceFromShares(_shares);\n    }\n\n    /// @inheritdoc ISharesManagerV1\n    function sharesFromUnderlyingBalance(uint256 _underlyingAssetAmount) external view returns (uint256) {\n        return _sharesFromBalance(_underlyingAssetAmount);\n    }\n\n    /// @inheritdoc ISharesManagerV1\n    function allowance(address _owner, address _spender) external view returns (uint256) {\n        return ApprovalsPerOwner.get(_owner, _spender);\n    }\n\n    /// @inheritdoc ISharesManagerV1\n    function transfer(address _to, uint256 _value)\n        external\n        transferAllowed(msg.sender, _to)\n        isNotZero(_value)\n        hasFunds(msg.sender, _value)\n        returns (bool)\n    {\n        if (_to == address(0)) {\n            revert UnauthorizedTransfer(msg.sender, address(0));\n        }\n        return _transfer(msg.sender, _to, _value);\n    }\n\n    /// @inheritdoc ISharesManagerV1\n    function transferFrom(address _from, address _to, uint256 _value)\n        external\n        transferAllowed(_from, _to)\n        isNotZero(_value)\n        hasFunds(_from, _value)\n        returns (bool)\n    {\n        if (_to == address(0)) {\n            revert UnauthorizedTransfer(_from, address(0));\n        }\n        _spendAllowance(_from, _value);\n        return _transfer(_from, _to, _value);\n    }\n\n    /// @inheritdoc ISharesManagerV1\n    function approve(address _spender, uint256 _value) external returns (bool) {\n        _approve(msg.sender, _spender, _value);\n        return true;\n    }\n\n    /// @inheritdoc ISharesManagerV1\n    function increaseAllowance(address _spender, uint256 _additionalValue) external returns (bool) {\n        _approve(msg.sender, _spender, ApprovalsPerOwner.get(msg.sender, _spender) + _additionalValue);\n        return true;\n    }\n\n    /// @inheritdoc ISharesManagerV1\n    function decreaseAllowance(address _spender, uint256 _subtractableValue) external returns (bool) {\n        _approve(msg.sender, _spender, ApprovalsPerOwner.get(msg.sender, _spender) - _subtractableValue);\n        return true;\n    }\n\n    /// @notice Internal utility to spend the allowance of an account from the message sender\n    /// @param _from Address owning the allowance\n    /// @param _value Amount of allowance in shares to spend\n    function _spendAllowance(address _from, uint256 _value) internal {\n        uint256 currentAllowance = ApprovalsPerOwner.get(_from, msg.sender);\n        if (currentAllowance < _value) {\n            revert AllowanceTooLow(_from, msg.sender, currentAllowance, _value);\n        }\n        if (currentAllowance != type(uint256).max) {\n            unchecked {\n                _approve(_from, msg.sender, currentAllowance - _value);\n            }\n        }\n    }\n\n    /// @notice Internal utility to change the allowance of an owner to a spender\n    /// @param _owner The owner of the shares\n    /// @param _spender The allowed spender of the shares\n    /// @param _value The new allowance value\n    function _approve(address _owner, address _spender, uint256 _value) internal {\n        LibSanitize._notZeroAddress(_owner);\n        LibSanitize._notZeroAddress(_spender);\n        ApprovalsPerOwner.set(_owner, _spender, _value);\n        emit Approval(_owner, _spender, _value);\n    }\n\n    /// @notice Internal utility to retrieve the total supply of tokens\n    /// @return The total supply\n    function _totalSupply() internal view returns (uint256) {\n        return Shares.get();\n    }\n\n    /// @notice Internal utility to perform an unchecked transfer\n    /// @param _from Address sending the tokens\n    /// @param _to Address receiving the tokens\n    /// @param _value Amount of shares to be sent\n    /// @return True if success\n    function _transfer(address _from, address _to, uint256 _value) internal returns (bool) {\n        SharesPerOwner.set(_from, SharesPerOwner.get(_from) - _value);\n        SharesPerOwner.set(_to, SharesPerOwner.get(_to) + _value);\n\n        emit Transfer(_from, _to, _value);\n\n        return true;\n    }\n\n    /// @notice Internal utility to retrieve the underlying asset balance for the given shares\n    /// @param _shares Amount of shares to convert\n    /// @return The balance from the given shares\n    function _balanceFromShares(uint256 _shares) internal view returns (uint256) {\n        uint256 _totalSharesValue = Shares.get();\n\n        if (_totalSharesValue == 0) {\n            return 0;\n        }\n\n        return ((_shares * _assetBalance())) / _totalSharesValue;\n    }\n\n    /// @notice Internal utility to retrieve the shares count for a given underlying asset amount\n    /// @param _balance Amount of underlying asset balance to convert\n    /// @return The shares from the given balance\n    function _sharesFromBalance(uint256 _balance) internal view returns (uint256) {\n        uint256 _totalUnderlyingSupply = _assetBalance();\n\n        if (_totalUnderlyingSupply == 0) {\n            return 0;\n        }\n\n        return (_balance * Shares.get()) / _totalUnderlyingSupply;\n    }\n\n    /// @notice Internal utility to mint shares for the specified user\n    /// @dev This method assumes that funds received are now part of the _assetBalance()\n    /// @param _owner Account that should receive the new shares\n    /// @param _underlyingAssetValue Value of underlying asset received, to convert into shares\n    /// @return sharesToMint The amnount of minted shares\n    function _mintShares(address _owner, uint256 _underlyingAssetValue) internal returns (uint256 sharesToMint) {\n        uint256 oldTotalAssetBalance = _assetBalance() - _underlyingAssetValue;\n        uint256 tSupply = _totalSupply();\n\n        if (oldTotalAssetBalance == 0 || tSupply == 0) {\n            sharesToMint = _underlyingAssetValue;\n            _mintRawShares(_owner, _underlyingAssetValue);\n        } else {\n            sharesToMint = (_underlyingAssetValue * tSupply) / oldTotalAssetBalance;\n            _mintRawShares(_owner, sharesToMint);\n        }\n    }\n\n    /// @notice Internal utility to retrieve the amount of shares per owner\n    /// @param _owner Account to be checked\n    /// @return The balance of the account in shares\n    function _balanceOf(address _owner) internal view returns (uint256) {\n        return SharesPerOwner.get(_owner);\n    }\n\n    /// @notice Internal utility to mint shares without any conversion, and emits a mint Transfer event\n    /// @param _owner Account that should receive the new shares\n    /// @param _value Amount of shares to mint\n    function _mintRawShares(address _owner, uint256 _value) internal {\n        _setTotalSupply(Shares.get() + _value);\n        SharesPerOwner.set(_owner, SharesPerOwner.get(_owner) + _value);\n        emit Transfer(address(0), _owner, _value);\n    }\n\n    /// @notice Internal utility to burn shares without any conversion, and emits a burn Transfer event\n    /// @param _owner Account that should burn its shares\n    /// @param _value Amount of shares to burn\n    function _burnRawShares(address _owner, uint256 _value) internal {\n        _setTotalSupply(Shares.get() - _value);\n        SharesPerOwner.set(_owner, SharesPerOwner.get(_owner) - _value);\n        emit Transfer(_owner, address(0), _value);\n    }\n\n    /// @notice Internal utility to set the total supply and emit an event\n    /// @param newTotalSupply The new total supply value\n    function _setTotalSupply(uint256 newTotalSupply) internal {\n        Shares.set(newTotalSupply);\n        emit SetTotalSupply(newTotalSupply);\n    }\n}\n"
    },
    "contracts/src/components/UserDepositManager.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\nimport \"../interfaces/components/IUserDepositManager.1.sol\";\n\nimport \"../libraries/LibSanitize.sol\";\n\nimport \"../state/river/BalanceToDeposit.sol\";\n\n/// @title User Deposit Manager (v1)\n/// @author Alluvial Finance Inc.\n/// @notice This contract handles the inbound transfers cases or the explicit submissions\nabstract contract UserDepositManagerV1 is IUserDepositManagerV1 {\n    /// @notice Handler called whenever a user has sent funds to the contract\n    /// @dev Must be overridden\n    /// @param _depositor Address that made the deposit\n    /// @param _recipient Address that receives the minted shares\n    /// @param _amount Amount deposited\n    function _onDeposit(address _depositor, address _recipient, uint256 _amount) internal virtual;\n    function _setBalanceToDeposit(uint256 newBalanceToDeposit) internal virtual;\n\n    /// @inheritdoc IUserDepositManagerV1\n    function deposit() external payable {\n        _deposit(msg.sender);\n    }\n\n    /// @inheritdoc IUserDepositManagerV1\n    function depositAndTransfer(address _recipient) external payable {\n        LibSanitize._notZeroAddress(_recipient);\n        _deposit(_recipient);\n    }\n\n    /// @inheritdoc IUserDepositManagerV1\n    receive() external payable {\n        _deposit(msg.sender);\n    }\n\n    /// @inheritdoc IUserDepositManagerV1\n    fallback() external payable {\n        revert LibErrors.InvalidCall();\n    }\n\n    /// @notice Internal utility calling the deposit handler and emitting the deposit details\n    /// @param _recipient The account receiving the minted shares\n    function _deposit(address _recipient) internal {\n        if (msg.value == 0) {\n            revert EmptyDeposit();\n        }\n\n        _setBalanceToDeposit(BalanceToDeposit.get() + msg.value);\n\n        _onDeposit(msg.sender, _recipient, msg.value);\n\n        emit UserDeposit(msg.sender, _recipient, msg.value);\n    }\n}\n"
    },
    "contracts/src/Initializable.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\nimport \"./state/shared/Version.sol\";\n\n/// @title Initializable\n/// @author Alluvial Finance Inc.\n/// @notice This contract ensures that initializers are called only once per version\ncontract Initializable {\n    /// @notice Disable initialization on implementations\n    constructor() {\n        Version.set(type(uint256).max);\n        emit Initialize(type(uint256).max, msg.data);\n    }\n\n    /// @notice An error occured during the initialization\n    /// @param version The version that was attempting to be initialized\n    /// @param expectedVersion The version that was expected\n    error InvalidInitialization(uint256 version, uint256 expectedVersion);\n\n    /// @notice Emitted when the contract is properly initialized\n    /// @param version New version of the contracts\n    /// @param cdata Complete calldata that was used during the initialization\n    event Initialize(uint256 version, bytes cdata);\n\n    /// @notice Use this modifier on initializers along with a hard-coded version number\n    /// @param _version Version to initialize\n    modifier init(uint256 _version) {\n        if (_version != Version.get()) {\n            revert InvalidInitialization(_version, Version.get());\n        }\n        Version.set(_version + 1); // prevents reentrency on the called method\n        _;\n        emit Initialize(_version, msg.data);\n    }\n}\n"
    },
    "contracts/src/interfaces/components/IConsensusLayerDepositManager.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\n/// @title Consensys Layer Deposit Manager Interface (v1)\n/// @author Alluvial Finance Inc.\n/// @notice This interface exposes methods to handle the interactions with the official deposit contract\ninterface IConsensusLayerDepositManagerV1 {\n    /// @notice The stored deposit contract address changed\n    /// @param depositContract Address of the deposit contract\n    event SetDepositContractAddress(address indexed depositContract);\n\n    /// @notice The stored withdrawal credentials changed\n    /// @param withdrawalCredentials The withdrawal credentials to use for deposits\n    event SetWithdrawalCredentials(bytes32 withdrawalCredentials);\n\n    /// @notice Emitted when the deposited validator count is updated\n    /// @param oldDepositedValidatorCount The old deposited validator count value\n    /// @param newDepositedValidatorCount The new deposited validator count value\n    event SetDepositedValidatorCount(uint256 oldDepositedValidatorCount, uint256 newDepositedValidatorCount);\n\n    /// @notice Not enough funds to deposit one validator\n    error NotEnoughFunds();\n\n    /// @notice The length of the BLS Public key is invalid during deposit\n    error InconsistentPublicKeys();\n\n    /// @notice The length of the BLS Signature is invalid during deposit\n    error InconsistentSignatures();\n\n    /// @notice The internal key retrieval returned no keys\n    error NoAvailableValidatorKeys();\n\n    /// @notice The received count of public keys to deposit is invalid\n    error InvalidPublicKeyCount();\n\n    /// @notice The received count of signatures to deposit is invalid\n    error InvalidSignatureCount();\n\n    /// @notice The withdrawal credentials value is null\n    error InvalidWithdrawalCredentials();\n\n    /// @notice An error occured during the deposit\n    error ErrorOnDeposit();\n\n    /// @notice Invalid deposit root\n    error InvalidDepositRoot();\n\n    // @notice Not keeper\n    error OnlyKeeper();\n\n    /// @notice Returns the amount of ETH not yet committed for deposit\n    /// @return The amount of ETH not yet committed for deposit\n    function getBalanceToDeposit() external view returns (uint256);\n\n    /// @notice Returns the amount of ETH committed for deposit\n    /// @return The amount of ETH committed for deposit\n    function getCommittedBalance() external view returns (uint256);\n\n    /// @notice Retrieve the withdrawal credentials\n    /// @return The withdrawal credentials\n    function getWithdrawalCredentials() external view returns (bytes32);\n\n    /// @notice Get the deposited validator count (the count of deposits made by the contract)\n    /// @return The deposited validator count\n    function getDepositedValidatorCount() external view returns (uint256);\n\n    /// @notice Get the keeper address\n    /// @return The keeper address\n    function getKeeper() external view returns (address);\n\n    /// @notice Deposits current balance to the Consensus Layer by batches of 32 ETH\n    /// @param _maxCount The maximum amount of validator keys to fund\n    /// @param _depositRoot The root of the deposit tree\n    function depositToConsensusLayerWithDepositRoot(uint256 _maxCount, bytes32 _depositRoot) external;\n}\n"
    },
    "contracts/src/interfaces/components/IOracleManager.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\nimport \"../../state/river/CLSpec.sol\";\nimport \"../../state/river/ReportBounds.sol\";\n\n/// @title Oracle Manager (v1)\n/// @author Alluvial Finance Inc.\n/// @notice This interface exposes methods to handle the inputs provided by the oracle\ninterface IOracleManagerV1 {\n    /// @notice The stored oracle address changed\n    /// @param oracleAddress The new oracle address\n    event SetOracle(address indexed oracleAddress);\n\n    /// @notice The consensus layer data provided by the oracle has been updated\n    /// @param validatorCount The new count of validators running on the consensus layer\n    /// @param validatorTotalBalance The new total balance sum of all validators\n    /// @param roundId Round identifier\n    event ConsensusLayerDataUpdate(uint256 validatorCount, uint256 validatorTotalBalance, bytes32 roundId);\n\n    /// @notice The Consensus Layer Spec is changed\n    /// @param epochsPerFrame The number of epochs inside a frame\n    /// @param slotsPerEpoch The number of slots inside an epoch\n    /// @param secondsPerSlot The number of seconds inside a slot\n    /// @param genesisTime The genesis timestamp\n    /// @param epochsToAssumedFinality The number of epochs before an epoch is considered final\n    event SetSpec(\n        uint64 epochsPerFrame,\n        uint64 slotsPerEpoch,\n        uint64 secondsPerSlot,\n        uint64 genesisTime,\n        uint64 epochsToAssumedFinality\n    );\n\n    /// @notice The Report Bounds are changed\n    /// @param annualAprUpperBound The reporting upper bound\n    /// @param relativeLowerBound The reporting lower bound\n    event SetBounds(uint256 annualAprUpperBound, uint256 relativeLowerBound);\n\n    /// @notice The provided report has beend processed\n    /// @param report The report that was provided\n    /// @param trace The trace structure providing more insights on internals\n    event ProcessedConsensusLayerReport(\n        IOracleManagerV1.ConsensusLayerReport report, ConsensusLayerDataReportingTrace trace\n    );\n\n    /// @notice The reported validator count is invalid\n    /// @param providedValidatorCount The received validator count value\n    /// @param depositedValidatorCount The number of deposits performed by the system\n    /// @param lastReportedValidatorCount The last reported validator count\n    error InvalidValidatorCountReport(\n        uint256 providedValidatorCount, uint256 depositedValidatorCount, uint256 lastReportedValidatorCount\n    );\n\n    /// @notice Thrown when an invalid epoch was reported\n    /// @param epoch Invalid epoch\n    error InvalidEpoch(uint256 epoch);\n\n    /// @notice The balance increase is higher than the maximum allowed by the upper bound\n    /// @param prevTotalEthIncludingExited The previous total balance, including all exited balance\n    /// @param postTotalEthIncludingExited The post-report total balance, including all exited balance\n    /// @param timeElapsed The time in seconds since last report\n    /// @param annualAprUpperBound The upper bound value that was used\n    error TotalValidatorBalanceIncreaseOutOfBound(\n        uint256 prevTotalEthIncludingExited,\n        uint256 postTotalEthIncludingExited,\n        uint256 timeElapsed,\n        uint256 annualAprUpperBound\n    );\n\n    /// @notice The balance decrease is higher than the maximum allowed by the lower bound\n    /// @param prevTotalEthIncludingExited The previous total balance, including all exited balance\n    /// @param postTotalEthIncludingExited The post-report total balance, including all exited balance\n    /// @param timeElapsed The time in seconds since last report\n    /// @param relativeLowerBound The lower bound value that was used\n    error TotalValidatorBalanceDecreaseOutOfBound(\n        uint256 prevTotalEthIncludingExited,\n        uint256 postTotalEthIncludingExited,\n        uint256 timeElapsed,\n        uint256 relativeLowerBound\n    );\n\n    /// @notice The total exited balance decreased\n    /// @param currentValidatorsExitedBalance The current exited balance\n    /// @param newValidatorsExitedBalance The new exited balance\n    error InvalidDecreasingValidatorsExitedBalance(\n        uint256 currentValidatorsExitedBalance, uint256 newValidatorsExitedBalance\n    );\n\n    /// @notice The total skimmed balance decreased\n    /// @param currentValidatorsSkimmedBalance The current exited balance\n    /// @param newValidatorsSkimmedBalance The new exited balance\n    error InvalidDecreasingValidatorsSkimmedBalance(\n        uint256 currentValidatorsSkimmedBalance, uint256 newValidatorsSkimmedBalance\n    );\n\n    /// @notice Trace structure emitted via logs during reporting\n    struct ConsensusLayerDataReportingTrace {\n        uint256 rewards;\n        uint256 pulledELFees;\n        uint256 pulledRedeemManagerExceedingEthBuffer;\n        uint256 pulledCoverageFunds;\n    }\n\n    /// @notice The format of the oracle report\n    struct ConsensusLayerReport {\n        // this is the epoch at which the report was performed\n        // data should be fetched up to the state of this epoch by the oracles\n        uint256 epoch;\n        // the sum of all the validator balances on the consensus layer\n        // when a validator enters the exit queue, the validator is considered stopped, its balance is accounted in both validatorsExitingBalance and validatorsBalance\n        // when a validator leaves the exit queue and the funds are sweeped onto the execution layer, the balance is only accounted in validatorsExitedBalance and not in validatorsBalance\n        // this value can decrease between reports\n        uint256 validatorsBalance;\n        // the sum of all the skimmings performed on the validators\n        // these values can be found in the execution layer block bodies under the withdrawals field\n        // a withdrawal is considered skimming if\n        // - the epoch at which it happened is < validator.withdrawableEpoch\n        // - the epoch at which it happened is >= validator.withdrawableEpoch and in that case we only account for what would be above 32 eth as skimming\n        // this value cannot decrease over reports\n        uint256 validatorsSkimmedBalance;\n        // the sum of all the exits performed on the validators\n        // these values can be found in the execution layer block bodies under the withdrawals field\n        // a withdrawal is considered exit if\n        // - the epoch at which it happened is >= validator.withdrawableEpoch and in that case we only account for what would be <= 32 eth as exit\n        // this value cannot decrease over reports\n        uint256 validatorsExitedBalance;\n        // the sum of all the exiting balance, which is all the validators on their way to get sweeped and exited\n        // this includes voluntary exits and slashings\n        // this value can decrease between reports\n        uint256 validatorsExitingBalance;\n        // the count of activated validators\n        // even validators that are exited are still accounted\n        // this value cannot decrease over reports\n        uint32 validatorsCount;\n        // an array containing the count of stopped validators per operator\n        // the first element of the array is the sum of all stopped validators\n        // then index 1 would be operator 0\n        // these values cannot decrease over reports\n        uint32[] stoppedValidatorCountPerOperator;\n        // flag enabled by the oracles when the buffer rebalancing is activated\n        // the activation logic is written in the oracle specification and all oracle members must agree on the activation\n        // when active, the eth in the deposit buffer can be used to pay for exits in the redeem manager\n        bool rebalanceDepositToRedeemMode;\n        // flag enabled by the oracles when the slashing containment is activated\n        // the activation logic is written in the oracle specification and all oracle members must agree on the activation\n        // This flag is activated when a pre-defined threshold of slashed validators in our set of validators is reached\n        // This flag is deactivated when a bottom threshold is met, this means that when we reach the upper threshold and activate the flag, we will deactivate it when we reach the bottom threshold and not before\n        // when active, no more validator exits can be requested by the protocol\n        bool slashingContainmentMode;\n    }\n\n    /// @notice The format of the oracle report in storage\n    /// @notice These fields have the exact same function as the ones in ConsensusLayerReport, but this struct is optimized for storage\n    struct StoredConsensusLayerReport {\n        uint256 epoch;\n        uint256 validatorsBalance;\n        uint256 validatorsSkimmedBalance;\n        uint256 validatorsExitedBalance;\n        uint256 validatorsExitingBalance;\n        uint32 validatorsCount;\n        bool rebalanceDepositToRedeemMode;\n        bool slashingContainmentMode;\n    }\n\n    /// @notice Get oracle address\n    /// @return The oracle address\n    function getOracle() external view returns (address);\n\n    /// @notice Get CL validator total balance\n    /// @return The CL Validator total balance\n    function getCLValidatorTotalBalance() external view returns (uint256);\n\n    /// @notice Get CL validator count (the amount of validator reported by the oracles)\n    /// @return The CL validator count\n    function getCLValidatorCount() external view returns (uint256);\n\n    /// @notice Verifies if the provided epoch is valid\n    /// @param epoch The epoch to lookup\n    /// @return True if valid\n    function isValidEpoch(uint256 epoch) external view returns (bool);\n\n    /// @notice Retrieve the block timestamp\n    /// @return The current timestamp from the EVM context\n    function getTime() external view returns (uint256);\n\n    /// @notice Retrieve expected epoch id\n    /// @return The current expected epoch id\n    function getExpectedEpochId() external view returns (uint256);\n\n    /// @notice Retrieve the last completed epoch id\n    /// @return The last completed epoch id\n    function getLastCompletedEpochId() external view returns (uint256);\n\n    /// @notice Retrieve the current epoch id based on block timestamp\n    /// @return The current epoch id\n    function getCurrentEpochId() external view returns (uint256);\n\n    /// @notice Retrieve the current cl spec\n    /// @return The Consensus Layer Specification\n    function getCLSpec() external view returns (CLSpec.CLSpecStruct memory);\n\n    /// @notice Retrieve the current frame details\n    /// @return _startEpochId The epoch at the beginning of the frame\n    /// @return _startTime The timestamp of the beginning of the frame in seconds\n    /// @return _endTime The timestamp of the end of the frame in seconds\n    function getCurrentFrame() external view returns (uint256 _startEpochId, uint256 _startTime, uint256 _endTime);\n\n    /// @notice Retrieve the first epoch id of the frame of the provided epoch id\n    /// @param _epochId Epoch id used to get the frame\n    /// @return The first epoch id of the frame containing the given epoch id\n    function getFrameFirstEpochId(uint256 _epochId) external view returns (uint256);\n\n    /// @notice Retrieve the report bounds\n    /// @return The report bounds\n    function getReportBounds() external view returns (ReportBounds.ReportBoundsStruct memory);\n\n    /// @notice Retrieve the last consensus layer report\n    /// @return The stored consensus layer report\n    function getLastConsensusLayerReport() external view returns (IOracleManagerV1.StoredConsensusLayerReport memory);\n\n    /// @notice Set the oracle address\n    /// @param _oracleAddress Address of the oracle\n    function setOracle(address _oracleAddress) external;\n\n    /// @notice Set the consensus layer spec\n    /// @param _newValue The new consensus layer spec value\n    function setCLSpec(CLSpec.CLSpecStruct calldata _newValue) external;\n\n    /// @notice Set the report bounds\n    /// @param _newValue The new report bounds value\n    function setReportBounds(ReportBounds.ReportBoundsStruct calldata _newValue) external;\n\n    /// @notice Performs all the reporting logics\n    /// @param _report The consensus layer report structure\n    function setConsensusLayerData(ConsensusLayerReport calldata _report) external;\n}\n"
    },
    "contracts/src/interfaces/components/ISharesManager.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\n\n/// @title Shares Manager Interface (v1)\n/// @author Alluvial Finance Inc.\n/// @notice This interface exposes methods to handle the shares of the depositor and the ERC20 interface\ninterface ISharesManagerV1 is IERC20 {\n    /// @notice Emitted when the total supply is changed\n    event SetTotalSupply(uint256 totalSupply);\n\n    /// @notice Balance too low to perform operation\n    error BalanceTooLow();\n\n    /// @notice Allowance too low to perform operation\n    /// @param _from Account where funds are sent from\n    /// @param _operator Account attempting the transfer\n    /// @param _allowance Current allowance\n    /// @param _value Requested transfer value in shares\n    error AllowanceTooLow(address _from, address _operator, uint256 _allowance, uint256 _value);\n\n    /// @notice Invalid empty transfer\n    error NullTransfer();\n\n    /// @notice Invalid transfer recipients\n    /// @param _from Account sending the funds in the invalid transfer\n    /// @param _to Account receiving the funds in the invalid transfer\n    error UnauthorizedTransfer(address _from, address _to);\n\n    /// @notice Retrieve the token name\n    /// @return The token name\n    function name() external pure returns (string memory);\n\n    /// @notice Retrieve the token symbol\n    /// @return The token symbol\n    function symbol() external pure returns (string memory);\n\n    /// @notice Retrieve the decimal count\n    /// @return The decimal count\n    function decimals() external pure returns (uint8);\n\n    /// @notice Retrieve the total token supply\n    /// @return The total supply in shares\n    function totalSupply() external view returns (uint256);\n\n    /// @notice Retrieve the total underlying asset supply\n    /// @return The total underlying asset supply\n    function totalUnderlyingSupply() external view returns (uint256);\n\n    /// @notice Retrieve the balance of an account\n    /// @param _owner Address to be checked\n    /// @return The balance of the account in shares\n    function balanceOf(address _owner) external view returns (uint256);\n\n    /// @notice Retrieve the underlying asset balance of an account\n    /// @param _owner Address to be checked\n    /// @return The underlying balance of the account\n    function balanceOfUnderlying(address _owner) external view returns (uint256);\n\n    /// @notice Retrieve the underlying asset balance from an amount of shares\n    /// @param _shares Amount of shares to convert\n    /// @return The underlying asset balance represented by the shares\n    function underlyingBalanceFromShares(uint256 _shares) external view returns (uint256);\n\n    /// @notice Retrieve the shares count from an underlying asset amount\n    /// @param _underlyingAssetAmount Amount of underlying asset to convert\n    /// @return The amount of shares worth the underlying asset amopunt\n    function sharesFromUnderlyingBalance(uint256 _underlyingAssetAmount) external view returns (uint256);\n\n    /// @notice Retrieve the allowance value for a spender\n    /// @param _owner Address that issued the allowance\n    /// @param _spender Address that received the allowance\n    /// @return The allowance in shares for a given spender\n    function allowance(address _owner, address _spender) external view returns (uint256);\n\n    /// @notice Performs a transfer from the message sender to the provided account\n    /// @param _to Address receiving the tokens\n    /// @param _value Amount of shares to be sent\n    /// @return True if success\n    function transfer(address _to, uint256 _value) external returns (bool);\n\n    /// @notice Performs a transfer between two recipients\n    /// @param _from Address sending the tokens\n    /// @param _to Address receiving the tokens\n    /// @param _value Amount of shares to be sent\n    /// @return True if success\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\n\n    /// @notice Approves an account for future spendings\n    /// @dev An approved account can use transferFrom to transfer funds on behalf of the token owner\n    /// @param _spender Address that is allowed to spend the tokens\n    /// @param _value The allowed amount in shares, will override previous value\n    /// @return True if success\n    function approve(address _spender, uint256 _value) external returns (bool);\n\n    /// @notice Increase allowance to another account\n    /// @param _spender Spender that receives the allowance\n    /// @param _additionalValue Amount of shares to add\n    /// @return True if success\n    function increaseAllowance(address _spender, uint256 _additionalValue) external returns (bool);\n\n    /// @notice Decrease allowance to another account\n    /// @param _spender Spender that receives the allowance\n    /// @param _subtractableValue Amount of shares to subtract\n    /// @return True if success\n    function decreaseAllowance(address _spender, uint256 _subtractableValue) external returns (bool);\n}\n"
    },
    "contracts/src/interfaces/components/IUserDepositManager.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\n/// @title User Deposit Manager (v1)\n/// @author Alluvial Finance Inc.\n/// @notice This interface exposes methods to handle the inbound transfers cases or the explicit submissions\ninterface IUserDepositManagerV1 {\n    /// @notice User deposited ETH in the system\n    /// @param depositor Address performing the deposit\n    /// @param recipient Address receiving the minted shares\n    /// @param amount Amount in ETH deposited\n    event UserDeposit(address indexed depositor, address indexed recipient, uint256 amount);\n\n    /// @notice And empty deposit attempt was made\n    error EmptyDeposit();\n\n    /// @notice Explicit deposit method to mint on msg.sender\n    function deposit() external payable;\n\n    /// @notice Explicit deposit method to mint on msg.sender and transfer to _recipient\n    /// @param _recipient Address receiving the minted LsETH\n    function depositAndTransfer(address _recipient) external payable;\n\n    /// @notice Implicit deposit method, when the user performs a regular transfer to the contract\n    receive() external payable;\n\n    /// @notice Invalid call, when the user sends a transaction with a data payload but no method matched\n    fallback() external payable;\n}\n"
    },
    "contracts/src/interfaces/IAdministrable.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\n/// @title Administrable Interface\n/// @author Alluvial Finance Inc.\n/// @notice This interface exposes methods to handle the ownership of the contracts\ninterface IAdministrable {\n    /// @notice The pending admin address changed\n    /// @param pendingAdmin New pending admin address\n    event SetPendingAdmin(address indexed pendingAdmin);\n\n    /// @notice The admin address changed\n    /// @param admin New admin address\n    event SetAdmin(address indexed admin);\n\n    /// @notice Retrieves the current admin address\n    /// @return The admin address\n    function getAdmin() external view returns (address);\n\n    /// @notice Retrieve the current pending admin address\n    /// @return The pending admin address\n    function getPendingAdmin() external view returns (address);\n\n    /// @notice Proposes a new address as admin\n    /// @dev This security prevents setting an invalid address as an admin. The pending\n    /// @dev admin has to claim its ownership of the contract, and prove that the new\n    /// @dev address is able to perform regular transactions.\n    /// @param _newAdmin New admin address\n    function proposeAdmin(address _newAdmin) external;\n\n    /// @notice Accept the transfer of ownership\n    /// @dev Only callable by the pending admin. Resets the pending admin if succesful.\n    function acceptAdmin() external;\n}\n"
    },
    "contracts/src/interfaces/IAllowlist.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\n/// @title Allowlist Interface (v1)\n/// @author Alluvial Finance Inc.\n/// @notice This interface exposes methods to handle the list of allowed recipients.\ninterface IAllowlistV1 {\n    /// @notice The permissions of several accounts have changed\n    /// @param accounts List of accounts\n    /// @param permissions New permissions for each account at the same index\n    event SetAllowlistPermissions(address[] accounts, uint256[] permissions);\n\n    /// @notice The stored allower address has been changed\n    /// @param allower The new allower address\n    event SetAllower(address indexed allower);\n\n    /// @notice The stored denier address has been changed\n    /// @param denier The new denier address\n    event SetDenier(address indexed denier);\n\n    /// @notice The provided accounts list is empty\n    error InvalidCount();\n\n    /// @notice The account is denied access\n    /// @param _account The denied account\n    error Denied(address _account);\n\n    /// @notice The provided accounts and permissions list have different lengths\n    error MismatchedArrayLengths();\n\n    /// @notice Allower can't set deny permission\n    error AttemptToSetDenyPermission();\n\n    /// @notice Allower can't remove deny permission\n    error AttemptToRemoveDenyPermission();\n\n    /// @notice Initializes the allowlist\n    /// @param _admin Address of the Allowlist administrator\n    /// @param _allower Address of the allower\n    function initAllowlistV1(address _admin, address _allower) external;\n\n    /// @notice Initializes the allowlist denier\n    /// @param _denier Address of the denier\n    function initAllowlistV1_1(address _denier) external;\n\n    /// @notice Retrieves the allower address\n    /// @return The address of the allower\n    function getAllower() external view returns (address);\n\n    /// @notice Retrieves the denier address\n    /// @return The address of the denier\n    function getDenier() external view returns (address);\n\n    /// @notice This method returns true if the user has the expected permission and\n    ///         is not in the deny list\n    /// @param _account Recipient to verify\n    /// @param _mask Combination of permissions to verify\n    /// @return True if mask is respected and user is allowed\n    function isAllowed(address _account, uint256 _mask) external view returns (bool);\n\n    /// @notice This method returns true if the user is in the deny list\n    /// @param _account Recipient to verify\n    /// @return True if user is denied access\n    function isDenied(address _account) external view returns (bool);\n\n    /// @notice This method returns true if the user has the expected permission\n    ///         ignoring any deny list membership\n    /// @param _account Recipient to verify\n    /// @param _mask Combination of permissions to verify\n    /// @return True if mask is respected\n    function hasPermission(address _account, uint256 _mask) external view returns (bool);\n\n    /// @notice This method retrieves the raw permission value\n    /// @param _account Recipient to verify\n    /// @return The raw permissions value of the account\n    function getPermissions(address _account) external view returns (uint256);\n\n    /// @notice This method should be used as a modifier and is expected to revert\n    ///         if the user hasn't got the required permission or if the user is\n    ///         in the deny list.\n    /// @param _account Recipient to verify\n    /// @param _mask Combination of permissions to verify\n    function onlyAllowed(address _account, uint256 _mask) external view;\n\n    /// @notice Changes the allower address\n    /// @param _newAllowerAddress New address allowed to edit the allowlist\n    function setAllower(address _newAllowerAddress) external;\n\n    /// @notice Changes the denier address\n    /// @param _newDenierAddress New address allowed to edit the allowlist\n    function setDenier(address _newDenierAddress) external;\n\n    /// @notice Sets the allow permissions for one or more accounts\n    /// @dev This function is for allocating or removing deposit, redeem or donate permissions.\n    ///      This function could be used to give any permissions that we come up with in the future.\n    ///      An address which was denied has to be undenied first before they could be given any permission(s).\n    /// @param _accounts Accounts to update\n    /// @param _permissions New permission values\n    function setAllowPermissions(address[] calldata _accounts, uint256[] calldata _permissions) external;\n\n    /// @notice Sets the deny permissions for one or more accounts\n    /// @dev This function is for allocating or removing deny permissions.\n    ///      An address which is undenied has to be given permissions again for them to be able to deposit, donate or redeem.\n    /// @param _accounts Accounts to update\n    /// @param _permissions New permission values\n    function setDenyPermissions(address[] calldata _accounts, uint256[] calldata _permissions) external;\n}\n"
    },
    "contracts/src/interfaces/ICoverageFund.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\n/// @title Coverage Fund Interface (v1)\n/// @author Alluvial Finance Inc.\n/// @notice This interface exposes methods to receive donations for the slashing coverage fund and pull the funds into river\ninterface ICoverageFundV1 {\n    /// @notice The storage river address has changed\n    /// @param river The new river address\n    event SetRiver(address indexed river);\n\n    /// @notice A donation has been made to the coverage fund\n    /// @param donator Address that performed the donation\n    /// @param amount The amount donated\n    event Donate(address indexed donator, uint256 amount);\n\n    /// @notice The fallback or receive callback has been triggered\n    error InvalidCall();\n\n    /// @notice A donation with 0 ETH has been performed\n    error EmptyDonation();\n\n    /// @notice Initialize the coverage fund with the required arguments\n    /// @param _riverAddress Address of River\n    function initCoverageFundV1(address _riverAddress) external;\n\n    /// @notice Pulls ETH into the River contract\n    /// @dev Only callable by the River contract\n    /// @param _maxAmount The maximum amount to pull into the system\n    function pullCoverageFunds(uint256 _maxAmount) external;\n\n    /// @notice Donates ETH to the coverage fund contract\n    function donate() external payable;\n\n    /// @notice Ether receiver\n    receive() external payable;\n\n    /// @notice Invalid fallback detector\n    fallback() external payable;\n}\n"
    },
    "contracts/src/interfaces/IDepositContract.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\n/// @title Deposit Contract Interface\n/// @notice This interface exposes methods to perform validator deposits\ninterface IDepositContract {\n    /// @notice Official deposit method to activate a validator on the consensus layer\n    /// @param pubkey The 48 bytes long BLS Public key representing the validator\n    /// @param withdrawalCredentials The 32 bytes long withdrawal credentials, configures the withdrawal recipient\n    /// @param signature The 96 bytes long BLS Signature performed by the pubkey's private key\n    /// @param depositDataRoot The root hash of the whole deposit data structure\n    function deposit(\n        bytes calldata pubkey,\n        bytes calldata withdrawalCredentials,\n        bytes calldata signature,\n        bytes32 depositDataRoot\n    ) external payable;\n\n    /// @notice Query the current deposit root hash.\n    /// @return The deposit root hash.\n    function get_deposit_root() external view returns (bytes32);\n}\n"
    },
    "contracts/src/interfaces/IELFeeRecipient.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\n/// @title Execution Layer Fee Recipient Interface (v1)\n/// @author Alluvial Finance Inc.\n/// @notice This interface exposes methods to receive all the execution layer fees from the proposed blocks + bribes\ninterface IELFeeRecipientV1 {\n    /// @notice The storage river address has changed\n    /// @param river The new river address\n    event SetRiver(address indexed river);\n\n    /// @notice The fallback has been triggered\n    error InvalidCall();\n\n    /// @notice Initialize the fee recipient with the required arguments\n    /// @param _riverAddress Address of River\n    function initELFeeRecipientV1(address _riverAddress) external;\n\n    /// @notice Pulls ETH to the River contract\n    /// @dev Only callable by the River contract\n    /// @param _maxAmount The maximum amount to pull into the system\n    function pullELFees(uint256 _maxAmount) external;\n\n    /// @notice Ether receiver\n    receive() external payable;\n\n    /// @notice Invalid fallback detector\n    fallback() external payable;\n}\n"
    },
    "contracts/src/interfaces/IOperatorRegistry.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\nimport \"../state/operatorsRegistry/Operators.2.sol\";\n\n/// @title Operators Registry Interface (v1)\n/// @author Alluvial Finance Inc.\n/// @notice This interface exposes methods to handle the list of operators and their keys\ninterface IOperatorsRegistryV1 {\n    /// @notice A new operator has been added to the registry\n    /// @param index The operator index\n    /// @param name The operator display name\n    /// @param operatorAddress The operator address\n    event AddedOperator(uint256 indexed index, string name, address indexed operatorAddress);\n\n    /// @notice The operator status has been changed\n    /// @param index The operator index\n    /// @param active True if the operator is active\n    event SetOperatorStatus(uint256 indexed index, bool active);\n\n    /// @notice The operator limit has been changed\n    /// @param index The operator index\n    /// @param newLimit The new operator staking limit\n    event SetOperatorLimit(uint256 indexed index, uint256 newLimit);\n\n    /// @notice The operator stopped validator count has been changed\n    /// @param index The operator index\n    /// @param newStoppedValidatorCount The new stopped validator count\n    event SetOperatorStoppedValidatorCount(uint256 indexed index, uint256 newStoppedValidatorCount);\n\n    /// @notice The operator address has been changed\n    /// @param index The operator index\n    /// @param newOperatorAddress The new operator address\n    event SetOperatorAddress(uint256 indexed index, address indexed newOperatorAddress);\n\n    /// @notice The operator display name has been changed\n    /// @param index The operator index\n    /// @param newName The new display name\n    event SetOperatorName(uint256 indexed index, string newName);\n\n    /// @notice The operator or the admin added new validator keys and signatures\n    /// @dev The public keys and signatures are concatenated\n    /// @dev A public key is 48 bytes long\n    /// @dev A signature is 96 bytes long\n    /// @dev [P1, S1, P2, S2, ..., PN, SN] where N is the bytes length divided by (96 + 48)\n    /// @param index The operator index\n    /// @param publicKeysAndSignatures The concatenated public keys and signatures\n    event AddedValidatorKeys(uint256 indexed index, bytes publicKeysAndSignatures);\n\n    /// @notice The operator or the admin removed a public key and its signature from the registry\n    /// @param index The operator index\n    /// @param publicKey The BLS public key that has been removed\n    event RemovedValidatorKey(uint256 indexed index, bytes publicKey);\n\n    /// @notice The stored river address has been changed\n    /// @param river The new river address\n    event SetRiver(address indexed river);\n\n    /// @notice The operator edited its keys after the snapshot block\n    /// @dev This means that we cannot assume that its key set is checked by the snapshot\n    /// @dev This happens only if the limit was meant to be increased\n    /// @param index The operator index\n    /// @param currentLimit The current operator limit\n    /// @param newLimit The new operator limit that was attempted to be set\n    /// @param latestKeysEditBlockNumber The last block number at which the operator changed its keys\n    /// @param snapshotBlock The block number of the snapshot\n    event OperatorEditsAfterSnapshot(\n        uint256 indexed index,\n        uint256 currentLimit,\n        uint256 newLimit,\n        uint256 indexed latestKeysEditBlockNumber,\n        uint256 indexed snapshotBlock\n    );\n\n    /// @notice The call didn't alter the limit of the operator\n    /// @param index The operator index\n    /// @param limit The limit of the operator\n    event OperatorLimitUnchanged(uint256 indexed index, uint256 limit);\n\n    /// @notice The stopped validator array has been changed\n    /// @notice A validator is considered stopped if exiting, exited or slashed\n    /// @notice This event is emitted when the oracle reports new stopped validators counts\n    /// @param stoppedValidatorCounts The new stopped validator counts\n    event UpdatedStoppedValidators(uint32[] stoppedValidatorCounts);\n\n    /// @notice The requested exit count has been updated\n    /// @param index The operator index\n    /// @param count The count of requested exits\n    event RequestedValidatorExits(uint256 indexed index, uint256 count);\n\n    /// @notice The exit request demand has been updated\n    /// @param previousValidatorExitsDemand The previous exit request demand\n    /// @param nextValidatorExitsDemand The new exit request demand\n    event SetCurrentValidatorExitsDemand(uint256 previousValidatorExitsDemand, uint256 nextValidatorExitsDemand);\n\n    /// @notice The total requested exit has been updated\n    /// @param previousTotalValidatorExitsRequested The previous total requested exit\n    /// @param newTotalValidatorExitsRequested The new total requested exit\n    event SetTotalValidatorExitsRequested(\n        uint256 previousTotalValidatorExitsRequested, uint256 newTotalValidatorExitsRequested\n    );\n\n    /// @notice A validator key got funded on the deposit contract\n    /// @notice This event was introduced during a contract upgrade, in order to cover all possible public keys, this event\n    /// @notice will be replayed for past funded keys in order to have a complete coverage of all the funded public keys.\n    /// @notice In this particuliar scenario, the deferred value will be set to true, to indicate that we are not going to have\n    /// @notice the expected additional events and side effects in the same transaction (deposit to official DepositContract etc ...) because\n    /// @notice the event was synthetically crafted.\n    /// @param index The operator index\n    /// @param publicKeys BLS Public key that got funded\n    /// @param deferred True if event has been replayed in the context of a migration\n    event FundedValidatorKeys(uint256 indexed index, bytes[] publicKeys, bool deferred);\n\n    /// @notice The requested exit count has been update to fill the gap with the reported stopped count\n    /// @param index The operator index\n    /// @param oldRequestedExits The old requested exit count\n    /// @param newRequestedExits The new requested exit count\n    event UpdatedRequestedValidatorExitsUponStopped(\n        uint256 indexed index, uint32 oldRequestedExits, uint32 newRequestedExits\n    );\n\n    /// @notice The calling operator is inactive\n    /// @param index The operator index\n    error InactiveOperator(uint256 index);\n\n    /// @notice A funded key deletion has been attempted\n    error InvalidFundedKeyDeletionAttempt();\n\n    /// @notice The index provided are not sorted properly (descending order)\n    error InvalidUnsortedIndexes();\n\n    /// @notice The provided operator and limits array have different lengths\n    error InvalidArrayLengths();\n\n    /// @notice The provided operator and limits array are empty\n    error InvalidEmptyArray();\n\n    /// @notice The provided key count is 0\n    error InvalidKeyCount();\n\n    /// @notice The provided concatenated keys do not have the expected length\n    error InvalidKeysLength();\n\n    /// @notice The index that is removed is out of bounds\n    error InvalidIndexOutOfBounds();\n\n    /// @notice The value for the operator limit is too high\n    /// @param index The operator index\n    /// @param limit The new limit provided\n    /// @param keyCount The operator key count\n    error OperatorLimitTooHigh(uint256 index, uint256 limit, uint256 keyCount);\n\n    /// @notice The value for the limit is too low\n    /// @param index The operator index\n    /// @param limit The new limit provided\n    /// @param fundedKeyCount The operator funded key count\n    error OperatorLimitTooLow(uint256 index, uint256 limit, uint256 fundedKeyCount);\n\n    /// @notice The provided list of operators is not in increasing order\n    error UnorderedOperatorList();\n\n    /// @notice Thrown when an invalid empty stopped validator array is provided\n    error InvalidEmptyStoppedValidatorCountsArray();\n\n    /// @notice Thrown when the sum of stopped validators is invalid\n    error InvalidStoppedValidatorCountsSum();\n\n    /// @notice Throw when an element in the stopped validator array is decreasing\n    error StoppedValidatorCountsDecreased();\n\n    /// @notice Thrown when the number of elements in the array is too high compared to operator count\n    error StoppedValidatorCountsTooHigh();\n\n    /// @notice Thrown when no exit requests can be performed\n    error NoExitRequestsToPerform();\n\n    /// @notice The provided stopped validator count array is shrinking\n    error StoppedValidatorCountArrayShrinking();\n\n    /// @notice The provided stopped validator count of an operator is above its funded validator count\n    error StoppedValidatorCountAboveFundedCount(uint256 operatorIndex, uint32 stoppedCount, uint32 fundedCount);\n\n    /// @notice Initializes the operators registry\n    /// @param _admin Admin in charge of managing operators\n    /// @param _river Address of River system\n    function initOperatorsRegistryV1(address _admin, address _river) external;\n\n    /// @notice Initializes the operators registry for V1_1\n    function initOperatorsRegistryV1_1() external;\n\n    /// @notice Retrieve the River address\n    /// @return The address of River\n    function getRiver() external view returns (address);\n\n    /// @notice Get operator details\n    /// @param _index The index of the operator\n    /// @return The details of the operator\n    function getOperator(uint256 _index) external view returns (OperatorsV2.Operator memory);\n\n    /// @notice Get operator count\n    /// @return The operator count\n    function getOperatorCount() external view returns (uint256);\n\n    /// @notice Retrieve the stopped validator count for an operator index\n    /// @param _idx The index of the operator\n    /// @return The stopped validator count of the operator\n    function getOperatorStoppedValidatorCount(uint256 _idx) external view returns (uint32);\n\n    /// @notice Retrieve the total stopped validator count\n    /// @return The total stopped validator count\n    function getTotalStoppedValidatorCount() external view returns (uint32);\n\n    /// @notice Retrieve the total requested exit count\n    /// @notice This value is the amount of exit requests that have been performed, emitting an event for operators to catch\n    /// @return The total requested exit count\n    function getTotalValidatorExitsRequested() external view returns (uint256);\n\n    /// @notice Get the current exit request demand waiting to be triggered\n    /// @notice This value is the amount of exit requests that are demanded and not yet performed by the contract\n    /// @return The current exit request demand\n    function getCurrentValidatorExitsDemand() external view returns (uint256);\n\n    /// @notice Retrieve the total stopped and requested exit count\n    /// @return The total stopped count\n    /// @return The total requested exit count\n    function getStoppedAndRequestedExitCounts() external view returns (uint32, uint256);\n\n    /// @notice Retrieve the raw stopped validators array from storage\n    /// @return The stopped validator array\n    function getStoppedValidatorCountPerOperator() external view returns (uint32[] memory);\n\n    /// @notice Get the details of a validator\n    /// @param _operatorIndex The index of the operator\n    /// @param _validatorIndex The index of the validator\n    /// @return publicKey The public key of the validator\n    /// @return signature The signature used during deposit\n    /// @return funded True if validator has been funded\n    function getValidator(uint256 _operatorIndex, uint256 _validatorIndex)\n        external\n        view\n        returns (bytes memory publicKey, bytes memory signature, bool funded);\n\n    /// @notice Get the next validators that would be funded\n    /// @param _count Count of validators that would be funded next\n    /// @return publicKeys An array of fundable public keys\n    /// @return signatures An array of signatures linked to the public keys\n    function getNextValidatorsToDepositFromActiveOperators(uint256 _count)\n        external\n        view\n        returns (bytes[] memory publicKeys, bytes[] memory signatures);\n\n    /// @notice Retrieve the active operator set\n    /// @return The list of active operators and their details\n    function listActiveOperators() external view returns (OperatorsV2.Operator[] memory);\n\n    /// @notice Allows river to override the stopped validators array\n    /// @notice This actions happens during the Oracle report processing\n    /// @param _stoppedValidatorCounts The new stopped validators array\n    /// @param _depositedValidatorCount The total deposited validator count\n    function reportStoppedValidatorCounts(uint32[] calldata _stoppedValidatorCounts, uint256 _depositedValidatorCount)\n        external;\n\n    /// @notice Adds an operator to the registry\n    /// @dev Only callable by the administrator\n    /// @param _name The name identifying the operator\n    /// @param _operator The address representing the operator, receiving the rewards\n    /// @return The index of the new operator\n    function addOperator(string calldata _name, address _operator) external returns (uint256);\n\n    /// @notice Changes the operator address of an operator\n    /// @dev Only callable by the administrator or the previous operator address\n    /// @param _index The operator index\n    /// @param _newOperatorAddress The new address of the operator\n    function setOperatorAddress(uint256 _index, address _newOperatorAddress) external;\n\n    /// @notice Changes the operator name\n    /// @dev Only callable by the administrator or the operator\n    /// @param _index The operator index\n    /// @param _newName The new operator name\n    function setOperatorName(uint256 _index, string calldata _newName) external;\n\n    /// @notice Changes the operator status\n    /// @dev Only callable by the administrator\n    /// @param _index The operator index\n    /// @param _newStatus The new status of the operator\n    function setOperatorStatus(uint256 _index, bool _newStatus) external;\n\n    /// @notice Changes the operator staking limit\n    /// @dev Only callable by the administrator\n    /// @dev The operator indexes must be in increasing order and contain no duplicate\n    /// @dev The limit cannot exceed the total key count of the operator\n    /// @dev The _indexes and _newLimits must have the same length.\n    /// @dev Each limit value is applied to the operator index at the same index in the _indexes array.\n    /// @param _operatorIndexes The operator indexes, in increasing order and duplicate free\n    /// @param _newLimits The new staking limit of the operators\n    /// @param _snapshotBlock The block number at which the snapshot was computed\n    function setOperatorLimits(\n        uint256[] calldata _operatorIndexes,\n        uint32[] calldata _newLimits,\n        uint256 _snapshotBlock\n    ) external;\n\n    /// @notice Adds new keys for an operator\n    /// @dev Only callable by the administrator or the operator address\n    /// @param _index The operator index\n    /// @param _keyCount The amount of keys provided\n    /// @param _publicKeysAndSignatures Public keys of the validator, concatenated\n    function addValidators(uint256 _index, uint32 _keyCount, bytes calldata _publicKeysAndSignatures) external;\n\n    /// @notice Remove validator keys\n    /// @dev Only callable by the administrator or the operator address\n    /// @dev The indexes must be provided sorted in decreasing order and duplicate-free, otherwise the method will revert\n    /// @dev The operator limit will be set to the lowest deleted key index if the operator's limit wasn't equal to its total key count\n    /// @dev The operator or the admin cannot remove funded keys\n    /// @dev When removing validators, the indexes of specific unfunded keys can be changed in order to properly\n    /// @dev remove the keys from the storage array. Beware of this specific behavior when chaining calls as the\n    /// @dev targeted public key indexes can point to a different key after a first call was made and performed\n    /// @dev some swaps\n    /// @param _index The operator index\n    /// @param _indexes The indexes of the keys to remove\n    function removeValidators(uint256 _index, uint256[] calldata _indexes) external;\n\n    /// @notice Retrieve validator keys based on operator statuses\n    /// @param _count Max amount of keys requested\n    /// @return publicKeys An array of public keys\n    /// @return signatures An array of signatures linked to the public keys\n    function pickNextValidatorsToDeposit(uint256 _count)\n        external\n        returns (bytes[] memory publicKeys, bytes[] memory signatures);\n\n    /// @notice Public endpoint to consume the exit request demand and perform the actual exit requests\n    /// @notice The selection algorithm will pick validators based on their active validator counts\n    /// @notice This value is computed by using the count of funded keys and taking into account the stopped validator counts and exit requests\n    /// @param _count Max amount of exits to request\n    function requestValidatorExits(uint256 _count) external;\n\n    /// @notice Increases the exit request demand\n    /// @dev This method is only callable by the river contract, and to actually forward the information to the node operators via event emission, the unprotected requestValidatorExits method must be called\n    /// @param _count The amount of exit requests to add to the demand\n    /// @param _depositedValidatorCount The total deposited validator count\n    function demandValidatorExits(uint256 _count, uint256 _depositedValidatorCount) external;\n}\n"
    },
    "contracts/src/interfaces/IProtocolVersion.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\ninterface IProtocolVersion {\n    /// @notice Retrieves the version of the contract\n    /// @return Version of the contract\n    function version() external pure returns (string memory);\n}\n"
    },
    "contracts/src/interfaces/IRedeemManager.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\nimport \"../state/redeemManager/RedeemQueue.2.sol\";\nimport \"../state/redeemManager/WithdrawalStack.sol\";\n\n/// @title Redeem Manager Interface (v1)\n/// @author Alluvial Finance Inc.\n/// @notice This contract handles the redeem requests of all users\ninterface IRedeemManagerV1 {\n    /// @notice Emitted when a redeem request is created\n    /// @param recipient The recipient of the redeem request\n    /// @param height The height of the redeem request in LsETH\n    /// @param amount The amount of the redeem request in LsETH\n    /// @param maxRedeemableEth The maximum amount of eth that can be redeemed from this request\n    /// @param id The id of the new redeem request\n    event RequestedRedeem(\n        address indexed recipient, uint256 height, uint256 amount, uint256 maxRedeemableEth, uint32 id\n    );\n\n    /// @notice Emitted when a withdrawal event is created\n    /// @param height The height of the withdrawal event in LsETH\n    /// @param amount The amount of the withdrawal event in LsETH\n    /// @param ethAmount The amount of eth to distrubute to claimers\n    /// @param id The id of the withdrawal event\n    event ReportedWithdrawal(uint256 height, uint256 amount, uint256 ethAmount, uint32 id);\n\n    /// @notice Emitted when a redeem request has been satisfied and filled (even partially) from a withdrawal event\n    /// @param redeemRequestId The id of the redeem request\n    /// @param withdrawalEventId The id of the withdrawal event used to fill the request\n    /// @param lsEthAmountSatisfied The amount of LsETH filled\n    /// @param ethAmountSatisfied The amount of ETH filled\n    /// @param lsEthAmountRemaining The amount of LsETH remaining\n    /// @param ethAmountExceeding The amount of eth added to the exceeding buffer\n    event SatisfiedRedeemRequest(\n        uint32 indexed redeemRequestId,\n        uint32 indexed withdrawalEventId,\n        uint256 lsEthAmountSatisfied,\n        uint256 ethAmountSatisfied,\n        uint256 lsEthAmountRemaining,\n        uint256 ethAmountExceeding\n    );\n\n    /// @notice Emitted when a redeem request claim has been processed and matched at least once and funds are sent to the recipient\n    /// @param redeemRequestId The id of the redeem request\n    /// @param recipient The address receiving the redeem request funds\n    /// @param ethAmount The amount of eth retrieved\n    /// @param lsEthAmount The total amount of LsETH used to redeem the eth\n    /// @param remainingLsEthAmount The amount of LsETH remaining\n    event ClaimedRedeemRequest(\n        uint32 indexed redeemRequestId,\n        address indexed recipient,\n        uint256 ethAmount,\n        uint256 lsEthAmount,\n        uint256 remainingLsEthAmount\n    );\n\n    /// @notice Emitted when the redeem demand is set\n    /// @param oldRedeemDemand The old redeem demand\n    /// @param newRedeemDemand The new redeem demand\n    event SetRedeemDemand(uint256 oldRedeemDemand, uint256 newRedeemDemand);\n\n    /// @notice Emitted when the River address is set\n    /// @param river The new river address\n    event SetRiver(address river);\n\n    /// @notice Thrown When a zero value is provided\n    error InvalidZeroAmount();\n\n    /// @notice Thrown when a transfer error occured with LsETH\n    error TransferError();\n\n    /// @notice Thrown when the provided arrays don't have matching lengths\n    error IncompatibleArrayLengths();\n\n    /// @notice Thrown when the provided redeem request id is out of bounds\n    /// @param id The redeem request id\n    error RedeemRequestOutOfBounds(uint256 id);\n\n    /// @notice Thrown when the withdrawal request id if out of bounds\n    /// @param id The withdrawal event id\n    error WithdrawalEventOutOfBounds(uint256 id);\n\n    /// @notice Thrown when\tthe redeem request id is already claimed\n    /// @param id The redeem request id\n    error RedeemRequestAlreadyClaimed(uint256 id);\n\n    /// @notice Thrown when the redeem request and withdrawal event are not matching during claim\n    /// @param redeemRequestId The provided redeem request id\n    /// @param withdrawalEventId The provided associated withdrawal event id\n    error DoesNotMatch(uint256 redeemRequestId, uint256 withdrawalEventId);\n\n    /// @notice Thrown when the provided withdrawal event exceeds the redeem demand\n    /// @param withdrawalAmount The amount of the withdrawal event\n    /// @param redeemDemand The current redeem demand\n    error WithdrawalExceedsRedeemDemand(uint256 withdrawalAmount, uint256 redeemDemand);\n\n    /// @notice Thrown when the payment after a claim failed\n    /// @param recipient The recipient of the payment\n    /// @param rdata The revert data\n    error ClaimRedeemFailed(address recipient, bytes rdata);\n\n    /// @notice Thrown when the claim recipient is denied\n    error ClaimRecipientIsDenied();\n\n    /// @notice Thrown when the claim initiator is denied\n    error ClaimInitiatorIsDenied();\n\n    /// @notice Thrown when the recipient of redeemRequest is denied\n    error RecipientIsDenied();\n\n    /// @param _river The address of the River contract\n    function initializeRedeemManagerV1(address _river) external;\n\n    function initializeRedeemManagerV1_2() external;\n\n    /// @notice Retrieve River address\n    /// @return The address of River\n    function getRiver() external view returns (address);\n\n    /// @notice Retrieve the global count of redeem requests\n    function getRedeemRequestCount() external view returns (uint256);\n\n    /// @notice Retrieve the details of a specific redeem request\n    /// @param _redeemRequestId The id of the request\n    /// @return The redeem request details\n    function getRedeemRequestDetails(uint32 _redeemRequestId)\n        external\n        view\n        returns (RedeemQueueV2.RedeemRequest memory);\n\n    /// @notice Retrieve the global count of withdrawal events\n    function getWithdrawalEventCount() external view returns (uint256);\n\n    /// @notice Retrieve the details of a specific withdrawal event\n    /// @param _withdrawalEventId The id of the withdrawal event\n    /// @return The withdrawal event details\n    function getWithdrawalEventDetails(uint32 _withdrawalEventId)\n        external\n        view\n        returns (WithdrawalStack.WithdrawalEvent memory);\n\n    /// @notice Retrieve the amount of redeemed LsETH pending to be supplied with withdrawn ETH\n    /// @return The amount of eth in the buffer\n    function getBufferedExceedingEth() external view returns (uint256);\n\n    /// @notice Retrieve the amount of LsETH waiting to be exited\n    /// @return The amount of LsETH waiting to be exited\n    function getRedeemDemand() external view returns (uint256);\n\n    /// @notice Resolves the provided list of redeem request ids\n    /// @dev The result is an array of equal length with ids or error code\n    /// @dev -1 means that the request is not satisfied yet\n    /// @dev -2 means that the request is out of bounds\n    /// @dev -3 means that the request has already been claimed\n    /// @dev This call was created to be called by an off-chain interface, the output could then be used to perform the claimRewards call in a regular transaction\n    /// @param _redeemRequestIds The list of redeem requests to resolve\n    /// @return withdrawalEventIds The list of withdrawal events matching every redeem request (or error codes)\n    function resolveRedeemRequests(uint32[] calldata _redeemRequestIds)\n        external\n        view\n        returns (int64[] memory withdrawalEventIds);\n\n    /// @notice Creates a redeem request\n    /// @param _lsETHAmount The amount of LsETH to redeem\n    /// @param _recipient The recipient owning the redeem request\n    /// @return redeemRequestId The id of the redeem request\n    function requestRedeem(uint256 _lsETHAmount, address _recipient) external returns (uint32 redeemRequestId);\n\n    /// @notice Creates a redeem request using msg.sender as recipient\n    /// @param _lsETHAmount The amount of LsETH to redeem\n    /// @return redeemRequestId The id of the redeem request\n    function requestRedeem(uint256 _lsETHAmount) external returns (uint32 redeemRequestId);\n\n    /// @notice Claims the rewards of the provided redeem request ids\n    /// @param _redeemRequestIds The list of redeem requests to claim\n    /// @param _withdrawalEventIds The list of withdrawal events to use for every redeem request claim\n    /// @param _skipAlreadyClaimed True if the call should not revert on claiming of already claimed requests\n    /// @param _depth The maximum recursive depth for the resolution of the redeem requests\n    /// @return claimStatuses The list of claim statuses. 0 for fully claimed, 1 for partially claimed, 2 for skipped\n    function claimRedeemRequests(\n        uint32[] calldata _redeemRequestIds,\n        uint32[] calldata _withdrawalEventIds,\n        bool _skipAlreadyClaimed,\n        uint16 _depth\n    ) external returns (uint8[] memory claimStatuses);\n\n    /// @notice Claims the rewards of the provided redeem request ids\n    /// @param _redeemRequestIds The list of redeem requests to claim\n    /// @param _withdrawalEventIds The list of withdrawal events to use for every redeem request claim\n    /// @return claimStatuses The list of claim statuses. 0 for fully claimed, 1 for partially claimed, 2 for skipped\n    function claimRedeemRequests(uint32[] calldata _redeemRequestIds, uint32[] calldata _withdrawalEventIds)\n        external\n        returns (uint8[] memory claimStatuses);\n\n    /// @notice Reports a withdraw event from River\n    /// @param _lsETHWithdrawable The amount of LsETH that can be redeemed due to this new withdraw event\n    function reportWithdraw(uint256 _lsETHWithdrawable) external payable;\n\n    /// @notice Pulls exceeding buffer eth\n    /// @param _max The maximum amount that should be pulled\n    function pullExceedingEth(uint256 _max) external;\n}\n"
    },
    "contracts/src/interfaces/IRiver.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\nimport \"../state/river/DailyCommittableLimits.sol\";\n\nimport \"./components/IConsensusLayerDepositManager.1.sol\";\nimport \"./components/IOracleManager.1.sol\";\nimport \"./components/ISharesManager.1.sol\";\nimport \"./components/IUserDepositManager.1.sol\";\n\n/// @title River Interface (v1)\n/// @author Alluvial Finance Inc.\n/// @notice The main system interface\ninterface IRiverV1 is IConsensusLayerDepositManagerV1, IUserDepositManagerV1, ISharesManagerV1, IOracleManagerV1 {\n    /// @notice Funds have been pulled from the Execution Layer Fee Recipient\n    /// @param amount The amount pulled\n    event PulledELFees(uint256 amount);\n\n    /// @notice Funds have been pulled from the Coverage Fund\n    /// @param amount The amount pulled\n    event PulledCoverageFunds(uint256 amount);\n\n    /// @notice Emitted when funds are pulled from the redeem manager\n    /// @param amount The amount pulled\n    event PulledRedeemManagerExceedingEth(uint256 amount);\n\n    /// @notice Emitted when funds are pulled from the CL recipient\n    /// @param pulledSkimmedEthAmount The amount of skimmed ETH pulled\n    /// @param pullExitedEthAmount The amount of exited ETH pulled\n    event PulledCLFunds(uint256 pulledSkimmedEthAmount, uint256 pullExitedEthAmount);\n\n    /// @notice The stored Execution Layer Fee Recipient has been changed\n    /// @param elFeeRecipient The new Execution Layer Fee Recipient\n    event SetELFeeRecipient(address indexed elFeeRecipient);\n\n    /// @notice The stored Coverage Fund has been changed\n    /// @param coverageFund The new Coverage Fund\n    event SetCoverageFund(address indexed coverageFund);\n\n    /// @notice The stored Collector has been changed\n    /// @param collector The new Collector\n    event SetCollector(address indexed collector);\n\n    /// @notice The stored Allowlist has been changed\n    /// @param allowlist The new Allowlist\n    event SetAllowlist(address indexed allowlist);\n\n    /// @notice The stored Global Fee has been changed\n    /// @param fee The new Global Fee\n    event SetGlobalFee(uint256 fee);\n\n    /// @notice The stored Operators Registry has been changed\n    /// @param operatorRegistry The new Operators Registry\n    event SetOperatorsRegistry(address indexed operatorRegistry);\n\n    /// @notice The stored Metadata URI string has been changed\n    /// @param metadataURI The new Metadata URI string\n    event SetMetadataURI(string metadataURI);\n\n    /// @notice The system underlying supply increased. This is a snapshot of the balances for accounting purposes\n    /// @param _collector The address of the collector during this event\n    /// @param _oldTotalUnderlyingBalance Old total ETH balance under management by River\n    /// @param _oldTotalSupply Old total supply in shares\n    /// @param _newTotalUnderlyingBalance New total ETH balance under management by River\n    /// @param _newTotalSupply New total supply in shares\n    event RewardsEarned(\n        address indexed _collector,\n        uint256 _oldTotalUnderlyingBalance,\n        uint256 _oldTotalSupply,\n        uint256 _newTotalUnderlyingBalance,\n        uint256 _newTotalSupply\n    );\n\n    /// @notice Emitted when the daily committable limits are changed\n    /// @param minNetAmount The minimum amount that must be used as the daily committable amount\n    /// @param maxRelativeAmount The maximum amount that can be used as the daily committable amount, relative to the total underlying supply\n    event SetMaxDailyCommittableAmounts(uint256 minNetAmount, uint256 maxRelativeAmount);\n\n    /// @notice Emitted when the redeem manager address is changed\n    /// @param redeemManager The address of the redeem manager\n    event SetRedeemManager(address redeemManager);\n\n    /// @notice Emitted when the balance to deposit is updated\n    /// @param oldAmount The old balance to deposit\n    /// @param newAmount The new balance to deposit\n    event SetBalanceToDeposit(uint256 oldAmount, uint256 newAmount);\n\n    /// @notice Emitted when the balance to redeem is updated\n    /// @param oldAmount The old balance to redeem\n    /// @param newAmount The new balance to redeem\n    event SetBalanceToRedeem(uint256 oldAmount, uint256 newAmount);\n\n    /// @notice Emitted when the balance committed to deposit\n    /// @param oldAmount The old balance committed to deposit\n    /// @param newAmount The new balance committed to deposit\n    event SetBalanceCommittedToDeposit(uint256 oldAmount, uint256 newAmount);\n\n    /// @notice Emitted when the redeem manager received a withdraw event report\n    /// @param redeemManagerDemand The total demand in LsETH of the redeem manager\n    /// @param suppliedRedeemManagerDemand The amount of LsETH demand actually supplied\n    /// @param suppliedRedeemManagerDemandInEth The amount in ETH of the supplied demand\n    event ReportedRedeemManager(\n        uint256 redeemManagerDemand, uint256 suppliedRedeemManagerDemand, uint256 suppliedRedeemManagerDemandInEth\n    );\n\n    /// @notice Thrown when the amount received from the Withdraw contract doe not match the requested amount\n    /// @param requested The amount that was requested\n    /// @param received The amount that was received\n    error InvalidPulledClFundsAmount(uint256 requested, uint256 received);\n\n    /// @notice The computed amount of shares to mint is 0\n    error ZeroMintedShares();\n\n    /// @notice The access was denied\n    /// @param account The account that was denied\n    error Denied(address account);\n\n    /// @notice Initializes the River system\n    /// @param _depositContractAddress Address to make Consensus Layer deposits\n    /// @param _elFeeRecipientAddress Address that receives the execution layer fees\n    /// @param _withdrawalCredentials Credentials to use for every validator deposit\n    /// @param _oracleAddress The address of the Oracle contract\n    /// @param _systemAdministratorAddress Administrator address\n    /// @param _allowlistAddress Address of the allowlist contract\n    /// @param _operatorRegistryAddress Address of the operator registry\n    /// @param _collectorAddress Address receiving the the global fee on revenue\n    /// @param _globalFee Amount retained when the ETH balance increases and sent to the collector\n    function initRiverV1(\n        address _depositContractAddress,\n        address _elFeeRecipientAddress,\n        bytes32 _withdrawalCredentials,\n        address _oracleAddress,\n        address _systemAdministratorAddress,\n        address _allowlistAddress,\n        address _operatorRegistryAddress,\n        address _collectorAddress,\n        uint256 _globalFee\n    ) external;\n\n    /// @notice Initialized version 1.1 of the River System\n    /// @param _redeemManager The redeem manager address\n    /// @param _epochsPerFrame The amounts of epochs in a frame\n    /// @param _slotsPerEpoch The slots inside an epoch\n    /// @param _secondsPerSlot The seconds inside a slot\n    /// @param _genesisTime The genesis timestamp\n    /// @param _epochsToAssumedFinality The number of epochs before an epoch is considered final on-chain\n    /// @param _annualAprUpperBound The reporting upper bound\n    /// @param _relativeLowerBound The reporting lower bound\n    /// @param _maxDailyNetCommittableAmount_ The net daily committable limit\n    /// @param _maxDailyRelativeCommittableAmount_ The relative daily committable limit\n    function initRiverV1_1(\n        address _redeemManager,\n        uint64 _epochsPerFrame,\n        uint64 _slotsPerEpoch,\n        uint64 _secondsPerSlot,\n        uint64 _genesisTime,\n        uint64 _epochsToAssumedFinality,\n        uint256 _annualAprUpperBound,\n        uint256 _relativeLowerBound,\n        uint128 _maxDailyNetCommittableAmount_,\n        uint128 _maxDailyRelativeCommittableAmount_\n    ) external;\n\n    /// @notice Initializes version 1.2 of the River System\n    function initRiverV1_2() external;\n\n    /// @notice Get the current global fee\n    /// @return The global fee\n    function getGlobalFee() external view returns (uint256);\n\n    /// @notice Retrieve the allowlist address\n    /// @return The allowlist address\n    function getAllowlist() external view returns (address);\n\n    /// @notice Retrieve the collector address\n    /// @return The collector address\n    function getCollector() external view returns (address);\n\n    /// @notice Retrieve the execution layer fee recipient\n    /// @return The execution layer fee recipient address\n    function getELFeeRecipient() external view returns (address);\n\n    /// @notice Retrieve the coverage fund\n    /// @return The coverage fund address\n    function getCoverageFund() external view returns (address);\n\n    /// @notice Retrieve the redeem manager\n    /// @return The redeem manager address\n    function getRedeemManager() external view returns (address);\n\n    /// @notice Retrieve the operators registry\n    /// @return The operators registry address\n    function getOperatorsRegistry() external view returns (address);\n\n    /// @notice Retrieve the metadata uri string value\n    /// @return The metadata uri string value\n    function getMetadataURI() external view returns (string memory);\n\n    /// @notice Retrieve the configured daily committable limits\n    /// @return The daily committable limits structure\n    function getDailyCommittableLimits()\n        external\n        view\n        returns (DailyCommittableLimits.DailyCommittableLimitsStruct memory);\n\n    /// @notice Resolves the provided redeem requests by calling the redeem manager\n    /// @param _redeemRequestIds The list of redeem requests to resolve\n    /// @return withdrawalEventIds The list of matching withdrawal events, or error codes\n    function resolveRedeemRequests(uint32[] calldata _redeemRequestIds)\n        external\n        view\n        returns (int64[] memory withdrawalEventIds);\n\n    /// @notice Set the daily committable limits\n    /// @param _dcl The Daily Committable Limits structure\n    function setDailyCommittableLimits(DailyCommittableLimits.DailyCommittableLimitsStruct memory _dcl) external;\n\n    /// @notice Retrieve the current balance to redeem\n    /// @return The current balance to redeem\n    function getBalanceToRedeem() external view returns (uint256);\n\n    /// @notice Performs a redeem request on the redeem manager\n    /// @param _lsETHAmount The amount of LsETH to redeem\n    /// @param _recipient The address that will own the redeem request\n    /// @return redeemRequestId The ID of the newly created redeem request\n    function requestRedeem(uint256 _lsETHAmount, address _recipient) external returns (uint32 redeemRequestId);\n\n    /// @notice Claims several redeem requests\n    /// @param _redeemRequestIds The list of redeem requests to claim\n    /// @param _withdrawalEventIds The list of resolved withdrawal event ids\n    /// @return claimStatuses The operation status results\n    function claimRedeemRequests(uint32[] calldata _redeemRequestIds, uint32[] calldata _withdrawalEventIds)\n        external\n        returns (uint8[] memory claimStatuses);\n\n    /// @notice Changes the global fee parameter\n    /// @param _newFee New fee value\n    function setGlobalFee(uint256 _newFee) external;\n\n    /// @notice Changes the allowlist address\n    /// @param _newAllowlist New address for the allowlist\n    function setAllowlist(address _newAllowlist) external;\n\n    /// @notice Changes the collector address\n    /// @param _newCollector New address for the collector\n    function setCollector(address _newCollector) external;\n\n    /// @notice Changes the execution layer fee recipient\n    /// @param _newELFeeRecipient New address for the recipient\n    function setELFeeRecipient(address _newELFeeRecipient) external;\n\n    /// @notice Changes the coverage fund\n    /// @param _newCoverageFund New address for the fund\n    function setCoverageFund(address _newCoverageFund) external;\n\n    /// @notice Sets the metadata uri string value\n    /// @param _metadataURI The new metadata uri string value\n    function setMetadataURI(string memory _metadataURI) external;\n\n    /// @notice Input for execution layer fee earnings\n    function sendELFees() external payable;\n\n    /// @notice Input for consensus layer funds, containing both exit and skimming\n    function sendCLFunds() external payable;\n\n    /// @notice Input for coverage funds\n    function sendCoverageFunds() external payable;\n\n    /// @notice Input for the redeem manager funds\n    function sendRedeemManagerExceedingFunds() external payable;\n}\n"
    },
    "contracts/src/interfaces/IWithdraw.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\n/// @title Withdraw Interface (V1)\n/// @author Alluvial Finance Inc.\n/// @notice This contract is in charge of holding the exit and skimming funds and allow river to pull these funds\ninterface IWithdrawV1 {\n    /// @notice Emitted when the linked River address is changed\n    /// @param river The new River address\n    event SetRiver(address river);\n\n    /// @param _river The address of the River contract\n    function initializeWithdrawV1(address _river) external;\n\n    /// @notice Retrieve the withdrawal credentials to use\n    /// @return The withdrawal credentials\n    function getCredentials() external view returns (bytes32);\n\n    /// @notice Retrieve the linked River address\n    /// @return The River address\n    function getRiver() external view returns (address);\n\n    /// @notice Callable by River, sends the specified amount of ETH to River\n    /// @param _amount The amount to pull\n    function pullEth(uint256 _amount) external;\n}\n"
    },
    "contracts/src/l2-token/BurnMintERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\nimport {CCIPAdminAddress} from \"contracts/src/l2-token/state/CCIPAdminAddress.sol\";\n\nimport {IBurnMintERC20} from \"./IBurnMintERC20.sol\";\nimport {IGetCCIPAdmin} from \"contracts/src/l2-token/IGetCCIPAdmin.sol\";\nimport {IAccessControl} from \"openzeppelin-contracts/contracts/access/IAccessControl.sol\";\nimport {IERC165} from \"openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\";\nimport {IERC20} from \"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport {AccessControlUpgradeable} from\n    \"openzeppelin-contracts-upgradeable/contracts/access/AccessControlUpgradeable.sol\";\nimport {ERC20BurnableUpgradeable} from\n    \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/extensions/ERC20BurnableUpgradeable.sol\";\n\n/// @notice A basic ERC20 compatible token contract with burn and minting roles.\n/// @dev This contract has not been audited and is not yet approved for production use.\ncontract BurnMintERC20 is IBurnMintERC20, IGetCCIPAdmin, IERC165, ERC20BurnableUpgradeable, AccessControlUpgradeable {\n    error InvalidRecipient(address recipient);\n\n    event CCIPAdminTransferred(address indexed previousAdmin, address indexed newAdmin);\n\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant BURNER_ROLE = keccak256(\"BURNER_ROLE\");\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(string memory _name, string memory _symbol) public initializer {\n        __AccessControl_init();\n        __ERC20_init(_name, _symbol);\n        CCIPAdminAddress.set(msg.sender);\n        // Set up the owner as the initial minter and burner\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId)\n        public\n        pure\n        virtual\n        override(AccessControlUpgradeable, IERC165)\n        returns (bool)\n    {\n        return interfaceId == type(IERC20).interfaceId || interfaceId == type(IBurnMintERC20).interfaceId\n            || interfaceId == type(IERC165).interfaceId || interfaceId == type(IAccessControl).interfaceId\n            || interfaceId == type(IGetCCIPAdmin).interfaceId;\n    }\n\n    // ================================================================\n    //                             ERC20                             \n    // ================================================================\n\n    /// @dev Uses OZ ERC20 _transfer to disallow sending to address(0).\n    /// @dev Disallows sending to address(this)\n    function _transfer(address from, address to, uint256 amount) internal virtual override {\n        if (to == address(this)) revert InvalidRecipient(to);\n\n        super._transfer(from, to, amount);\n    }\n\n    /// @dev Uses OZ ERC20 _approve to disallow approving for address(0).\n    /// @dev Disallows approving for address(this)\n    function _approve(address owner, address spender, uint256 amount) internal virtual override {\n        if (spender == address(this)) revert InvalidRecipient(spender);\n\n        super._approve(owner, spender, amount);\n    }\n\n    // ================================================================\n    //                       Burning & minting                       \n    // ================================================================\n\n    /// @inheritdoc ERC20BurnableUpgradeable\n    /// @dev Uses OZ ERC20 _burn to disallow burning from address(0).\n    /// @dev Decreases the total supply.\n    function burn(uint256 amount) public override(IBurnMintERC20, ERC20BurnableUpgradeable) onlyRole(BURNER_ROLE) {\n        super.burn(amount);\n    }\n\n    /// @inheritdoc IBurnMintERC20\n    /// @dev Alias for BurnFrom for compatibility with the older naming convention.\n    /// @dev Uses burnFrom for all validation & logic.\n    function burn(address account, uint256 amount) public virtual override {\n        burnFrom(account, amount);\n    }\n\n    /// @inheritdoc ERC20BurnableUpgradeable\n    /// @dev Uses OZ ERC20 _burn to disallow burning from address(0).\n    /// @dev Decreases the total supply.\n    function burnFrom(address account, uint256 amount)\n        public\n        override(IBurnMintERC20, ERC20BurnableUpgradeable)\n        onlyRole(BURNER_ROLE)\n    {\n        super.burnFrom(account, amount);\n    }\n\n    /// @inheritdoc IBurnMintERC20\n    /// @dev Uses OZ ERC20 _mint to disallow minting to address(0).\n    /// @dev Disallows minting to address(this)\n    /// @dev Increases the total supply.\n    function mint(address account, uint256 amount) external override onlyRole(MINTER_ROLE) {\n        if (account == address(this)) revert InvalidRecipient(account);\n\n        _mint(account, amount);\n    }\n\n    // ================================================================\n    //                             Roles                             \n    // ================================================================\n\n    /// @notice grants both mint and burn roles to `burnAndMinter`.\n    /// @dev calls public functions so this function does not require\n    /// access controls. This is handled in the inner functions.\n    function grantMintAndBurnRoles(address burnAndMinter) external {\n        grantRole(MINTER_ROLE, burnAndMinter);\n        grantRole(BURNER_ROLE, burnAndMinter);\n    }\n\n    /// @notice Returns the current CCIPAdmin\n    function getCCIPAdmin() external view returns (address) {\n        return CCIPAdminAddress.get();\n    }\n\n    /// @notice Transfers the CCIPAdmin role to a new address\n    /// @dev only the owner can call this function, NOT the current ccipAdmin, and 1-step ownership transfer is used.\n    /// @param newAdmin The address to transfer the CCIPAdmin role to. Setting to address(0) is a valid way to revoke\n    /// the role\n    function setCCIPAdmin(address newAdmin) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        address currentAdmin = CCIPAdminAddress.get();\n\n        CCIPAdminAddress.set(newAdmin);\n\n        emit CCIPAdminTransferred(currentAdmin, newAdmin);\n    }\n}\n"
    },
    "contracts/src/l2-token/IBurnMintERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\n\ninterface IBurnMintERC20 is IERC20Upgradeable {\n    /// @notice Mints new tokens for a given address.\n    /// @param account The address to mint the new tokens to.\n    /// @param amount The number of tokens to be minted.\n    /// @dev this function increases the total supply.\n    function mint(address account, uint256 amount) external;\n\n    /// @notice Burns tokens from the sender.\n    /// @param amount The number of tokens to be burned.\n    /// @dev this function decreases the total supply.\n    function burn(uint256 amount) external;\n\n    /// @notice Burns tokens from a given address..\n    /// @param account The address to burn tokens from.\n    /// @param amount The number of tokens to be burned.\n    /// @dev this function decreases the total supply.\n    function burn(address account, uint256 amount) external;\n\n    /// @notice Burns tokens from a given address..\n    /// @param account The address to burn tokens from.\n    /// @param amount The number of tokens to be burned.\n    /// @dev this function decreases the total supply.\n    function burnFrom(address account, uint256 amount) external;\n}\n"
    },
    "contracts/src/l2-token/IGetCCIPAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IGetCCIPAdmin {\n    /// @notice Returns the admin of the token.\n    /// @dev This method is named to never conflict with existing methods.\n    function getCCIPAdmin() external view returns (address);\n}\n"
    },
    "contracts/src/l2-token/state/CCIPAdminAddress.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\nimport \"../../libraries/LibSanitize.sol\";\n\n/// @title CCIPAdmin Address Storage\n/// @notice Utility to manage the CCIPAdmin Address in storage\nlibrary CCIPAdminAddress {\n    /// @notice Storage slot of the CCIPAdmin Address\n    bytes32 internal constant CCIP_ADMIN_ADDRESS_SLOT = bytes32(uint256(keccak256(\"state.ccipAdminAddress\")) - 1);\n\n    /// @notice Retrieve the CCIPAdmin Address\n    /// @return The CCIPAdmin Address\n    function get() internal view returns (address) {\n        return LibUnstructuredStorage.getStorageAddress(CCIP_ADMIN_ADDRESS_SLOT);\n    }\n\n    /// @notice Sets the CCIPAdmin Address\n    /// @param _newValue New CCIPAdmin Address\n    function set(address _newValue) internal {\n        LibUnstructuredStorage.setStorageAddress(CCIP_ADMIN_ADDRESS_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/libraries/LibAdministrable.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\nimport \"../state/shared/AdministratorAddress.sol\";\nimport \"../state/shared/PendingAdministratorAddress.sol\";\n\n/// @title Lib Administrable\n/// @author Alluvial Finance Inc.\n/// @notice This library handles the admin and pending admin storage vars\nlibrary LibAdministrable {\n    /// @notice Retrieve the system admin\n    /// @return The address of the system admin\n    function _getAdmin() internal view returns (address) {\n        return AdministratorAddress.get();\n    }\n\n    /// @notice Retrieve the pending system admin\n    /// @return The adress of the pending system admin\n    function _getPendingAdmin() internal view returns (address) {\n        return PendingAdministratorAddress.get();\n    }\n\n    /// @notice Sets the system admin\n    /// @param _admin New system admin\n    function _setAdmin(address _admin) internal {\n        AdministratorAddress.set(_admin);\n    }\n\n    /// @notice Sets the pending system admin\n    /// @param _pendingAdmin New pending system admin\n    function _setPendingAdmin(address _pendingAdmin) internal {\n        PendingAdministratorAddress.set(_pendingAdmin);\n    }\n}\n"
    },
    "contracts/src/libraries/LibAllowlistMasks.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\n/// @title Lib Allowlist Masks\n/// @notice Holds all the mask values\nlibrary LibAllowlistMasks {\n    /// @notice Mask used for denied accounts\n    uint256 internal constant DENY_MASK = 0x1 << 255;\n    /// @notice The mask for the deposit right\n    uint256 internal constant DEPOSIT_MASK = 0x1;\n    /// @notice The mask for the donation right\n    uint256 internal constant DONATE_MASK = 0x1 << 1;\n    /// @notice The mask for the redeem right\n    uint256 internal constant REDEEM_MASK = 0x1 << 2;\n}\n"
    },
    "contracts/src/libraries/LibBasisPoints.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\n/// @title Lib Basis Points\n/// @notice Holds the basis points max value\nlibrary LibBasisPoints {\n    /// @notice The max value for basis points (represents 100%)\n    uint256 internal constant BASIS_POINTS_MAX = 10_000;\n}\n"
    },
    "contracts/src/libraries/LibBytes.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\n/// @title Lib Bytes\n/// @notice This library helps manipulating bytes\nlibrary LibBytes {\n    /// @notice The length overflows an uint\n    error SliceOverflow();\n\n    /// @notice The slice is outside of the initial bytes bounds\n    error SliceOutOfBounds();\n\n    /// @notice Slices the provided bytes\n    /// @param _bytes Bytes to slice\n    /// @param _start The starting index of the slice\n    /// @param _length The length of the slice\n    /// @return The slice of _bytes starting at _start of length _length\n    function slice(bytes memory _bytes, uint256 _start, uint256 _length) internal pure returns (bytes memory) {\n        unchecked {\n            if (_length + 31 < _length) {\n                revert SliceOverflow();\n            }\n        }\n        if (_bytes.length < _start + _length) {\n            revert SliceOutOfBounds();\n        }\n\n        bytes memory tempBytes;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } { mstore(mc, mload(cc)) }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n}\n"
    },
    "contracts/src/libraries/LibErrors.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\n/// @title Lib Errors\n/// @notice Library of common errors\nlibrary LibErrors {\n    /// @notice The operator is unauthorized for the caller\n    /// @param caller Address performing the call\n    error Unauthorized(address caller);\n\n    /// @notice The call was invalid\n    error InvalidCall();\n\n    /// @notice The argument was invalid\n    error InvalidArgument();\n\n    /// @notice The address is zero\n    error InvalidZeroAddress();\n\n    /// @notice The string is empty\n    error InvalidEmptyString();\n\n    /// @notice The fee is invalid\n    error InvalidFee();\n}\n"
    },
    "contracts/src/libraries/LibSanitize.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\nimport \"./LibErrors.sol\";\nimport \"./LibBasisPoints.sol\";\n\n/// @title Lib Sanitize\n/// @notice Utilities to sanitize input values\nlibrary LibSanitize {\n    /// @notice Reverts if address is 0\n    /// @param _address Address to check\n    function _notZeroAddress(address _address) internal pure {\n        if (_address == address(0)) {\n            revert LibErrors.InvalidZeroAddress();\n        }\n    }\n\n    /// @notice Reverts if string is empty\n    /// @param _string String to check\n    function _notEmptyString(string memory _string) internal pure {\n        if (bytes(_string).length == 0) {\n            revert LibErrors.InvalidEmptyString();\n        }\n    }\n\n    /// @notice Reverts if fee is invalid\n    /// @param _fee Fee to check\n    function _validFee(uint256 _fee) internal pure {\n        if (_fee > LibBasisPoints.BASIS_POINTS_MAX) {\n            revert LibErrors.InvalidFee();\n        }\n    }\n}\n"
    },
    "contracts/src/libraries/LibUint256.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\n/// @title Lib Uint256\n/// @notice Utilities to perform uint operations\nlibrary LibUint256 {\n    /// @notice Converts a value to little endian (64 bits)\n    /// @param _value The value to convert\n    /// @return result The converted value\n    function toLittleEndian64(uint256 _value) internal pure returns (uint256 result) {\n        uint256 tempValue = _value;\n        result = tempValue & 0xFF;\n        tempValue >>= 8;\n\n        result = (result << 8) | (tempValue & 0xFF);\n        tempValue >>= 8;\n\n        result = (result << 8) | (tempValue & 0xFF);\n        tempValue >>= 8;\n\n        result = (result << 8) | (tempValue & 0xFF);\n        tempValue >>= 8;\n\n        result = (result << 8) | (tempValue & 0xFF);\n        tempValue >>= 8;\n\n        result = (result << 8) | (tempValue & 0xFF);\n        tempValue >>= 8;\n\n        result = (result << 8) | (tempValue & 0xFF);\n        tempValue >>= 8;\n\n        result = (result << 8) | (tempValue & 0xFF);\n        tempValue >>= 8;\n\n        assert(0 == tempValue); // fully converted\n        result <<= (24 * 8);\n    }\n\n    /// @notice Returns the minimum value\n    /// @param _a First value\n    /// @param _b Second value\n    /// @return Smallest value between _a and _b\n    function min(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        return (_a > _b ? _b : _a);\n    }\n\n    /// @notice Returns the max value\n    /// @param _a First value\n    /// @param _b Second value\n    /// @return Highest value between _a and _b\n    function max(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        return (_a < _b ? _b : _a);\n    }\n\n    /// @notice Performs a ceiled division\n    /// @param _a Numerator\n    /// @param _b Denominator\n    /// @return ceil(_a / _b)\n    function ceil(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        return (_a / _b) + (_a % _b > 0 ? 1 : 0);\n    }\n}\n"
    },
    "contracts/src/libraries/LibUnstructuredStorage.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.20;\n\n/// @title Lib Unstructured Storage\n/// @notice Utilities to work with unstructured storage\nlibrary LibUnstructuredStorage {\n    /// @notice Retrieve a bool value at a storage slot\n    /// @param _position The storage slot to retrieve\n    /// @return data The bool value\n    function getStorageBool(bytes32 _position) internal view returns (bool data) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            data := sload(_position)\n        }\n    }\n\n    /// @notice Retrieve an address value at a storage slot\n    /// @param _position The storage slot to retrieve\n    /// @return data The address value\n    function getStorageAddress(bytes32 _position) internal view returns (address data) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            data := sload(_position)\n        }\n    }\n\n    /// @notice Retrieve a bytes32 value at a storage slot\n    /// @param _position The storage slot to retrieve\n    /// @return data The bytes32 value\n    function getStorageBytes32(bytes32 _position) internal view returns (bytes32 data) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            data := sload(_position)\n        }\n    }\n\n    /// @notice Retrieve an uint256 value at a storage slot\n    /// @param _position The storage slot to retrieve\n    /// @return data The uint256 value\n    function getStorageUint256(bytes32 _position) internal view returns (uint256 data) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            data := sload(_position)\n        }\n    }\n\n    /// @notice Sets a bool value at a storage slot\n    /// @param _position The storage slot to set\n    /// @param _data The bool value to set\n    function setStorageBool(bytes32 _position, bool _data) internal {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(_position, _data)\n        }\n    }\n\n    /// @notice Sets an address value at a storage slot\n    /// @param _position The storage slot to set\n    /// @param _data The address value to set\n    function setStorageAddress(bytes32 _position, address _data) internal {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(_position, _data)\n        }\n    }\n\n    /// @notice Sets a bytes32 value at a storage slot\n    /// @param _position The storage slot to set\n    /// @param _data The bytes32 value to set\n    function setStorageBytes32(bytes32 _position, bytes32 _data) internal {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(_position, _data)\n        }\n    }\n\n    /// @notice Sets an uint256 value at a storage slot\n    /// @param _position The storage slot to set\n    /// @param _data The uint256 value to set\n    function setStorageUint256(bytes32 _position, uint256 _data) internal {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(_position, _data)\n        }\n    }\n}\n"
    },
    "contracts/src/River.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\nimport \"./interfaces/IAllowlist.1.sol\";\nimport \"./interfaces/IOperatorRegistry.1.sol\";\nimport \"./interfaces/IRiver.1.sol\";\nimport \"./interfaces/IWithdraw.1.sol\";\nimport \"./interfaces/IELFeeRecipient.1.sol\";\nimport \"./interfaces/ICoverageFund.1.sol\";\nimport \"./interfaces/IProtocolVersion.sol\";\n\nimport \"./components/ConsensusLayerDepositManager.1.sol\";\nimport \"./components/UserDepositManager.1.sol\";\nimport \"./components/SharesManager.1.sol\";\nimport \"./components/OracleManager.1.sol\";\nimport \"./Initializable.sol\";\nimport \"./Administrable.sol\";\n\nimport \"./libraries/LibAllowlistMasks.sol\";\n\nimport \"./state/river/AllowlistAddress.sol\";\nimport \"./state/river/RedeemManagerAddress.sol\";\nimport \"./state/river/OperatorsRegistryAddress.sol\";\nimport \"./state/river/CollectorAddress.sol\";\nimport \"./state/river/ELFeeRecipientAddress.sol\";\nimport \"./state/river/CoverageFundAddress.sol\";\nimport \"./state/river/BalanceToRedeem.sol\";\nimport \"./state/river/GlobalFee.sol\";\nimport \"./state/river/MetadataURI.sol\";\nimport \"./state/river/LastConsensusLayerReport.sol\";\n\n/// @title River (v1)\n/// @author Alluvial Finance Inc.\n/// @notice This contract merges all the manager contracts and implements all the virtual methods stitching all components together\ncontract RiverV1 is\n    ConsensusLayerDepositManagerV1,\n    UserDepositManagerV1,\n    SharesManagerV1,\n    OracleManagerV1,\n    Initializable,\n    Administrable,\n    IProtocolVersion,\n    IRiverV1\n{\n    /// @inheritdoc IRiverV1\n    function initRiverV1(\n        address _depositContractAddress,\n        address _elFeeRecipientAddress,\n        bytes32 _withdrawalCredentials,\n        address _oracleAddress,\n        address _systemAdministratorAddress,\n        address _allowlistAddress,\n        address _operatorRegistryAddress,\n        address _collectorAddress,\n        uint256 _globalFee\n    ) external init(0) {\n        _setAdmin(_systemAdministratorAddress);\n\n        CollectorAddress.set(_collectorAddress);\n        emit SetCollector(_collectorAddress);\n\n        GlobalFee.set(_globalFee);\n        emit SetGlobalFee(_globalFee);\n\n        ELFeeRecipientAddress.set(_elFeeRecipientAddress);\n        emit SetELFeeRecipient(_elFeeRecipientAddress);\n\n        AllowlistAddress.set(_allowlistAddress);\n        emit SetAllowlist(_allowlistAddress);\n\n        OperatorsRegistryAddress.set(_operatorRegistryAddress);\n        emit SetOperatorsRegistry(_operatorRegistryAddress);\n\n        ConsensusLayerDepositManagerV1.initConsensusLayerDepositManagerV1(\n            _depositContractAddress, _withdrawalCredentials\n        );\n\n        OracleManagerV1.initOracleManagerV1(_oracleAddress);\n    }\n\n    /// @inheritdoc IRiverV1\n    function initRiverV1_1(\n        address _redeemManager,\n        uint64 _epochsPerFrame,\n        uint64 _slotsPerEpoch,\n        uint64 _secondsPerSlot,\n        uint64 _genesisTime,\n        uint64 _epochsToAssumedFinality,\n        uint256 _annualAprUpperBound,\n        uint256 _relativeLowerBound,\n        uint128 _minDailyNetCommittableAmount_,\n        uint128 _maxDailyRelativeCommittableAmount_\n    ) external init(1) {\n        RedeemManagerAddress.set(_redeemManager);\n        emit SetRedeemManager(_redeemManager);\n\n        _setDailyCommittableLimits(\n            DailyCommittableLimits.DailyCommittableLimitsStruct({\n                minDailyNetCommittableAmount: _minDailyNetCommittableAmount_,\n                maxDailyRelativeCommittableAmount: _maxDailyRelativeCommittableAmount_\n            })\n        );\n\n        initOracleManagerV1_1(\n            _epochsPerFrame,\n            _slotsPerEpoch,\n            _secondsPerSlot,\n            _genesisTime,\n            _epochsToAssumedFinality,\n            _annualAprUpperBound,\n            _relativeLowerBound\n        );\n\n        _approve(address(this), _redeemManager, type(uint256).max);\n    }\n\n    /// @inheritdoc IRiverV1\n    function initRiverV1_2() external init(2) {\n        // force committed balance to a multiple of 32 ETH and\n        // move extra funds back to the deposit buffer\n        uint256 dustToUncommit = CommittedBalance.get() % DEPOSIT_SIZE;\n        unchecked {\n            _setCommittedBalance(CommittedBalance.get() - dustToUncommit);\n            _setBalanceToDeposit(BalanceToDeposit.get() + dustToUncommit);\n        }\n    }\n\n    /// @inheritdoc IRiverV1\n    function getGlobalFee() external view returns (uint256) {\n        return GlobalFee.get();\n    }\n\n    /// @inheritdoc IRiverV1\n    function getAllowlist() external view returns (address) {\n        return AllowlistAddress.get();\n    }\n\n    /// @inheritdoc IRiverV1\n    function getCollector() external view returns (address) {\n        return CollectorAddress.get();\n    }\n\n    /// @inheritdoc IRiverV1\n    function getELFeeRecipient() external view returns (address) {\n        return ELFeeRecipientAddress.get();\n    }\n\n    /// @inheritdoc IRiverV1\n    function getCoverageFund() external view returns (address) {\n        return CoverageFundAddress.get();\n    }\n\n    /// @inheritdoc IRiverV1\n    function getRedeemManager() external view returns (address) {\n        return RedeemManagerAddress.get();\n    }\n\n    /// @inheritdoc IRiverV1\n    function getMetadataURI() external view returns (string memory) {\n        return MetadataURI.get();\n    }\n\n    /// @inheritdoc IRiverV1\n    function getDailyCommittableLimits()\n        external\n        view\n        returns (DailyCommittableLimits.DailyCommittableLimitsStruct memory)\n    {\n        return DailyCommittableLimits.get();\n    }\n\n    /// @inheritdoc IRiverV1\n    function setDailyCommittableLimits(DailyCommittableLimits.DailyCommittableLimitsStruct memory _dcl)\n        external\n        onlyAdmin\n    {\n        _setDailyCommittableLimits(_dcl);\n    }\n\n    function setKeeper(address _keeper) external onlyAdmin {\n        _setKeeper(_keeper);\n    }\n\n    /// @inheritdoc IRiverV1\n    function getBalanceToRedeem() external view returns (uint256) {\n        return BalanceToRedeem.get();\n    }\n\n    /// @inheritdoc IRiverV1\n    function resolveRedeemRequests(uint32[] calldata _redeemRequestIds)\n        external\n        view\n        returns (int64[] memory withdrawalEventIds)\n    {\n        return IRedeemManagerV1(RedeemManagerAddress.get()).resolveRedeemRequests(_redeemRequestIds);\n    }\n\n    /// @inheritdoc IRiverV1\n    function requestRedeem(uint256 _lsETHAmount, address _recipient) external returns (uint32 _redeemRequestId) {\n        IAllowlistV1(AllowlistAddress.get()).onlyAllowed(msg.sender, LibAllowlistMasks.REDEEM_MASK);\n        _transfer(msg.sender, address(this), _lsETHAmount);\n        return IRedeemManagerV1(RedeemManagerAddress.get()).requestRedeem(_lsETHAmount, _recipient);\n    }\n\n    /// @inheritdoc IRiverV1\n    function claimRedeemRequests(uint32[] calldata _redeemRequestIds, uint32[] calldata _withdrawalEventIds)\n        external\n        returns (uint8[] memory claimStatuses)\n    {\n        return IRedeemManagerV1(RedeemManagerAddress.get()).claimRedeemRequests(\n            _redeemRequestIds, _withdrawalEventIds, true, type(uint16).max\n        );\n    }\n\n    /// @inheritdoc IRiverV1\n    function setGlobalFee(uint256 _newFee) external onlyAdmin {\n        GlobalFee.set(_newFee);\n        emit SetGlobalFee(_newFee);\n    }\n\n    /// @inheritdoc IRiverV1\n    function setAllowlist(address _newAllowlist) external onlyAdmin {\n        AllowlistAddress.set(_newAllowlist);\n        emit SetAllowlist(_newAllowlist);\n    }\n\n    /// @inheritdoc IRiverV1\n    function setCollector(address _newCollector) external onlyAdmin {\n        CollectorAddress.set(_newCollector);\n        emit SetCollector(_newCollector);\n    }\n\n    /// @inheritdoc IRiverV1\n    function setELFeeRecipient(address _newELFeeRecipient) external onlyAdmin {\n        ELFeeRecipientAddress.set(_newELFeeRecipient);\n        emit SetELFeeRecipient(_newELFeeRecipient);\n    }\n\n    /// @inheritdoc IRiverV1\n    function setCoverageFund(address _newCoverageFund) external onlyAdmin {\n        CoverageFundAddress.set(_newCoverageFund);\n        emit SetCoverageFund(_newCoverageFund);\n    }\n\n    /// @inheritdoc IRiverV1\n    function setMetadataURI(string memory _metadataURI) external onlyAdmin {\n        LibSanitize._notEmptyString(_metadataURI);\n        MetadataURI.set(_metadataURI);\n        emit SetMetadataURI(_metadataURI);\n    }\n\n    /// @inheritdoc IRiverV1\n    function getOperatorsRegistry() external view returns (address) {\n        return OperatorsRegistryAddress.get();\n    }\n\n    /// @inheritdoc IRiverV1\n    function sendELFees() external payable {\n        if (msg.sender != ELFeeRecipientAddress.get()) {\n            revert LibErrors.Unauthorized(msg.sender);\n        }\n    }\n\n    /// @inheritdoc IRiverV1\n    function sendCLFunds() external payable {\n        if (msg.sender != WithdrawalCredentials.getAddress()) {\n            revert LibErrors.Unauthorized(msg.sender);\n        }\n    }\n\n    /// @inheritdoc IRiverV1\n    function sendCoverageFunds() external payable {\n        if (msg.sender != CoverageFundAddress.get()) {\n            revert LibErrors.Unauthorized(msg.sender);\n        }\n    }\n\n    /// @inheritdoc IRiverV1\n    function sendRedeemManagerExceedingFunds() external payable {\n        if (msg.sender != RedeemManagerAddress.get()) {\n            revert LibErrors.Unauthorized(msg.sender);\n        }\n    }\n\n    /// @notice Overridden handler to pass the system admin inside components\n    /// @return The address of the admin\n    function _getRiverAdmin()\n        internal\n        view\n        override(OracleManagerV1, ConsensusLayerDepositManagerV1)\n        returns (address)\n    {\n        return Administrable._getAdmin();\n    }\n\n    /// @notice Overridden handler called whenever a token transfer is triggered\n    /// @param _from Token sender\n    /// @param _to Token receiver\n    function _onTransfer(address _from, address _to) internal view override {\n        IAllowlistV1 allowlist = IAllowlistV1(AllowlistAddress.get());\n        if (allowlist.isDenied(_from)) {\n            revert Denied(_from);\n        }\n        if (allowlist.isDenied(_to)) {\n            revert Denied(_to);\n        }\n    }\n\n    /// @notice Overridden handler called whenever a user deposits ETH to the system. Mints the adequate amount of shares.\n    /// @param _depositor User address that made the deposit\n    /// @param _amount Amount of ETH deposited\n    function _onDeposit(address _depositor, address _recipient, uint256 _amount) internal override {\n        uint256 mintedShares = SharesManagerV1._mintShares(_depositor, _amount);\n        IAllowlistV1 allowlist = IAllowlistV1(AllowlistAddress.get());\n        allowlist.onlyAllowed(_depositor, LibAllowlistMasks.DEPOSIT_MASK); // this call reverts if unauthorized or denied\n        if (_depositor != _recipient) {\n            if (allowlist.isDenied(_recipient)) {\n                revert Denied(_recipient);\n            }\n            _transfer(_depositor, _recipient, mintedShares);\n        }\n    }\n\n    /// @notice Overridden handler called whenever a deposit to the consensus layer is made. Should retrieve _requestedAmount or lower keys\n    /// @param _requestedAmount Amount of keys required. Contract is expected to send _requestedAmount or lower.\n    /// @return publicKeys Array of fundable public keys\n    /// @return signatures Array of signatures linked to the public keys\n    function _getNextValidators(uint256 _requestedAmount)\n        internal\n        override\n        returns (bytes[] memory publicKeys, bytes[] memory signatures)\n    {\n        return IOperatorsRegistryV1(OperatorsRegistryAddress.get()).pickNextValidatorsToDeposit(_requestedAmount);\n    }\n\n    /// @notice Overridden handler to pull funds from the execution layer fee recipient to River and return the delta in the balance\n    /// @param _max The maximum amount to pull from the execution layer fee recipient\n    /// @return The amount pulled from the execution layer fee recipient\n    function _pullELFees(uint256 _max) internal override returns (uint256) {\n        address elFeeRecipient = ELFeeRecipientAddress.get();\n        uint256 initialBalance = address(this).balance;\n        IELFeeRecipientV1(payable(elFeeRecipient)).pullELFees(_max);\n        uint256 collectedELFees = address(this).balance - initialBalance;\n        if (collectedELFees > 0) {\n            _setBalanceToDeposit(BalanceToDeposit.get() + collectedELFees);\n        }\n        emit PulledELFees(collectedELFees);\n        return collectedELFees;\n    }\n\n    /// @notice Overridden handler to pull funds from the coverage fund to River and return the delta in the balance\n    /// @param _max The maximum amount to pull from the coverage fund\n    /// @return The amount pulled from the coverage fund\n    function _pullCoverageFunds(uint256 _max) internal override returns (uint256) {\n        address coverageFund = CoverageFundAddress.get();\n        if (coverageFund == address(0)) {\n            return 0;\n        }\n        uint256 initialBalance = address(this).balance;\n        ICoverageFundV1(payable(coverageFund)).pullCoverageFunds(_max);\n        uint256 collectedCoverageFunds = address(this).balance - initialBalance;\n        if (collectedCoverageFunds > 0) {\n            _setBalanceToDeposit(BalanceToDeposit.get() + collectedCoverageFunds);\n        }\n        emit PulledCoverageFunds(collectedCoverageFunds);\n        return collectedCoverageFunds;\n    }\n\n    /// @notice Overridden handler called whenever the balance of ETH handled by the system increases. Computes the fees paid to the collector\n    /// @param _amount Additional ETH received\n    function _onEarnings(uint256 _amount) internal override {\n        uint256 oldTotalSupply = _totalSupply();\n        if (oldTotalSupply == 0) {\n            revert ZeroMintedShares();\n        }\n        uint256 newTotalBalance = _assetBalance();\n        uint256 globalFee = GlobalFee.get();\n        uint256 numerator = _amount * oldTotalSupply * globalFee;\n        uint256 denominator = (newTotalBalance * LibBasisPoints.BASIS_POINTS_MAX) - (_amount * globalFee);\n        uint256 sharesToMint = denominator == 0 ? 0 : (numerator / denominator);\n\n        if (sharesToMint > 0) {\n            address collector = CollectorAddress.get();\n            _mintRawShares(collector, sharesToMint);\n            uint256 newTotalSupply = _totalSupply();\n            uint256 oldTotalBalance = newTotalBalance - _amount;\n            emit RewardsEarned(collector, oldTotalBalance, oldTotalSupply, newTotalBalance, newTotalSupply);\n        }\n    }\n\n    /// @notice Overridden handler called whenever the total balance of ETH is requested\n    /// @return The current total asset balance managed by River\n    function _assetBalance() internal view override(SharesManagerV1, OracleManagerV1) returns (uint256) {\n        IOracleManagerV1.StoredConsensusLayerReport storage storedReport = LastConsensusLayerReport.get();\n        uint256 clValidatorCount = storedReport.validatorsCount;\n        uint256 depositedValidatorCount = DepositedValidatorCount.get();\n        if (clValidatorCount < depositedValidatorCount) {\n            return storedReport.validatorsBalance + BalanceToDeposit.get() + CommittedBalance.get()\n                + BalanceToRedeem.get()\n                + (depositedValidatorCount - clValidatorCount) * ConsensusLayerDepositManagerV1.DEPOSIT_SIZE;\n        } else {\n            return\n                storedReport.validatorsBalance + BalanceToDeposit.get() + CommittedBalance.get() + BalanceToRedeem.get();\n        }\n    }\n\n    /// @notice Internal utility to set the daily committable limits\n    /// @param _dcl The new daily committable limits\n    function _setDailyCommittableLimits(DailyCommittableLimits.DailyCommittableLimitsStruct memory _dcl) internal {\n        DailyCommittableLimits.set(_dcl);\n        emit SetMaxDailyCommittableAmounts(_dcl.minDailyNetCommittableAmount, _dcl.maxDailyRelativeCommittableAmount);\n    }\n\n    /// @notice Sets the balance to deposit, but not yet committed\n    /// @param _newBalanceToDeposit The new balance to deposit value\n    function _setBalanceToDeposit(uint256 _newBalanceToDeposit) internal override(UserDepositManagerV1) {\n        emit SetBalanceToDeposit(BalanceToDeposit.get(), _newBalanceToDeposit);\n        BalanceToDeposit.set(_newBalanceToDeposit);\n    }\n\n    /// @notice Sets the balance to redeem, to be used to satisfy redeem requests on the redeem manager\n    /// @param _newBalanceToRedeem The new balance to redeem value\n    function _setBalanceToRedeem(uint256 _newBalanceToRedeem) internal {\n        emit SetBalanceToRedeem(BalanceToRedeem.get(), _newBalanceToRedeem);\n        BalanceToRedeem.set(_newBalanceToRedeem);\n    }\n\n    /// @notice Sets the committed balance, ready to be deposited to the consensus layer\n    /// @param _newCommittedBalance The new committed balance value\n    function _setCommittedBalance(uint256 _newCommittedBalance) internal override(ConsensusLayerDepositManagerV1) {\n        emit SetBalanceCommittedToDeposit(CommittedBalance.get(), _newCommittedBalance);\n        CommittedBalance.set(_newCommittedBalance);\n    }\n\n    /// @notice Pulls funds from the Withdraw contract, and adds funds to deposit and redeem balances\n    /// @param _skimmedEthAmount The new amount of skimmed eth to pull\n    /// @param _exitedEthAmount The new amount of exited eth to pull\n    function _pullCLFunds(uint256 _skimmedEthAmount, uint256 _exitedEthAmount) internal override {\n        uint256 currentBalance = address(this).balance;\n        uint256 totalAmountToPull = _skimmedEthAmount + _exitedEthAmount;\n        IWithdrawV1(WithdrawalCredentials.getAddress()).pullEth(totalAmountToPull);\n        uint256 collectedCLFunds = address(this).balance - currentBalance;\n        if (collectedCLFunds != _skimmedEthAmount + _exitedEthAmount) {\n            revert InvalidPulledClFundsAmount(_skimmedEthAmount + _exitedEthAmount, collectedCLFunds);\n        }\n        if (_skimmedEthAmount > 0) {\n            _setBalanceToDeposit(BalanceToDeposit.get() + _skimmedEthAmount);\n        }\n        if (_exitedEthAmount > 0) {\n            _setBalanceToRedeem(BalanceToRedeem.get() + _exitedEthAmount);\n        }\n        emit PulledCLFunds(_skimmedEthAmount, _exitedEthAmount);\n    }\n\n    /// @notice Pulls funds from the redeem manager exceeding eth buffer\n    /// @param _max The maximum amount to pull\n    function _pullRedeemManagerExceedingEth(uint256 _max) internal override returns (uint256) {\n        uint256 currentBalance = address(this).balance;\n        IRedeemManagerV1(RedeemManagerAddress.get()).pullExceedingEth(_max);\n        uint256 collectedExceedingEth = address(this).balance - currentBalance;\n        if (collectedExceedingEth > 0) {\n            _setBalanceToDeposit(BalanceToDeposit.get() + collectedExceedingEth);\n        }\n        emit PulledRedeemManagerExceedingEth(collectedExceedingEth);\n        return collectedExceedingEth;\n    }\n\n    /// @notice Use the balance to redeem to report a withdrawal event on the redeem manager\n    function _reportWithdrawToRedeemManager() internal override {\n        IRedeemManagerV1 redeemManager_ = IRedeemManagerV1(RedeemManagerAddress.get());\n        uint256 underlyingAssetBalance = _assetBalance();\n        uint256 totalSupply = _totalSupply();\n\n        if (underlyingAssetBalance > 0 && totalSupply > 0) {\n            // we compute the redeem manager demands in eth and lsEth based on current conversion rate\n            uint256 redeemManagerDemand = redeemManager_.getRedeemDemand();\n            uint256 suppliedRedeemManagerDemand = redeemManagerDemand;\n            uint256 suppliedRedeemManagerDemandInEth = _balanceFromShares(suppliedRedeemManagerDemand);\n            uint256 availableBalanceToRedeem = BalanceToRedeem.get();\n\n            // if demand is higher than available eth, we update demand values to use the available eth\n            if (suppliedRedeemManagerDemandInEth > availableBalanceToRedeem) {\n                suppliedRedeemManagerDemandInEth = availableBalanceToRedeem;\n                suppliedRedeemManagerDemand = _sharesFromBalance(suppliedRedeemManagerDemandInEth);\n            }\n\n            emit ReportedRedeemManager(\n                redeemManagerDemand, suppliedRedeemManagerDemand, suppliedRedeemManagerDemandInEth\n            );\n\n            if (suppliedRedeemManagerDemandInEth > 0) {\n                // the available balance to redeem is updated\n                unchecked {\n                    _setBalanceToRedeem(availableBalanceToRedeem - suppliedRedeemManagerDemandInEth);\n                }\n\n                // we burn the shares of the redeem manager associated with the amount of eth provided\n                _burnRawShares(address(redeemManager_), suppliedRedeemManagerDemand);\n\n                // perform a report withdraw call to the redeem manager\n                redeemManager_.reportWithdraw{value: suppliedRedeemManagerDemandInEth}(suppliedRedeemManagerDemand);\n            }\n        }\n    }\n\n    /// @notice Requests exits of validators after possibly rebalancing deposit and redeem balances\n    /// @param _exitingBalance The currently exiting funds, soon to be received on the execution layer\n    /// @param _depositToRedeemRebalancingAllowed True if rebalancing from deposit to redeem is allowed\n    function _requestExitsBasedOnRedeemDemandAfterRebalancings(\n        uint256 _exitingBalance,\n        uint32[] memory _stoppedValidatorCounts,\n        bool _depositToRedeemRebalancingAllowed,\n        bool _slashingContainmentModeEnabled\n    ) internal override {\n        IOperatorsRegistryV1(OperatorsRegistryAddress.get()).reportStoppedValidatorCounts(\n            _stoppedValidatorCounts, DepositedValidatorCount.get()\n        );\n\n        if (_slashingContainmentModeEnabled) {\n            return;\n        }\n\n        uint256 totalSupply = _totalSupply();\n        if (totalSupply > 0) {\n            uint256 availableBalanceToRedeem = BalanceToRedeem.get();\n            uint256 availableBalanceToDeposit = BalanceToDeposit.get();\n            uint256 redeemManagerDemandInEth =\n                _balanceFromShares(IRedeemManagerV1(RedeemManagerAddress.get()).getRedeemDemand());\n\n            // if after all rebalancings, the redeem manager demand is still higher than the balance to redeem and exiting eth, we compute\n            // the amount of validators to exit in order to cover the remaining demand\n            if (availableBalanceToRedeem + _exitingBalance < redeemManagerDemandInEth) {\n                // if reblancing is enabled and the redeem manager demand is higher than exiting eth, we add eth for deposit buffer to redeem buffer\n                if (_depositToRedeemRebalancingAllowed && availableBalanceToDeposit > 0) {\n                    uint256 rebalancingAmount = LibUint256.min(\n                        availableBalanceToDeposit, redeemManagerDemandInEth - _exitingBalance - availableBalanceToRedeem\n                    );\n                    if (rebalancingAmount > 0) {\n                        availableBalanceToRedeem += rebalancingAmount;\n                        _setBalanceToRedeem(availableBalanceToRedeem);\n                        _setBalanceToDeposit(availableBalanceToDeposit - rebalancingAmount);\n                    }\n                }\n\n                IOperatorsRegistryV1 or = IOperatorsRegistryV1(OperatorsRegistryAddress.get());\n\n                (uint256 totalStoppedValidatorCount, uint256 totalRequestedExitsCount) =\n                    or.getStoppedAndRequestedExitCounts();\n\n                // what we are calling pre-exiting balance is the amount of eth that should soon enter the exiting balance\n                // because exit requests have been made and operators might have a lag to process them\n                // we take them into account to not exit too many validators\n                uint256 preExitingBalance = (\n                    totalRequestedExitsCount > totalStoppedValidatorCount\n                        ? (totalRequestedExitsCount - totalStoppedValidatorCount)\n                        : 0\n                ) * DEPOSIT_SIZE;\n\n                if (availableBalanceToRedeem + _exitingBalance + preExitingBalance < redeemManagerDemandInEth) {\n                    uint256 validatorCountToExit = LibUint256.ceil(\n                        redeemManagerDemandInEth - (availableBalanceToRedeem + _exitingBalance + preExitingBalance),\n                        DEPOSIT_SIZE\n                    );\n\n                    or.demandValidatorExits(validatorCountToExit, DepositedValidatorCount.get());\n                }\n            }\n        }\n    }\n\n    /// @notice Skims the redeem balance and sends remaining funds to the deposit balance\n    function _skimExcessBalanceToRedeem() internal override {\n        uint256 availableBalanceToRedeem = BalanceToRedeem.get();\n\n        // if the available balance to redeem is not 0, it means that all the redeem requests are fulfilled, we should redirect funds for deposits\n        if (availableBalanceToRedeem > 0) {\n            _setBalanceToDeposit(BalanceToDeposit.get() + availableBalanceToRedeem);\n            _setBalanceToRedeem(0);\n        }\n    }\n\n    /// @notice Commits the deposit balance up to the allowed daily limit in batches of 32 ETH.\n    /// @notice Committed funds are funds waiting to be deposited but that cannot be used to fund the redeem manager anymore\n    /// @notice This two step process is required to prevent possible out of gas issues we would have from actually funding the validators at this point\n    /// @param _period The period between current and last report\n    function _commitBalanceToDeposit(uint256 _period) internal override {\n        uint256 underlyingAssetBalance = _assetBalance();\n        uint256 currentBalanceToDeposit = BalanceToDeposit.get();\n        DailyCommittableLimits.DailyCommittableLimitsStruct memory dcl = DailyCommittableLimits.get();\n\n        // we compute the max daily committable amount by taking the asset balance without the balance to deposit into account\n        // this value is the daily maximum amount we can commit for deposits\n        // we take the maximum value between a net amount and an amount relative to the asset balance\n        // this ensures that the amount we can commit is not too low in the beginning and that it is not too high when volumes grow\n        // the relative amount is computed from the committed and activated funds (on the CL or committed to be on the CL soon) and not\n        // the deposit balance\n        // this value is computed by subtracting the current balance to deposit from the underlying asset balance\n        uint256 currentMaxDailyCommittableAmount = LibUint256.max(\n            dcl.minDailyNetCommittableAmount,\n            (uint256(dcl.maxDailyRelativeCommittableAmount) * (underlyingAssetBalance - currentBalanceToDeposit))\n                / LibBasisPoints.BASIS_POINTS_MAX\n        );\n        // we adapt the value for the reporting period by using the asset balance as upper bound\n        uint256 currentMaxCommittableAmount =\n            LibUint256.min((currentMaxDailyCommittableAmount * _period) / 1 days, currentBalanceToDeposit);\n        // we only commit multiples of 32 ETH\n        currentMaxCommittableAmount = (currentMaxCommittableAmount / DEPOSIT_SIZE) * DEPOSIT_SIZE;\n\n        if (currentMaxCommittableAmount > 0) {\n            _setCommittedBalance(CommittedBalance.get() + currentMaxCommittableAmount);\n            _setBalanceToDeposit(currentBalanceToDeposit - currentMaxCommittableAmount);\n        }\n    }\n\n    function version() external pure returns (string memory) {\n        return \"1.2.1\";\n    }\n}\n"
    },
    "contracts/src/state/operatorsRegistry/Operators.2.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\nimport \"../../libraries/LibSanitize.sol\";\n\n/// @title Operators Storage\n/// @notice Utility to manage the Operators in storage\nlibrary OperatorsV2 {\n    /// @notice Storage slot of the Operators\n    bytes32 internal constant OPERATORS_SLOT = bytes32(uint256(keccak256(\"river.state.v2.operators\")) - 1);\n\n    /// @notice The Operator structure in storage\n    struct Operator {\n        /// @dev The following values respect this invariant:\n        /// @dev     keys >= limit >= funded >= RequestedExits\n\n        /// @custom:attribute Staking limit of the operator\n        uint32 limit;\n        /// @custom:attribute The count of funded validators\n        uint32 funded;\n        /// @custom:attribute The count of exit requests made to this operator\n        uint32 requestedExits;\n        /// @custom:attribute The total count of keys of the operator\n        uint32 keys;\n        /// @custom attribute The block at which the last edit happened in the operator details\n        uint64 latestKeysEditBlockNumber;\n        /// @custom:attribute True if the operator is active and allowed to operate on River\n        bool active;\n        /// @custom:attribute Display name of the operator\n        string name;\n        /// @custom:attribute Address of the operator\n        address operator;\n    }\n\n    /// @notice The Operator structure when loaded in memory\n    struct CachedOperator {\n        /// @custom:attribute Staking limit of the operator\n        uint32 limit;\n        /// @custom:attribute The count of funded validators\n        uint32 funded;\n        /// @custom:attribute The count of exit requests made to this operator\n        uint32 requestedExits;\n        /// @custom:attribute The original index of the operator\n        uint32 index;\n        /// @custom:attribute The amount of picked keys, buffer used before changing funded in storage\n        uint32 picked;\n    }\n\n    /// @notice The Operator structure when loaded in memory for the exit selection\n    struct CachedExitableOperator {\n        /// @custom:attribute The count of funded validators\n        uint32 funded;\n        /// @custom:attribute The count of exit requests made to this operator\n        uint32 requestedExits;\n        /// @custom:attribute The original index of the operator\n        uint32 index;\n        /// @custom:attribute The amount of picked keys, buffer used before changing funded in storage\n        uint32 picked;\n    }\n\n    /// @notice The structure at the storage slot\n    struct SlotOperator {\n        /// @custom:attribute Array containing all the operators\n        Operator[] value;\n    }\n\n    /// @notice The operator was not found\n    /// @param index The provided index\n    error OperatorNotFound(uint256 index);\n\n    /// @notice Retrieve the operator in storage\n    /// @param _index The index of the operator\n    /// @return The Operator structure\n    function get(uint256 _index) internal view returns (Operator storage) {\n        bytes32 slot = OPERATORS_SLOT;\n\n        SlotOperator storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        if (r.value.length <= _index) {\n            revert OperatorNotFound(_index);\n        }\n\n        return r.value[_index];\n    }\n\n    /// @notice Retrieve the operators in storage\n    /// @return The Operator structure array\n    function getAll() internal view returns (Operator[] storage) {\n        bytes32 slot = OPERATORS_SLOT;\n\n        SlotOperator storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value;\n    }\n\n    /// @notice Retrieve the operator count in storage\n    /// @return The count of operators in storage\n    function getCount() internal view returns (uint256) {\n        bytes32 slot = OPERATORS_SLOT;\n\n        SlotOperator storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value.length;\n    }\n\n    /// @notice Retrieve all the active operators\n    /// @return The list of active operator structures\n    function getAllActive() internal view returns (Operator[] memory) {\n        bytes32 slot = OPERATORS_SLOT;\n\n        SlotOperator storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        uint256 activeCount = 0;\n        uint256 operatorCount = r.value.length;\n        Operator[] memory activeOperators = new Operator[](operatorCount);\n\n        for (uint256 idx = 0; idx < operatorCount;) {\n            if (r.value[idx].active) {\n                activeOperators[activeCount] = r.value[idx];\n                unchecked {\n                    ++activeCount;\n                }\n            }\n            unchecked {\n                ++idx;\n            }\n        }\n        assembly (\"memory-safe\") {\n            mstore(activeOperators, activeCount)\n        }\n\n        return activeOperators;\n    }\n\n    /// @notice Retrieve the stopped validator count for an operator by its index\n    /// @param stoppedValidatorCounts The storage pointer to the raw array containing the stopped validator counts\n    /// @param index The index of the operator to lookup\n    /// @return The amount of stopped validators for the given operator index\n    function _getStoppedValidatorCountAtIndex(uint32[] storage stoppedValidatorCounts, uint256 index)\n        internal\n        view\n        returns (uint32)\n    {\n        if (index + 1 >= stoppedValidatorCounts.length) {\n            return 0;\n        }\n        return stoppedValidatorCounts[index + 1];\n    }\n\n    /// @notice Retrieve all the active and fundable operators\n    /// @dev This method will return a memory array of length equal to the number of operator, but only\n    /// @dev populated up to the fundable operator count, also returned by the method\n    /// @return The list of active and fundable operators\n    /// @return The count of active and fundable operators\n    function getAllFundable() internal view returns (CachedOperator[] memory, uint256) {\n        bytes32 slot = OPERATORS_SLOT;\n\n        SlotOperator storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        uint256 fundableCount = 0;\n        uint256 operatorCount = r.value.length;\n        CachedOperator[] memory fundableOperators = new CachedOperator[](operatorCount);\n\n        uint32[] storage stoppedValidatorCounts = getStoppedValidators();\n\n        for (uint256 idx = 0; idx < operatorCount;) {\n            if (\n                _hasFundableKeys(r.value[idx])\n                    && _getStoppedValidatorCountAtIndex(stoppedValidatorCounts, idx) >= r.value[idx].requestedExits\n            ) {\n                Operator storage op = r.value[idx];\n                fundableOperators[fundableCount] = CachedOperator({\n                    limit: op.limit,\n                    funded: op.funded,\n                    requestedExits: op.requestedExits,\n                    index: uint32(idx),\n                    picked: 0\n                });\n                unchecked {\n                    ++fundableCount;\n                }\n            }\n            unchecked {\n                ++idx;\n            }\n        }\n\n        assembly (\"memory-safe\") {\n            mstore(fundableOperators, fundableCount)\n        }\n\n        return (fundableOperators, fundableCount);\n    }\n\n    /// @notice Retrieve all the active and exitable operators\n    /// @dev This method will return a memory array of length equal to the number of operator, but only\n    /// @dev populated up to the exitable operator count, also returned by the method\n    /// @return The list of active and exitable operators\n    /// @return The count of active and exitable operators\n    function getAllExitable() internal view returns (CachedExitableOperator[] memory, uint256) {\n        bytes32 slot = OPERATORS_SLOT;\n\n        SlotOperator storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        uint256 exitableCount = 0;\n        uint256 operatorCount = r.value.length;\n\n        CachedExitableOperator[] memory exitableOperators = new CachedExitableOperator[](operatorCount);\n\n        for (uint256 idx = 0; idx < operatorCount;) {\n            if (_hasExitableKeys(r.value[idx])) {\n                Operator storage op = r.value[idx];\n                exitableOperators[exitableCount] = CachedExitableOperator({\n                    funded: op.funded,\n                    requestedExits: op.requestedExits,\n                    index: uint32(idx),\n                    picked: 0\n                });\n                unchecked {\n                    ++exitableCount;\n                }\n            }\n            unchecked {\n                ++idx;\n            }\n        }\n\n        assembly (\"memory-safe\") {\n            mstore(exitableOperators, exitableCount)\n        }\n\n        return (exitableOperators, exitableCount);\n    }\n\n    /// @notice Add a new operator in storage\n    /// @param _newOperator Value of the new operator\n    /// @return The size of the operator array after the operation\n    function push(Operator memory _newOperator) internal returns (uint256) {\n        LibSanitize._notZeroAddress(_newOperator.operator);\n        LibSanitize._notEmptyString(_newOperator.name);\n        bytes32 slot = OPERATORS_SLOT;\n\n        SlotOperator storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        r.value.push(_newOperator);\n\n        return r.value.length;\n    }\n\n    /// @notice Atomic operation to set the key count and update the latestKeysEditBlockNumber field at the same time\n    /// @param _index The operator index\n    /// @param _newKeys The new value for the key count\n    function setKeys(uint256 _index, uint32 _newKeys) internal {\n        Operator storage op = get(_index);\n\n        op.keys = _newKeys;\n        op.latestKeysEditBlockNumber = uint64(block.number);\n    }\n\n    /// @notice Checks if an operator is active and has fundable keys\n    /// @param _operator The operator details\n    /// @return True if active and fundable\n    function _hasFundableKeys(OperatorsV2.Operator memory _operator) internal pure returns (bool) {\n        return (_operator.active && _operator.limit > _operator.funded);\n    }\n\n    /// @notice Checks if an operator is active and has exitable keys\n    /// @param _operator The operator details\n    /// @return True if active and exitable\n    function _hasExitableKeys(OperatorsV2.Operator memory _operator) internal pure returns (bool) {\n        return (_operator.active && _operator.funded > _operator.requestedExits);\n    }\n\n    /// @notice Storage slot of the Stopped Validators\n    bytes32 internal constant STOPPED_VALIDATORS_SLOT = bytes32(uint256(keccak256(\"river.state.stoppedValidators\")) - 1);\n\n    struct SlotStoppedValidators {\n        uint32[] value;\n    }\n\n    /// @notice Retrieve the storage pointer of the Stopped Validators array\n    /// @return The Stopped Validators storage pointer\n    function getStoppedValidators() internal view returns (uint32[] storage) {\n        bytes32 slot = STOPPED_VALIDATORS_SLOT;\n\n        SlotStoppedValidators storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value;\n    }\n\n    /// @notice Sets the entire stopped validators array\n    /// @param value The new stopped validators array\n    function setRawStoppedValidators(uint32[] memory value) internal {\n        bytes32 slot = STOPPED_VALIDATORS_SLOT;\n\n        SlotStoppedValidators storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        r.value = value;\n    }\n}\n"
    },
    "contracts/src/state/redeemManager/RedeemQueue.2.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\n/// @title Redeem Manager Redeem Queue storage\n/// @notice Utility to manage the Redeem Queue in the Redeem Manager\nlibrary RedeemQueueV2 {\n    /// @notice Storage slot of the Redeem Queue\n    bytes32 internal constant REDEEM_QUEUE_ID_SLOT = bytes32(uint256(keccak256(\"river.state.redeemQueue\")) - 1);\n\n    /// @notice The updated V1_2 Redeemer structure represents the redeem request made by a user\n    struct RedeemRequest {\n        /// @custom:attribute The amount of the redeem request in LsETH\n        uint256 amount;\n        /// @custom:attribute The maximum amount of ETH redeemable by this request\n        uint256 maxRedeemableEth;\n        /// @custom:attribute The recipient of the redeem request\n        address recipient;\n        /// @custom:attribute The height is the cumulative sum of all the sizes of preceding redeem requests\n        uint256 height;\n        /// @custom:attribute The initiator of the redeem request\n        address initiator;\n    }\n\n    /// @notice Retrieve the Redeem Queue array storage pointer\n    /// @return data The Redeem Queue array storage pointer\n    function get() internal pure returns (RedeemRequest[] storage data) {\n        bytes32 position = REDEEM_QUEUE_ID_SLOT;\n        assembly {\n            data.slot := position\n        }\n    }\n}\n"
    },
    "contracts/src/state/redeemManager/WithdrawalStack.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\n/// @title Redeem Manager Withdrawal Stack storage\n/// @notice Utility to manage the Withdrawal Stack in the Redeem Manager\nlibrary WithdrawalStack {\n    /// @notice Storage slot of the Withdrawal Stack\n    bytes32 internal constant WITHDRAWAL_STACK_ID_SLOT = bytes32(uint256(keccak256(\"river.state.withdrawalStack\")) - 1);\n\n    /// @notice The Redeemer structure represents the withdrawal events made by River\n    struct WithdrawalEvent {\n        /// @custom:attribute The amount of the withdrawal event in LsETH\n        uint256 amount;\n        /// @custom:attribute The amount of the withdrawal event in ETH\n        uint256 withdrawnEth;\n        /// @custom:attribute The height is the cumulative sum of all the sizes of preceding withdrawal events\n        uint256 height;\n    }\n\n    /// @notice Retrieve the Withdrawal Stack array storage pointer\n    /// @return data The Withdrawal Stack array storage pointer\n    function get() internal pure returns (WithdrawalEvent[] storage data) {\n        bytes32 position = WITHDRAWAL_STACK_ID_SLOT;\n        assembly {\n            data.slot := position\n        }\n    }\n}\n"
    },
    "contracts/src/state/river/AllowlistAddress.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\nimport \"../../libraries/LibSanitize.sol\";\n\n/// @title Allowlist Address Storage\n/// @notice Utility to manage the Allowlist Address in storage\nlibrary AllowlistAddress {\n    /// @notice Storage slot of the Allowlist Address\n    bytes32 internal constant ALLOWLIST_ADDRESS_SLOT = bytes32(uint256(keccak256(\"river.state.allowlistAddress\")) - 1);\n\n    /// @notice Retrieve the Allowlist Address\n    /// @return The Allowlist Address\n    function get() internal view returns (address) {\n        return LibUnstructuredStorage.getStorageAddress(ALLOWLIST_ADDRESS_SLOT);\n    }\n\n    /// @notice Sets the Allowlist Address\n    /// @param _newValue New Allowlist Address\n    function set(address _newValue) internal {\n        LibSanitize._notZeroAddress(_newValue);\n        LibUnstructuredStorage.setStorageAddress(ALLOWLIST_ADDRESS_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/river/BalanceToDeposit.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\n\nlibrary BalanceToDeposit {\n    bytes32 internal constant BALANCE_TO_DEPOSIT_SLOT = bytes32(uint256(keccak256(\"river.state.balanceToDeposit\")) - 1);\n\n    function get() internal view returns (uint256) {\n        return LibUnstructuredStorage.getStorageUint256(BALANCE_TO_DEPOSIT_SLOT);\n    }\n\n    function set(uint256 newValue) internal {\n        LibUnstructuredStorage.setStorageUint256(BALANCE_TO_DEPOSIT_SLOT, newValue);\n    }\n}\n"
    },
    "contracts/src/state/river/BalanceToRedeem.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\n\nlibrary BalanceToRedeem {\n    bytes32 internal constant BALANCE_TO_REDEEM_SLOT = bytes32(uint256(keccak256(\"river.state.balanceToRedeem\")) - 1);\n\n    function get() internal view returns (uint256) {\n        return LibUnstructuredStorage.getStorageUint256(BALANCE_TO_REDEEM_SLOT);\n    }\n\n    function set(uint256 newValue) internal {\n        LibUnstructuredStorage.setStorageUint256(BALANCE_TO_REDEEM_SLOT, newValue);\n    }\n}\n"
    },
    "contracts/src/state/river/CLSpec.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\n/// @title Consensus Layer Spec Storage\n/// @notice Utility to manage the Consensus Layer Spec in storage\nlibrary CLSpec {\n    /// @notice Storage slot of the Consensus Layer Spec\n    bytes32 internal constant CL_SPEC_SLOT = bytes32(uint256(keccak256(\"river.state.clSpec\")) - 1);\n\n    /// @notice The Consensus Layer Spec structure\n    struct CLSpecStruct {\n        /// @custom:attribute The count of epochs per frame, 225 means 24h\n        uint64 epochsPerFrame;\n        /// @custom:attribute The count of slots in an epoch (32 on mainnet)\n        uint64 slotsPerEpoch;\n        /// @custom:attribute The seconds in a slot (12 on mainnet)\n        uint64 secondsPerSlot;\n        /// @custom:attribute The block timestamp of the first consensus layer block\n        uint64 genesisTime;\n        /// @custom:attribute The count of epochs before considering an epoch final on-chain\n        uint64 epochsToAssumedFinality;\n    }\n\n    /// @notice The structure in storage\n    struct Slot {\n        /// @custom:attribute The structure in storage\n        CLSpecStruct value;\n    }\n\n    /// @notice Retrieve the Consensus Layer Spec from storage\n    /// @return The Consensus Layer Spec\n    function get() internal view returns (CLSpecStruct memory) {\n        bytes32 slot = CL_SPEC_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value;\n    }\n\n    /// @notice Set the Consensus Layer Spec value in storage\n    /// @param _newCLSpec The new value to set in storage\n    function set(CLSpecStruct memory _newCLSpec) internal {\n        bytes32 slot = CL_SPEC_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        r.value = _newCLSpec;\n    }\n}\n"
    },
    "contracts/src/state/river/CLValidatorCount.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\n\n/// @title Consensus Layer Validator Count Storage\n/// @notice Utility to manage the Consensus Layer Validator Count in storage\n/// @notice This state variable is deprecated and was kept due to migration logic needs\nlibrary CLValidatorCount {\n    /// @notice Storage slot of the Consensus Layer Validator Count\n    bytes32 internal constant CL_VALIDATOR_COUNT_SLOT = bytes32(uint256(keccak256(\"river.state.clValidatorCount\")) - 1);\n\n    /// @notice Retrieve the Consensus Layer Validator Count\n    /// @return The Consensus Layer Validator Count\n    function get() internal view returns (uint256) {\n        return LibUnstructuredStorage.getStorageUint256(CL_VALIDATOR_COUNT_SLOT);\n    }\n\n    /// @notice Sets the Consensus Layer Validator Count\n    /// @param _newValue New Consensus Layer Validator Count\n    function set(uint256 _newValue) internal {\n        LibUnstructuredStorage.setStorageUint256(CL_VALIDATOR_COUNT_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/river/CLValidatorTotalBalance.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\n\n/// @title Consensus Layer Validator Total Balance Storage\n/// @notice Utility to manage the Consensus Layer Validator Total Balance in storage\n/// @notice This state variable is deprecated and was kept due to migration logic needs\nlibrary CLValidatorTotalBalance {\n    /// @notice Storage slot of the Consensus Layer Validator Total Balance\n    bytes32 internal constant CL_VALIDATOR_TOTAL_BALANCE_SLOT =\n        bytes32(uint256(keccak256(\"river.state.clValidatorTotalBalance\")) - 1);\n\n    /// @notice Retrieve the Consensus Layer Validator Total Balance\n    /// @return The Consensus Layer Validator Total Balance\n    function get() internal view returns (uint256) {\n        return LibUnstructuredStorage.getStorageUint256(CL_VALIDATOR_TOTAL_BALANCE_SLOT);\n    }\n\n    /// @notice Sets the Consensus Layer Validator Total Balance\n    /// @param _newValue New Consensus Layer Validator Total Balance\n    function set(uint256 _newValue) internal {\n        LibUnstructuredStorage.setStorageUint256(CL_VALIDATOR_TOTAL_BALANCE_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/river/CollectorAddress.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\nimport \"../../libraries/LibSanitize.sol\";\n\n/// @title Collector Address Storage\n/// @notice Utility to manage the Collector Address in storage\nlibrary CollectorAddress {\n    /// @notice Storage slot of the Collector Address\n    bytes32 internal constant COLLECTOR_ADDRESS_SLOT = bytes32(uint256(keccak256(\"river.state.collectorAddress\")) - 1);\n\n    /// @notice Retrieve the Collector Address\n    /// @return The Collector Address\n    function get() internal view returns (address) {\n        return LibUnstructuredStorage.getStorageAddress(COLLECTOR_ADDRESS_SLOT);\n    }\n\n    /// @notice Sets the Collector Address\n    /// @param _newValue New Collector Address\n    function set(address _newValue) internal {\n        LibSanitize._notZeroAddress(_newValue);\n        LibUnstructuredStorage.setStorageAddress(COLLECTOR_ADDRESS_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/river/CommittedBalance.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\n\nlibrary CommittedBalance {\n    bytes32 internal constant COMMITTED_BALANCE_SLOT = bytes32(uint256(keccak256(\"river.state.committedBalance\")) - 1);\n\n    function get() internal view returns (uint256) {\n        return LibUnstructuredStorage.getStorageUint256(COMMITTED_BALANCE_SLOT);\n    }\n\n    function set(uint256 newValue) internal {\n        LibUnstructuredStorage.setStorageUint256(COMMITTED_BALANCE_SLOT, newValue);\n    }\n}\n"
    },
    "contracts/src/state/river/CoverageFundAddress.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\nimport \"../../libraries/LibSanitize.sol\";\n\n/// @title Coverage Fund Address Storage\n/// @notice Utility to manage the Coverage Fund Address in storage\nlibrary CoverageFundAddress {\n    /// @notice Storage slot of the Coverage Fund Address\n    bytes32 internal constant COVERAGE_FUND_ADDRESS_SLOT =\n        bytes32(uint256(keccak256(\"river.state.coverageFundAddress\")) - 1);\n\n    /// @notice Retrieve the Coverage Fund Address\n    /// @return The Coverage Fund Address\n    function get() internal view returns (address) {\n        return LibUnstructuredStorage.getStorageAddress(COVERAGE_FUND_ADDRESS_SLOT);\n    }\n\n    /// @notice Sets the Coverage Fund Address\n    /// @param _newValue New Coverage Fund Address\n    function set(address _newValue) internal {\n        LibSanitize._notZeroAddress(_newValue);\n        LibUnstructuredStorage.setStorageAddress(COVERAGE_FUND_ADDRESS_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/river/DailyCommittableLimits.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\nimport \"../../libraries/LibSanitize.sol\";\n\n/// @title Daily Committable Limits storage\n/// @notice Utility to manage the Daily Committable Limits in storage\nlibrary DailyCommittableLimits {\n    /// @notice Storage slot of the Daily Committable Limits storage\n    bytes32 internal constant DAILY_COMMITTABLE_LIMITS_SLOT =\n        bytes32(uint256(keccak256(\"river.state.dailyCommittableLimits\")) - 1);\n\n    /// @notice The daily committable limits structure\n    struct DailyCommittableLimitsStruct {\n        uint128 minDailyNetCommittableAmount;\n        uint128 maxDailyRelativeCommittableAmount;\n    }\n\n    /// @notice The structure in storage\n    struct Slot {\n        /// @custom:attribute The structure in storage\n        DailyCommittableLimitsStruct value;\n    }\n\n    /// @notice Retrieve the Daily Committable Limits from storage\n    /// @return The Daily Committable Limits\n    function get() internal view returns (DailyCommittableLimitsStruct memory) {\n        bytes32 slot = DAILY_COMMITTABLE_LIMITS_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value;\n    }\n\n    /// @notice Set the Daily Committable Limits value in storage\n    /// @param _newValue The new value to set in storage\n    function set(DailyCommittableLimitsStruct memory _newValue) internal {\n        bytes32 slot = DAILY_COMMITTABLE_LIMITS_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        r.value = _newValue;\n    }\n}\n"
    },
    "contracts/src/state/river/DepositContractAddress.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\nimport \"../../libraries/LibSanitize.sol\";\nimport \"../../libraries/LibUnstructuredStorage.sol\";\n\n/// @title Deposit Contract Address Storage\n/// @notice Utility to manage the Deposit Contract Address in storage\nlibrary DepositContractAddress {\n    /// @notice Storage slot of the Deposit Contract Address\n    bytes32 internal constant DEPOSIT_CONTRACT_ADDRESS_SLOT =\n        bytes32(uint256(keccak256(\"river.state.depositContractAddress\")) - 1);\n\n    /// @notice Retrieve the Deposit Contract Address\n    /// @return The Deposit Contract Address\n    function get() internal view returns (address) {\n        return LibUnstructuredStorage.getStorageAddress(DEPOSIT_CONTRACT_ADDRESS_SLOT);\n    }\n\n    /// @notice Sets the Deposit Contract Address\n    /// @param _newValue New Deposit Contract Address\n    function set(address _newValue) internal {\n        LibSanitize._notZeroAddress(_newValue);\n        LibUnstructuredStorage.setStorageAddress(DEPOSIT_CONTRACT_ADDRESS_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/river/DepositedValidatorCount.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\n\n/// @title Deposited Validator Count Storage\n/// @notice Utility to manage the Deposited Validator Count in storage\nlibrary DepositedValidatorCount {\n    /// @notice Storage slot of the Deposited Validator Count\n    bytes32 internal constant DEPOSITED_VALIDATOR_COUNT_SLOT =\n        bytes32(uint256(keccak256(\"river.state.depositedValidatorCount\")) - 1);\n\n    /// @notice Retrieve the Deposited Validator Count\n    /// @return The Deposited Validator Count\n    function get() internal view returns (uint256) {\n        return LibUnstructuredStorage.getStorageUint256(DEPOSITED_VALIDATOR_COUNT_SLOT);\n    }\n\n    /// @notice Sets the Deposited Validator Count\n    /// @param _newValue New Deposited Validator Count\n    function set(uint256 _newValue) internal {\n        LibUnstructuredStorage.setStorageUint256(DEPOSITED_VALIDATOR_COUNT_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/river/ELFeeRecipientAddress.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\nimport \"../../libraries/LibSanitize.sol\";\n\n/// @title Execution Layer Fee Recipient Address Storage\n/// @notice Utility to manage the Execution Layer Fee Recipient Address in storage\nlibrary ELFeeRecipientAddress {\n    /// @notice Storage slot of the Execution Layer Fee Recipient Address\n    bytes32 internal constant EL_FEE_RECIPIENT_ADDRESS =\n        bytes32(uint256(keccak256(\"river.state.elFeeRecipientAddress\")) - 1);\n\n    /// @notice Retrieve the Execution Layer Fee Recipient Address\n    /// @return The Execution Layer Fee Recipient Address\n    function get() internal view returns (address) {\n        return LibUnstructuredStorage.getStorageAddress(EL_FEE_RECIPIENT_ADDRESS);\n    }\n\n    /// @notice Sets the Execution Layer Fee Recipient Address\n    /// @param _newValue New Execution Layer Fee Recipient Address\n    function set(address _newValue) internal {\n        LibSanitize._notZeroAddress(_newValue);\n        LibUnstructuredStorage.setStorageAddress(EL_FEE_RECIPIENT_ADDRESS, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/river/GlobalFee.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\nimport \"../../libraries/LibSanitize.sol\";\nimport \"../../libraries/LibUnstructuredStorage.sol\";\n\n/// @title Global Fee Storage\n/// @notice Utility to manage the Global Fee in storage\nlibrary GlobalFee {\n    /// @notice Storage slot of the Global Fee\n    bytes32 internal constant GLOBAL_FEE_SLOT = bytes32(uint256(keccak256(\"river.state.globalFee\")) - 1);\n\n    /// @notice Retrieve the Global Fee\n    /// @return The Global Fee\n    function get() internal view returns (uint256) {\n        return LibUnstructuredStorage.getStorageUint256(GLOBAL_FEE_SLOT);\n    }\n\n    /// @notice Sets the Global Fee\n    /// @param _newValue New Global Fee\n    function set(uint256 _newValue) internal {\n        LibSanitize._validFee(_newValue);\n        LibUnstructuredStorage.setStorageUint256(GLOBAL_FEE_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/river/KeeperAddress.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\nimport \"../../libraries/LibSanitize.sol\";\n\n/// @title Keeper Address Storage\n/// @notice Utility to manage the Keeper Address in storage\nlibrary KeeperAddress {\n    /// @notice Storage slot of the Keeper Address\n    bytes32 internal constant KEEPER_ADDRESS_SLOT = bytes32(uint256(keccak256(\"river.state.KeeperAddress\")) - 1);\n\n    /// @notice Retrieve the Keeper Address\n    /// @return The Keeper Address\n    function get() internal view returns (address) {\n        return LibUnstructuredStorage.getStorageAddress(KEEPER_ADDRESS_SLOT);\n    }\n\n    /// @notice Sets the Keeper Address\n    /// @param _newValue New Keeper Address\n    function set(address _newValue) internal {\n        LibSanitize._notZeroAddress(_newValue);\n        LibUnstructuredStorage.setStorageAddress(KEEPER_ADDRESS_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/river/LastConsensusLayerReport.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\nimport \"../../interfaces/components/IOracleManager.1.sol\";\n\n/// @title Last Consensus Layer Report Storage\n/// @notice Utility to manage the Last Consensus Layer Report in storage\nlibrary LastConsensusLayerReport {\n    /// @notice Storage slot of the Last Consensus Layer Report\n    bytes32 internal constant LAST_CONSENSUS_LAYER_REPORT_SLOT =\n        bytes32(uint256(keccak256(\"river.state.lastConsensusLayerReport\")) - 1);\n\n    /// @notice The structure in storage\n    struct Slot {\n        /// @custom:attribute The structure in storage\n        IOracleManagerV1.StoredConsensusLayerReport value;\n    }\n\n    /// @notice Retrieve the Last Consensus Layer Report from storage\n    /// @return The Last Consensus Layer Report\n    function get() internal view returns (IOracleManagerV1.StoredConsensusLayerReport storage) {\n        bytes32 slot = LAST_CONSENSUS_LAYER_REPORT_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value;\n    }\n\n    /// @notice Set the Last Consensus Layer Report value in storage\n    /// @param _newValue The new value to set in storage\n    function set(IOracleManagerV1.StoredConsensusLayerReport memory _newValue) internal {\n        bytes32 slot = LAST_CONSENSUS_LAYER_REPORT_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        r.value = _newValue;\n    }\n}\n"
    },
    "contracts/src/state/river/LastOracleRoundId.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\n\n/// @title Last Oracle Round Id Storage\n/// @notice Utility to manage the Last Oracle Round Id in storage\n/// @notice This state variable is deprecated and was kept due to migration logic needs\nlibrary LastOracleRoundId {\n    /// @notice Storage slot of the Last Oracle Round Id\n    bytes32 internal constant LAST_ORACLE_ROUND_ID_SLOT =\n        bytes32(uint256(keccak256(\"river.state.lastOracleRoundId\")) - 1);\n\n    /// @notice Retrieve the Last Oracle Round Id\n    /// @return The Last Oracle Round Id\n    function get() internal view returns (bytes32) {\n        return LibUnstructuredStorage.getStorageBytes32(LAST_ORACLE_ROUND_ID_SLOT);\n    }\n\n    /// @notice Sets the Last Oracle Round Id\n    /// @param _newValue New Last Oracle Round Id\n    function set(bytes32 _newValue) internal {\n        LibUnstructuredStorage.setStorageBytes32(LAST_ORACLE_ROUND_ID_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/river/MetadataURI.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\n/// @title Metadata URI Storage\n/// @notice Utility to manage the Metadata in storage\nlibrary MetadataURI {\n    /// @notice Storage slot of the Metadata URI\n    bytes32 internal constant METADATA_URI_SLOT = bytes32(uint256(keccak256(\"river.state.metadataUri\")) - 1);\n\n    /// @notice Structure in storage\n    struct Slot {\n        /// @custom:attribute The metadata value\n        string value;\n    }\n\n    /// @notice Retrieve the metadata URI\n    /// @return The metadata URI string\n    function get() internal view returns (string memory) {\n        bytes32 slot = METADATA_URI_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value;\n    }\n\n    /// @notice Set the metadata URI value\n    /// @param _newValue The new metadata URI value\n    function set(string memory _newValue) internal {\n        bytes32 slot = METADATA_URI_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        r.value = _newValue;\n    }\n}\n"
    },
    "contracts/src/state/river/OperatorsRegistryAddress.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\nimport \"../../libraries/LibSanitize.sol\";\n\n/// @title Operators Registry Address Storage\n/// @notice Utility to manage the Operators Registry Address in storage\nlibrary OperatorsRegistryAddress {\n    /// @notice Storage slot of the Operators Registry Address\n    bytes32 internal constant OPERATORS_REGISTRY_ADDRESS_SLOT =\n        bytes32(uint256(keccak256(\"river.state.operatorsRegistryAddress\")) - 1);\n\n    /// @notice Retrieve the Operators Registry Address\n    /// @return The Operators Registry Address\n    function get() internal view returns (address) {\n        return LibUnstructuredStorage.getStorageAddress(OPERATORS_REGISTRY_ADDRESS_SLOT);\n    }\n\n    /// @notice Sets the Operators Registry Address\n    /// @param _newValue New Operators Registry Address\n    function set(address _newValue) internal {\n        LibSanitize._notZeroAddress(_newValue);\n        LibUnstructuredStorage.setStorageAddress(OPERATORS_REGISTRY_ADDRESS_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/river/OracleAddress.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\nimport \"../../libraries/LibSanitize.sol\";\n\n/// @title Oracle Address Storage\n/// @notice Utility to manage the Oracle Address in storage\nlibrary OracleAddress {\n    /// @notice Storage slot of the Oracle Address\n    bytes32 internal constant ORACLE_ADDRESS_SLOT = bytes32(uint256(keccak256(\"river.state.oracleAddress\")) - 1);\n\n    /// @notice Retrieve the Oracle Address\n    /// @return The Oracle Address\n    function get() internal view returns (address) {\n        return LibUnstructuredStorage.getStorageAddress(ORACLE_ADDRESS_SLOT);\n    }\n\n    /// @notice Sets the Oracle Address\n    /// @param _newValue New Oracle Address\n    function set(address _newValue) internal {\n        LibSanitize._notZeroAddress(_newValue);\n        LibUnstructuredStorage.setStorageAddress(ORACLE_ADDRESS_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/river/RedeemManagerAddress.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\nimport \"../../libraries/LibSanitize.sol\";\n\n/// @title Redeem Manager Address Storage\n/// @notice Utility to manage the Redeem Manager Address in storage\nlibrary RedeemManagerAddress {\n    /// @notice Storage slot of the Redeem Manager Address\n    bytes32 internal constant REDEEM_MANAGER_ADDRESS_SLOT =\n        bytes32(uint256(keccak256(\"river.state.redeemManagerAddress\")) - 1);\n\n    /// @notice Retrieve the Redeem Manager Address\n    /// @return The Redeem Manager Address\n    function get() internal view returns (address) {\n        return LibUnstructuredStorage.getStorageAddress(REDEEM_MANAGER_ADDRESS_SLOT);\n    }\n\n    /// @notice Sets the Redeem Manager Address\n    /// @param _newValue New Redeem Manager Address\n    function set(address _newValue) internal {\n        LibSanitize._notZeroAddress(_newValue);\n        LibUnstructuredStorage.setStorageAddress(REDEEM_MANAGER_ADDRESS_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/river/ReportBounds.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\n/// @title Report Bounds Storage\n/// @notice Utility to manage the Report Bounds in storage\nlibrary ReportBounds {\n    /// @notice Storage slot of the Report Bounds\n    bytes32 internal constant REPORT_BOUNDS_SLOT = bytes32(uint256(keccak256(\"river.state.reportBounds\")) - 1);\n\n    /// @notice The Report Bounds structure\n    struct ReportBoundsStruct {\n        /// @custom:attribute The maximum allowed annual apr, checked before submitting a report to River\n        uint256 annualAprUpperBound;\n        /// @custom:attribute The maximum allowed balance decrease, also checked before submitting a report to River\n        uint256 relativeLowerBound;\n    }\n\n    /// @notice The structure in storage\n    struct Slot {\n        /// @custom:attribute The structure in storage\n        ReportBoundsStruct value;\n    }\n\n    /// @notice Retrieve the Report Bounds from storage\n    /// @return The Report Bounds\n    function get() internal view returns (ReportBoundsStruct memory) {\n        bytes32 slot = REPORT_BOUNDS_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value;\n    }\n\n    /// @notice Set the Report Bounds in storage\n    /// @param _newReportBounds The new Report Bounds value\n    function set(ReportBoundsStruct memory _newReportBounds) internal {\n        bytes32 slot = REPORT_BOUNDS_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        r.value = _newReportBounds;\n    }\n}\n"
    },
    "contracts/src/state/river/Shares.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\n\n/// @title Shares Count Storage\n/// @notice Utility to manage the Shares Count in storage\nlibrary Shares {\n    /// @notice Storage slot of the Shares Count\n    bytes32 internal constant SHARES_SLOT = bytes32(uint256(keccak256(\"river.state.shares\")) - 1);\n\n    /// @notice Retrieve the Shares Count\n    /// @return The Shares Count\n    function get() internal view returns (uint256) {\n        return LibUnstructuredStorage.getStorageUint256(SHARES_SLOT);\n    }\n\n    /// @notice Sets the Shares Count\n    /// @param _newValue New Shares Count\n    function set(uint256 _newValue) internal {\n        LibUnstructuredStorage.setStorageUint256(SHARES_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/river/SharesPerOwner.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\n/// @title Shares Per Owner Storage\n/// @notice Utility to manage the Shares Per Owner in storage\nlibrary SharesPerOwner {\n    /// @notice Storage slot of the Shares Per Owner\n    bytes32 internal constant SHARES_PER_OWNER_SLOT = bytes32(uint256(keccak256(\"river.state.sharesPerOwner\")) - 1);\n\n    /// @notice Structure in storage\n    struct Slot {\n        /// @custom:attribute The mapping from an owner to its share count\n        mapping(address => uint256) value;\n    }\n\n    /// @notice Retrieve the share count for given owner\n    /// @param _owner The address to get the balance of\n    /// @return The amount of shares\n    function get(address _owner) internal view returns (uint256) {\n        bytes32 slot = SHARES_PER_OWNER_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value[_owner];\n    }\n\n    /// @notice Set the amount of shares for an owner\n    /// @param _owner The owner of the shares to edit\n    /// @param _newValue The new shares value for the owner\n    function set(address _owner, uint256 _newValue) internal {\n        bytes32 slot = SHARES_PER_OWNER_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        r.value[_owner] = _newValue;\n    }\n}\n"
    },
    "contracts/src/state/river/WithdrawalCredentials.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\nimport \"../../libraries/LibErrors.sol\";\nimport \"../../libraries/LibUnstructuredStorage.sol\";\n\n/// @title Withdrawal Credentials Storage\n/// @notice Utility to manage the Withdrawal Credentials in storage\nlibrary WithdrawalCredentials {\n    /// @notice Storage slot of the Withdrawal Credentials\n    bytes32 internal constant WITHDRAWAL_CREDENTIALS_SLOT =\n        bytes32(uint256(keccak256(\"river.state.withdrawalCredentials\")) - 1);\n\n    /// @notice Retrieve the Withdrawal Credentials\n    /// @return The Withdrawal Credentials\n    function get() internal view returns (bytes32) {\n        return LibUnstructuredStorage.getStorageBytes32(WITHDRAWAL_CREDENTIALS_SLOT);\n    }\n\n    /// @notice Retrieve the Withdrawal Credential under its address format\n    /// @return The Withdrawal Credentials in its address format\n    function getAddress() internal view returns (address) {\n        return LibUnstructuredStorage.getStorageAddress(WITHDRAWAL_CREDENTIALS_SLOT);\n    }\n\n    /// @notice Sets the Withdrawal Credentials\n    /// @param _newValue New Withdrawal Credentials\n    function set(bytes32 _newValue) internal {\n        if (_newValue == bytes32(0)) {\n            revert LibErrors.InvalidArgument();\n        }\n        LibUnstructuredStorage.setStorageBytes32(WITHDRAWAL_CREDENTIALS_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/shared/AdministratorAddress.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\nimport \"../../libraries/LibSanitize.sol\";\n\n/// @title Administrator Address Storage\n/// @notice Utility to manage the Administrator Address in storage\nlibrary AdministratorAddress {\n    /// @notice Storage slot of the Administrator Address\n    bytes32 public constant ADMINISTRATOR_ADDRESS_SLOT =\n        bytes32(uint256(keccak256(\"river.state.administratorAddress\")) - 1);\n\n    /// @notice Retrieve the Administrator Address\n    /// @return The Administrator Address\n    function get() internal view returns (address) {\n        return LibUnstructuredStorage.getStorageAddress(ADMINISTRATOR_ADDRESS_SLOT);\n    }\n\n    /// @notice Sets the Administrator Address\n    /// @param _newValue New Administrator Address\n    function set(address _newValue) internal {\n        LibSanitize._notZeroAddress(_newValue);\n        LibUnstructuredStorage.setStorageAddress(ADMINISTRATOR_ADDRESS_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/shared/ApprovalsPerOwner.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\n/// @title Approvals Per Owner Storage\n/// @notice Utility to manage the Approvals Per Owner in storage\nlibrary ApprovalsPerOwner {\n    /// @notice Storage slot of the Approvals Per Owner\n    bytes32 internal constant APPROVALS_PER_OWNER_SLOT =\n        bytes32(uint256(keccak256(\"river.state.approvalsPerOwner\")) - 1);\n\n    /// @notice The structure in storage\n    struct Slot {\n        /// @custom:attribute The mapping from an owner to an operator to the approval amount\n        mapping(address => mapping(address => uint256)) value;\n    }\n\n    /// @notice Retrieve the approval for an owner to an operator\n    /// @param _owner The account that gave the approval\n    /// @param _operator The account receiving the approval\n    /// @return The value of the approval\n    function get(address _owner, address _operator) internal view returns (uint256) {\n        bytes32 slot = APPROVALS_PER_OWNER_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value[_owner][_operator];\n    }\n\n    /// @notice Set the approval value for an owner to an operator\n    /// @param _owner The account that gives the approval\n    /// @param _operator The account receiving the approval\n    /// @param _newValue The value of the approval\n    function set(address _owner, address _operator, uint256 _newValue) internal {\n        bytes32 slot = APPROVALS_PER_OWNER_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        r.value[_owner][_operator] = _newValue;\n    }\n}\n"
    },
    "contracts/src/state/shared/PendingAdministratorAddress.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\n\n/// @title Pending Administrator Address Storage\n/// @notice Utility to manage the Pending Administrator Address in storage\nlibrary PendingAdministratorAddress {\n    /// @notice Storage slot of the Pending Administrator Address\n    bytes32 public constant PENDING_ADMINISTRATOR_ADDRESS_SLOT =\n        bytes32(uint256(keccak256(\"river.state.pendingAdministratorAddress\")) - 1);\n\n    /// @notice Retrieve the Pending Administrator Address\n    /// @return The Pending Administrator Address\n    function get() internal view returns (address) {\n        return LibUnstructuredStorage.getStorageAddress(PENDING_ADMINISTRATOR_ADDRESS_SLOT);\n    }\n\n    /// @notice Sets the Pending Administrator Address\n    /// @param _newValue New Pending Administrator Address\n    function set(address _newValue) internal {\n        LibUnstructuredStorage.setStorageAddress(PENDING_ADMINISTRATOR_ADDRESS_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/shared/Version.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\n\n/// @title Version Storage\n/// @notice Utility to manage the Version in storage\nlibrary Version {\n    /// @notice Storage slot of the Version\n    bytes32 public constant VERSION_SLOT = bytes32(uint256(keccak256(\"river.state.version\")) - 1);\n\n    /// @notice Retrieve the Version\n    /// @return The Version\n    function get() internal view returns (uint256) {\n        return LibUnstructuredStorage.getStorageUint256(VERSION_SLOT);\n    }\n\n    /// @notice Sets the Version\n    /// @param _newValue New Version\n    function set(uint256 _newValue) internal {\n        LibUnstructuredStorage.setStorageUint256(VERSION_SLOT, _newValue);\n    }\n}\n"
    },
    "openzeppelin-contracts-upgradeable/contracts/access/AccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../utils/StringsUpgradeable.sol\";\nimport \"../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        StringsUpgradeable.toHexString(account),\n                        \" is missing role \",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "openzeppelin-contracts-upgradeable/contracts/access/IAccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControlUpgradeable {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"./extensions/IERC20MetadataUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[45] private __gap;\n}\n"
    },
    "openzeppelin-contracts-upgradeable/contracts/token/ERC20/extensions/ERC20BurnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20Upgradeable.sol\";\nimport \"../../../utils/ContextUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20BurnableUpgradeable is Initializable, ContextUpgradeable, ERC20Upgradeable {\n    function __ERC20Burnable_init() internal onlyInitializing {\n    }\n\n    function __ERC20Burnable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        _spendAllowance(account, _msgSender(), amount);\n        _burn(account, amount);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "openzeppelin-contracts-upgradeable/contracts/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "openzeppelin-contracts-upgradeable/contracts/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "openzeppelin-contracts-upgradeable/contracts/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "openzeppelin-contracts-upgradeable/contracts/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "openzeppelin-contracts-upgradeable/contracts/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "openzeppelin-contracts-upgradeable/contracts/utils/math/MathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary MathUpgradeable {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "openzeppelin-contracts-upgradeable/contracts/utils/math/SignedMathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMathUpgradeable {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "openzeppelin-contracts-upgradeable/contracts/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/MathUpgradeable.sol\";\nimport \"./math/SignedMathUpgradeable.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = MathUpgradeable.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMathUpgradeable.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "openzeppelin-contracts/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "openzeppelin-contracts/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "openzeppelin-contracts/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    }
  },
  "settings": {
    "viaIR": true,
    "optimizer": {
      "enabled": true,
      "runs": 100
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "devdoc",
          "userdoc",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}