{
  "language": "Solidity",
  "sources": {
    "contracts/src/Administrable.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\nimport \"./interfaces/IAdministrable.sol\";\n\nimport \"./libraries/LibAdministrable.sol\";\nimport \"./libraries/LibSanitize.sol\";\n\n/// @title Administrable\n/// @author Alluvial Finance Inc.\n/// @notice This contract handles the administration of the contracts\nabstract contract Administrable is IAdministrable {\n    /// @notice Prevents unauthorized calls\n    modifier onlyAdmin() {\n        if (msg.sender != LibAdministrable._getAdmin()) {\n            revert LibErrors.Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    /// @notice Prevents unauthorized calls\n    modifier onlyPendingAdmin() {\n        if (msg.sender != LibAdministrable._getPendingAdmin()) {\n            revert LibErrors.Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    /// @inheritdoc IAdministrable\n    function getAdmin() external view returns (address) {\n        return LibAdministrable._getAdmin();\n    }\n\n    /// @inheritdoc IAdministrable\n    function getPendingAdmin() external view returns (address) {\n        return LibAdministrable._getPendingAdmin();\n    }\n\n    /// @inheritdoc IAdministrable\n    function proposeAdmin(address _newAdmin) external onlyAdmin {\n        _setPendingAdmin(_newAdmin);\n    }\n\n    /// @inheritdoc IAdministrable\n    function acceptAdmin() external onlyPendingAdmin {\n        _setAdmin(LibAdministrable._getPendingAdmin());\n        _setPendingAdmin(address(0));\n    }\n\n    /// @notice Internal utility to set the admin address\n    /// @param _admin Address to set as admin\n    function _setAdmin(address _admin) internal {\n        LibAdministrable._setAdmin(_admin);\n        emit SetAdmin(_admin);\n    }\n\n    /// @notice Internal utility to set the pending admin address\n    /// @param _pendingAdmin Address to set as pending admin\n    function _setPendingAdmin(address _pendingAdmin) internal {\n        LibAdministrable._setPendingAdmin(_pendingAdmin);\n        emit SetPendingAdmin(_pendingAdmin);\n    }\n\n    /// @notice Internal utility to retrieve the address of the current admin\n    /// @return The address of admin\n    function _getAdmin() internal view returns (address) {\n        return LibAdministrable._getAdmin();\n    }\n}\n"
    },
    "contracts/src/Initializable.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\nimport \"./state/shared/Version.sol\";\n\n/// @title Initializable\n/// @author Alluvial Finance Inc.\n/// @notice This contract ensures that initializers are called only once per version\ncontract Initializable {\n    /// @notice Disable initialization on implementations\n    constructor() {\n        Version.set(type(uint256).max);\n        emit Initialize(type(uint256).max, msg.data);\n    }\n\n    /// @notice An error occured during the initialization\n    /// @param version The version that was attempting to be initialized\n    /// @param expectedVersion The version that was expected\n    error InvalidInitialization(uint256 version, uint256 expectedVersion);\n\n    /// @notice Emitted when the contract is properly initialized\n    /// @param version New version of the contracts\n    /// @param cdata Complete calldata that was used during the initialization\n    event Initialize(uint256 version, bytes cdata);\n\n    /// @notice Use this modifier on initializers along with a hard-coded version number\n    /// @param _version Version to initialize\n    modifier init(uint256 _version) {\n        if (_version != Version.get()) {\n            revert InvalidInitialization(_version, Version.get());\n        }\n        Version.set(_version + 1); // prevents reentrency on the called method\n        _;\n        emit Initialize(_version, msg.data);\n    }\n}\n"
    },
    "contracts/src/interfaces/components/IConsensusLayerDepositManager.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\n/// @title Consensys Layer Deposit Manager Interface (v1)\n/// @author Alluvial Finance Inc.\n/// @notice This interface exposes methods to handle the interactions with the official deposit contract\ninterface IConsensusLayerDepositManagerV1 {\n    /// @notice The stored deposit contract address changed\n    /// @param depositContract Address of the deposit contract\n    event SetDepositContractAddress(address indexed depositContract);\n\n    /// @notice The stored withdrawal credentials changed\n    /// @param withdrawalCredentials The withdrawal credentials to use for deposits\n    event SetWithdrawalCredentials(bytes32 withdrawalCredentials);\n\n    /// @notice Emitted when the deposited validator count is updated\n    /// @param oldDepositedValidatorCount The old deposited validator count value\n    /// @param newDepositedValidatorCount The new deposited validator count value\n    event SetDepositedValidatorCount(uint256 oldDepositedValidatorCount, uint256 newDepositedValidatorCount);\n\n    /// @notice Not enough funds to deposit one validator\n    error NotEnoughFunds();\n\n    /// @notice The length of the BLS Public key is invalid during deposit\n    error InconsistentPublicKeys();\n\n    /// @notice The length of the BLS Signature is invalid during deposit\n    error InconsistentSignatures();\n\n    /// @notice The internal key retrieval returned no keys\n    error NoAvailableValidatorKeys();\n\n    /// @notice The received count of public keys to deposit is invalid\n    error InvalidPublicKeyCount();\n\n    /// @notice The received count of signatures to deposit is invalid\n    error InvalidSignatureCount();\n\n    /// @notice The withdrawal credentials value is null\n    error InvalidWithdrawalCredentials();\n\n    /// @notice An error occured during the deposit\n    error ErrorOnDeposit();\n\n    /// @notice Invalid deposit root\n    error InvalidDepositRoot();\n\n    // @notice Not keeper\n    error OnlyKeeper();\n\n    /// @notice Returns the amount of ETH not yet committed for deposit\n    /// @return The amount of ETH not yet committed for deposit\n    function getBalanceToDeposit() external view returns (uint256);\n\n    /// @notice Returns the amount of ETH committed for deposit\n    /// @return The amount of ETH committed for deposit\n    function getCommittedBalance() external view returns (uint256);\n\n    /// @notice Retrieve the withdrawal credentials\n    /// @return The withdrawal credentials\n    function getWithdrawalCredentials() external view returns (bytes32);\n\n    /// @notice Get the deposited validator count (the count of deposits made by the contract)\n    /// @return The deposited validator count\n    function getDepositedValidatorCount() external view returns (uint256);\n\n    /// @notice Get the keeper address\n    /// @return The keeper address\n    function getKeeper() external view returns (address);\n\n    /// @notice Deposits current balance to the Consensus Layer by batches of 32 ETH\n    /// @param _maxCount The maximum amount of validator keys to fund\n    /// @param _depositRoot The root of the deposit tree\n    function depositToConsensusLayerWithDepositRoot(uint256 _maxCount, bytes32 _depositRoot) external;\n}\n"
    },
    "contracts/src/interfaces/components/IOracleManager.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\nimport \"../../state/river/CLSpec.sol\";\nimport \"../../state/river/ReportBounds.sol\";\n\n/// @title Oracle Manager (v1)\n/// @author Alluvial Finance Inc.\n/// @notice This interface exposes methods to handle the inputs provided by the oracle\ninterface IOracleManagerV1 {\n    /// @notice The stored oracle address changed\n    /// @param oracleAddress The new oracle address\n    event SetOracle(address indexed oracleAddress);\n\n    /// @notice The consensus layer data provided by the oracle has been updated\n    /// @param validatorCount The new count of validators running on the consensus layer\n    /// @param validatorTotalBalance The new total balance sum of all validators\n    /// @param roundId Round identifier\n    event ConsensusLayerDataUpdate(uint256 validatorCount, uint256 validatorTotalBalance, bytes32 roundId);\n\n    /// @notice The Consensus Layer Spec is changed\n    /// @param epochsPerFrame The number of epochs inside a frame\n    /// @param slotsPerEpoch The number of slots inside an epoch\n    /// @param secondsPerSlot The number of seconds inside a slot\n    /// @param genesisTime The genesis timestamp\n    /// @param epochsToAssumedFinality The number of epochs before an epoch is considered final\n    event SetSpec(\n        uint64 epochsPerFrame,\n        uint64 slotsPerEpoch,\n        uint64 secondsPerSlot,\n        uint64 genesisTime,\n        uint64 epochsToAssumedFinality\n    );\n\n    /// @notice The Report Bounds are changed\n    /// @param annualAprUpperBound The reporting upper bound\n    /// @param relativeLowerBound The reporting lower bound\n    event SetBounds(uint256 annualAprUpperBound, uint256 relativeLowerBound);\n\n    /// @notice The provided report has beend processed\n    /// @param report The report that was provided\n    /// @param trace The trace structure providing more insights on internals\n    event ProcessedConsensusLayerReport(\n        IOracleManagerV1.ConsensusLayerReport report, ConsensusLayerDataReportingTrace trace\n    );\n\n    /// @notice The reported validator count is invalid\n    /// @param providedValidatorCount The received validator count value\n    /// @param depositedValidatorCount The number of deposits performed by the system\n    /// @param lastReportedValidatorCount The last reported validator count\n    error InvalidValidatorCountReport(\n        uint256 providedValidatorCount, uint256 depositedValidatorCount, uint256 lastReportedValidatorCount\n    );\n\n    /// @notice Thrown when an invalid epoch was reported\n    /// @param epoch Invalid epoch\n    error InvalidEpoch(uint256 epoch);\n\n    /// @notice The balance increase is higher than the maximum allowed by the upper bound\n    /// @param prevTotalEthIncludingExited The previous total balance, including all exited balance\n    /// @param postTotalEthIncludingExited The post-report total balance, including all exited balance\n    /// @param timeElapsed The time in seconds since last report\n    /// @param annualAprUpperBound The upper bound value that was used\n    error TotalValidatorBalanceIncreaseOutOfBound(\n        uint256 prevTotalEthIncludingExited,\n        uint256 postTotalEthIncludingExited,\n        uint256 timeElapsed,\n        uint256 annualAprUpperBound\n    );\n\n    /// @notice The balance decrease is higher than the maximum allowed by the lower bound\n    /// @param prevTotalEthIncludingExited The previous total balance, including all exited balance\n    /// @param postTotalEthIncludingExited The post-report total balance, including all exited balance\n    /// @param timeElapsed The time in seconds since last report\n    /// @param relativeLowerBound The lower bound value that was used\n    error TotalValidatorBalanceDecreaseOutOfBound(\n        uint256 prevTotalEthIncludingExited,\n        uint256 postTotalEthIncludingExited,\n        uint256 timeElapsed,\n        uint256 relativeLowerBound\n    );\n\n    /// @notice The total exited balance decreased\n    /// @param currentValidatorsExitedBalance The current exited balance\n    /// @param newValidatorsExitedBalance The new exited balance\n    error InvalidDecreasingValidatorsExitedBalance(\n        uint256 currentValidatorsExitedBalance, uint256 newValidatorsExitedBalance\n    );\n\n    /// @notice The total skimmed balance decreased\n    /// @param currentValidatorsSkimmedBalance The current exited balance\n    /// @param newValidatorsSkimmedBalance The new exited balance\n    error InvalidDecreasingValidatorsSkimmedBalance(\n        uint256 currentValidatorsSkimmedBalance, uint256 newValidatorsSkimmedBalance\n    );\n\n    /// @notice Trace structure emitted via logs during reporting\n    struct ConsensusLayerDataReportingTrace {\n        uint256 rewards;\n        uint256 pulledELFees;\n        uint256 pulledRedeemManagerExceedingEthBuffer;\n        uint256 pulledCoverageFunds;\n    }\n\n    /// @notice The format of the oracle report\n    struct ConsensusLayerReport {\n        // this is the epoch at which the report was performed\n        // data should be fetched up to the state of this epoch by the oracles\n        uint256 epoch;\n        // the sum of all the validator balances on the consensus layer\n        // when a validator enters the exit queue, the validator is considered stopped, its balance is accounted in both validatorsExitingBalance and validatorsBalance\n        // when a validator leaves the exit queue and the funds are sweeped onto the execution layer, the balance is only accounted in validatorsExitedBalance and not in validatorsBalance\n        // this value can decrease between reports\n        uint256 validatorsBalance;\n        // the sum of all the skimmings performed on the validators\n        // these values can be found in the execution layer block bodies under the withdrawals field\n        // a withdrawal is considered skimming if\n        // - the epoch at which it happened is < validator.withdrawableEpoch\n        // - the epoch at which it happened is >= validator.withdrawableEpoch and in that case we only account for what would be above 32 eth as skimming\n        // this value cannot decrease over reports\n        uint256 validatorsSkimmedBalance;\n        // the sum of all the exits performed on the validators\n        // these values can be found in the execution layer block bodies under the withdrawals field\n        // a withdrawal is considered exit if\n        // - the epoch at which it happened is >= validator.withdrawableEpoch and in that case we only account for what would be <= 32 eth as exit\n        // this value cannot decrease over reports\n        uint256 validatorsExitedBalance;\n        // the sum of all the exiting balance, which is all the validators on their way to get sweeped and exited\n        // this includes voluntary exits and slashings\n        // this value can decrease between reports\n        uint256 validatorsExitingBalance;\n        // the count of activated validators\n        // even validators that are exited are still accounted\n        // this value cannot decrease over reports\n        uint32 validatorsCount;\n        // an array containing the count of stopped validators per operator\n        // the first element of the array is the sum of all stopped validators\n        // then index 1 would be operator 0\n        // these values cannot decrease over reports\n        uint32[] stoppedValidatorCountPerOperator;\n        // flag enabled by the oracles when the buffer rebalancing is activated\n        // the activation logic is written in the oracle specification and all oracle members must agree on the activation\n        // when active, the eth in the deposit buffer can be used to pay for exits in the redeem manager\n        bool rebalanceDepositToRedeemMode;\n        // flag enabled by the oracles when the slashing containment is activated\n        // the activation logic is written in the oracle specification and all oracle members must agree on the activation\n        // This flag is activated when a pre-defined threshold of slashed validators in our set of validators is reached\n        // This flag is deactivated when a bottom threshold is met, this means that when we reach the upper threshold and activate the flag, we will deactivate it when we reach the bottom threshold and not before\n        // when active, no more validator exits can be requested by the protocol\n        bool slashingContainmentMode;\n    }\n\n    /// @notice The format of the oracle report in storage\n    /// @notice These fields have the exact same function as the ones in ConsensusLayerReport, but this struct is optimized for storage\n    struct StoredConsensusLayerReport {\n        uint256 epoch;\n        uint256 validatorsBalance;\n        uint256 validatorsSkimmedBalance;\n        uint256 validatorsExitedBalance;\n        uint256 validatorsExitingBalance;\n        uint32 validatorsCount;\n        bool rebalanceDepositToRedeemMode;\n        bool slashingContainmentMode;\n    }\n\n    /// @notice Get oracle address\n    /// @return The oracle address\n    function getOracle() external view returns (address);\n\n    /// @notice Get CL validator total balance\n    /// @return The CL Validator total balance\n    function getCLValidatorTotalBalance() external view returns (uint256);\n\n    /// @notice Get CL validator count (the amount of validator reported by the oracles)\n    /// @return The CL validator count\n    function getCLValidatorCount() external view returns (uint256);\n\n    /// @notice Verifies if the provided epoch is valid\n    /// @param epoch The epoch to lookup\n    /// @return True if valid\n    function isValidEpoch(uint256 epoch) external view returns (bool);\n\n    /// @notice Retrieve the block timestamp\n    /// @return The current timestamp from the EVM context\n    function getTime() external view returns (uint256);\n\n    /// @notice Retrieve expected epoch id\n    /// @return The current expected epoch id\n    function getExpectedEpochId() external view returns (uint256);\n\n    /// @notice Retrieve the last completed epoch id\n    /// @return The last completed epoch id\n    function getLastCompletedEpochId() external view returns (uint256);\n\n    /// @notice Retrieve the current epoch id based on block timestamp\n    /// @return The current epoch id\n    function getCurrentEpochId() external view returns (uint256);\n\n    /// @notice Retrieve the current cl spec\n    /// @return The Consensus Layer Specification\n    function getCLSpec() external view returns (CLSpec.CLSpecStruct memory);\n\n    /// @notice Retrieve the current frame details\n    /// @return _startEpochId The epoch at the beginning of the frame\n    /// @return _startTime The timestamp of the beginning of the frame in seconds\n    /// @return _endTime The timestamp of the end of the frame in seconds\n    function getCurrentFrame() external view returns (uint256 _startEpochId, uint256 _startTime, uint256 _endTime);\n\n    /// @notice Retrieve the first epoch id of the frame of the provided epoch id\n    /// @param _epochId Epoch id used to get the frame\n    /// @return The first epoch id of the frame containing the given epoch id\n    function getFrameFirstEpochId(uint256 _epochId) external view returns (uint256);\n\n    /// @notice Retrieve the report bounds\n    /// @return The report bounds\n    function getReportBounds() external view returns (ReportBounds.ReportBoundsStruct memory);\n\n    /// @notice Retrieve the last consensus layer report\n    /// @return The stored consensus layer report\n    function getLastConsensusLayerReport() external view returns (IOracleManagerV1.StoredConsensusLayerReport memory);\n\n    /// @notice Set the oracle address\n    /// @param _oracleAddress Address of the oracle\n    function setOracle(address _oracleAddress) external;\n\n    /// @notice Set the consensus layer spec\n    /// @param _newValue The new consensus layer spec value\n    function setCLSpec(CLSpec.CLSpecStruct calldata _newValue) external;\n\n    /// @notice Set the report bounds\n    /// @param _newValue The new report bounds value\n    function setReportBounds(ReportBounds.ReportBoundsStruct calldata _newValue) external;\n\n    /// @notice Performs all the reporting logics\n    /// @param _report The consensus layer report structure\n    function setConsensusLayerData(ConsensusLayerReport calldata _report) external;\n}\n"
    },
    "contracts/src/interfaces/components/ISharesManager.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\n\n/// @title Shares Manager Interface (v1)\n/// @author Alluvial Finance Inc.\n/// @notice This interface exposes methods to handle the shares of the depositor and the ERC20 interface\ninterface ISharesManagerV1 is IERC20 {\n    /// @notice Emitted when the total supply is changed\n    event SetTotalSupply(uint256 totalSupply);\n\n    /// @notice Balance too low to perform operation\n    error BalanceTooLow();\n\n    /// @notice Allowance too low to perform operation\n    /// @param _from Account where funds are sent from\n    /// @param _operator Account attempting the transfer\n    /// @param _allowance Current allowance\n    /// @param _value Requested transfer value in shares\n    error AllowanceTooLow(address _from, address _operator, uint256 _allowance, uint256 _value);\n\n    /// @notice Invalid empty transfer\n    error NullTransfer();\n\n    /// @notice Invalid transfer recipients\n    /// @param _from Account sending the funds in the invalid transfer\n    /// @param _to Account receiving the funds in the invalid transfer\n    error UnauthorizedTransfer(address _from, address _to);\n\n    /// @notice Retrieve the token name\n    /// @return The token name\n    function name() external pure returns (string memory);\n\n    /// @notice Retrieve the token symbol\n    /// @return The token symbol\n    function symbol() external pure returns (string memory);\n\n    /// @notice Retrieve the decimal count\n    /// @return The decimal count\n    function decimals() external pure returns (uint8);\n\n    /// @notice Retrieve the total token supply\n    /// @return The total supply in shares\n    function totalSupply() external view returns (uint256);\n\n    /// @notice Retrieve the total underlying asset supply\n    /// @return The total underlying asset supply\n    function totalUnderlyingSupply() external view returns (uint256);\n\n    /// @notice Retrieve the balance of an account\n    /// @param _owner Address to be checked\n    /// @return The balance of the account in shares\n    function balanceOf(address _owner) external view returns (uint256);\n\n    /// @notice Retrieve the underlying asset balance of an account\n    /// @param _owner Address to be checked\n    /// @return The underlying balance of the account\n    function balanceOfUnderlying(address _owner) external view returns (uint256);\n\n    /// @notice Retrieve the underlying asset balance from an amount of shares\n    /// @param _shares Amount of shares to convert\n    /// @return The underlying asset balance represented by the shares\n    function underlyingBalanceFromShares(uint256 _shares) external view returns (uint256);\n\n    /// @notice Retrieve the shares count from an underlying asset amount\n    /// @param _underlyingAssetAmount Amount of underlying asset to convert\n    /// @return The amount of shares worth the underlying asset amopunt\n    function sharesFromUnderlyingBalance(uint256 _underlyingAssetAmount) external view returns (uint256);\n\n    /// @notice Retrieve the allowance value for a spender\n    /// @param _owner Address that issued the allowance\n    /// @param _spender Address that received the allowance\n    /// @return The allowance in shares for a given spender\n    function allowance(address _owner, address _spender) external view returns (uint256);\n\n    /// @notice Performs a transfer from the message sender to the provided account\n    /// @param _to Address receiving the tokens\n    /// @param _value Amount of shares to be sent\n    /// @return True if success\n    function transfer(address _to, uint256 _value) external returns (bool);\n\n    /// @notice Performs a transfer between two recipients\n    /// @param _from Address sending the tokens\n    /// @param _to Address receiving the tokens\n    /// @param _value Amount of shares to be sent\n    /// @return True if success\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\n\n    /// @notice Approves an account for future spendings\n    /// @dev An approved account can use transferFrom to transfer funds on behalf of the token owner\n    /// @param _spender Address that is allowed to spend the tokens\n    /// @param _value The allowed amount in shares, will override previous value\n    /// @return True if success\n    function approve(address _spender, uint256 _value) external returns (bool);\n\n    /// @notice Increase allowance to another account\n    /// @param _spender Spender that receives the allowance\n    /// @param _additionalValue Amount of shares to add\n    /// @return True if success\n    function increaseAllowance(address _spender, uint256 _additionalValue) external returns (bool);\n\n    /// @notice Decrease allowance to another account\n    /// @param _spender Spender that receives the allowance\n    /// @param _subtractableValue Amount of shares to subtract\n    /// @return True if success\n    function decreaseAllowance(address _spender, uint256 _subtractableValue) external returns (bool);\n}\n"
    },
    "contracts/src/interfaces/components/IUserDepositManager.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\n/// @title User Deposit Manager (v1)\n/// @author Alluvial Finance Inc.\n/// @notice This interface exposes methods to handle the inbound transfers cases or the explicit submissions\ninterface IUserDepositManagerV1 {\n    /// @notice User deposited ETH in the system\n    /// @param depositor Address performing the deposit\n    /// @param recipient Address receiving the minted shares\n    /// @param amount Amount in ETH deposited\n    event UserDeposit(address indexed depositor, address indexed recipient, uint256 amount);\n\n    /// @notice And empty deposit attempt was made\n    error EmptyDeposit();\n\n    /// @notice Explicit deposit method to mint on msg.sender\n    function deposit() external payable;\n\n    /// @notice Explicit deposit method to mint on msg.sender and transfer to _recipient\n    /// @param _recipient Address receiving the minted LsETH\n    function depositAndTransfer(address _recipient) external payable;\n\n    /// @notice Implicit deposit method, when the user performs a regular transfer to the contract\n    receive() external payable;\n\n    /// @notice Invalid call, when the user sends a transaction with a data payload but no method matched\n    fallback() external payable;\n}\n"
    },
    "contracts/src/interfaces/IAdministrable.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\n/// @title Administrable Interface\n/// @author Alluvial Finance Inc.\n/// @notice This interface exposes methods to handle the ownership of the contracts\ninterface IAdministrable {\n    /// @notice The pending admin address changed\n    /// @param pendingAdmin New pending admin address\n    event SetPendingAdmin(address indexed pendingAdmin);\n\n    /// @notice The admin address changed\n    /// @param admin New admin address\n    event SetAdmin(address indexed admin);\n\n    /// @notice Retrieves the current admin address\n    /// @return The admin address\n    function getAdmin() external view returns (address);\n\n    /// @notice Retrieve the current pending admin address\n    /// @return The pending admin address\n    function getPendingAdmin() external view returns (address);\n\n    /// @notice Proposes a new address as admin\n    /// @dev This security prevents setting an invalid address as an admin. The pending\n    /// @dev admin has to claim its ownership of the contract, and prove that the new\n    /// @dev address is able to perform regular transactions.\n    /// @param _newAdmin New admin address\n    function proposeAdmin(address _newAdmin) external;\n\n    /// @notice Accept the transfer of ownership\n    /// @dev Only callable by the pending admin. Resets the pending admin if succesful.\n    function acceptAdmin() external;\n}\n"
    },
    "contracts/src/interfaces/IOperatorRegistry.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\nimport \"../state/operatorsRegistry/Operators.2.sol\";\n\n/// @title Operators Registry Interface (v1)\n/// @author Alluvial Finance Inc.\n/// @notice This interface exposes methods to handle the list of operators and their keys\ninterface IOperatorsRegistryV1 {\n    /// @notice A new operator has been added to the registry\n    /// @param index The operator index\n    /// @param name The operator display name\n    /// @param operatorAddress The operator address\n    event AddedOperator(uint256 indexed index, string name, address indexed operatorAddress);\n\n    /// @notice The operator status has been changed\n    /// @param index The operator index\n    /// @param active True if the operator is active\n    event SetOperatorStatus(uint256 indexed index, bool active);\n\n    /// @notice The operator limit has been changed\n    /// @param index The operator index\n    /// @param newLimit The new operator staking limit\n    event SetOperatorLimit(uint256 indexed index, uint256 newLimit);\n\n    /// @notice The operator stopped validator count has been changed\n    /// @param index The operator index\n    /// @param newStoppedValidatorCount The new stopped validator count\n    event SetOperatorStoppedValidatorCount(uint256 indexed index, uint256 newStoppedValidatorCount);\n\n    /// @notice The operator address has been changed\n    /// @param index The operator index\n    /// @param newOperatorAddress The new operator address\n    event SetOperatorAddress(uint256 indexed index, address indexed newOperatorAddress);\n\n    /// @notice The operator display name has been changed\n    /// @param index The operator index\n    /// @param newName The new display name\n    event SetOperatorName(uint256 indexed index, string newName);\n\n    /// @notice The operator or the admin added new validator keys and signatures\n    /// @dev The public keys and signatures are concatenated\n    /// @dev A public key is 48 bytes long\n    /// @dev A signature is 96 bytes long\n    /// @dev [P1, S1, P2, S2, ..., PN, SN] where N is the bytes length divided by (96 + 48)\n    /// @param index The operator index\n    /// @param publicKeysAndSignatures The concatenated public keys and signatures\n    event AddedValidatorKeys(uint256 indexed index, bytes publicKeysAndSignatures);\n\n    /// @notice The operator or the admin removed a public key and its signature from the registry\n    /// @param index The operator index\n    /// @param publicKey The BLS public key that has been removed\n    event RemovedValidatorKey(uint256 indexed index, bytes publicKey);\n\n    /// @notice The stored river address has been changed\n    /// @param river The new river address\n    event SetRiver(address indexed river);\n\n    /// @notice The operator edited its keys after the snapshot block\n    /// @dev This means that we cannot assume that its key set is checked by the snapshot\n    /// @dev This happens only if the limit was meant to be increased\n    /// @param index The operator index\n    /// @param currentLimit The current operator limit\n    /// @param newLimit The new operator limit that was attempted to be set\n    /// @param latestKeysEditBlockNumber The last block number at which the operator changed its keys\n    /// @param snapshotBlock The block number of the snapshot\n    event OperatorEditsAfterSnapshot(\n        uint256 indexed index,\n        uint256 currentLimit,\n        uint256 newLimit,\n        uint256 indexed latestKeysEditBlockNumber,\n        uint256 indexed snapshotBlock\n    );\n\n    /// @notice The call didn't alter the limit of the operator\n    /// @param index The operator index\n    /// @param limit The limit of the operator\n    event OperatorLimitUnchanged(uint256 indexed index, uint256 limit);\n\n    /// @notice The stopped validator array has been changed\n    /// @notice A validator is considered stopped if exiting, exited or slashed\n    /// @notice This event is emitted when the oracle reports new stopped validators counts\n    /// @param stoppedValidatorCounts The new stopped validator counts\n    event UpdatedStoppedValidators(uint32[] stoppedValidatorCounts);\n\n    /// @notice The requested exit count has been updated\n    /// @param index The operator index\n    /// @param count The count of requested exits\n    event RequestedValidatorExits(uint256 indexed index, uint256 count);\n\n    /// @notice The exit request demand has been updated\n    /// @param previousValidatorExitsDemand The previous exit request demand\n    /// @param nextValidatorExitsDemand The new exit request demand\n    event SetCurrentValidatorExitsDemand(uint256 previousValidatorExitsDemand, uint256 nextValidatorExitsDemand);\n\n    /// @notice The total requested exit has been updated\n    /// @param previousTotalValidatorExitsRequested The previous total requested exit\n    /// @param newTotalValidatorExitsRequested The new total requested exit\n    event SetTotalValidatorExitsRequested(\n        uint256 previousTotalValidatorExitsRequested, uint256 newTotalValidatorExitsRequested\n    );\n\n    /// @notice A validator key got funded on the deposit contract\n    /// @notice This event was introduced during a contract upgrade, in order to cover all possible public keys, this event\n    /// @notice will be replayed for past funded keys in order to have a complete coverage of all the funded public keys.\n    /// @notice In this particuliar scenario, the deferred value will be set to true, to indicate that we are not going to have\n    /// @notice the expected additional events and side effects in the same transaction (deposit to official DepositContract etc ...) because\n    /// @notice the event was synthetically crafted.\n    /// @param index The operator index\n    /// @param publicKeys BLS Public key that got funded\n    /// @param deferred True if event has been replayed in the context of a migration\n    event FundedValidatorKeys(uint256 indexed index, bytes[] publicKeys, bool deferred);\n\n    /// @notice The requested exit count has been update to fill the gap with the reported stopped count\n    /// @param index The operator index\n    /// @param oldRequestedExits The old requested exit count\n    /// @param newRequestedExits The new requested exit count\n    event UpdatedRequestedValidatorExitsUponStopped(\n        uint256 indexed index, uint32 oldRequestedExits, uint32 newRequestedExits\n    );\n\n    /// @notice The calling operator is inactive\n    /// @param index The operator index\n    error InactiveOperator(uint256 index);\n\n    /// @notice A funded key deletion has been attempted\n    error InvalidFundedKeyDeletionAttempt();\n\n    /// @notice The index provided are not sorted properly (descending order)\n    error InvalidUnsortedIndexes();\n\n    /// @notice The provided operator and limits array have different lengths\n    error InvalidArrayLengths();\n\n    /// @notice The provided operator and limits array are empty\n    error InvalidEmptyArray();\n\n    /// @notice The provided key count is 0\n    error InvalidKeyCount();\n\n    /// @notice The provided concatenated keys do not have the expected length\n    error InvalidKeysLength();\n\n    /// @notice The index that is removed is out of bounds\n    error InvalidIndexOutOfBounds();\n\n    /// @notice The value for the operator limit is too high\n    /// @param index The operator index\n    /// @param limit The new limit provided\n    /// @param keyCount The operator key count\n    error OperatorLimitTooHigh(uint256 index, uint256 limit, uint256 keyCount);\n\n    /// @notice The value for the limit is too low\n    /// @param index The operator index\n    /// @param limit The new limit provided\n    /// @param fundedKeyCount The operator funded key count\n    error OperatorLimitTooLow(uint256 index, uint256 limit, uint256 fundedKeyCount);\n\n    /// @notice The provided list of operators is not in increasing order\n    error UnorderedOperatorList();\n\n    /// @notice Thrown when an invalid empty stopped validator array is provided\n    error InvalidEmptyStoppedValidatorCountsArray();\n\n    /// @notice Thrown when the sum of stopped validators is invalid\n    error InvalidStoppedValidatorCountsSum();\n\n    /// @notice Throw when an element in the stopped validator array is decreasing\n    error StoppedValidatorCountsDecreased();\n\n    /// @notice Thrown when the number of elements in the array is too high compared to operator count\n    error StoppedValidatorCountsTooHigh();\n\n    /// @notice Thrown when no exit requests can be performed\n    error NoExitRequestsToPerform();\n\n    /// @notice The provided stopped validator count array is shrinking\n    error StoppedValidatorCountArrayShrinking();\n\n    /// @notice The provided stopped validator count of an operator is above its funded validator count\n    error StoppedValidatorCountAboveFundedCount(uint256 operatorIndex, uint32 stoppedCount, uint32 fundedCount);\n\n    /// @notice Initializes the operators registry\n    /// @param _admin Admin in charge of managing operators\n    /// @param _river Address of River system\n    function initOperatorsRegistryV1(address _admin, address _river) external;\n\n    /// @notice Initializes the operators registry for V1_1\n    function initOperatorsRegistryV1_1() external;\n\n    /// @notice Retrieve the River address\n    /// @return The address of River\n    function getRiver() external view returns (address);\n\n    /// @notice Get operator details\n    /// @param _index The index of the operator\n    /// @return The details of the operator\n    function getOperator(uint256 _index) external view returns (OperatorsV2.Operator memory);\n\n    /// @notice Get operator count\n    /// @return The operator count\n    function getOperatorCount() external view returns (uint256);\n\n    /// @notice Retrieve the stopped validator count for an operator index\n    /// @param _idx The index of the operator\n    /// @return The stopped validator count of the operator\n    function getOperatorStoppedValidatorCount(uint256 _idx) external view returns (uint32);\n\n    /// @notice Retrieve the total stopped validator count\n    /// @return The total stopped validator count\n    function getTotalStoppedValidatorCount() external view returns (uint32);\n\n    /// @notice Retrieve the total requested exit count\n    /// @notice This value is the amount of exit requests that have been performed, emitting an event for operators to catch\n    /// @return The total requested exit count\n    function getTotalValidatorExitsRequested() external view returns (uint256);\n\n    /// @notice Get the current exit request demand waiting to be triggered\n    /// @notice This value is the amount of exit requests that are demanded and not yet performed by the contract\n    /// @return The current exit request demand\n    function getCurrentValidatorExitsDemand() external view returns (uint256);\n\n    /// @notice Retrieve the total stopped and requested exit count\n    /// @return The total stopped count\n    /// @return The total requested exit count\n    function getStoppedAndRequestedExitCounts() external view returns (uint32, uint256);\n\n    /// @notice Retrieve the raw stopped validators array from storage\n    /// @return The stopped validator array\n    function getStoppedValidatorCountPerOperator() external view returns (uint32[] memory);\n\n    /// @notice Get the details of a validator\n    /// @param _operatorIndex The index of the operator\n    /// @param _validatorIndex The index of the validator\n    /// @return publicKey The public key of the validator\n    /// @return signature The signature used during deposit\n    /// @return funded True if validator has been funded\n    function getValidator(uint256 _operatorIndex, uint256 _validatorIndex)\n        external\n        view\n        returns (bytes memory publicKey, bytes memory signature, bool funded);\n\n    /// @notice Get the next validators that would be funded\n    /// @param _count Count of validators that would be funded next\n    /// @return publicKeys An array of fundable public keys\n    /// @return signatures An array of signatures linked to the public keys\n    function getNextValidatorsToDepositFromActiveOperators(uint256 _count)\n        external\n        view\n        returns (bytes[] memory publicKeys, bytes[] memory signatures);\n\n    /// @notice Retrieve the active operator set\n    /// @return The list of active operators and their details\n    function listActiveOperators() external view returns (OperatorsV2.Operator[] memory);\n\n    /// @notice Allows river to override the stopped validators array\n    /// @notice This actions happens during the Oracle report processing\n    /// @param _stoppedValidatorCounts The new stopped validators array\n    /// @param _depositedValidatorCount The total deposited validator count\n    function reportStoppedValidatorCounts(uint32[] calldata _stoppedValidatorCounts, uint256 _depositedValidatorCount)\n        external;\n\n    /// @notice Adds an operator to the registry\n    /// @dev Only callable by the administrator\n    /// @param _name The name identifying the operator\n    /// @param _operator The address representing the operator, receiving the rewards\n    /// @return The index of the new operator\n    function addOperator(string calldata _name, address _operator) external returns (uint256);\n\n    /// @notice Changes the operator address of an operator\n    /// @dev Only callable by the administrator or the previous operator address\n    /// @param _index The operator index\n    /// @param _newOperatorAddress The new address of the operator\n    function setOperatorAddress(uint256 _index, address _newOperatorAddress) external;\n\n    /// @notice Changes the operator name\n    /// @dev Only callable by the administrator or the operator\n    /// @param _index The operator index\n    /// @param _newName The new operator name\n    function setOperatorName(uint256 _index, string calldata _newName) external;\n\n    /// @notice Changes the operator status\n    /// @dev Only callable by the administrator\n    /// @param _index The operator index\n    /// @param _newStatus The new status of the operator\n    function setOperatorStatus(uint256 _index, bool _newStatus) external;\n\n    /// @notice Changes the operator staking limit\n    /// @dev Only callable by the administrator\n    /// @dev The operator indexes must be in increasing order and contain no duplicate\n    /// @dev The limit cannot exceed the total key count of the operator\n    /// @dev The _indexes and _newLimits must have the same length.\n    /// @dev Each limit value is applied to the operator index at the same index in the _indexes array.\n    /// @param _operatorIndexes The operator indexes, in increasing order and duplicate free\n    /// @param _newLimits The new staking limit of the operators\n    /// @param _snapshotBlock The block number at which the snapshot was computed\n    function setOperatorLimits(\n        uint256[] calldata _operatorIndexes,\n        uint32[] calldata _newLimits,\n        uint256 _snapshotBlock\n    ) external;\n\n    /// @notice Adds new keys for an operator\n    /// @dev Only callable by the administrator or the operator address\n    /// @param _index The operator index\n    /// @param _keyCount The amount of keys provided\n    /// @param _publicKeysAndSignatures Public keys of the validator, concatenated\n    function addValidators(uint256 _index, uint32 _keyCount, bytes calldata _publicKeysAndSignatures) external;\n\n    /// @notice Remove validator keys\n    /// @dev Only callable by the administrator or the operator address\n    /// @dev The indexes must be provided sorted in decreasing order and duplicate-free, otherwise the method will revert\n    /// @dev The operator limit will be set to the lowest deleted key index if the operator's limit wasn't equal to its total key count\n    /// @dev The operator or the admin cannot remove funded keys\n    /// @dev When removing validators, the indexes of specific unfunded keys can be changed in order to properly\n    /// @dev remove the keys from the storage array. Beware of this specific behavior when chaining calls as the\n    /// @dev targeted public key indexes can point to a different key after a first call was made and performed\n    /// @dev some swaps\n    /// @param _index The operator index\n    /// @param _indexes The indexes of the keys to remove\n    function removeValidators(uint256 _index, uint256[] calldata _indexes) external;\n\n    /// @notice Retrieve validator keys based on operator statuses\n    /// @param _count Max amount of keys requested\n    /// @return publicKeys An array of public keys\n    /// @return signatures An array of signatures linked to the public keys\n    function pickNextValidatorsToDeposit(uint256 _count)\n        external\n        returns (bytes[] memory publicKeys, bytes[] memory signatures);\n\n    /// @notice Public endpoint to consume the exit request demand and perform the actual exit requests\n    /// @notice The selection algorithm will pick validators based on their active validator counts\n    /// @notice This value is computed by using the count of funded keys and taking into account the stopped validator counts and exit requests\n    /// @param _count Max amount of exits to request\n    function requestValidatorExits(uint256 _count) external;\n\n    /// @notice Increases the exit request demand\n    /// @dev This method is only callable by the river contract, and to actually forward the information to the node operators via event emission, the unprotected requestValidatorExits method must be called\n    /// @param _count The amount of exit requests to add to the demand\n    /// @param _depositedValidatorCount The total deposited validator count\n    function demandValidatorExits(uint256 _count, uint256 _depositedValidatorCount) external;\n}\n"
    },
    "contracts/src/interfaces/IProtocolVersion.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\ninterface IProtocolVersion {\n    /// @notice Retrieves the version of the contract\n    /// @return Version of the contract\n    function version() external pure returns (string memory);\n}\n"
    },
    "contracts/src/interfaces/IRiver.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\nimport \"../state/river/DailyCommittableLimits.sol\";\n\nimport \"./components/IConsensusLayerDepositManager.1.sol\";\nimport \"./components/IOracleManager.1.sol\";\nimport \"./components/ISharesManager.1.sol\";\nimport \"./components/IUserDepositManager.1.sol\";\n\n/// @title River Interface (v1)\n/// @author Alluvial Finance Inc.\n/// @notice The main system interface\ninterface IRiverV1 is IConsensusLayerDepositManagerV1, IUserDepositManagerV1, ISharesManagerV1, IOracleManagerV1 {\n    /// @notice Funds have been pulled from the Execution Layer Fee Recipient\n    /// @param amount The amount pulled\n    event PulledELFees(uint256 amount);\n\n    /// @notice Funds have been pulled from the Coverage Fund\n    /// @param amount The amount pulled\n    event PulledCoverageFunds(uint256 amount);\n\n    /// @notice Emitted when funds are pulled from the redeem manager\n    /// @param amount The amount pulled\n    event PulledRedeemManagerExceedingEth(uint256 amount);\n\n    /// @notice Emitted when funds are pulled from the CL recipient\n    /// @param pulledSkimmedEthAmount The amount of skimmed ETH pulled\n    /// @param pullExitedEthAmount The amount of exited ETH pulled\n    event PulledCLFunds(uint256 pulledSkimmedEthAmount, uint256 pullExitedEthAmount);\n\n    /// @notice The stored Execution Layer Fee Recipient has been changed\n    /// @param elFeeRecipient The new Execution Layer Fee Recipient\n    event SetELFeeRecipient(address indexed elFeeRecipient);\n\n    /// @notice The stored Coverage Fund has been changed\n    /// @param coverageFund The new Coverage Fund\n    event SetCoverageFund(address indexed coverageFund);\n\n    /// @notice The stored Collector has been changed\n    /// @param collector The new Collector\n    event SetCollector(address indexed collector);\n\n    /// @notice The stored Allowlist has been changed\n    /// @param allowlist The new Allowlist\n    event SetAllowlist(address indexed allowlist);\n\n    /// @notice The stored Global Fee has been changed\n    /// @param fee The new Global Fee\n    event SetGlobalFee(uint256 fee);\n\n    /// @notice The stored Operators Registry has been changed\n    /// @param operatorRegistry The new Operators Registry\n    event SetOperatorsRegistry(address indexed operatorRegistry);\n\n    /// @notice The stored Metadata URI string has been changed\n    /// @param metadataURI The new Metadata URI string\n    event SetMetadataURI(string metadataURI);\n\n    /// @notice The system underlying supply increased. This is a snapshot of the balances for accounting purposes\n    /// @param _collector The address of the collector during this event\n    /// @param _oldTotalUnderlyingBalance Old total ETH balance under management by River\n    /// @param _oldTotalSupply Old total supply in shares\n    /// @param _newTotalUnderlyingBalance New total ETH balance under management by River\n    /// @param _newTotalSupply New total supply in shares\n    event RewardsEarned(\n        address indexed _collector,\n        uint256 _oldTotalUnderlyingBalance,\n        uint256 _oldTotalSupply,\n        uint256 _newTotalUnderlyingBalance,\n        uint256 _newTotalSupply\n    );\n\n    /// @notice Emitted when the daily committable limits are changed\n    /// @param minNetAmount The minimum amount that must be used as the daily committable amount\n    /// @param maxRelativeAmount The maximum amount that can be used as the daily committable amount, relative to the total underlying supply\n    event SetMaxDailyCommittableAmounts(uint256 minNetAmount, uint256 maxRelativeAmount);\n\n    /// @notice Emitted when the redeem manager address is changed\n    /// @param redeemManager The address of the redeem manager\n    event SetRedeemManager(address redeemManager);\n\n    /// @notice Emitted when the balance to deposit is updated\n    /// @param oldAmount The old balance to deposit\n    /// @param newAmount The new balance to deposit\n    event SetBalanceToDeposit(uint256 oldAmount, uint256 newAmount);\n\n    /// @notice Emitted when the balance to redeem is updated\n    /// @param oldAmount The old balance to redeem\n    /// @param newAmount The new balance to redeem\n    event SetBalanceToRedeem(uint256 oldAmount, uint256 newAmount);\n\n    /// @notice Emitted when the balance committed to deposit\n    /// @param oldAmount The old balance committed to deposit\n    /// @param newAmount The new balance committed to deposit\n    event SetBalanceCommittedToDeposit(uint256 oldAmount, uint256 newAmount);\n\n    /// @notice Emitted when the redeem manager received a withdraw event report\n    /// @param redeemManagerDemand The total demand in LsETH of the redeem manager\n    /// @param suppliedRedeemManagerDemand The amount of LsETH demand actually supplied\n    /// @param suppliedRedeemManagerDemandInEth The amount in ETH of the supplied demand\n    event ReportedRedeemManager(\n        uint256 redeemManagerDemand, uint256 suppliedRedeemManagerDemand, uint256 suppliedRedeemManagerDemandInEth\n    );\n\n    /// @notice Thrown when the amount received from the Withdraw contract doe not match the requested amount\n    /// @param requested The amount that was requested\n    /// @param received The amount that was received\n    error InvalidPulledClFundsAmount(uint256 requested, uint256 received);\n\n    /// @notice The computed amount of shares to mint is 0\n    error ZeroMintedShares();\n\n    /// @notice The access was denied\n    /// @param account The account that was denied\n    error Denied(address account);\n\n    /// @notice Initializes the River system\n    /// @param _depositContractAddress Address to make Consensus Layer deposits\n    /// @param _elFeeRecipientAddress Address that receives the execution layer fees\n    /// @param _withdrawalCredentials Credentials to use for every validator deposit\n    /// @param _oracleAddress The address of the Oracle contract\n    /// @param _systemAdministratorAddress Administrator address\n    /// @param _allowlistAddress Address of the allowlist contract\n    /// @param _operatorRegistryAddress Address of the operator registry\n    /// @param _collectorAddress Address receiving the the global fee on revenue\n    /// @param _globalFee Amount retained when the ETH balance increases and sent to the collector\n    function initRiverV1(\n        address _depositContractAddress,\n        address _elFeeRecipientAddress,\n        bytes32 _withdrawalCredentials,\n        address _oracleAddress,\n        address _systemAdministratorAddress,\n        address _allowlistAddress,\n        address _operatorRegistryAddress,\n        address _collectorAddress,\n        uint256 _globalFee\n    ) external;\n\n    /// @notice Initialized version 1.1 of the River System\n    /// @param _redeemManager The redeem manager address\n    /// @param _epochsPerFrame The amounts of epochs in a frame\n    /// @param _slotsPerEpoch The slots inside an epoch\n    /// @param _secondsPerSlot The seconds inside a slot\n    /// @param _genesisTime The genesis timestamp\n    /// @param _epochsToAssumedFinality The number of epochs before an epoch is considered final on-chain\n    /// @param _annualAprUpperBound The reporting upper bound\n    /// @param _relativeLowerBound The reporting lower bound\n    /// @param _maxDailyNetCommittableAmount_ The net daily committable limit\n    /// @param _maxDailyRelativeCommittableAmount_ The relative daily committable limit\n    function initRiverV1_1(\n        address _redeemManager,\n        uint64 _epochsPerFrame,\n        uint64 _slotsPerEpoch,\n        uint64 _secondsPerSlot,\n        uint64 _genesisTime,\n        uint64 _epochsToAssumedFinality,\n        uint256 _annualAprUpperBound,\n        uint256 _relativeLowerBound,\n        uint128 _maxDailyNetCommittableAmount_,\n        uint128 _maxDailyRelativeCommittableAmount_\n    ) external;\n\n    /// @notice Initializes version 1.2 of the River System\n    function initRiverV1_2() external;\n\n    /// @notice Get the current global fee\n    /// @return The global fee\n    function getGlobalFee() external view returns (uint256);\n\n    /// @notice Retrieve the allowlist address\n    /// @return The allowlist address\n    function getAllowlist() external view returns (address);\n\n    /// @notice Retrieve the collector address\n    /// @return The collector address\n    function getCollector() external view returns (address);\n\n    /// @notice Retrieve the execution layer fee recipient\n    /// @return The execution layer fee recipient address\n    function getELFeeRecipient() external view returns (address);\n\n    /// @notice Retrieve the coverage fund\n    /// @return The coverage fund address\n    function getCoverageFund() external view returns (address);\n\n    /// @notice Retrieve the redeem manager\n    /// @return The redeem manager address\n    function getRedeemManager() external view returns (address);\n\n    /// @notice Retrieve the operators registry\n    /// @return The operators registry address\n    function getOperatorsRegistry() external view returns (address);\n\n    /// @notice Retrieve the metadata uri string value\n    /// @return The metadata uri string value\n    function getMetadataURI() external view returns (string memory);\n\n    /// @notice Retrieve the configured daily committable limits\n    /// @return The daily committable limits structure\n    function getDailyCommittableLimits()\n        external\n        view\n        returns (DailyCommittableLimits.DailyCommittableLimitsStruct memory);\n\n    /// @notice Resolves the provided redeem requests by calling the redeem manager\n    /// @param _redeemRequestIds The list of redeem requests to resolve\n    /// @return withdrawalEventIds The list of matching withdrawal events, or error codes\n    function resolveRedeemRequests(uint32[] calldata _redeemRequestIds)\n        external\n        view\n        returns (int64[] memory withdrawalEventIds);\n\n    /// @notice Set the daily committable limits\n    /// @param _dcl The Daily Committable Limits structure\n    function setDailyCommittableLimits(DailyCommittableLimits.DailyCommittableLimitsStruct memory _dcl) external;\n\n    /// @notice Retrieve the current balance to redeem\n    /// @return The current balance to redeem\n    function getBalanceToRedeem() external view returns (uint256);\n\n    /// @notice Performs a redeem request on the redeem manager\n    /// @param _lsETHAmount The amount of LsETH to redeem\n    /// @param _recipient The address that will own the redeem request\n    /// @return redeemRequestId The ID of the newly created redeem request\n    function requestRedeem(uint256 _lsETHAmount, address _recipient) external returns (uint32 redeemRequestId);\n\n    /// @notice Claims several redeem requests\n    /// @param _redeemRequestIds The list of redeem requests to claim\n    /// @param _withdrawalEventIds The list of resolved withdrawal event ids\n    /// @return claimStatuses The operation status results\n    function claimRedeemRequests(uint32[] calldata _redeemRequestIds, uint32[] calldata _withdrawalEventIds)\n        external\n        returns (uint8[] memory claimStatuses);\n\n    /// @notice Changes the global fee parameter\n    /// @param _newFee New fee value\n    function setGlobalFee(uint256 _newFee) external;\n\n    /// @notice Changes the allowlist address\n    /// @param _newAllowlist New address for the allowlist\n    function setAllowlist(address _newAllowlist) external;\n\n    /// @notice Changes the collector address\n    /// @param _newCollector New address for the collector\n    function setCollector(address _newCollector) external;\n\n    /// @notice Changes the execution layer fee recipient\n    /// @param _newELFeeRecipient New address for the recipient\n    function setELFeeRecipient(address _newELFeeRecipient) external;\n\n    /// @notice Changes the coverage fund\n    /// @param _newCoverageFund New address for the fund\n    function setCoverageFund(address _newCoverageFund) external;\n\n    /// @notice Sets the metadata uri string value\n    /// @param _metadataURI The new metadata uri string value\n    function setMetadataURI(string memory _metadataURI) external;\n\n    /// @notice Input for execution layer fee earnings\n    function sendELFees() external payable;\n\n    /// @notice Input for consensus layer funds, containing both exit and skimming\n    function sendCLFunds() external payable;\n\n    /// @notice Input for coverage funds\n    function sendCoverageFunds() external payable;\n\n    /// @notice Input for the redeem manager funds\n    function sendRedeemManagerExceedingFunds() external payable;\n}\n"
    },
    "contracts/src/libraries/LibAdministrable.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\nimport \"../state/shared/AdministratorAddress.sol\";\nimport \"../state/shared/PendingAdministratorAddress.sol\";\n\n/// @title Lib Administrable\n/// @author Alluvial Finance Inc.\n/// @notice This library handles the admin and pending admin storage vars\nlibrary LibAdministrable {\n    /// @notice Retrieve the system admin\n    /// @return The address of the system admin\n    function _getAdmin() internal view returns (address) {\n        return AdministratorAddress.get();\n    }\n\n    /// @notice Retrieve the pending system admin\n    /// @return The adress of the pending system admin\n    function _getPendingAdmin() internal view returns (address) {\n        return PendingAdministratorAddress.get();\n    }\n\n    /// @notice Sets the system admin\n    /// @param _admin New system admin\n    function _setAdmin(address _admin) internal {\n        AdministratorAddress.set(_admin);\n    }\n\n    /// @notice Sets the pending system admin\n    /// @param _pendingAdmin New pending system admin\n    function _setPendingAdmin(address _pendingAdmin) internal {\n        PendingAdministratorAddress.set(_pendingAdmin);\n    }\n}\n"
    },
    "contracts/src/libraries/LibBasisPoints.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\n/// @title Lib Basis Points\n/// @notice Holds the basis points max value\nlibrary LibBasisPoints {\n    /// @notice The max value for basis points (represents 100%)\n    uint256 internal constant BASIS_POINTS_MAX = 10_000;\n}\n"
    },
    "contracts/src/libraries/LibBytes.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\n/// @title Lib Bytes\n/// @notice This library helps manipulating bytes\nlibrary LibBytes {\n    /// @notice The length overflows an uint\n    error SliceOverflow();\n\n    /// @notice The slice is outside of the initial bytes bounds\n    error SliceOutOfBounds();\n\n    /// @notice Slices the provided bytes\n    /// @param _bytes Bytes to slice\n    /// @param _start The starting index of the slice\n    /// @param _length The length of the slice\n    /// @return The slice of _bytes starting at _start of length _length\n    function slice(bytes memory _bytes, uint256 _start, uint256 _length) internal pure returns (bytes memory) {\n        unchecked {\n            if (_length + 31 < _length) {\n                revert SliceOverflow();\n            }\n        }\n        if (_bytes.length < _start + _length) {\n            revert SliceOutOfBounds();\n        }\n\n        bytes memory tempBytes;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } { mstore(mc, mload(cc)) }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n}\n"
    },
    "contracts/src/libraries/LibErrors.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\n/// @title Lib Errors\n/// @notice Library of common errors\nlibrary LibErrors {\n    /// @notice The operator is unauthorized for the caller\n    /// @param caller Address performing the call\n    error Unauthorized(address caller);\n\n    /// @notice The call was invalid\n    error InvalidCall();\n\n    /// @notice The argument was invalid\n    error InvalidArgument();\n\n    /// @notice The address is zero\n    error InvalidZeroAddress();\n\n    /// @notice The string is empty\n    error InvalidEmptyString();\n\n    /// @notice The fee is invalid\n    error InvalidFee();\n}\n"
    },
    "contracts/src/libraries/LibSanitize.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\nimport \"./LibErrors.sol\";\nimport \"./LibBasisPoints.sol\";\n\n/// @title Lib Sanitize\n/// @notice Utilities to sanitize input values\nlibrary LibSanitize {\n    /// @notice Reverts if address is 0\n    /// @param _address Address to check\n    function _notZeroAddress(address _address) internal pure {\n        if (_address == address(0)) {\n            revert LibErrors.InvalidZeroAddress();\n        }\n    }\n\n    /// @notice Reverts if string is empty\n    /// @param _string String to check\n    function _notEmptyString(string memory _string) internal pure {\n        if (bytes(_string).length == 0) {\n            revert LibErrors.InvalidEmptyString();\n        }\n    }\n\n    /// @notice Reverts if fee is invalid\n    /// @param _fee Fee to check\n    function _validFee(uint256 _fee) internal pure {\n        if (_fee > LibBasisPoints.BASIS_POINTS_MAX) {\n            revert LibErrors.InvalidFee();\n        }\n    }\n}\n"
    },
    "contracts/src/libraries/LibUint256.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\n/// @title Lib Uint256\n/// @notice Utilities to perform uint operations\nlibrary LibUint256 {\n    /// @notice Converts a value to little endian (64 bits)\n    /// @param _value The value to convert\n    /// @return result The converted value\n    function toLittleEndian64(uint256 _value) internal pure returns (uint256 result) {\n        uint256 tempValue = _value;\n        result = tempValue & 0xFF;\n        tempValue >>= 8;\n\n        result = (result << 8) | (tempValue & 0xFF);\n        tempValue >>= 8;\n\n        result = (result << 8) | (tempValue & 0xFF);\n        tempValue >>= 8;\n\n        result = (result << 8) | (tempValue & 0xFF);\n        tempValue >>= 8;\n\n        result = (result << 8) | (tempValue & 0xFF);\n        tempValue >>= 8;\n\n        result = (result << 8) | (tempValue & 0xFF);\n        tempValue >>= 8;\n\n        result = (result << 8) | (tempValue & 0xFF);\n        tempValue >>= 8;\n\n        result = (result << 8) | (tempValue & 0xFF);\n        tempValue >>= 8;\n\n        assert(0 == tempValue); // fully converted\n        result <<= (24 * 8);\n    }\n\n    /// @notice Returns the minimum value\n    /// @param _a First value\n    /// @param _b Second value\n    /// @return Smallest value between _a and _b\n    function min(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        return (_a > _b ? _b : _a);\n    }\n\n    /// @notice Returns the max value\n    /// @param _a First value\n    /// @param _b Second value\n    /// @return Highest value between _a and _b\n    function max(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        return (_a < _b ? _b : _a);\n    }\n\n    /// @notice Performs a ceiled division\n    /// @param _a Numerator\n    /// @param _b Denominator\n    /// @return ceil(_a / _b)\n    function ceil(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        return (_a / _b) + (_a % _b > 0 ? 1 : 0);\n    }\n}\n"
    },
    "contracts/src/libraries/LibUnstructuredStorage.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.20;\n\n/// @title Lib Unstructured Storage\n/// @notice Utilities to work with unstructured storage\nlibrary LibUnstructuredStorage {\n    /// @notice Retrieve a bool value at a storage slot\n    /// @param _position The storage slot to retrieve\n    /// @return data The bool value\n    function getStorageBool(bytes32 _position) internal view returns (bool data) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            data := sload(_position)\n        }\n    }\n\n    /// @notice Retrieve an address value at a storage slot\n    /// @param _position The storage slot to retrieve\n    /// @return data The address value\n    function getStorageAddress(bytes32 _position) internal view returns (address data) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            data := sload(_position)\n        }\n    }\n\n    /// @notice Retrieve a bytes32 value at a storage slot\n    /// @param _position The storage slot to retrieve\n    /// @return data The bytes32 value\n    function getStorageBytes32(bytes32 _position) internal view returns (bytes32 data) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            data := sload(_position)\n        }\n    }\n\n    /// @notice Retrieve an uint256 value at a storage slot\n    /// @param _position The storage slot to retrieve\n    /// @return data The uint256 value\n    function getStorageUint256(bytes32 _position) internal view returns (uint256 data) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            data := sload(_position)\n        }\n    }\n\n    /// @notice Sets a bool value at a storage slot\n    /// @param _position The storage slot to set\n    /// @param _data The bool value to set\n    function setStorageBool(bytes32 _position, bool _data) internal {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(_position, _data)\n        }\n    }\n\n    /// @notice Sets an address value at a storage slot\n    /// @param _position The storage slot to set\n    /// @param _data The address value to set\n    function setStorageAddress(bytes32 _position, address _data) internal {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(_position, _data)\n        }\n    }\n\n    /// @notice Sets a bytes32 value at a storage slot\n    /// @param _position The storage slot to set\n    /// @param _data The bytes32 value to set\n    function setStorageBytes32(bytes32 _position, bytes32 _data) internal {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(_position, _data)\n        }\n    }\n\n    /// @notice Sets an uint256 value at a storage slot\n    /// @param _position The storage slot to set\n    /// @param _data The uint256 value to set\n    function setStorageUint256(bytes32 _position, uint256 _data) internal {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(_position, _data)\n        }\n    }\n}\n"
    },
    "contracts/src/OperatorsRegistry.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\nimport \"./interfaces/IOperatorRegistry.1.sol\";\nimport \"./interfaces/IRiver.1.sol\";\nimport \"./interfaces/IProtocolVersion.sol\";\n\nimport \"./libraries/LibUint256.sol\";\n\nimport \"./Initializable.sol\";\nimport \"./Administrable.sol\";\n\nimport \"./state/operatorsRegistry/Operators.1.sol\";\nimport \"./state/operatorsRegistry/Operators.2.sol\";\nimport \"./state/operatorsRegistry/ValidatorKeys.sol\";\nimport \"./state/operatorsRegistry/TotalValidatorExitsRequested.sol\";\nimport \"./state/operatorsRegistry/CurrentValidatorExitsDemand.sol\";\nimport \"./state/shared/RiverAddress.sol\";\n\nimport \"./state/migration/OperatorsRegistry_FundedKeyEventRebroadcasting_KeyIndex.sol\";\nimport \"./state/migration/OperatorsRegistry_FundedKeyEventRebroadcasting_OperatorIndex.sol\";\n\n/// @title Operators Registry (v1)\n/// @author Alluvial Finance Inc.\n/// @notice This contract handles the list of operators and their keys\ncontract OperatorsRegistryV1 is IOperatorsRegistryV1, Initializable, Administrable, IProtocolVersion {\n    /// @notice Maximum validators given to an operator per selection loop round\n    uint256 internal constant MAX_VALIDATOR_ATTRIBUTION_PER_ROUND = 5;\n\n    /// @inheritdoc IOperatorsRegistryV1\n    function initOperatorsRegistryV1(address _admin, address _river) external init(0) {\n        _setAdmin(_admin);\n        RiverAddress.set(_river);\n        emit SetRiver(_river);\n    }\n\n    /// @notice Internal migration utility to migrate all operators to OperatorsV2 format\n    function _migrateOperators_V1_1() internal {\n        uint256 opCount = OperatorsV1.getCount();\n\n        for (uint256 idx = 0; idx < opCount;) {\n            OperatorsV1.Operator memory oldOperatorValue = OperatorsV1.get(idx);\n\n            OperatorsV2.push(\n                OperatorsV2.Operator({\n                    limit: uint32(oldOperatorValue.limit),\n                    funded: uint32(oldOperatorValue.funded),\n                    requestedExits: 0,\n                    keys: uint32(oldOperatorValue.keys),\n                    latestKeysEditBlockNumber: uint64(oldOperatorValue.latestKeysEditBlockNumber),\n                    active: oldOperatorValue.active,\n                    name: oldOperatorValue.name,\n                    operator: oldOperatorValue.operator\n                })\n            );\n\n            unchecked {\n                ++idx;\n            }\n        }\n    }\n\n    /// MIGRATION: FUNDED VALIDATOR KEY EVENT REBROADCASTING\n    /// As the event for funded keys was moved from River to this contract because we needed to be able to bind\n    /// operator indexes to public keys, we need to rebroadcast the past funded validator keys with the new event\n    /// to keep retro-compatibility\n\n    /// Emitted when the event rebroadcasting is done and we attempt to broadcast new events\n    error FundedKeyEventMigrationComplete();\n\n    /// Utility to force the broadcasting of events. Will keep its progress in storage to prevent being DoSed by the number of keys\n    /// @param _amountToEmit The amount of events to emit at maximum in this call\n    function forceFundedValidatorKeysEventEmission(uint256 _amountToEmit) external {\n        uint256 operatorIndex = OperatorsRegistry_FundedKeyEventRebroadcasting_OperatorIndex.get();\n        if (operatorIndex == type(uint256).max) {\n            revert FundedKeyEventMigrationComplete();\n        }\n        if (OperatorsV2.getCount() == 0) {\n            OperatorsRegistry_FundedKeyEventRebroadcasting_OperatorIndex.set(type(uint256).max);\n            return;\n        }\n        uint256 keyIndex = OperatorsRegistry_FundedKeyEventRebroadcasting_KeyIndex.get();\n        while (_amountToEmit > 0 && operatorIndex != type(uint256).max) {\n            OperatorsV2.Operator memory operator = OperatorsV2.get(operatorIndex);\n\n            (bytes[] memory publicKeys,) = ValidatorKeys.getKeys(\n                operatorIndex, keyIndex, LibUint256.min(_amountToEmit, operator.funded - keyIndex)\n            );\n            emit FundedValidatorKeys(operatorIndex, publicKeys, true);\n            if (keyIndex + publicKeys.length == operator.funded) {\n                keyIndex = 0;\n                if (operatorIndex == OperatorsV2.getCount() - 1) {\n                    operatorIndex = type(uint256).max;\n                } else {\n                    unchecked {\n                        ++operatorIndex;\n                    }\n                }\n            } else {\n                keyIndex += publicKeys.length;\n            }\n            _amountToEmit -= publicKeys.length;\n        }\n        OperatorsRegistry_FundedKeyEventRebroadcasting_OperatorIndex.set(operatorIndex);\n        OperatorsRegistry_FundedKeyEventRebroadcasting_KeyIndex.set(keyIndex);\n    }\n\n    /// @inheritdoc IOperatorsRegistryV1\n    function initOperatorsRegistryV1_1() external init(1) {\n        _migrateOperators_V1_1();\n    }\n\n    /// @notice Prevent unauthorized calls\n    modifier onlyRiver() virtual {\n        if (msg.sender != RiverAddress.get()) {\n            revert LibErrors.Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    /// @notice Prevents anyone except the admin or the given operator to make the call. Also checks if operator is active\n    /// @notice The admin is able to call this method on behalf of any operator, even if inactive\n    /// @param _index The index identifying the operator\n    modifier onlyOperatorOrAdmin(uint256 _index) {\n        if (msg.sender == _getAdmin()) {\n            _;\n            return;\n        }\n        OperatorsV2.Operator storage operator = OperatorsV2.get(_index);\n        if (!operator.active) {\n            revert InactiveOperator(_index);\n        }\n        if (msg.sender != operator.operator) {\n            revert LibErrors.Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    /// @inheritdoc IOperatorsRegistryV1\n    function getRiver() external view returns (address) {\n        return RiverAddress.get();\n    }\n\n    /// @inheritdoc IOperatorsRegistryV1\n    function getOperator(uint256 _index) external view returns (OperatorsV2.Operator memory) {\n        return OperatorsV2.get(_index);\n    }\n\n    /// @inheritdoc IOperatorsRegistryV1\n    function getOperatorStoppedValidatorCount(uint256 _idx) external view returns (uint32) {\n        return _getStoppedValidatorsCount(_idx);\n    }\n\n    /// @inheritdoc IOperatorsRegistryV1\n    function getTotalStoppedValidatorCount() external view returns (uint32) {\n        return _getTotalStoppedValidatorCount();\n    }\n\n    /// @inheritdoc IOperatorsRegistryV1\n    function getTotalValidatorExitsRequested() external view returns (uint256) {\n        return TotalValidatorExitsRequested.get();\n    }\n\n    /// @inheritdoc IOperatorsRegistryV1\n    function getCurrentValidatorExitsDemand() external view returns (uint256) {\n        return CurrentValidatorExitsDemand.get();\n    }\n\n    /// @inheritdoc IOperatorsRegistryV1\n    function getStoppedAndRequestedExitCounts() external view returns (uint32, uint256) {\n        return\n            (_getTotalStoppedValidatorCount(), TotalValidatorExitsRequested.get() + CurrentValidatorExitsDemand.get());\n    }\n\n    /// @inheritdoc IOperatorsRegistryV1\n    function getOperatorCount() external view returns (uint256) {\n        return OperatorsV2.getCount();\n    }\n\n    /// @inheritdoc IOperatorsRegistryV1\n    function getStoppedValidatorCountPerOperator() external view returns (uint32[] memory) {\n        uint32[] memory completeList = OperatorsV2.getStoppedValidators();\n        uint256 listLength = completeList.length;\n\n        if (listLength > 0) {\n            assembly {\n                // no need to use free memory pointer as we reuse the same memory range\n\n                // erase previous word storing length\n                mstore(completeList, 0)\n\n                // move memory pointer up by a word\n                completeList := add(completeList, 0x20)\n\n                // store updated length at new memory pointer location\n                mstore(completeList, sub(listLength, 1))\n            }\n        }\n\n        return completeList;\n    }\n\n    /// @inheritdoc IOperatorsRegistryV1\n    function getValidator(uint256 _operatorIndex, uint256 _validatorIndex)\n        external\n        view\n        returns (bytes memory publicKey, bytes memory signature, bool funded)\n    {\n        (publicKey, signature) = ValidatorKeys.get(_operatorIndex, _validatorIndex);\n        funded = _validatorIndex < OperatorsV2.get(_operatorIndex).funded;\n    }\n\n    /// @inheritdoc IOperatorsRegistryV1\n    function getNextValidatorsToDepositFromActiveOperators(uint256 _count)\n        external\n        view\n        returns (bytes[] memory publicKeys, bytes[] memory signatures)\n    {\n        (OperatorsV2.CachedOperator[] memory operators, uint256 fundableOperatorCount) = OperatorsV2.getAllFundable();\n\n        if (fundableOperatorCount == 0) {\n            return (publicKeys, signatures);\n        }\n\n        _updateCountOfPickedValidatorsForEachOperator(operators, fundableOperatorCount, _count);\n\n        // we loop on all operators\n        for (uint256 idx = 0; idx < fundableOperatorCount; ++idx) {\n            // if we picked keys on any operator, we extract the keys from storage and concatenate them in the result\n            // we then update the funded value\n            if (operators[idx].picked > 0) {\n                (bytes[] memory _publicKeys, bytes[] memory _signatures) =\n                    ValidatorKeys.getKeys(operators[idx].index, operators[idx].funded, operators[idx].picked);\n                publicKeys = _concatenateByteArrays(publicKeys, _publicKeys);\n                signatures = _concatenateByteArrays(signatures, _signatures);\n            }\n        }\n    }\n\n    /// @inheritdoc IOperatorsRegistryV1\n    function listActiveOperators() external view returns (OperatorsV2.Operator[] memory) {\n        return OperatorsV2.getAllActive();\n    }\n\n    /// @inheritdoc IOperatorsRegistryV1\n    function reportStoppedValidatorCounts(uint32[] calldata _stoppedValidatorCounts, uint256 _depositedValidatorCount)\n        external\n        onlyRiver\n    {\n        _setStoppedValidatorCounts(_stoppedValidatorCounts, _depositedValidatorCount);\n    }\n\n    /// @inheritdoc IOperatorsRegistryV1\n    function addOperator(string calldata _name, address _operator) external onlyAdmin returns (uint256) {\n        OperatorsV2.Operator memory newOperator = OperatorsV2.Operator({\n            active: true,\n            operator: _operator,\n            name: _name,\n            limit: 0,\n            funded: 0,\n            keys: 0,\n            requestedExits: 0,\n            latestKeysEditBlockNumber: uint64(block.number)\n        });\n\n        uint256 operatorIndex = OperatorsV2.push(newOperator) - 1;\n\n        emit AddedOperator(operatorIndex, _name, _operator);\n        return operatorIndex;\n    }\n\n    /// @inheritdoc IOperatorsRegistryV1\n    function setOperatorAddress(uint256 _index, address _newOperatorAddress) external onlyOperatorOrAdmin(_index) {\n        LibSanitize._notZeroAddress(_newOperatorAddress);\n        OperatorsV2.Operator storage operator = OperatorsV2.get(_index);\n\n        operator.operator = _newOperatorAddress;\n\n        emit SetOperatorAddress(_index, _newOperatorAddress);\n    }\n\n    /// @inheritdoc IOperatorsRegistryV1\n    function setOperatorName(uint256 _index, string calldata _newName) external onlyOperatorOrAdmin(_index) {\n        LibSanitize._notEmptyString(_newName);\n        OperatorsV2.Operator storage operator = OperatorsV2.get(_index);\n        operator.name = _newName;\n\n        emit SetOperatorName(_index, _newName);\n    }\n\n    /// @inheritdoc IOperatorsRegistryV1\n    function setOperatorStatus(uint256 _index, bool _newStatus) external onlyAdmin {\n        OperatorsV2.Operator storage operator = OperatorsV2.get(_index);\n        operator.active = _newStatus;\n\n        emit SetOperatorStatus(_index, _newStatus);\n    }\n\n    /// @inheritdoc IOperatorsRegistryV1\n    function setOperatorLimits(\n        uint256[] calldata _operatorIndexes,\n        uint32[] calldata _newLimits,\n        uint256 _snapshotBlock\n    ) external onlyAdmin {\n        uint256 _operatorIndexesLength = _operatorIndexes.length;\n        if (_operatorIndexesLength != _newLimits.length) {\n            revert InvalidArrayLengths();\n        }\n        if (_operatorIndexesLength == 0) {\n            revert InvalidEmptyArray();\n        }\n        for (uint256 idx = 0; idx < _operatorIndexesLength;) {\n            uint256 operatorIndex = _operatorIndexes[idx];\n            uint32 newLimit = _newLimits[idx];\n\n            // prevents duplicates\n            if (idx > 0 && !(operatorIndex > _operatorIndexes[idx - 1])) {\n                revert UnorderedOperatorList();\n            }\n\n            OperatorsV2.Operator storage operator = OperatorsV2.get(operatorIndex);\n\n            uint32 currentLimit = operator.limit;\n            if (newLimit == currentLimit) {\n                emit OperatorLimitUnchanged(operatorIndex, newLimit);\n                unchecked {\n                    ++idx;\n                }\n                continue;\n            }\n\n            // we enter this condition if the operator edited its keys after the off-chain key audit was made\n            // we will skip any limit update on that operator unless it was a decrease in the initial limit\n            if (_snapshotBlock < operator.latestKeysEditBlockNumber && newLimit > currentLimit) {\n                emit OperatorEditsAfterSnapshot(\n                    operatorIndex, currentLimit, newLimit, operator.latestKeysEditBlockNumber, _snapshotBlock\n                );\n                unchecked {\n                    ++idx;\n                }\n                continue;\n            }\n\n            // otherwise, we check for limit invariants that shouldn't happen if the off-chain key audit\n            // was made properly, and if everything is respected, we update the limit\n\n            if (newLimit > operator.keys) {\n                revert OperatorLimitTooHigh(operatorIndex, newLimit, operator.keys);\n            }\n\n            if (newLimit < operator.funded) {\n                revert OperatorLimitTooLow(operatorIndex, newLimit, operator.funded);\n            }\n\n            operator.limit = newLimit;\n            emit SetOperatorLimit(operatorIndex, newLimit);\n\n            unchecked {\n                ++idx;\n            }\n        }\n    }\n\n    /// @inheritdoc IOperatorsRegistryV1\n    function addValidators(uint256 _index, uint32 _keyCount, bytes calldata _publicKeysAndSignatures)\n        external\n        onlyOperatorOrAdmin(_index)\n    {\n        if (_keyCount == 0) {\n            revert InvalidKeyCount();\n        }\n\n        if (\n            _publicKeysAndSignatures.length\n                != _keyCount * (ValidatorKeys.PUBLIC_KEY_LENGTH + ValidatorKeys.SIGNATURE_LENGTH)\n        ) {\n            revert InvalidKeysLength();\n        }\n\n        OperatorsV2.Operator storage operator = OperatorsV2.get(_index);\n        uint256 totalKeys = uint256(operator.keys);\n        for (uint256 idx = 0; idx < _keyCount;) {\n            bytes memory publicKeyAndSignature = LibBytes.slice(\n                _publicKeysAndSignatures,\n                idx * (ValidatorKeys.PUBLIC_KEY_LENGTH + ValidatorKeys.SIGNATURE_LENGTH),\n                ValidatorKeys.PUBLIC_KEY_LENGTH + ValidatorKeys.SIGNATURE_LENGTH\n            );\n            ValidatorKeys.set(_index, totalKeys + idx, publicKeyAndSignature);\n            unchecked {\n                ++idx;\n            }\n        }\n        OperatorsV2.setKeys(_index, uint32(totalKeys) + _keyCount);\n\n        emit AddedValidatorKeys(_index, _publicKeysAndSignatures);\n    }\n\n    /// @inheritdoc IOperatorsRegistryV1\n    function removeValidators(uint256 _index, uint256[] calldata _indexes) external onlyOperatorOrAdmin(_index) {\n        uint256 indexesLength = _indexes.length;\n        if (indexesLength == 0) {\n            revert InvalidKeyCount();\n        }\n\n        OperatorsV2.Operator storage operator = OperatorsV2.get(_index);\n\n        uint32 totalKeys = operator.keys;\n\n        if (!(_indexes[0] < totalKeys)) {\n            revert InvalidIndexOutOfBounds();\n        }\n\n        uint256 lastIndex = _indexes[indexesLength - 1];\n\n        if (lastIndex < operator.funded) {\n            revert InvalidFundedKeyDeletionAttempt();\n        }\n\n        bool limitEqualsKeyCount = totalKeys == operator.limit;\n        OperatorsV2.setKeys(_index, totalKeys - uint32(indexesLength));\n\n        uint256 idx;\n        for (; idx < indexesLength;) {\n            uint256 keyIndex = _indexes[idx];\n\n            if (idx > 0 && !(keyIndex < _indexes[idx - 1])) {\n                revert InvalidUnsortedIndexes();\n            }\n\n            unchecked {\n                ++idx;\n            }\n\n            uint256 lastKeyIndex = totalKeys - idx;\n\n            (bytes memory removedPublicKey,) = ValidatorKeys.get(_index, keyIndex);\n            (bytes memory lastPublicKeyAndSignature) = ValidatorKeys.getRaw(_index, lastKeyIndex);\n            ValidatorKeys.set(_index, keyIndex, lastPublicKeyAndSignature);\n            ValidatorKeys.set(_index, lastKeyIndex, new bytes(0));\n\n            emit RemovedValidatorKey(_index, removedPublicKey);\n        }\n\n        if (limitEqualsKeyCount) {\n            operator.limit = operator.keys;\n        } else if (lastIndex < operator.limit) {\n            operator.limit = uint32(lastIndex);\n        }\n    }\n\n    /// @inheritdoc IOperatorsRegistryV1\n    function pickNextValidatorsToDeposit(uint256 _count)\n        external\n        onlyRiver\n        returns (bytes[] memory publicKeys, bytes[] memory signatures)\n    {\n        return _pickNextValidatorsToDepositFromActiveOperators(_count);\n    }\n\n    /// @inheritdoc IOperatorsRegistryV1\n    function requestValidatorExits(uint256 _count) external {\n        uint256 currentValidatorExitsDemand = CurrentValidatorExitsDemand.get();\n        uint256 exitRequestsToPerform = LibUint256.min(currentValidatorExitsDemand, _count);\n        if (exitRequestsToPerform == 0) {\n            revert NoExitRequestsToPerform();\n        }\n        uint256 savedCurrentValidatorExitsDemand = currentValidatorExitsDemand;\n        currentValidatorExitsDemand -= _pickNextValidatorsToExitFromActiveOperators(exitRequestsToPerform);\n\n        _setCurrentValidatorExitsDemand(savedCurrentValidatorExitsDemand, currentValidatorExitsDemand);\n    }\n\n    /// @inheritdoc IOperatorsRegistryV1\n    function demandValidatorExits(uint256 _count, uint256 _depositedValidatorCount) external onlyRiver {\n        uint256 currentValidatorExitsDemand = CurrentValidatorExitsDemand.get();\n        uint256 totalValidatorExitsRequested = TotalValidatorExitsRequested.get();\n        _count = LibUint256.min(\n            _count, _depositedValidatorCount - (totalValidatorExitsRequested + currentValidatorExitsDemand)\n        );\n        if (_count > 0) {\n            _setCurrentValidatorExitsDemand(currentValidatorExitsDemand, currentValidatorExitsDemand + _count);\n        }\n    }\n\n    /// @notice Internal utility to retrieve the total stopped validator count\n    /// @return The total stopped validator count\n    function _getTotalStoppedValidatorCount() internal view returns (uint32) {\n        uint32[] storage stoppedValidatorCounts = OperatorsV2.getStoppedValidators();\n        if (stoppedValidatorCounts.length == 0) {\n            return 0;\n        }\n        return stoppedValidatorCounts[0];\n    }\n\n    /// @notice Internal utility to set the current validator exits demand\n    /// @param _currentValue The current value\n    /// @param _newValue The new value\n    function _setCurrentValidatorExitsDemand(uint256 _currentValue, uint256 _newValue) internal {\n        CurrentValidatorExitsDemand.set(_newValue);\n        emit SetCurrentValidatorExitsDemand(_currentValue, _newValue);\n    }\n\n    /// @notice Internal structure to hold variables for the _setStoppedValidatorCounts method\n    struct SetStoppedValidatorCountInternalVars {\n        uint256 stoppedValidatorCountsLength;\n        uint32[] currentStoppedValidatorCounts;\n        uint256 currentStoppedValidatorCountsLength;\n        uint32 totalStoppedValidatorCount;\n        uint32 count;\n        uint256 currentValidatorExitsDemand;\n        uint256 cachedCurrentValidatorExitsDemand;\n        uint256 totalRequestedExits;\n        uint256 cachedTotalRequestedExits;\n    }\n\n    /// @notice Internal utiltiy to set the stopped validator array after sanity checks\n    /// @param _stoppedValidatorCounts The stopped validators counts for every operator + the total count in index 0\n    /// @param _depositedValidatorCount The current deposited validator count\n    function _setStoppedValidatorCounts(uint32[] calldata _stoppedValidatorCounts, uint256 _depositedValidatorCount)\n        internal\n    {\n        SetStoppedValidatorCountInternalVars memory vars;\n        // we check that the array is not empty\n        vars.stoppedValidatorCountsLength = _stoppedValidatorCounts.length;\n        if (vars.stoppedValidatorCountsLength == 0) {\n            revert InvalidEmptyStoppedValidatorCountsArray();\n        }\n\n        OperatorsV2.Operator[] storage operators = OperatorsV2.getAll();\n\n        // we check that the cells containing operator stopped values are no more than the current operator count\n        if (vars.stoppedValidatorCountsLength - 1 > operators.length) {\n            revert StoppedValidatorCountsTooHigh();\n        }\n\n        vars.currentStoppedValidatorCounts = OperatorsV2.getStoppedValidators();\n        vars.currentStoppedValidatorCountsLength = vars.currentStoppedValidatorCounts.length;\n\n        // we check that the number of stopped values is not decreasing\n        if (vars.stoppedValidatorCountsLength < vars.currentStoppedValidatorCountsLength) {\n            revert StoppedValidatorCountArrayShrinking();\n        }\n\n        vars.totalStoppedValidatorCount = _stoppedValidatorCounts[0];\n        vars.count = 0;\n\n        // create value to track unsollicited validator exits (e.g. to cover cases when Node Operator exit a validator without being requested to)\n        vars.currentValidatorExitsDemand = CurrentValidatorExitsDemand.get();\n        vars.cachedCurrentValidatorExitsDemand = vars.currentValidatorExitsDemand;\n        vars.totalRequestedExits = TotalValidatorExitsRequested.get();\n        vars.cachedTotalRequestedExits = vars.totalRequestedExits;\n\n        uint256 idx = 1;\n        uint256 unsollicitedExitsSum;\n        for (; idx < vars.currentStoppedValidatorCountsLength;) {\n            // if the previous array was long enough, we check that the values are not decreasing\n            if (_stoppedValidatorCounts[idx] < vars.currentStoppedValidatorCounts[idx]) {\n                revert StoppedValidatorCountsDecreased();\n            }\n\n            // we check that the count of stopped validators is not above the funded validator count of an operator\n            if (_stoppedValidatorCounts[idx] > operators[idx - 1].funded) {\n                revert StoppedValidatorCountAboveFundedCount(\n                    idx - 1, _stoppedValidatorCounts[idx], operators[idx - 1].funded\n                );\n            }\n\n            // if the stopped validator count is greater than its requested exit count, we update the requested exit count\n            if (_stoppedValidatorCounts[idx] > operators[idx - 1].requestedExits) {\n                emit UpdatedRequestedValidatorExitsUponStopped(\n                    idx - 1, operators[idx - 1].requestedExits, _stoppedValidatorCounts[idx]\n                );\n                unsollicitedExitsSum += _stoppedValidatorCounts[idx] - operators[idx - 1].requestedExits;\n                operators[idx - 1].requestedExits = _stoppedValidatorCounts[idx];\n            }\n            emit SetOperatorStoppedValidatorCount(idx - 1, _stoppedValidatorCounts[idx]);\n\n            // we recompute the total to ensure it's not an invalid sum\n            vars.count += _stoppedValidatorCounts[idx];\n            unchecked {\n                ++idx;\n            }\n        }\n\n        // In case of a new operator we do not check against the current stopped validator count (would revert OOB)\n        for (; idx < vars.stoppedValidatorCountsLength;) {\n            // we check that the count of stopped validators is not above the funded validator count of an operator\n            if (_stoppedValidatorCounts[idx] > operators[idx - 1].funded) {\n                revert StoppedValidatorCountAboveFundedCount(\n                    idx - 1, _stoppedValidatorCounts[idx], operators[idx - 1].funded\n                );\n            }\n\n            // if the stopped validator count is greater than its requested exit count, we update the requested exit count\n            if (_stoppedValidatorCounts[idx] > operators[idx - 1].requestedExits) {\n                emit UpdatedRequestedValidatorExitsUponStopped(\n                    idx - 1, operators[idx - 1].requestedExits, _stoppedValidatorCounts[idx]\n                );\n                unsollicitedExitsSum += _stoppedValidatorCounts[idx] - operators[idx - 1].requestedExits;\n                operators[idx - 1].requestedExits = _stoppedValidatorCounts[idx];\n            }\n            emit SetOperatorStoppedValidatorCount(idx - 1, _stoppedValidatorCounts[idx]);\n\n            // we recompute the total to ensure it's not an invalid sum\n            vars.count += _stoppedValidatorCounts[idx];\n            unchecked {\n                ++idx;\n            }\n        }\n\n        vars.totalRequestedExits += unsollicitedExitsSum;\n        // we decrease the demand, considering unsollicited exits as if they were answering the demand\n        vars.currentValidatorExitsDemand -= LibUint256.min(unsollicitedExitsSum, vars.currentValidatorExitsDemand);\n\n        if (vars.totalRequestedExits != vars.cachedTotalRequestedExits) {\n            _setTotalValidatorExitsRequested(vars.cachedTotalRequestedExits, vars.totalRequestedExits);\n        }\n\n        if (vars.currentValidatorExitsDemand != vars.cachedCurrentValidatorExitsDemand) {\n            _setCurrentValidatorExitsDemand(vars.cachedCurrentValidatorExitsDemand, vars.currentValidatorExitsDemand);\n        }\n\n        // we check that the total is matching the sum of the individual values\n        if (vars.totalStoppedValidatorCount != vars.count) {\n            revert InvalidStoppedValidatorCountsSum();\n        }\n        // we check that the total is not higher than the current deposited validator count\n        if (vars.totalStoppedValidatorCount > _depositedValidatorCount) {\n            revert StoppedValidatorCountsTooHigh();\n        }\n        // we set the new stopped validators counts\n        OperatorsV2.setRawStoppedValidators(_stoppedValidatorCounts);\n        emit UpdatedStoppedValidators(_stoppedValidatorCounts);\n    }\n\n    /// @notice Internal utility to concatenate bytes arrays together\n    /// @param _arr1 First array\n    /// @param _arr2 Second array\n    /// @return The result of the concatenation of _arr1 + _arr2\n    function _concatenateByteArrays(bytes[] memory _arr1, bytes[] memory _arr2)\n        internal\n        pure\n        returns (bytes[] memory)\n    {\n        bytes[] memory res = new bytes[](_arr1.length + _arr2.length);\n        for (uint256 idx = 0; idx < _arr1.length;) {\n            res[idx] = _arr1[idx];\n            unchecked {\n                ++idx;\n            }\n        }\n        for (uint256 idx = 0; idx < _arr2.length;) {\n            res[idx + _arr1.length] = _arr2[idx];\n            unchecked {\n                ++idx;\n            }\n        }\n        return res;\n    }\n\n    /// @notice Internal utility to verify if an operator has fundable keys during the selection process\n    /// @param _operator The Operator structure in memory\n    /// @return True if at least one fundable key is available\n    function _hasFundableKeys(OperatorsV2.CachedOperator memory _operator) internal pure returns (bool) {\n        return (_operator.funded + _operator.picked) < _operator.limit;\n    }\n\n    /// @notice Internal utility to retrieve the actual stopped validator count of an operator from the reported array\n    /// @param _operatorIndex The operator index\n    /// @return The count of stopped validators\n    function _getStoppedValidatorsCount(uint256 _operatorIndex) internal view returns (uint32) {\n        return OperatorsV2._getStoppedValidatorCountAtIndex(OperatorsV2.getStoppedValidators(), _operatorIndex);\n    }\n\n    /// @notice Internal utility to get the count of active validators during the deposit selection process\n    /// @param _operator The Operator structure in memory\n    /// @return The count of active validators for the operator\n    function _getActiveValidatorCountForDeposits(OperatorsV2.CachedOperator memory _operator)\n        internal\n        view\n        returns (uint256)\n    {\n        return (_operator.funded + _operator.picked) - _getStoppedValidatorsCount(_operator.index);\n    }\n\n    /// @notice Internal utility to retrieve _count or lower fundable keys\n    /// @dev The selection process starts by retrieving the full list of active operators with at least one fundable key.\n    /// @dev\n    /// @dev An operator is considered to have at least one fundable key when their staking limit is higher than their funded key count.\n    /// @dev\n    /// @dev    isFundable = operator.active && operator.limit > operator.funded\n    /// @dev\n    /// @dev The internal utility will loop on all operators and select the operator with the lowest active validator count.\n    /// @dev The active validator count is computed by subtracting the stopped validator count to the funded validator count.\n    /// @dev\n    /// @dev    activeValidatorCount = operator.funded - operator.stopped\n    /// @dev\n    /// @dev During the selection process, we keep in memory all previously selected operators and the number of given validators inside a field\n    /// @dev called picked that only exists on the CachedOperator structure in memory.\n    /// @dev\n    /// @dev    isFundable = operator.active && operator.limit > (operator.funded + operator.picked)\n    /// @dev    activeValidatorCount = (operator.funded + operator.picked) - operator.stopped\n    /// @dev\n    /// @dev When we reach the requested key count or when all available keys are used, we perform a final loop on all the operators and extract keys\n    /// @dev if any operator has a positive picked count. We then update the storage counters and return the arrays with the public keys and signatures.\n    /// @param _count Amount of keys required. Contract is expected to send _count or lower.\n    /// @return publicKeys An array of fundable public keys\n    /// @return signatures An array of signatures linked to the public keys\n    function _pickNextValidatorsToDepositFromActiveOperators(uint256 _count)\n        internal\n        returns (bytes[] memory publicKeys, bytes[] memory signatures)\n    {\n        (OperatorsV2.CachedOperator[] memory operators, uint256 fundableOperatorCount) = OperatorsV2.getAllFundable();\n\n        if (fundableOperatorCount == 0) {\n            return (new bytes[](0), new bytes[](0));\n        }\n\n        _updateCountOfPickedValidatorsForEachOperator(operators, fundableOperatorCount, _count);\n\n        // we loop on all operators\n        for (uint256 idx = 0; idx < fundableOperatorCount; ++idx) {\n            // if we picked keys on any operator, we extract the keys from storage and concatenate them in the result\n            // we then update the funded value\n            if (operators[idx].picked > 0) {\n                (bytes[] memory _publicKeys, bytes[] memory _signatures) =\n                    ValidatorKeys.getKeys(operators[idx].index, operators[idx].funded, operators[idx].picked);\n                emit FundedValidatorKeys(operators[idx].index, _publicKeys, false);\n                publicKeys = _concatenateByteArrays(publicKeys, _publicKeys);\n                signatures = _concatenateByteArrays(signatures, _signatures);\n                (OperatorsV2.get(operators[idx].index)).funded += operators[idx].picked;\n            }\n        }\n    }\n\n    function _updateCountOfPickedValidatorsForEachOperator(\n        OperatorsV2.CachedOperator[] memory operators,\n        uint256 fundableOperatorCount,\n        uint256 _count\n    ) internal view {\n        while (_count > 0) {\n            // loop on operators to find the first that has fundable keys, taking into account previous loop round attributions\n            uint256 selectedOperatorIndex = 0;\n            for (; selectedOperatorIndex < fundableOperatorCount;) {\n                if (_hasFundableKeys(operators[selectedOperatorIndex])) {\n                    break;\n                }\n                unchecked {\n                    ++selectedOperatorIndex;\n                }\n            }\n\n            // if we reach the end, we have allocated all keys\n            if (selectedOperatorIndex == fundableOperatorCount) {\n                break;\n            }\n\n            // we start from the next operator and we try to find one that has fundable keys but a lower (funded + picked) - stopped value\n            for (uint256 idx = selectedOperatorIndex + 1; idx < fundableOperatorCount;) {\n                if (\n                    _getActiveValidatorCountForDeposits(operators[idx])\n                        < _getActiveValidatorCountForDeposits(operators[selectedOperatorIndex])\n                        && _hasFundableKeys(operators[idx])\n                ) {\n                    selectedOperatorIndex = idx;\n                }\n                unchecked {\n                    ++idx;\n                }\n            }\n\n            // we take the smallest value between limit - (funded + picked), _requestedAmount and MAX_VALIDATOR_ATTRIBUTION_PER_ROUND\n            uint256 pickedKeyCount = LibUint256.min(\n                LibUint256.min(\n                    operators[selectedOperatorIndex].limit\n                        - (operators[selectedOperatorIndex].funded + operators[selectedOperatorIndex].picked),\n                    MAX_VALIDATOR_ATTRIBUTION_PER_ROUND\n                ),\n                _count\n            );\n\n            // we update the cached picked amount\n            operators[selectedOperatorIndex].picked += uint32(pickedKeyCount);\n\n            // we update the requested amount count\n            _count -= pickedKeyCount;\n        }\n    }\n\n    /// @notice Internal utility to get the count of active validators during the exit selection process\n    /// @param _operator The Operator structure in memory\n    /// @return The count of active validators for the operator\n    function _getActiveValidatorCountForExitRequests(OperatorsV2.CachedExitableOperator memory _operator)\n        internal\n        pure\n        returns (uint32)\n    {\n        return _operator.funded - (_operator.requestedExits + _operator.picked);\n    }\n\n    /// @notice Internal utility to pick the next validator counts to exit for every operator\n    /// @param _count The count of validators to request exits for\n    function _pickNextValidatorsToExitFromActiveOperators(uint256 _count) internal returns (uint256) {\n        (OperatorsV2.CachedExitableOperator[] memory operators, uint256 exitableOperatorCount) =\n            OperatorsV2.getAllExitable();\n\n        if (exitableOperatorCount == 0) {\n            return 0;\n        }\n\n        uint256 initialExitRequestDemand = _count;\n        uint256 totalRequestedExitsValue = TotalValidatorExitsRequested.get();\n        uint256 totalRequestedExitsCopy = totalRequestedExitsValue;\n\n        // we loop to find the highest count of active validators, the number of operators that have this amount and the second highest amount\n        while (_count > 0) {\n            uint32 highestActiveCount = 0;\n            uint32 secondHighestActiveCount = 0;\n            uint32 siblings = 0;\n\n            for (uint256 idx = 0; idx < exitableOperatorCount;) {\n                uint32 activeCount = _getActiveValidatorCountForExitRequests(operators[idx]);\n\n                if (activeCount == highestActiveCount) {\n                    unchecked {\n                        ++siblings;\n                    }\n                } else if (activeCount > highestActiveCount) {\n                    secondHighestActiveCount = highestActiveCount;\n                    highestActiveCount = activeCount;\n                    siblings = 1;\n                } else if (activeCount > secondHighestActiveCount) {\n                    secondHighestActiveCount = activeCount;\n                }\n\n                unchecked {\n                    ++idx;\n                }\n            }\n\n            // we exited all exitable validators\n            if (highestActiveCount == 0) {\n                break;\n            }\n            // The optimal amount is how much we should dispatch to all the operators with the highest count for them to get the same amount\n            // of active validators as the second highest count. We then take the minimum between this value and the total we need to exit\n            uint32 optimalTotalDispatchCount =\n                uint32(LibUint256.min((highestActiveCount - secondHighestActiveCount) * siblings, _count));\n\n            // We lookup the operators again to assign the exit requests\n            uint256 rest = optimalTotalDispatchCount % siblings;\n            uint32 baseExitRequestAmount = optimalTotalDispatchCount / siblings;\n            for (uint256 idx = 0; idx < exitableOperatorCount;) {\n                if (_getActiveValidatorCountForExitRequests(operators[idx]) == highestActiveCount) {\n                    uint32 additionalRequestedExits = baseExitRequestAmount + (rest > 0 ? 1 : 0);\n                    operators[idx].picked += additionalRequestedExits;\n                    if (rest > 0) {\n                        unchecked {\n                            --rest;\n                        }\n                    }\n                }\n                unchecked {\n                    ++idx;\n                }\n            }\n\n            totalRequestedExitsValue += optimalTotalDispatchCount;\n            _count -= optimalTotalDispatchCount;\n        }\n\n        // We loop over the operators and apply the change, also emit the exit request event\n        for (uint256 idx = 0; idx < exitableOperatorCount;) {\n            if (operators[idx].picked > 0) {\n                uint256 opIndex = operators[idx].index;\n                uint32 newRequestedExits = operators[idx].requestedExits + operators[idx].picked;\n\n                OperatorsV2.get(opIndex).requestedExits = newRequestedExits;\n                emit RequestedValidatorExits(opIndex, newRequestedExits);\n            }\n\n            unchecked {\n                ++idx;\n            }\n        }\n\n        if (totalRequestedExitsValue != totalRequestedExitsCopy) {\n            _setTotalValidatorExitsRequested(totalRequestedExitsCopy, totalRequestedExitsValue);\n        }\n\n        return initialExitRequestDemand - _count;\n    }\n\n    /// @notice Internal utility to set the total validator exits requested by the system\n    /// @param _currentValue The current value of the total validator exits requested\n    /// @param _newValue The new value of the total validator exits requested\n    function _setTotalValidatorExitsRequested(uint256 _currentValue, uint256 _newValue) internal {\n        TotalValidatorExitsRequested.set(_newValue);\n        emit SetTotalValidatorExitsRequested(_currentValue, _newValue);\n    }\n\n    /// @inheritdoc IProtocolVersion\n    function version() external pure returns (string memory) {\n        return \"1.2.1\";\n    }\n}\n"
    },
    "contracts/src/state/migration/OperatorsRegistry_FundedKeyEventRebroadcasting_KeyIndex.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\n\nlibrary OperatorsRegistry_FundedKeyEventRebroadcasting_KeyIndex {\n    bytes32 internal constant KEY_INDEX_SLOT =\n        bytes32(uint256(keccak256(\"river.state.migration.operatorsRegistry.fundedKeyEventRebroadcasting.keyIndex\")) - 1);\n\n    function get() internal view returns (uint256) {\n        return LibUnstructuredStorage.getStorageUint256(KEY_INDEX_SLOT);\n    }\n\n    function set(uint256 _newValue) internal {\n        LibUnstructuredStorage.setStorageUint256(KEY_INDEX_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/migration/OperatorsRegistry_FundedKeyEventRebroadcasting_OperatorIndex.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\n\nlibrary OperatorsRegistry_FundedKeyEventRebroadcasting_OperatorIndex {\n    bytes32 internal constant OPERATOR_INDEX_SLOT = bytes32(\n        uint256(keccak256(\"river.state.migration.operatorsRegistry.fundedKeyEventRebroadcasting.operatorIndex\")) - 1\n    );\n\n    function get() internal view returns (uint256) {\n        return LibUnstructuredStorage.getStorageUint256(OPERATOR_INDEX_SLOT);\n    }\n\n    function set(uint256 _newValue) internal {\n        LibUnstructuredStorage.setStorageUint256(OPERATOR_INDEX_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/operatorsRegistry/CurrentValidatorExitsDemand.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\n\n/// @title CurrentValidatorExitsDemand Storage\n/// @notice This value controls the current demand for exits that still need to be triggered\n/// @notice in order to notify the operators\n/// @notice Utility to manage the CurrentValidatorExitsDemand in storage\nlibrary CurrentValidatorExitsDemand {\n    /// @notice Storage slot of the CurrentValidatorExitsDemand\n    bytes32 internal constant CURRENT_VALIDATOR_EXITS_DEMAND_SLOT =\n        bytes32(uint256(keccak256(\"river.state.currentValidatorExitsDemand\")) - 1);\n\n    /// @notice Retrieve the CurrentValidatorExitsDemand\n    /// @return The CurrentValidatorExitsDemand\n    function get() internal view returns (uint256) {\n        return LibUnstructuredStorage.getStorageUint256(CURRENT_VALIDATOR_EXITS_DEMAND_SLOT);\n    }\n\n    /// @notice Sets the CurrentValidatorExitsDemand\n    /// @param _newValue New CurrentValidatorExitsDemand\n    function set(uint256 _newValue) internal {\n        return LibUnstructuredStorage.setStorageUint256(CURRENT_VALIDATOR_EXITS_DEMAND_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/operatorsRegistry/Operators.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\nimport \"../../libraries/LibSanitize.sol\";\n\n/// @title Operators Storage\n/// @notice Utility to manage the Operators in storage\n/// @notice This state variable is deprecated and was kept due to migration logic needs\nlibrary OperatorsV1 {\n    /// @notice Storage slot of the Operators\n    bytes32 internal constant OPERATORS_SLOT = bytes32(uint256(keccak256(\"river.state.operators\")) - 1);\n\n    /// @notice The Operator structure in storage\n    struct Operator {\n        /// @custom:attribute True if the operator is active and allowed to operate on River\n        bool active;\n        /// @custom:attribute Display name of the operator\n        string name;\n        /// @custom:attribute Address of the operator\n        address operator;\n        /// @dev The following values respect this invariant:\n        /// @dev     keys >= limit >= funded >= stopped\n\n        /// @custom:attribute Staking limit of the operator\n        uint256 limit;\n        /// @custom:attribute The count of funded validators\n        uint256 funded;\n        /// @custom:attribute The total count of keys of the operator\n        uint256 keys;\n        /// @custom:attribute The count of stopped validators. Stopped validators are validators\n        ///                   that exited the consensus layer (voluntary or slashed)\n        uint256 stopped;\n        uint256 latestKeysEditBlockNumber;\n    }\n\n    /// @notice The Operator structure when loaded in memory\n    struct CachedOperator {\n        /// @custom:attribute True if the operator is active and allowed to operate on River\n        bool active;\n        /// @custom:attribute Display name of the operator\n        string name;\n        /// @custom:attribute Address of the operator\n        address operator;\n        /// @custom:attribute Staking limit of the operator\n        uint256 limit;\n        /// @custom:attribute The count of funded validators\n        uint256 funded;\n        /// @custom:attribute The total count of keys of the operator\n        uint256 keys;\n        /// @custom:attribute The count of stopped validators\n        uint256 stopped;\n        /// @custom:attribute The count of stopped validators. Stopped validators are validators\n        ///                   that exited the consensus layer (voluntary or slashed)\n        uint256 index;\n        /// @custom:attribute The amount of picked keys, buffer used before changing funded in storage\n        uint256 picked;\n    }\n\n    /// @notice The structure at the storage slot\n    struct SlotOperator {\n        /// @custom:attribute Array containing all the operators\n        Operator[] value;\n    }\n\n    /// @notice The operator was not found\n    /// @param index The provided index\n    error OperatorNotFound(uint256 index);\n\n    /// @notice Retrieve the operator in storage\n    /// @param _index The index of the operator\n    /// @return The Operator structure\n    function get(uint256 _index) internal view returns (Operator storage) {\n        bytes32 slot = OPERATORS_SLOT;\n\n        SlotOperator storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        if (r.value.length <= _index) {\n            revert OperatorNotFound(_index);\n        }\n\n        return r.value[_index];\n    }\n\n    /// @notice Retrieve the operator count in storage\n    /// @return The count of operators in storage\n    function getCount() internal view returns (uint256) {\n        bytes32 slot = OPERATORS_SLOT;\n\n        SlotOperator storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value.length;\n    }\n\n    /// @notice Retrieve all the active operators\n    /// @return The list of active operator structures\n    function getAllActive() internal view returns (Operator[] memory) {\n        bytes32 slot = OPERATORS_SLOT;\n\n        SlotOperator storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        uint256 activeCount = 0;\n        uint256 operatorCount = r.value.length;\n\n        for (uint256 idx = 0; idx < operatorCount;) {\n            if (r.value[idx].active) {\n                unchecked {\n                    ++activeCount;\n                }\n            }\n            unchecked {\n                ++idx;\n            }\n        }\n\n        Operator[] memory activeOperators = new Operator[](activeCount);\n\n        uint256 activeIdx = 0;\n        for (uint256 idx = 0; idx < operatorCount;) {\n            if (r.value[idx].active) {\n                activeOperators[activeIdx] = r.value[idx];\n                unchecked {\n                    ++activeIdx;\n                }\n            }\n            unchecked {\n                ++idx;\n            }\n        }\n\n        return activeOperators;\n    }\n\n    /// @notice Retrieve all the active and fundable operators\n    /// @return The list of active and fundable operators\n    function getAllFundable() internal view returns (CachedOperator[] memory) {\n        bytes32 slot = OPERATORS_SLOT;\n\n        SlotOperator storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        uint256 activeCount = 0;\n        uint256 operatorCount = r.value.length;\n\n        for (uint256 idx = 0; idx < operatorCount;) {\n            if (_hasFundableKeys(r.value[idx])) {\n                unchecked {\n                    ++activeCount;\n                }\n            }\n            unchecked {\n                ++idx;\n            }\n        }\n\n        CachedOperator[] memory activeOperators = new CachedOperator[](activeCount);\n\n        uint256 activeIdx = 0;\n        for (uint256 idx = 0; idx < operatorCount;) {\n            Operator memory op = r.value[idx];\n            if (_hasFundableKeys(op)) {\n                activeOperators[activeIdx] = CachedOperator({\n                    active: op.active,\n                    name: op.name,\n                    operator: op.operator,\n                    limit: op.limit,\n                    funded: op.funded,\n                    keys: op.keys,\n                    stopped: op.stopped,\n                    index: idx,\n                    picked: 0\n                });\n                unchecked {\n                    ++activeIdx;\n                }\n            }\n            unchecked {\n                ++idx;\n            }\n        }\n\n        return activeOperators;\n    }\n\n    /// @notice Add a new operator in storage\n    /// @param _newOperator Value of the new operator\n    /// @return The size of the operator array after the operation\n    function push(Operator memory _newOperator) internal returns (uint256) {\n        LibSanitize._notZeroAddress(_newOperator.operator);\n        LibSanitize._notEmptyString(_newOperator.name);\n        bytes32 slot = OPERATORS_SLOT;\n\n        SlotOperator storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        r.value.push(_newOperator);\n\n        return r.value.length;\n    }\n\n    /// @notice Atomic operation to set the key count and update the latestKeysEditBlockNumber field at the same time\n    /// @param _index The operator index\n    /// @param _newKeys The new value for the key count\n    function setKeys(uint256 _index, uint256 _newKeys) internal {\n        Operator storage op = get(_index);\n\n        op.keys = _newKeys;\n        op.latestKeysEditBlockNumber = block.number;\n    }\n\n    /// @notice Checks if an operator is active and has fundable keys\n    /// @param _operator The operator details\n    /// @return True if active and fundable\n    function _hasFundableKeys(OperatorsV1.Operator memory _operator) internal pure returns (bool) {\n        return (_operator.active && _operator.limit > _operator.funded);\n    }\n}\n"
    },
    "contracts/src/state/operatorsRegistry/Operators.2.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\nimport \"../../libraries/LibSanitize.sol\";\n\n/// @title Operators Storage\n/// @notice Utility to manage the Operators in storage\nlibrary OperatorsV2 {\n    /// @notice Storage slot of the Operators\n    bytes32 internal constant OPERATORS_SLOT = bytes32(uint256(keccak256(\"river.state.v2.operators\")) - 1);\n\n    /// @notice The Operator structure in storage\n    struct Operator {\n        /// @dev The following values respect this invariant:\n        /// @dev     keys >= limit >= funded >= RequestedExits\n\n        /// @custom:attribute Staking limit of the operator\n        uint32 limit;\n        /// @custom:attribute The count of funded validators\n        uint32 funded;\n        /// @custom:attribute The count of exit requests made to this operator\n        uint32 requestedExits;\n        /// @custom:attribute The total count of keys of the operator\n        uint32 keys;\n        /// @custom attribute The block at which the last edit happened in the operator details\n        uint64 latestKeysEditBlockNumber;\n        /// @custom:attribute True if the operator is active and allowed to operate on River\n        bool active;\n        /// @custom:attribute Display name of the operator\n        string name;\n        /// @custom:attribute Address of the operator\n        address operator;\n    }\n\n    /// @notice The Operator structure when loaded in memory\n    struct CachedOperator {\n        /// @custom:attribute Staking limit of the operator\n        uint32 limit;\n        /// @custom:attribute The count of funded validators\n        uint32 funded;\n        /// @custom:attribute The count of exit requests made to this operator\n        uint32 requestedExits;\n        /// @custom:attribute The original index of the operator\n        uint32 index;\n        /// @custom:attribute The amount of picked keys, buffer used before changing funded in storage\n        uint32 picked;\n    }\n\n    /// @notice The Operator structure when loaded in memory for the exit selection\n    struct CachedExitableOperator {\n        /// @custom:attribute The count of funded validators\n        uint32 funded;\n        /// @custom:attribute The count of exit requests made to this operator\n        uint32 requestedExits;\n        /// @custom:attribute The original index of the operator\n        uint32 index;\n        /// @custom:attribute The amount of picked keys, buffer used before changing funded in storage\n        uint32 picked;\n    }\n\n    /// @notice The structure at the storage slot\n    struct SlotOperator {\n        /// @custom:attribute Array containing all the operators\n        Operator[] value;\n    }\n\n    /// @notice The operator was not found\n    /// @param index The provided index\n    error OperatorNotFound(uint256 index);\n\n    /// @notice Retrieve the operator in storage\n    /// @param _index The index of the operator\n    /// @return The Operator structure\n    function get(uint256 _index) internal view returns (Operator storage) {\n        bytes32 slot = OPERATORS_SLOT;\n\n        SlotOperator storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        if (r.value.length <= _index) {\n            revert OperatorNotFound(_index);\n        }\n\n        return r.value[_index];\n    }\n\n    /// @notice Retrieve the operators in storage\n    /// @return The Operator structure array\n    function getAll() internal view returns (Operator[] storage) {\n        bytes32 slot = OPERATORS_SLOT;\n\n        SlotOperator storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value;\n    }\n\n    /// @notice Retrieve the operator count in storage\n    /// @return The count of operators in storage\n    function getCount() internal view returns (uint256) {\n        bytes32 slot = OPERATORS_SLOT;\n\n        SlotOperator storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value.length;\n    }\n\n    /// @notice Retrieve all the active operators\n    /// @return The list of active operator structures\n    function getAllActive() internal view returns (Operator[] memory) {\n        bytes32 slot = OPERATORS_SLOT;\n\n        SlotOperator storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        uint256 activeCount = 0;\n        uint256 operatorCount = r.value.length;\n        Operator[] memory activeOperators = new Operator[](operatorCount);\n\n        for (uint256 idx = 0; idx < operatorCount;) {\n            if (r.value[idx].active) {\n                activeOperators[activeCount] = r.value[idx];\n                unchecked {\n                    ++activeCount;\n                }\n            }\n            unchecked {\n                ++idx;\n            }\n        }\n        assembly (\"memory-safe\") {\n            mstore(activeOperators, activeCount)\n        }\n\n        return activeOperators;\n    }\n\n    /// @notice Retrieve the stopped validator count for an operator by its index\n    /// @param stoppedValidatorCounts The storage pointer to the raw array containing the stopped validator counts\n    /// @param index The index of the operator to lookup\n    /// @return The amount of stopped validators for the given operator index\n    function _getStoppedValidatorCountAtIndex(uint32[] storage stoppedValidatorCounts, uint256 index)\n        internal\n        view\n        returns (uint32)\n    {\n        if (index + 1 >= stoppedValidatorCounts.length) {\n            return 0;\n        }\n        return stoppedValidatorCounts[index + 1];\n    }\n\n    /// @notice Retrieve all the active and fundable operators\n    /// @dev This method will return a memory array of length equal to the number of operator, but only\n    /// @dev populated up to the fundable operator count, also returned by the method\n    /// @return The list of active and fundable operators\n    /// @return The count of active and fundable operators\n    function getAllFundable() internal view returns (CachedOperator[] memory, uint256) {\n        bytes32 slot = OPERATORS_SLOT;\n\n        SlotOperator storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        uint256 fundableCount = 0;\n        uint256 operatorCount = r.value.length;\n        CachedOperator[] memory fundableOperators = new CachedOperator[](operatorCount);\n\n        uint32[] storage stoppedValidatorCounts = getStoppedValidators();\n\n        for (uint256 idx = 0; idx < operatorCount;) {\n            if (\n                _hasFundableKeys(r.value[idx])\n                    && _getStoppedValidatorCountAtIndex(stoppedValidatorCounts, idx) >= r.value[idx].requestedExits\n            ) {\n                Operator storage op = r.value[idx];\n                fundableOperators[fundableCount] = CachedOperator({\n                    limit: op.limit,\n                    funded: op.funded,\n                    requestedExits: op.requestedExits,\n                    index: uint32(idx),\n                    picked: 0\n                });\n                unchecked {\n                    ++fundableCount;\n                }\n            }\n            unchecked {\n                ++idx;\n            }\n        }\n\n        assembly (\"memory-safe\") {\n            mstore(fundableOperators, fundableCount)\n        }\n\n        return (fundableOperators, fundableCount);\n    }\n\n    /// @notice Retrieve all the active and exitable operators\n    /// @dev This method will return a memory array of length equal to the number of operator, but only\n    /// @dev populated up to the exitable operator count, also returned by the method\n    /// @return The list of active and exitable operators\n    /// @return The count of active and exitable operators\n    function getAllExitable() internal view returns (CachedExitableOperator[] memory, uint256) {\n        bytes32 slot = OPERATORS_SLOT;\n\n        SlotOperator storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        uint256 exitableCount = 0;\n        uint256 operatorCount = r.value.length;\n\n        CachedExitableOperator[] memory exitableOperators = new CachedExitableOperator[](operatorCount);\n\n        for (uint256 idx = 0; idx < operatorCount;) {\n            if (_hasExitableKeys(r.value[idx])) {\n                Operator storage op = r.value[idx];\n                exitableOperators[exitableCount] = CachedExitableOperator({\n                    funded: op.funded,\n                    requestedExits: op.requestedExits,\n                    index: uint32(idx),\n                    picked: 0\n                });\n                unchecked {\n                    ++exitableCount;\n                }\n            }\n            unchecked {\n                ++idx;\n            }\n        }\n\n        assembly (\"memory-safe\") {\n            mstore(exitableOperators, exitableCount)\n        }\n\n        return (exitableOperators, exitableCount);\n    }\n\n    /// @notice Add a new operator in storage\n    /// @param _newOperator Value of the new operator\n    /// @return The size of the operator array after the operation\n    function push(Operator memory _newOperator) internal returns (uint256) {\n        LibSanitize._notZeroAddress(_newOperator.operator);\n        LibSanitize._notEmptyString(_newOperator.name);\n        bytes32 slot = OPERATORS_SLOT;\n\n        SlotOperator storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        r.value.push(_newOperator);\n\n        return r.value.length;\n    }\n\n    /// @notice Atomic operation to set the key count and update the latestKeysEditBlockNumber field at the same time\n    /// @param _index The operator index\n    /// @param _newKeys The new value for the key count\n    function setKeys(uint256 _index, uint32 _newKeys) internal {\n        Operator storage op = get(_index);\n\n        op.keys = _newKeys;\n        op.latestKeysEditBlockNumber = uint64(block.number);\n    }\n\n    /// @notice Checks if an operator is active and has fundable keys\n    /// @param _operator The operator details\n    /// @return True if active and fundable\n    function _hasFundableKeys(OperatorsV2.Operator memory _operator) internal pure returns (bool) {\n        return (_operator.active && _operator.limit > _operator.funded);\n    }\n\n    /// @notice Checks if an operator is active and has exitable keys\n    /// @param _operator The operator details\n    /// @return True if active and exitable\n    function _hasExitableKeys(OperatorsV2.Operator memory _operator) internal pure returns (bool) {\n        return (_operator.active && _operator.funded > _operator.requestedExits);\n    }\n\n    /// @notice Storage slot of the Stopped Validators\n    bytes32 internal constant STOPPED_VALIDATORS_SLOT = bytes32(uint256(keccak256(\"river.state.stoppedValidators\")) - 1);\n\n    struct SlotStoppedValidators {\n        uint32[] value;\n    }\n\n    /// @notice Retrieve the storage pointer of the Stopped Validators array\n    /// @return The Stopped Validators storage pointer\n    function getStoppedValidators() internal view returns (uint32[] storage) {\n        bytes32 slot = STOPPED_VALIDATORS_SLOT;\n\n        SlotStoppedValidators storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value;\n    }\n\n    /// @notice Sets the entire stopped validators array\n    /// @param value The new stopped validators array\n    function setRawStoppedValidators(uint32[] memory value) internal {\n        bytes32 slot = STOPPED_VALIDATORS_SLOT;\n\n        SlotStoppedValidators storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        r.value = value;\n    }\n}\n"
    },
    "contracts/src/state/operatorsRegistry/TotalValidatorExitsRequested.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\n\n/// @title TotalValidatorExitsRequested Storage\n/// @notice This value is the amount of performed exit requests, only increased when there is current exit demand\n/// @notice Utility to manage the TotalValidatorExitsRequested in storage\nlibrary TotalValidatorExitsRequested {\n    /// @notice Storage slot of the TotalValidatorExitsRequested\n    bytes32 internal constant TOTAL_VALIDATOR_EXITS_REQUESTED_SLOT =\n        bytes32(uint256(keccak256(\"river.state.totalValidatorExitsRequested\")) - 1);\n\n    /// @notice Retrieve the TotalValidatorExitsRequested\n    /// @return The TotalValidatorExitsRequested\n    function get() internal view returns (uint256) {\n        return LibUnstructuredStorage.getStorageUint256(TOTAL_VALIDATOR_EXITS_REQUESTED_SLOT);\n    }\n\n    /// @notice Sets the TotalValidatorExitsRequested\n    /// @param _newValue New TotalValidatorExitsRequested\n    function set(uint256 _newValue) internal {\n        return LibUnstructuredStorage.setStorageUint256(TOTAL_VALIDATOR_EXITS_REQUESTED_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/operatorsRegistry/ValidatorKeys.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\nimport \"../../libraries/LibBytes.sol\";\n\n/// @title Validator Keys Storage\n/// @notice Utility to manage the validator keys in storage\nlibrary ValidatorKeys {\n    /// @notice Storage slot of the Validator Keys\n    bytes32 internal constant VALIDATOR_KEYS_SLOT = bytes32(uint256(keccak256(\"river.state.validatorKeys\")) - 1);\n\n    /// @notice Length in bytes of a BLS Public Key used for validator deposits\n    uint256 internal constant PUBLIC_KEY_LENGTH = 48;\n\n    /// @notice Length in bytes of a BLS Signature used for validator deposits\n    uint256 internal constant SIGNATURE_LENGTH = 96;\n\n    /// @notice The provided public key is not matching the expected length\n    error InvalidPublicKey();\n\n    /// @notice The provided signature is not matching the expected length\n    error InvalidSignature();\n\n    /// @notice Structure of the Validator Keys in storage\n    struct Slot {\n        /// @custom:attribute The mapping from operator index to key index to key value\n        mapping(uint256 => mapping(uint256 => bytes)) value;\n    }\n\n    /// @notice Retrieve the Validator Key of an operator at a specific index\n    /// @param _operatorIndex The operator index\n    /// @param _idx the Validator Key index\n    /// @return publicKey The Validator Key public key\n    /// @return signature The Validator Key signature\n    function get(uint256 _operatorIndex, uint256 _idx)\n        internal\n        view\n        returns (bytes memory publicKey, bytes memory signature)\n    {\n        bytes32 slot = VALIDATOR_KEYS_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        bytes storage entry = r.value[_operatorIndex][_idx];\n\n        publicKey = LibBytes.slice(entry, 0, PUBLIC_KEY_LENGTH);\n        signature = LibBytes.slice(entry, PUBLIC_KEY_LENGTH, SIGNATURE_LENGTH);\n    }\n\n    /// @notice Retrieve the raw concatenated Validator Keys\n    /// @param _operatorIndex The operator index\n    /// @param _idx The Validator Key index\n    /// @return The concatenated public key and signature\n    function getRaw(uint256 _operatorIndex, uint256 _idx) internal view returns (bytes memory) {\n        bytes32 slot = VALIDATOR_KEYS_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value[_operatorIndex][_idx];\n    }\n\n    /// @notice Retrieve multiple keys of an operator starting at an index\n    /// @param _operatorIndex The operator index\n    /// @param _startIdx The starting index to retrieve the keys from\n    /// @param _amount The amount of keys to retrieve\n    /// @return publicKeys The public keys retrieved\n    /// @return signatures The signatures associated with the public keys\n    function getKeys(uint256 _operatorIndex, uint256 _startIdx, uint256 _amount)\n        internal\n        view\n        returns (bytes[] memory publicKeys, bytes[] memory signatures)\n    {\n        publicKeys = new bytes[](_amount);\n        signatures = new bytes[](_amount);\n\n        bytes32 slot = VALIDATOR_KEYS_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n        uint256 idx;\n        for (; idx < _amount;) {\n            bytes memory rawCredentials = r.value[_operatorIndex][idx + _startIdx];\n            publicKeys[idx] = LibBytes.slice(rawCredentials, 0, PUBLIC_KEY_LENGTH);\n            signatures[idx] = LibBytes.slice(rawCredentials, PUBLIC_KEY_LENGTH, SIGNATURE_LENGTH);\n            unchecked {\n                ++idx;\n            }\n        }\n    }\n\n    /// @notice Set the concatenated Validator Keys at an index for an operator\n    /// @param _operatorIndex The operator index\n    /// @param _idx The key index to write on\n    /// @param _publicKeyAndSignature The concatenated Validator Keys\n    function set(uint256 _operatorIndex, uint256 _idx, bytes memory _publicKeyAndSignature) internal {\n        bytes32 slot = VALIDATOR_KEYS_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        r.value[_operatorIndex][_idx] = _publicKeyAndSignature;\n    }\n}\n"
    },
    "contracts/src/state/river/CLSpec.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\n/// @title Consensus Layer Spec Storage\n/// @notice Utility to manage the Consensus Layer Spec in storage\nlibrary CLSpec {\n    /// @notice Storage slot of the Consensus Layer Spec\n    bytes32 internal constant CL_SPEC_SLOT = bytes32(uint256(keccak256(\"river.state.clSpec\")) - 1);\n\n    /// @notice The Consensus Layer Spec structure\n    struct CLSpecStruct {\n        /// @custom:attribute The count of epochs per frame, 225 means 24h\n        uint64 epochsPerFrame;\n        /// @custom:attribute The count of slots in an epoch (32 on mainnet)\n        uint64 slotsPerEpoch;\n        /// @custom:attribute The seconds in a slot (12 on mainnet)\n        uint64 secondsPerSlot;\n        /// @custom:attribute The block timestamp of the first consensus layer block\n        uint64 genesisTime;\n        /// @custom:attribute The count of epochs before considering an epoch final on-chain\n        uint64 epochsToAssumedFinality;\n    }\n\n    /// @notice The structure in storage\n    struct Slot {\n        /// @custom:attribute The structure in storage\n        CLSpecStruct value;\n    }\n\n    /// @notice Retrieve the Consensus Layer Spec from storage\n    /// @return The Consensus Layer Spec\n    function get() internal view returns (CLSpecStruct memory) {\n        bytes32 slot = CL_SPEC_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value;\n    }\n\n    /// @notice Set the Consensus Layer Spec value in storage\n    /// @param _newCLSpec The new value to set in storage\n    function set(CLSpecStruct memory _newCLSpec) internal {\n        bytes32 slot = CL_SPEC_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        r.value = _newCLSpec;\n    }\n}\n"
    },
    "contracts/src/state/river/DailyCommittableLimits.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\nimport \"../../libraries/LibSanitize.sol\";\n\n/// @title Daily Committable Limits storage\n/// @notice Utility to manage the Daily Committable Limits in storage\nlibrary DailyCommittableLimits {\n    /// @notice Storage slot of the Daily Committable Limits storage\n    bytes32 internal constant DAILY_COMMITTABLE_LIMITS_SLOT =\n        bytes32(uint256(keccak256(\"river.state.dailyCommittableLimits\")) - 1);\n\n    /// @notice The daily committable limits structure\n    struct DailyCommittableLimitsStruct {\n        uint128 minDailyNetCommittableAmount;\n        uint128 maxDailyRelativeCommittableAmount;\n    }\n\n    /// @notice The structure in storage\n    struct Slot {\n        /// @custom:attribute The structure in storage\n        DailyCommittableLimitsStruct value;\n    }\n\n    /// @notice Retrieve the Daily Committable Limits from storage\n    /// @return The Daily Committable Limits\n    function get() internal view returns (DailyCommittableLimitsStruct memory) {\n        bytes32 slot = DAILY_COMMITTABLE_LIMITS_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value;\n    }\n\n    /// @notice Set the Daily Committable Limits value in storage\n    /// @param _newValue The new value to set in storage\n    function set(DailyCommittableLimitsStruct memory _newValue) internal {\n        bytes32 slot = DAILY_COMMITTABLE_LIMITS_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        r.value = _newValue;\n    }\n}\n"
    },
    "contracts/src/state/river/ReportBounds.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\n/// @title Report Bounds Storage\n/// @notice Utility to manage the Report Bounds in storage\nlibrary ReportBounds {\n    /// @notice Storage slot of the Report Bounds\n    bytes32 internal constant REPORT_BOUNDS_SLOT = bytes32(uint256(keccak256(\"river.state.reportBounds\")) - 1);\n\n    /// @notice The Report Bounds structure\n    struct ReportBoundsStruct {\n        /// @custom:attribute The maximum allowed annual apr, checked before submitting a report to River\n        uint256 annualAprUpperBound;\n        /// @custom:attribute The maximum allowed balance decrease, also checked before submitting a report to River\n        uint256 relativeLowerBound;\n    }\n\n    /// @notice The structure in storage\n    struct Slot {\n        /// @custom:attribute The structure in storage\n        ReportBoundsStruct value;\n    }\n\n    /// @notice Retrieve the Report Bounds from storage\n    /// @return The Report Bounds\n    function get() internal view returns (ReportBoundsStruct memory) {\n        bytes32 slot = REPORT_BOUNDS_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value;\n    }\n\n    /// @notice Set the Report Bounds in storage\n    /// @param _newReportBounds The new Report Bounds value\n    function set(ReportBoundsStruct memory _newReportBounds) internal {\n        bytes32 slot = REPORT_BOUNDS_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        r.value = _newReportBounds;\n    }\n}\n"
    },
    "contracts/src/state/shared/AdministratorAddress.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\nimport \"../../libraries/LibSanitize.sol\";\n\n/// @title Administrator Address Storage\n/// @notice Utility to manage the Administrator Address in storage\nlibrary AdministratorAddress {\n    /// @notice Storage slot of the Administrator Address\n    bytes32 public constant ADMINISTRATOR_ADDRESS_SLOT =\n        bytes32(uint256(keccak256(\"river.state.administratorAddress\")) - 1);\n\n    /// @notice Retrieve the Administrator Address\n    /// @return The Administrator Address\n    function get() internal view returns (address) {\n        return LibUnstructuredStorage.getStorageAddress(ADMINISTRATOR_ADDRESS_SLOT);\n    }\n\n    /// @notice Sets the Administrator Address\n    /// @param _newValue New Administrator Address\n    function set(address _newValue) internal {\n        LibSanitize._notZeroAddress(_newValue);\n        LibUnstructuredStorage.setStorageAddress(ADMINISTRATOR_ADDRESS_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/shared/PendingAdministratorAddress.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\n\n/// @title Pending Administrator Address Storage\n/// @notice Utility to manage the Pending Administrator Address in storage\nlibrary PendingAdministratorAddress {\n    /// @notice Storage slot of the Pending Administrator Address\n    bytes32 public constant PENDING_ADMINISTRATOR_ADDRESS_SLOT =\n        bytes32(uint256(keccak256(\"river.state.pendingAdministratorAddress\")) - 1);\n\n    /// @notice Retrieve the Pending Administrator Address\n    /// @return The Pending Administrator Address\n    function get() internal view returns (address) {\n        return LibUnstructuredStorage.getStorageAddress(PENDING_ADMINISTRATOR_ADDRESS_SLOT);\n    }\n\n    /// @notice Sets the Pending Administrator Address\n    /// @param _newValue New Pending Administrator Address\n    function set(address _newValue) internal {\n        LibUnstructuredStorage.setStorageAddress(PENDING_ADMINISTRATOR_ADDRESS_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/shared/RiverAddress.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\nimport \"../../libraries/LibSanitize.sol\";\nimport \"../../libraries/LibUnstructuredStorage.sol\";\n\n/// @title River Address Storage\n/// @notice Utility to manage the River Address in storage\nlibrary RiverAddress {\n    /// @notice Storage slot of the River Address\n    bytes32 internal constant RIVER_ADDRESS_SLOT = bytes32(uint256(keccak256(\"river.state.riverAddress\")) - 1);\n\n    /// @notice Retrieve the River Address\n    /// @return The River Address\n    function get() internal view returns (address) {\n        return LibUnstructuredStorage.getStorageAddress(RIVER_ADDRESS_SLOT);\n    }\n\n    /// @notice Sets the River Address\n    /// @param _newValue New River Address\n    function set(address _newValue) internal {\n        LibSanitize._notZeroAddress(_newValue);\n        LibUnstructuredStorage.setStorageAddress(RIVER_ADDRESS_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/shared/Version.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.20;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\n\n/// @title Version Storage\n/// @notice Utility to manage the Version in storage\nlibrary Version {\n    /// @notice Storage slot of the Version\n    bytes32 public constant VERSION_SLOT = bytes32(uint256(keccak256(\"river.state.version\")) - 1);\n\n    /// @notice Retrieve the Version\n    /// @return The Version\n    function get() internal view returns (uint256) {\n        return LibUnstructuredStorage.getStorageUint256(VERSION_SLOT);\n    }\n\n    /// @notice Sets the Version\n    /// @param _newValue New Version\n    function set(uint256 _newValue) internal {\n        LibUnstructuredStorage.setStorageUint256(VERSION_SLOT, _newValue);\n    }\n}\n"
    },
    "openzeppelin-contracts/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    }
  },
  "settings": {
    "viaIR": true,
    "optimizer": {
      "enabled": true,
      "runs": 100
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "devdoc",
          "userdoc",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}