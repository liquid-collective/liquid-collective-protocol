{
  "address": "0x1F0a6496C08ca6a05D2A6f7F5B18d31eBBc05668",
  "abi": [
    {
      "inputs": [],
      "name": "InvalidCall",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "version",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "expectedVersion",
          "type": "uint256"
        }
      ],
      "name": "InvalidInitialization",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidZeroAddress",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "caller",
          "type": "address"
        }
      ],
      "name": "Unauthorized",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "version",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "cdata",
          "type": "bytes"
        }
      ],
      "name": "Initialize",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "river",
          "type": "address"
        }
      ],
      "name": "SetRiver",
      "type": "event"
    },
    {
      "stateMutability": "payable",
      "type": "fallback"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_riverAddress",
          "type": "address"
        }
      ],
      "name": "initELFeeRecipientV1",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_maxAmount",
          "type": "uint256"
        }
      ],
      "name": "pullELFees",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "version",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "stateMutability": "payable",
      "type": "receive"
    }
  ],
  "transactionHash": "0x2e5b3439e98bb3647c4e722a8a63d2a4b244c20144322e2df98ad62ad98e633e",
  "receipt": {
    "to": null,
    "from": "0x341C40B94bF2afBFa42573cB78f16Ee15a056238",
    "contractAddress": "0x1F0a6496C08ca6a05D2A6f7F5B18d31eBBc05668",
    "transactionIndex": 0,
    "gasUsed": "256376",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000080000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000",
    "blockHash": "0x75bf3dc6f9b89caa6e04dee78a49dff57ee556a3df920b6377dd3509e637d802",
    "transactionHash": "0x2e5b3439e98bb3647c4e722a8a63d2a4b244c20144322e2df98ad62ad98e633e",
    "logs": [
      {
        "transactionIndex": 0,
        "blockNumber": 2183918,
        "transactionHash": "0x2e5b3439e98bb3647c4e722a8a63d2a4b244c20144322e2df98ad62ad98e633e",
        "address": "0x1F0a6496C08ca6a05D2A6f7F5B18d31eBBc05668",
        "topics": [
          "0x1809e49bba43f2d39fa57894b50cd6ccb428cc438230e065cac3eb24a1355a71"
        ],
        "data": "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000",
        "logIndex": 0,
        "blockHash": "0x75bf3dc6f9b89caa6e04dee78a49dff57ee556a3df920b6377dd3509e637d802"
      }
    ],
    "blockNumber": 2183918,
    "cumulativeGasUsed": "256376",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "9213235610761b71d3e739f6815540a5",
  "metadata": "{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"InvalidCall\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expectedVersion\",\"type\":\"uint256\"}],\"name\":\"InvalidInitialization\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidZeroAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"cdata\",\"type\":\"bytes\"}],\"name\":\"Initialize\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"river\",\"type\":\"address\"}],\"name\":\"SetRiver\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_riverAddress\",\"type\":\"address\"}],\"name\":\"initELFeeRecipientV1\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxAmount\",\"type\":\"uint256\"}],\"name\":\"pullELFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}],\"devdoc\":{\"author\":\"Alluvial Finance Inc.\",\"errors\":{\"InvalidInitialization(uint256,uint256)\":[{\"params\":{\"expectedVersion\":\"The version that was expected\",\"version\":\"The version that was attempting to be initialized\"}}],\"Unauthorized(address)\":[{\"params\":{\"caller\":\"Address performing the call\"}}]},\"events\":{\"Initialize(uint256,bytes)\":{\"params\":{\"cdata\":\"Complete calldata that was used during the initialization\",\"version\":\"New version of the contracts\"}},\"SetRiver(address)\":{\"params\":{\"river\":\"The new river address\"}}},\"kind\":\"dev\",\"methods\":{\"initELFeeRecipientV1(address)\":{\"params\":{\"_riverAddress\":\"Address of River\"}},\"pullELFees(uint256)\":{\"details\":\"Only callable by the River contract\",\"params\":{\"_maxAmount\":\"The maximum amount to pull into the system\"}},\"version()\":{\"returns\":{\"_0\":\"Version of the contract\"}}},\"title\":\"Execution Layer Fee Recipient (v1)\",\"version\":1},\"userdoc\":{\"errors\":{\"InvalidCall()\":[{\"notice\":\"The fallback has been triggered\"}],\"InvalidInitialization(uint256,uint256)\":[{\"notice\":\"An error occured during the initialization\"}],\"InvalidZeroAddress()\":[{\"notice\":\"The address is zero\"}],\"Unauthorized(address)\":[{\"notice\":\"The operator is unauthorized for the caller\"}]},\"events\":{\"Initialize(uint256,bytes)\":{\"notice\":\"Emitted when the contract is properly initialized\"},\"SetRiver(address)\":{\"notice\":\"The storage river address has changed\"}},\"kind\":\"user\",\"methods\":{\"initELFeeRecipientV1(address)\":{\"notice\":\"Initialize the fee recipient with the required arguments\"},\"pullELFees(uint256)\":{\"notice\":\"Pulls ETH to the River contract\"},\"version()\":{\"notice\":\"Retrieves the version of the contract\"}},\"notice\":\"This contract receives all the execution layer fees from the proposed blocks + bribes\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/src/ELFeeRecipient.1.sol\":\"ELFeeRecipientV1\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":100},\"remappings\":[],\"viaIR\":true},\"sources\":{\"contracts/src/ELFeeRecipient.1.sol\":{\"content\":\"//SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\nimport \\\"./interfaces/IRiver.1.sol\\\";\\nimport \\\"./interfaces/IELFeeRecipient.1.sol\\\";\\nimport \\\"./interfaces/IProtocolVersion.sol\\\";\\n\\nimport \\\"./libraries/LibUint256.sol\\\";\\n\\nimport \\\"./Initializable.sol\\\";\\n\\nimport \\\"./state/shared/RiverAddress.sol\\\";\\n\\n/// @title Execution Layer Fee Recipient (v1)\\n/// @author Alluvial Finance Inc.\\n/// @notice This contract receives all the execution layer fees from the proposed blocks + bribes\\ncontract ELFeeRecipientV1 is Initializable, IELFeeRecipientV1, IProtocolVersion {\\n    /// @inheritdoc IELFeeRecipientV1\\n    function initELFeeRecipientV1(address _riverAddress) external init(0) {\\n        RiverAddress.set(_riverAddress);\\n        emit SetRiver(_riverAddress);\\n    }\\n\\n    /// @inheritdoc IELFeeRecipientV1\\n    function pullELFees(uint256 _maxAmount) external {\\n        address river = RiverAddress.get();\\n        if (msg.sender != river) {\\n            revert LibErrors.Unauthorized(msg.sender);\\n        }\\n        uint256 amount = LibUint256.min(_maxAmount, address(this).balance);\\n\\n        if (amount > 0) {\\n            IRiverV1(payable(river)).sendELFees{value: amount}();\\n        }\\n    }\\n\\n    /// @inheritdoc IELFeeRecipientV1\\n    receive() external payable {\\n        this;\\n    }\\n\\n    /// @inheritdoc IELFeeRecipientV1\\n    fallback() external payable {\\n        revert InvalidCall();\\n    }\\n\\n    function version() external pure returns (string memory) {\\n        return \\\"1.2.0\\\";\\n    }\\n}\\n\",\"keccak256\":\"0xe9aa1f4af0378dc468a0739cc0784b15d7a23bdbb92727afd4e3a2a22b518864\",\"license\":\"BUSL-1.1\"},\"contracts/src/Initializable.sol\":{\"content\":\"//SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\nimport \\\"./state/shared/Version.sol\\\";\\n\\n/// @title Initializable\\n/// @author Alluvial Finance Inc.\\n/// @notice This contract ensures that initializers are called only once per version\\ncontract Initializable {\\n    /// @notice Disable initialization on implementations\\n    constructor() {\\n        Version.set(type(uint256).max);\\n        emit Initialize(type(uint256).max, msg.data);\\n    }\\n\\n    /// @notice An error occured during the initialization\\n    /// @param version The version that was attempting to be initialized\\n    /// @param expectedVersion The version that was expected\\n    error InvalidInitialization(uint256 version, uint256 expectedVersion);\\n\\n    /// @notice Emitted when the contract is properly initialized\\n    /// @param version New version of the contracts\\n    /// @param cdata Complete calldata that was used during the initialization\\n    event Initialize(uint256 version, bytes cdata);\\n\\n    /// @notice Use this modifier on initializers along with a hard-coded version number\\n    /// @param _version Version to initialize\\n    modifier init(uint256 _version) {\\n        if (_version != Version.get()) {\\n            revert InvalidInitialization(_version, Version.get());\\n        }\\n        Version.set(_version + 1); // prevents reentrency on the called method\\n        _;\\n        emit Initialize(_version, msg.data);\\n    }\\n}\\n\",\"keccak256\":\"0xd371aeefbb5ed0d3d3b6efdd70044eb949161e6f534730fd0868f85a204c76c9\",\"license\":\"BUSL-1.1\"},\"contracts/src/interfaces/IELFeeRecipient.1.sol\":{\"content\":\"//SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\n/// @title Execution Layer Fee Recipient Interface (v1)\\n/// @author Alluvial Finance Inc.\\n/// @notice This interface exposes methods to receive all the execution layer fees from the proposed blocks + bribes\\ninterface IELFeeRecipientV1 {\\n    /// @notice The storage river address has changed\\n    /// @param river The new river address\\n    event SetRiver(address indexed river);\\n\\n    /// @notice The fallback has been triggered\\n    error InvalidCall();\\n\\n    /// @notice Initialize the fee recipient with the required arguments\\n    /// @param _riverAddress Address of River\\n    function initELFeeRecipientV1(address _riverAddress) external;\\n\\n    /// @notice Pulls ETH to the River contract\\n    /// @dev Only callable by the River contract\\n    /// @param _maxAmount The maximum amount to pull into the system\\n    function pullELFees(uint256 _maxAmount) external;\\n\\n    /// @notice Ether receiver\\n    receive() external payable;\\n\\n    /// @notice Invalid fallback detector\\n    fallback() external payable;\\n}\\n\",\"keccak256\":\"0x239e8c0ad095f5a651ca464531dc2e7fc3d95dd2f257fefac7f4a4a92d46da50\",\"license\":\"BUSL-1.1\"},\"contracts/src/interfaces/IProtocolVersion.sol\":{\"content\":\"//SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\ninterface IProtocolVersion {\\n    /// @notice Retrieves the version of the contract\\n    /// @return Version of the contract\\n    function version() external pure returns (string memory);\\n}\\n\",\"keccak256\":\"0x2fc810a5c001d641d4b19c28631dac46201e3780e91dfeb5dc836f92f1aee8b3\",\"license\":\"BUSL-1.1\"},\"contracts/src/interfaces/IRiver.1.sol\":{\"content\":\"//SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\nimport \\\"../state/river/DailyCommittableLimits.sol\\\";\\n\\nimport \\\"./components/IConsensusLayerDepositManager.1.sol\\\";\\nimport \\\"./components/IOracleManager.1.sol\\\";\\nimport \\\"./components/ISharesManager.1.sol\\\";\\nimport \\\"./components/IUserDepositManager.1.sol\\\";\\n\\n/// @title River Interface (v1)\\n/// @author Alluvial Finance Inc.\\n/// @notice The main system interface\\ninterface IRiverV1 is IConsensusLayerDepositManagerV1, IUserDepositManagerV1, ISharesManagerV1, IOracleManagerV1 {\\n    /// @notice Funds have been pulled from the Execution Layer Fee Recipient\\n    /// @param amount The amount pulled\\n    event PulledELFees(uint256 amount);\\n\\n    /// @notice Funds have been pulled from the Coverage Fund\\n    /// @param amount The amount pulled\\n    event PulledCoverageFunds(uint256 amount);\\n\\n    /// @notice Emitted when funds are pulled from the redeem manager\\n    /// @param amount The amount pulled\\n    event PulledRedeemManagerExceedingEth(uint256 amount);\\n\\n    /// @notice Emitted when funds are pulled from the CL recipient\\n    /// @param pulledSkimmedEthAmount The amount of skimmed ETH pulled\\n    /// @param pullExitedEthAmount The amount of exited ETH pulled\\n    event PulledCLFunds(uint256 pulledSkimmedEthAmount, uint256 pullExitedEthAmount);\\n\\n    /// @notice The stored Execution Layer Fee Recipient has been changed\\n    /// @param elFeeRecipient The new Execution Layer Fee Recipient\\n    event SetELFeeRecipient(address indexed elFeeRecipient);\\n\\n    /// @notice The stored Coverage Fund has been changed\\n    /// @param coverageFund The new Coverage Fund\\n    event SetCoverageFund(address indexed coverageFund);\\n\\n    /// @notice The stored Collector has been changed\\n    /// @param collector The new Collector\\n    event SetCollector(address indexed collector);\\n\\n    /// @notice The stored Allowlist has been changed\\n    /// @param allowlist The new Allowlist\\n    event SetAllowlist(address indexed allowlist);\\n\\n    /// @notice The stored Global Fee has been changed\\n    /// @param fee The new Global Fee\\n    event SetGlobalFee(uint256 fee);\\n\\n    /// @notice The stored Operators Registry has been changed\\n    /// @param operatorRegistry The new Operators Registry\\n    event SetOperatorsRegistry(address indexed operatorRegistry);\\n\\n    /// @notice The stored Metadata URI string has been changed\\n    /// @param metadataURI The new Metadata URI string\\n    event SetMetadataURI(string metadataURI);\\n\\n    /// @notice The system underlying supply increased. This is a snapshot of the balances for accounting purposes\\n    /// @param _collector The address of the collector during this event\\n    /// @param _oldTotalUnderlyingBalance Old total ETH balance under management by River\\n    /// @param _oldTotalSupply Old total supply in shares\\n    /// @param _newTotalUnderlyingBalance New total ETH balance under management by River\\n    /// @param _newTotalSupply New total supply in shares\\n    event RewardsEarned(\\n        address indexed _collector,\\n        uint256 _oldTotalUnderlyingBalance,\\n        uint256 _oldTotalSupply,\\n        uint256 _newTotalUnderlyingBalance,\\n        uint256 _newTotalSupply\\n    );\\n\\n    /// @notice Emitted when the daily committable limits are changed\\n    /// @param minNetAmount The minimum amount that must be used as the daily committable amount\\n    /// @param maxRelativeAmount The maximum amount that can be used as the daily committable amount, relative to the total underlying supply\\n    event SetMaxDailyCommittableAmounts(uint256 minNetAmount, uint256 maxRelativeAmount);\\n\\n    /// @notice Emitted when the redeem manager address is changed\\n    /// @param redeemManager The address of the redeem manager\\n    event SetRedeemManager(address redeemManager);\\n\\n    /// @notice Emitted when the balance to deposit is updated\\n    /// @param oldAmount The old balance to deposit\\n    /// @param newAmount The new balance to deposit\\n    event SetBalanceToDeposit(uint256 oldAmount, uint256 newAmount);\\n\\n    /// @notice Emitted when the balance to redeem is updated\\n    /// @param oldAmount The old balance to redeem\\n    /// @param newAmount The new balance to redeem\\n    event SetBalanceToRedeem(uint256 oldAmount, uint256 newAmount);\\n\\n    /// @notice Emitted when the balance committed to deposit\\n    /// @param oldAmount The old balance committed to deposit\\n    /// @param newAmount The new balance committed to deposit\\n    event SetBalanceCommittedToDeposit(uint256 oldAmount, uint256 newAmount);\\n\\n    /// @notice Emitted when the redeem manager received a withdraw event report\\n    /// @param redeemManagerDemand The total demand in LsETH of the redeem manager\\n    /// @param suppliedRedeemManagerDemand The amount of LsETH demand actually supplied\\n    /// @param suppliedRedeemManagerDemandInEth The amount in ETH of the supplied demand\\n    event ReportedRedeemManager(\\n        uint256 redeemManagerDemand, uint256 suppliedRedeemManagerDemand, uint256 suppliedRedeemManagerDemandInEth\\n    );\\n\\n    /// @notice Thrown when the amount received from the Withdraw contract doe not match the requested amount\\n    /// @param requested The amount that was requested\\n    /// @param received The amount that was received\\n    error InvalidPulledClFundsAmount(uint256 requested, uint256 received);\\n\\n    /// @notice The computed amount of shares to mint is 0\\n    error ZeroMintedShares();\\n\\n    /// @notice The access was denied\\n    /// @param account The account that was denied\\n    error Denied(address account);\\n\\n    /// @notice Initializes the River system\\n    /// @param _depositContractAddress Address to make Consensus Layer deposits\\n    /// @param _elFeeRecipientAddress Address that receives the execution layer fees\\n    /// @param _withdrawalCredentials Credentials to use for every validator deposit\\n    /// @param _oracleAddress The address of the Oracle contract\\n    /// @param _systemAdministratorAddress Administrator address\\n    /// @param _allowlistAddress Address of the allowlist contract\\n    /// @param _operatorRegistryAddress Address of the operator registry\\n    /// @param _collectorAddress Address receiving the the global fee on revenue\\n    /// @param _globalFee Amount retained when the ETH balance increases and sent to the collector\\n    function initRiverV1(\\n        address _depositContractAddress,\\n        address _elFeeRecipientAddress,\\n        bytes32 _withdrawalCredentials,\\n        address _oracleAddress,\\n        address _systemAdministratorAddress,\\n        address _allowlistAddress,\\n        address _operatorRegistryAddress,\\n        address _collectorAddress,\\n        uint256 _globalFee\\n    ) external;\\n\\n    /// @notice Initialized version 1.1 of the River System\\n    /// @param _redeemManager The redeem manager address\\n    /// @param _epochsPerFrame The amounts of epochs in a frame\\n    /// @param _slotsPerEpoch The slots inside an epoch\\n    /// @param _secondsPerSlot The seconds inside a slot\\n    /// @param _genesisTime The genesis timestamp\\n    /// @param _epochsToAssumedFinality The number of epochs before an epoch is considered final on-chain\\n    /// @param _annualAprUpperBound The reporting upper bound\\n    /// @param _relativeLowerBound The reporting lower bound\\n    /// @param _maxDailyNetCommittableAmount_ The net daily committable limit\\n    /// @param _maxDailyRelativeCommittableAmount_ The relative daily committable limit\\n    function initRiverV1_1(\\n        address _redeemManager,\\n        uint64 _epochsPerFrame,\\n        uint64 _slotsPerEpoch,\\n        uint64 _secondsPerSlot,\\n        uint64 _genesisTime,\\n        uint64 _epochsToAssumedFinality,\\n        uint256 _annualAprUpperBound,\\n        uint256 _relativeLowerBound,\\n        uint128 _maxDailyNetCommittableAmount_,\\n        uint128 _maxDailyRelativeCommittableAmount_\\n    ) external;\\n\\n    /// @notice Initializes version 1.2 of the River System\\n    function initRiverV1_2() external;\\n\\n    /// @notice Get the current global fee\\n    /// @return The global fee\\n    function getGlobalFee() external view returns (uint256);\\n\\n    /// @notice Retrieve the allowlist address\\n    /// @return The allowlist address\\n    function getAllowlist() external view returns (address);\\n\\n    /// @notice Retrieve the collector address\\n    /// @return The collector address\\n    function getCollector() external view returns (address);\\n\\n    /// @notice Retrieve the execution layer fee recipient\\n    /// @return The execution layer fee recipient address\\n    function getELFeeRecipient() external view returns (address);\\n\\n    /// @notice Retrieve the coverage fund\\n    /// @return The coverage fund address\\n    function getCoverageFund() external view returns (address);\\n\\n    /// @notice Retrieve the redeem manager\\n    /// @return The redeem manager address\\n    function getRedeemManager() external view returns (address);\\n\\n    /// @notice Retrieve the operators registry\\n    /// @return The operators registry address\\n    function getOperatorsRegistry() external view returns (address);\\n\\n    /// @notice Retrieve the metadata uri string value\\n    /// @return The metadata uri string value\\n    function getMetadataURI() external view returns (string memory);\\n\\n    /// @notice Retrieve the configured daily committable limits\\n    /// @return The daily committable limits structure\\n    function getDailyCommittableLimits()\\n        external\\n        view\\n        returns (DailyCommittableLimits.DailyCommittableLimitsStruct memory);\\n\\n    /// @notice Resolves the provided redeem requests by calling the redeem manager\\n    /// @param _redeemRequestIds The list of redeem requests to resolve\\n    /// @return withdrawalEventIds The list of matching withdrawal events, or error codes\\n    function resolveRedeemRequests(uint32[] calldata _redeemRequestIds)\\n        external\\n        view\\n        returns (int64[] memory withdrawalEventIds);\\n\\n    /// @notice Set the daily committable limits\\n    /// @param _dcl The Daily Committable Limits structure\\n    function setDailyCommittableLimits(DailyCommittableLimits.DailyCommittableLimitsStruct memory _dcl) external;\\n\\n    /// @notice Retrieve the current balance to redeem\\n    /// @return The current balance to redeem\\n    function getBalanceToRedeem() external view returns (uint256);\\n\\n    /// @notice Performs a redeem request on the redeem manager\\n    /// @param _lsETHAmount The amount of LsETH to redeem\\n    /// @param _recipient The address that will own the redeem request\\n    /// @return redeemRequestId The ID of the newly created redeem request\\n    function requestRedeem(uint256 _lsETHAmount, address _recipient) external returns (uint32 redeemRequestId);\\n\\n    /// @notice Claims several redeem requests\\n    /// @param _redeemRequestIds The list of redeem requests to claim\\n    /// @param _withdrawalEventIds The list of resolved withdrawal event ids\\n    /// @return claimStatuses The operation status results\\n    function claimRedeemRequests(uint32[] calldata _redeemRequestIds, uint32[] calldata _withdrawalEventIds)\\n        external\\n        returns (uint8[] memory claimStatuses);\\n\\n    /// @notice Changes the global fee parameter\\n    /// @param _newFee New fee value\\n    function setGlobalFee(uint256 _newFee) external;\\n\\n    /// @notice Changes the allowlist address\\n    /// @param _newAllowlist New address for the allowlist\\n    function setAllowlist(address _newAllowlist) external;\\n\\n    /// @notice Changes the collector address\\n    /// @param _newCollector New address for the collector\\n    function setCollector(address _newCollector) external;\\n\\n    /// @notice Changes the execution layer fee recipient\\n    /// @param _newELFeeRecipient New address for the recipient\\n    function setELFeeRecipient(address _newELFeeRecipient) external;\\n\\n    /// @notice Changes the coverage fund\\n    /// @param _newCoverageFund New address for the fund\\n    function setCoverageFund(address _newCoverageFund) external;\\n\\n    /// @notice Sets the metadata uri string value\\n    /// @param _metadataURI The new metadata uri string value\\n    function setMetadataURI(string memory _metadataURI) external;\\n\\n    /// @notice Input for execution layer fee earnings\\n    function sendELFees() external payable;\\n\\n    /// @notice Input for consensus layer funds, containing both exit and skimming\\n    function sendCLFunds() external payable;\\n\\n    /// @notice Input for coverage funds\\n    function sendCoverageFunds() external payable;\\n\\n    /// @notice Input for the redeem manager funds\\n    function sendRedeemManagerExceedingFunds() external payable;\\n}\\n\",\"keccak256\":\"0xcb57b5480b1849e52fe74552c5aac448fe3c2232a6c72b7d56b34fa9bc878ea1\",\"license\":\"BUSL-1.1\"},\"contracts/src/interfaces/components/IConsensusLayerDepositManager.1.sol\":{\"content\":\"//SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\n/// @title Consensys Layer Deposit Manager Interface (v1)\\n/// @author Alluvial Finance Inc.\\n/// @notice This interface exposes methods to handle the interactions with the official deposit contract\\ninterface IConsensusLayerDepositManagerV1 {\\n    /// @notice The stored deposit contract address changed\\n    /// @param depositContract Address of the deposit contract\\n    event SetDepositContractAddress(address indexed depositContract);\\n\\n    /// @notice The stored withdrawal credentials changed\\n    /// @param withdrawalCredentials The withdrawal credentials to use for deposits\\n    event SetWithdrawalCredentials(bytes32 withdrawalCredentials);\\n\\n    /// @notice Emitted when the deposited validator count is updated\\n    /// @param oldDepositedValidatorCount The old deposited validator count value\\n    /// @param newDepositedValidatorCount The new deposited validator count value\\n    event SetDepositedValidatorCount(uint256 oldDepositedValidatorCount, uint256 newDepositedValidatorCount);\\n\\n    /// @notice Not enough funds to deposit one validator\\n    error NotEnoughFunds();\\n\\n    /// @notice The length of the BLS Public key is invalid during deposit\\n    error InconsistentPublicKeys();\\n\\n    /// @notice The length of the BLS Signature is invalid during deposit\\n    error InconsistentSignatures();\\n\\n    /// @notice The internal key retrieval returned no keys\\n    error NoAvailableValidatorKeys();\\n\\n    /// @notice The received count of public keys to deposit is invalid\\n    error InvalidPublicKeyCount();\\n\\n    /// @notice The received count of signatures to deposit is invalid\\n    error InvalidSignatureCount();\\n\\n    /// @notice The withdrawal credentials value is null\\n    error InvalidWithdrawalCredentials();\\n\\n    /// @notice An error occured during the deposit\\n    error ErrorOnDeposit();\\n\\n    /// @notice Invalid deposit root\\n    error InvalidDepositRoot();\\n\\n    // @notice Not keeper\\n    error OnlyKeeper();\\n\\n    /// @notice Returns the amount of ETH not yet committed for deposit\\n    /// @return The amount of ETH not yet committed for deposit\\n    function getBalanceToDeposit() external view returns (uint256);\\n\\n    /// @notice Returns the amount of ETH committed for deposit\\n    /// @return The amount of ETH committed for deposit\\n    function getCommittedBalance() external view returns (uint256);\\n\\n    /// @notice Retrieve the withdrawal credentials\\n    /// @return The withdrawal credentials\\n    function getWithdrawalCredentials() external view returns (bytes32);\\n\\n    /// @notice Get the deposited validator count (the count of deposits made by the contract)\\n    /// @return The deposited validator count\\n    function getDepositedValidatorCount() external view returns (uint256);\\n\\n    /// @notice Get the keeper address\\n    /// @return The keeper address\\n    function getKeeper() external view returns (address);\\n\\n    /// @notice Deposits current balance to the Consensus Layer by batches of 32 ETH\\n    /// @param _maxCount The maximum amount of validator keys to fund\\n    /// @param _depositRoot The root of the deposit tree\\n    function depositToConsensusLayerWithDepositRoot(uint256 _maxCount, bytes32 _depositRoot) external;\\n}\\n\",\"keccak256\":\"0xd7e41b30bdc6108f85633988ac53e9196285cee3d28c978054deb76b2268915d\",\"license\":\"BUSL-1.1\"},\"contracts/src/interfaces/components/IOracleManager.1.sol\":{\"content\":\"//SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\nimport \\\"../../state/river/CLSpec.sol\\\";\\nimport \\\"../../state/river/ReportBounds.sol\\\";\\n\\n/// @title Oracle Manager (v1)\\n/// @author Alluvial Finance Inc.\\n/// @notice This interface exposes methods to handle the inputs provided by the oracle\\ninterface IOracleManagerV1 {\\n    /// @notice The stored oracle address changed\\n    /// @param oracleAddress The new oracle address\\n    event SetOracle(address indexed oracleAddress);\\n\\n    /// @notice The consensus layer data provided by the oracle has been updated\\n    /// @param validatorCount The new count of validators running on the consensus layer\\n    /// @param validatorTotalBalance The new total balance sum of all validators\\n    /// @param roundId Round identifier\\n    event ConsensusLayerDataUpdate(uint256 validatorCount, uint256 validatorTotalBalance, bytes32 roundId);\\n\\n    /// @notice The Consensus Layer Spec is changed\\n    /// @param epochsPerFrame The number of epochs inside a frame\\n    /// @param slotsPerEpoch The number of slots inside an epoch\\n    /// @param secondsPerSlot The number of seconds inside a slot\\n    /// @param genesisTime The genesis timestamp\\n    /// @param epochsToAssumedFinality The number of epochs before an epoch is considered final\\n    event SetSpec(\\n        uint64 epochsPerFrame,\\n        uint64 slotsPerEpoch,\\n        uint64 secondsPerSlot,\\n        uint64 genesisTime,\\n        uint64 epochsToAssumedFinality\\n    );\\n\\n    /// @notice The Report Bounds are changed\\n    /// @param annualAprUpperBound The reporting upper bound\\n    /// @param relativeLowerBound The reporting lower bound\\n    event SetBounds(uint256 annualAprUpperBound, uint256 relativeLowerBound);\\n\\n    /// @notice The provided report has beend processed\\n    /// @param report The report that was provided\\n    /// @param trace The trace structure providing more insights on internals\\n    event ProcessedConsensusLayerReport(\\n        IOracleManagerV1.ConsensusLayerReport report, ConsensusLayerDataReportingTrace trace\\n    );\\n\\n    /// @notice The reported validator count is invalid\\n    /// @param providedValidatorCount The received validator count value\\n    /// @param depositedValidatorCount The number of deposits performed by the system\\n    /// @param lastReportedValidatorCount The last reported validator count\\n    error InvalidValidatorCountReport(\\n        uint256 providedValidatorCount, uint256 depositedValidatorCount, uint256 lastReportedValidatorCount\\n    );\\n\\n    /// @notice Thrown when an invalid epoch was reported\\n    /// @param epoch Invalid epoch\\n    error InvalidEpoch(uint256 epoch);\\n\\n    /// @notice The balance increase is higher than the maximum allowed by the upper bound\\n    /// @param prevTotalEthIncludingExited The previous total balance, including all exited balance\\n    /// @param postTotalEthIncludingExited The post-report total balance, including all exited balance\\n    /// @param timeElapsed The time in seconds since last report\\n    /// @param annualAprUpperBound The upper bound value that was used\\n    error TotalValidatorBalanceIncreaseOutOfBound(\\n        uint256 prevTotalEthIncludingExited,\\n        uint256 postTotalEthIncludingExited,\\n        uint256 timeElapsed,\\n        uint256 annualAprUpperBound\\n    );\\n\\n    /// @notice The balance decrease is higher than the maximum allowed by the lower bound\\n    /// @param prevTotalEthIncludingExited The previous total balance, including all exited balance\\n    /// @param postTotalEthIncludingExited The post-report total balance, including all exited balance\\n    /// @param timeElapsed The time in seconds since last report\\n    /// @param relativeLowerBound The lower bound value that was used\\n    error TotalValidatorBalanceDecreaseOutOfBound(\\n        uint256 prevTotalEthIncludingExited,\\n        uint256 postTotalEthIncludingExited,\\n        uint256 timeElapsed,\\n        uint256 relativeLowerBound\\n    );\\n\\n    /// @notice The total exited balance decreased\\n    /// @param currentValidatorsExitedBalance The current exited balance\\n    /// @param newValidatorsExitedBalance The new exited balance\\n    error InvalidDecreasingValidatorsExitedBalance(\\n        uint256 currentValidatorsExitedBalance, uint256 newValidatorsExitedBalance\\n    );\\n\\n    /// @notice The total skimmed balance decreased\\n    /// @param currentValidatorsSkimmedBalance The current exited balance\\n    /// @param newValidatorsSkimmedBalance The new exited balance\\n    error InvalidDecreasingValidatorsSkimmedBalance(\\n        uint256 currentValidatorsSkimmedBalance, uint256 newValidatorsSkimmedBalance\\n    );\\n\\n    /// @notice Trace structure emitted via logs during reporting\\n    struct ConsensusLayerDataReportingTrace {\\n        uint256 rewards;\\n        uint256 pulledELFees;\\n        uint256 pulledRedeemManagerExceedingEthBuffer;\\n        uint256 pulledCoverageFunds;\\n    }\\n\\n    /// @notice The format of the oracle report\\n    struct ConsensusLayerReport {\\n        // this is the epoch at which the report was performed\\n        // data should be fetched up to the state of this epoch by the oracles\\n        uint256 epoch;\\n        // the sum of all the validator balances on the consensus layer\\n        // when a validator enters the exit queue, the validator is considered stopped, its balance is accounted in both validatorsExitingBalance and validatorsBalance\\n        // when a validator leaves the exit queue and the funds are sweeped onto the execution layer, the balance is only accounted in validatorsExitedBalance and not in validatorsBalance\\n        // this value can decrease between reports\\n        uint256 validatorsBalance;\\n        // the sum of all the skimmings performed on the validators\\n        // these values can be found in the execution layer block bodies under the withdrawals field\\n        // a withdrawal is considered skimming if\\n        // - the epoch at which it happened is < validator.withdrawableEpoch\\n        // - the epoch at which it happened is >= validator.withdrawableEpoch and in that case we only account for what would be above 32 eth as skimming\\n        // this value cannot decrease over reports\\n        uint256 validatorsSkimmedBalance;\\n        // the sum of all the exits performed on the validators\\n        // these values can be found in the execution layer block bodies under the withdrawals field\\n        // a withdrawal is considered exit if\\n        // - the epoch at which it happened is >= validator.withdrawableEpoch and in that case we only account for what would be <= 32 eth as exit\\n        // this value cannot decrease over reports\\n        uint256 validatorsExitedBalance;\\n        // the sum of all the exiting balance, which is all the validators on their way to get sweeped and exited\\n        // this includes voluntary exits and slashings\\n        // this value can decrease between reports\\n        uint256 validatorsExitingBalance;\\n        // the count of activated validators\\n        // even validators that are exited are still accounted\\n        // this value cannot decrease over reports\\n        uint32 validatorsCount;\\n        // an array containing the count of stopped validators per operator\\n        // the first element of the array is the sum of all stopped validators\\n        // then index 1 would be operator 0\\n        // these values cannot decrease over reports\\n        uint32[] stoppedValidatorCountPerOperator;\\n        // flag enabled by the oracles when the buffer rebalancing is activated\\n        // the activation logic is written in the oracle specification and all oracle members must agree on the activation\\n        // when active, the eth in the deposit buffer can be used to pay for exits in the redeem manager\\n        bool rebalanceDepositToRedeemMode;\\n        // flag enabled by the oracles when the slashing containment is activated\\n        // the activation logic is written in the oracle specification and all oracle members must agree on the activation\\n        // This flag is activated when a pre-defined threshold of slashed validators in our set of validators is reached\\n        // This flag is deactivated when a bottom threshold is met, this means that when we reach the upper threshold and activate the flag, we will deactivate it when we reach the bottom threshold and not before\\n        // when active, no more validator exits can be requested by the protocol\\n        bool slashingContainmentMode;\\n    }\\n\\n    /// @notice The format of the oracle report in storage\\n    /// @notice These fields have the exact same function as the ones in ConsensusLayerReport, but this struct is optimized for storage\\n    struct StoredConsensusLayerReport {\\n        uint256 epoch;\\n        uint256 validatorsBalance;\\n        uint256 validatorsSkimmedBalance;\\n        uint256 validatorsExitedBalance;\\n        uint256 validatorsExitingBalance;\\n        uint32 validatorsCount;\\n        bool rebalanceDepositToRedeemMode;\\n        bool slashingContainmentMode;\\n    }\\n\\n    /// @notice Get oracle address\\n    /// @return The oracle address\\n    function getOracle() external view returns (address);\\n\\n    /// @notice Get CL validator total balance\\n    /// @return The CL Validator total balance\\n    function getCLValidatorTotalBalance() external view returns (uint256);\\n\\n    /// @notice Get CL validator count (the amount of validator reported by the oracles)\\n    /// @return The CL validator count\\n    function getCLValidatorCount() external view returns (uint256);\\n\\n    /// @notice Verifies if the provided epoch is valid\\n    /// @param epoch The epoch to lookup\\n    /// @return True if valid\\n    function isValidEpoch(uint256 epoch) external view returns (bool);\\n\\n    /// @notice Retrieve the block timestamp\\n    /// @return The current timestamp from the EVM context\\n    function getTime() external view returns (uint256);\\n\\n    /// @notice Retrieve expected epoch id\\n    /// @return The current expected epoch id\\n    function getExpectedEpochId() external view returns (uint256);\\n\\n    /// @notice Retrieve the last completed epoch id\\n    /// @return The last completed epoch id\\n    function getLastCompletedEpochId() external view returns (uint256);\\n\\n    /// @notice Retrieve the current epoch id based on block timestamp\\n    /// @return The current epoch id\\n    function getCurrentEpochId() external view returns (uint256);\\n\\n    /// @notice Retrieve the current cl spec\\n    /// @return The Consensus Layer Specification\\n    function getCLSpec() external view returns (CLSpec.CLSpecStruct memory);\\n\\n    /// @notice Retrieve the current frame details\\n    /// @return _startEpochId The epoch at the beginning of the frame\\n    /// @return _startTime The timestamp of the beginning of the frame in seconds\\n    /// @return _endTime The timestamp of the end of the frame in seconds\\n    function getCurrentFrame() external view returns (uint256 _startEpochId, uint256 _startTime, uint256 _endTime);\\n\\n    /// @notice Retrieve the first epoch id of the frame of the provided epoch id\\n    /// @param _epochId Epoch id used to get the frame\\n    /// @return The first epoch id of the frame containing the given epoch id\\n    function getFrameFirstEpochId(uint256 _epochId) external view returns (uint256);\\n\\n    /// @notice Retrieve the report bounds\\n    /// @return The report bounds\\n    function getReportBounds() external view returns (ReportBounds.ReportBoundsStruct memory);\\n\\n    /// @notice Retrieve the last consensus layer report\\n    /// @return The stored consensus layer report\\n    function getLastConsensusLayerReport() external view returns (IOracleManagerV1.StoredConsensusLayerReport memory);\\n\\n    /// @notice Set the oracle address\\n    /// @param _oracleAddress Address of the oracle\\n    function setOracle(address _oracleAddress) external;\\n\\n    /// @notice Set the consensus layer spec\\n    /// @param _newValue The new consensus layer spec value\\n    function setCLSpec(CLSpec.CLSpecStruct calldata _newValue) external;\\n\\n    /// @notice Set the report bounds\\n    /// @param _newValue The new report bounds value\\n    function setReportBounds(ReportBounds.ReportBoundsStruct calldata _newValue) external;\\n\\n    /// @notice Performs all the reporting logics\\n    /// @param _report The consensus layer report structure\\n    function setConsensusLayerData(ConsensusLayerReport calldata _report) external;\\n}\\n\",\"keccak256\":\"0x9109a0a200d62513d217b41d4904d7bbd2a87ec7d3f5a5e683e13ba76c8bcd2e\",\"license\":\"BUSL-1.1\"},\"contracts/src/interfaces/components/ISharesManager.1.sol\":{\"content\":\"//SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\nimport \\\"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/// @title Shares Manager Interface (v1)\\n/// @author Alluvial Finance Inc.\\n/// @notice This interface exposes methods to handle the shares of the depositor and the ERC20 interface\\ninterface ISharesManagerV1 is IERC20 {\\n    /// @notice Emitted when the total supply is changed\\n    event SetTotalSupply(uint256 totalSupply);\\n\\n    /// @notice Balance too low to perform operation\\n    error BalanceTooLow();\\n\\n    /// @notice Allowance too low to perform operation\\n    /// @param _from Account where funds are sent from\\n    /// @param _operator Account attempting the transfer\\n    /// @param _allowance Current allowance\\n    /// @param _value Requested transfer value in shares\\n    error AllowanceTooLow(address _from, address _operator, uint256 _allowance, uint256 _value);\\n\\n    /// @notice Invalid empty transfer\\n    error NullTransfer();\\n\\n    /// @notice Invalid transfer recipients\\n    /// @param _from Account sending the funds in the invalid transfer\\n    /// @param _to Account receiving the funds in the invalid transfer\\n    error UnauthorizedTransfer(address _from, address _to);\\n\\n    /// @notice Retrieve the token name\\n    /// @return The token name\\n    function name() external pure returns (string memory);\\n\\n    /// @notice Retrieve the token symbol\\n    /// @return The token symbol\\n    function symbol() external pure returns (string memory);\\n\\n    /// @notice Retrieve the decimal count\\n    /// @return The decimal count\\n    function decimals() external pure returns (uint8);\\n\\n    /// @notice Retrieve the total token supply\\n    /// @return The total supply in shares\\n    function totalSupply() external view returns (uint256);\\n\\n    /// @notice Retrieve the total underlying asset supply\\n    /// @return The total underlying asset supply\\n    function totalUnderlyingSupply() external view returns (uint256);\\n\\n    /// @notice Retrieve the balance of an account\\n    /// @param _owner Address to be checked\\n    /// @return The balance of the account in shares\\n    function balanceOf(address _owner) external view returns (uint256);\\n\\n    /// @notice Retrieve the underlying asset balance of an account\\n    /// @param _owner Address to be checked\\n    /// @return The underlying balance of the account\\n    function balanceOfUnderlying(address _owner) external view returns (uint256);\\n\\n    /// @notice Retrieve the underlying asset balance from an amount of shares\\n    /// @param _shares Amount of shares to convert\\n    /// @return The underlying asset balance represented by the shares\\n    function underlyingBalanceFromShares(uint256 _shares) external view returns (uint256);\\n\\n    /// @notice Retrieve the shares count from an underlying asset amount\\n    /// @param _underlyingAssetAmount Amount of underlying asset to convert\\n    /// @return The amount of shares worth the underlying asset amopunt\\n    function sharesFromUnderlyingBalance(uint256 _underlyingAssetAmount) external view returns (uint256);\\n\\n    /// @notice Retrieve the allowance value for a spender\\n    /// @param _owner Address that issued the allowance\\n    /// @param _spender Address that received the allowance\\n    /// @return The allowance in shares for a given spender\\n    function allowance(address _owner, address _spender) external view returns (uint256);\\n\\n    /// @notice Performs a transfer from the message sender to the provided account\\n    /// @param _to Address receiving the tokens\\n    /// @param _value Amount of shares to be sent\\n    /// @return True if success\\n    function transfer(address _to, uint256 _value) external returns (bool);\\n\\n    /// @notice Performs a transfer between two recipients\\n    /// @param _from Address sending the tokens\\n    /// @param _to Address receiving the tokens\\n    /// @param _value Amount of shares to be sent\\n    /// @return True if success\\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\\n\\n    /// @notice Approves an account for future spendings\\n    /// @dev An approved account can use transferFrom to transfer funds on behalf of the token owner\\n    /// @param _spender Address that is allowed to spend the tokens\\n    /// @param _value The allowed amount in shares, will override previous value\\n    /// @return True if success\\n    function approve(address _spender, uint256 _value) external returns (bool);\\n\\n    /// @notice Increase allowance to another account\\n    /// @param _spender Spender that receives the allowance\\n    /// @param _additionalValue Amount of shares to add\\n    /// @return True if success\\n    function increaseAllowance(address _spender, uint256 _additionalValue) external returns (bool);\\n\\n    /// @notice Decrease allowance to another account\\n    /// @param _spender Spender that receives the allowance\\n    /// @param _subtractableValue Amount of shares to subtract\\n    /// @return True if success\\n    function decreaseAllowance(address _spender, uint256 _subtractableValue) external returns (bool);\\n}\\n\",\"keccak256\":\"0xbbbc45cddcad60c43e2f78a0a075f3f171f9606a9142d692138f09093ef3f451\",\"license\":\"BUSL-1.1\"},\"contracts/src/interfaces/components/IUserDepositManager.1.sol\":{\"content\":\"//SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\n/// @title User Deposit Manager (v1)\\n/// @author Alluvial Finance Inc.\\n/// @notice This interface exposes methods to handle the inbound transfers cases or the explicit submissions\\ninterface IUserDepositManagerV1 {\\n    /// @notice User deposited ETH in the system\\n    /// @param depositor Address performing the deposit\\n    /// @param recipient Address receiving the minted shares\\n    /// @param amount Amount in ETH deposited\\n    event UserDeposit(address indexed depositor, address indexed recipient, uint256 amount);\\n\\n    /// @notice And empty deposit attempt was made\\n    error EmptyDeposit();\\n\\n    /// @notice Explicit deposit method to mint on msg.sender\\n    function deposit() external payable;\\n\\n    /// @notice Explicit deposit method to mint on msg.sender and transfer to _recipient\\n    /// @param _recipient Address receiving the minted LsETH\\n    function depositAndTransfer(address _recipient) external payable;\\n\\n    /// @notice Implicit deposit method, when the user performs a regular transfer to the contract\\n    receive() external payable;\\n\\n    /// @notice Invalid call, when the user sends a transaction with a data payload but no method matched\\n    fallback() external payable;\\n}\\n\",\"keccak256\":\"0x883f8d2b25d540915ac4cfededee1c4ee3f4ca90e3fe71748fd0e4b46d752c6a\",\"license\":\"BUSL-1.1\"},\"contracts/src/libraries/LibBasisPoints.sol\":{\"content\":\"//SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\n/// @title Lib Basis Points\\n/// @notice Holds the basis points max value\\nlibrary LibBasisPoints {\\n    /// @notice The max value for basis points (represents 100%)\\n    uint256 internal constant BASIS_POINTS_MAX = 10_000;\\n}\\n\",\"keccak256\":\"0x87e0393c2317b33ae449221747b42f7237362adf9b7a0902433d57574473303a\",\"license\":\"BUSL-1.1\"},\"contracts/src/libraries/LibErrors.sol\":{\"content\":\"//SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\n/// @title Lib Errors\\n/// @notice Library of common errors\\nlibrary LibErrors {\\n    /// @notice The operator is unauthorized for the caller\\n    /// @param caller Address performing the call\\n    error Unauthorized(address caller);\\n\\n    /// @notice The call was invalid\\n    error InvalidCall();\\n\\n    /// @notice The argument was invalid\\n    error InvalidArgument();\\n\\n    /// @notice The address is zero\\n    error InvalidZeroAddress();\\n\\n    /// @notice The string is empty\\n    error InvalidEmptyString();\\n\\n    /// @notice The fee is invalid\\n    error InvalidFee();\\n}\\n\",\"keccak256\":\"0xc6f936719c01ce7ee4ba9ef66e8af75ca8a09b216efd38c0d66d87d08b05bc95\",\"license\":\"BUSL-1.1\"},\"contracts/src/libraries/LibSanitize.sol\":{\"content\":\"//SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\nimport \\\"./LibErrors.sol\\\";\\nimport \\\"./LibBasisPoints.sol\\\";\\n\\n/// @title Lib Sanitize\\n/// @notice Utilities to sanitize input values\\nlibrary LibSanitize {\\n    /// @notice Reverts if address is 0\\n    /// @param _address Address to check\\n    function _notZeroAddress(address _address) internal pure {\\n        if (_address == address(0)) {\\n            revert LibErrors.InvalidZeroAddress();\\n        }\\n    }\\n\\n    /// @notice Reverts if string is empty\\n    /// @param _string String to check\\n    function _notEmptyString(string memory _string) internal pure {\\n        if (bytes(_string).length == 0) {\\n            revert LibErrors.InvalidEmptyString();\\n        }\\n    }\\n\\n    /// @notice Reverts if fee is invalid\\n    /// @param _fee Fee to check\\n    function _validFee(uint256 _fee) internal pure {\\n        if (_fee > LibBasisPoints.BASIS_POINTS_MAX) {\\n            revert LibErrors.InvalidFee();\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xce078083ab565058f68cd7be35ffeb0d88ab990a769c905094520a46edbccfee\",\"license\":\"BUSL-1.1\"},\"contracts/src/libraries/LibUint256.sol\":{\"content\":\"//SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\n/// @title Lib Uint256\\n/// @notice Utilities to perform uint operations\\nlibrary LibUint256 {\\n    /// @notice Converts a value to little endian (64 bits)\\n    /// @param _value The value to convert\\n    /// @return result The converted value\\n    function toLittleEndian64(uint256 _value) internal pure returns (uint256 result) {\\n        uint256 tempValue = _value;\\n        result = tempValue & 0xFF;\\n        tempValue >>= 8;\\n\\n        result = (result << 8) | (tempValue & 0xFF);\\n        tempValue >>= 8;\\n\\n        result = (result << 8) | (tempValue & 0xFF);\\n        tempValue >>= 8;\\n\\n        result = (result << 8) | (tempValue & 0xFF);\\n        tempValue >>= 8;\\n\\n        result = (result << 8) | (tempValue & 0xFF);\\n        tempValue >>= 8;\\n\\n        result = (result << 8) | (tempValue & 0xFF);\\n        tempValue >>= 8;\\n\\n        result = (result << 8) | (tempValue & 0xFF);\\n        tempValue >>= 8;\\n\\n        result = (result << 8) | (tempValue & 0xFF);\\n        tempValue >>= 8;\\n\\n        assert(0 == tempValue); // fully converted\\n        result <<= (24 * 8);\\n    }\\n\\n    /// @notice Returns the minimum value\\n    /// @param _a First value\\n    /// @param _b Second value\\n    /// @return Smallest value between _a and _b\\n    function min(uint256 _a, uint256 _b) internal pure returns (uint256) {\\n        return (_a > _b ? _b : _a);\\n    }\\n\\n    /// @notice Returns the max value\\n    /// @param _a First value\\n    /// @param _b Second value\\n    /// @return Highest value between _a and _b\\n    function max(uint256 _a, uint256 _b) internal pure returns (uint256) {\\n        return (_a < _b ? _b : _a);\\n    }\\n\\n    /// @notice Performs a ceiled division\\n    /// @param _a Numerator\\n    /// @param _b Denominator\\n    /// @return ceil(_a / _b)\\n    function ceil(uint256 _a, uint256 _b) internal pure returns (uint256) {\\n        return (_a / _b) + (_a % _b > 0 ? 1 : 0);\\n    }\\n}\\n\",\"keccak256\":\"0x18d3a772fd7ee36faa69bd6d97f0d3eeae39b90ff42c1f66352650f09a940e17\",\"license\":\"BUSL-1.1\"},\"contracts/src/libraries/LibUnstructuredStorage.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.20;\\n\\n/// @title Lib Unstructured Storage\\n/// @notice Utilities to work with unstructured storage\\nlibrary LibUnstructuredStorage {\\n    /// @notice Retrieve a bool value at a storage slot\\n    /// @param _position The storage slot to retrieve\\n    /// @return data The bool value\\n    function getStorageBool(bytes32 _position) internal view returns (bool data) {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            data := sload(_position)\\n        }\\n    }\\n\\n    /// @notice Retrieve an address value at a storage slot\\n    /// @param _position The storage slot to retrieve\\n    /// @return data The address value\\n    function getStorageAddress(bytes32 _position) internal view returns (address data) {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            data := sload(_position)\\n        }\\n    }\\n\\n    /// @notice Retrieve a bytes32 value at a storage slot\\n    /// @param _position The storage slot to retrieve\\n    /// @return data The bytes32 value\\n    function getStorageBytes32(bytes32 _position) internal view returns (bytes32 data) {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            data := sload(_position)\\n        }\\n    }\\n\\n    /// @notice Retrieve an uint256 value at a storage slot\\n    /// @param _position The storage slot to retrieve\\n    /// @return data The uint256 value\\n    function getStorageUint256(bytes32 _position) internal view returns (uint256 data) {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            data := sload(_position)\\n        }\\n    }\\n\\n    /// @notice Sets a bool value at a storage slot\\n    /// @param _position The storage slot to set\\n    /// @param _data The bool value to set\\n    function setStorageBool(bytes32 _position, bool _data) internal {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            sstore(_position, _data)\\n        }\\n    }\\n\\n    /// @notice Sets an address value at a storage slot\\n    /// @param _position The storage slot to set\\n    /// @param _data The address value to set\\n    function setStorageAddress(bytes32 _position, address _data) internal {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            sstore(_position, _data)\\n        }\\n    }\\n\\n    /// @notice Sets a bytes32 value at a storage slot\\n    /// @param _position The storage slot to set\\n    /// @param _data The bytes32 value to set\\n    function setStorageBytes32(bytes32 _position, bytes32 _data) internal {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            sstore(_position, _data)\\n        }\\n    }\\n\\n    /// @notice Sets an uint256 value at a storage slot\\n    /// @param _position The storage slot to set\\n    /// @param _data The uint256 value to set\\n    function setStorageUint256(bytes32 _position, uint256 _data) internal {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            sstore(_position, _data)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xe48b249b789acdd6f9e1b80f6b1dc3fc69d5593c8b836fad803b7d9fd10dd841\",\"license\":\"BUSL-1.1\"},\"contracts/src/state/river/CLSpec.sol\":{\"content\":\"//SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\n/// @title Consensus Layer Spec Storage\\n/// @notice Utility to manage the Consensus Layer Spec in storage\\nlibrary CLSpec {\\n    /// @notice Storage slot of the Consensus Layer Spec\\n    bytes32 internal constant CL_SPEC_SLOT = bytes32(uint256(keccak256(\\\"river.state.clSpec\\\")) - 1);\\n\\n    /// @notice The Consensus Layer Spec structure\\n    struct CLSpecStruct {\\n        /// @custom:attribute The count of epochs per frame, 225 means 24h\\n        uint64 epochsPerFrame;\\n        /// @custom:attribute The count of slots in an epoch (32 on mainnet)\\n        uint64 slotsPerEpoch;\\n        /// @custom:attribute The seconds in a slot (12 on mainnet)\\n        uint64 secondsPerSlot;\\n        /// @custom:attribute The block timestamp of the first consensus layer block\\n        uint64 genesisTime;\\n        /// @custom:attribute The count of epochs before considering an epoch final on-chain\\n        uint64 epochsToAssumedFinality;\\n    }\\n\\n    /// @notice The structure in storage\\n    struct Slot {\\n        /// @custom:attribute The structure in storage\\n        CLSpecStruct value;\\n    }\\n\\n    /// @notice Retrieve the Consensus Layer Spec from storage\\n    /// @return The Consensus Layer Spec\\n    function get() internal view returns (CLSpecStruct memory) {\\n        bytes32 slot = CL_SPEC_SLOT;\\n\\n        Slot storage r;\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n\\n        return r.value;\\n    }\\n\\n    /// @notice Set the Consensus Layer Spec value in storage\\n    /// @param _newCLSpec The new value to set in storage\\n    function set(CLSpecStruct memory _newCLSpec) internal {\\n        bytes32 slot = CL_SPEC_SLOT;\\n\\n        Slot storage r;\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n\\n        r.value = _newCLSpec;\\n    }\\n}\\n\",\"keccak256\":\"0x111bed0ac40bd03195b1091cb1d01b325af7390d5ec5297955cc5567f70fd2cc\",\"license\":\"BUSL-1.1\"},\"contracts/src/state/river/DailyCommittableLimits.sol\":{\"content\":\"//SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\nimport \\\"../../libraries/LibSanitize.sol\\\";\\n\\n/// @title Daily Committable Limits storage\\n/// @notice Utility to manage the Daily Committable Limits in storage\\nlibrary DailyCommittableLimits {\\n    /// @notice Storage slot of the Daily Committable Limits storage\\n    bytes32 internal constant DAILY_COMMITTABLE_LIMITS_SLOT =\\n        bytes32(uint256(keccak256(\\\"river.state.dailyCommittableLimits\\\")) - 1);\\n\\n    /// @notice The daily committable limits structure\\n    struct DailyCommittableLimitsStruct {\\n        uint128 minDailyNetCommittableAmount;\\n        uint128 maxDailyRelativeCommittableAmount;\\n    }\\n\\n    /// @notice The structure in storage\\n    struct Slot {\\n        /// @custom:attribute The structure in storage\\n        DailyCommittableLimitsStruct value;\\n    }\\n\\n    /// @notice Retrieve the Daily Committable Limits from storage\\n    /// @return The Daily Committable Limits\\n    function get() internal view returns (DailyCommittableLimitsStruct memory) {\\n        bytes32 slot = DAILY_COMMITTABLE_LIMITS_SLOT;\\n\\n        Slot storage r;\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n\\n        return r.value;\\n    }\\n\\n    /// @notice Set the Daily Committable Limits value in storage\\n    /// @param _newValue The new value to set in storage\\n    function set(DailyCommittableLimitsStruct memory _newValue) internal {\\n        bytes32 slot = DAILY_COMMITTABLE_LIMITS_SLOT;\\n\\n        Slot storage r;\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n\\n        r.value = _newValue;\\n    }\\n}\\n\",\"keccak256\":\"0x5299d5f41a6f24b09b81a1a00da6db15fbe2aa16718bc435ecb60016897f1f90\",\"license\":\"BUSL-1.1\"},\"contracts/src/state/river/ReportBounds.sol\":{\"content\":\"//SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\n/// @title Report Bounds Storage\\n/// @notice Utility to manage the Report Bounds in storage\\nlibrary ReportBounds {\\n    /// @notice Storage slot of the Report Bounds\\n    bytes32 internal constant REPORT_BOUNDS_SLOT = bytes32(uint256(keccak256(\\\"river.state.reportBounds\\\")) - 1);\\n\\n    /// @notice The Report Bounds structure\\n    struct ReportBoundsStruct {\\n        /// @custom:attribute The maximum allowed annual apr, checked before submitting a report to River\\n        uint256 annualAprUpperBound;\\n        /// @custom:attribute The maximum allowed balance decrease, also checked before submitting a report to River\\n        uint256 relativeLowerBound;\\n    }\\n\\n    /// @notice The structure in storage\\n    struct Slot {\\n        /// @custom:attribute The structure in storage\\n        ReportBoundsStruct value;\\n    }\\n\\n    /// @notice Retrieve the Report Bounds from storage\\n    /// @return The Report Bounds\\n    function get() internal view returns (ReportBoundsStruct memory) {\\n        bytes32 slot = REPORT_BOUNDS_SLOT;\\n\\n        Slot storage r;\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n\\n        return r.value;\\n    }\\n\\n    /// @notice Set the Report Bounds in storage\\n    /// @param _newReportBounds The new Report Bounds value\\n    function set(ReportBoundsStruct memory _newReportBounds) internal {\\n        bytes32 slot = REPORT_BOUNDS_SLOT;\\n\\n        Slot storage r;\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n\\n        r.value = _newReportBounds;\\n    }\\n}\\n\",\"keccak256\":\"0x032757c478e9132a66b7da31e2eb5f85f8f818503b51b3783c088d3625b3403a\",\"license\":\"BUSL-1.1\"},\"contracts/src/state/shared/RiverAddress.sol\":{\"content\":\"//SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\nimport \\\"../../libraries/LibSanitize.sol\\\";\\nimport \\\"../../libraries/LibUnstructuredStorage.sol\\\";\\n\\n/// @title River Address Storage\\n/// @notice Utility to manage the River Address in storage\\nlibrary RiverAddress {\\n    /// @notice Storage slot of the River Address\\n    bytes32 internal constant RIVER_ADDRESS_SLOT = bytes32(uint256(keccak256(\\\"river.state.riverAddress\\\")) - 1);\\n\\n    /// @notice Retrieve the River Address\\n    /// @return The River Address\\n    function get() internal view returns (address) {\\n        return LibUnstructuredStorage.getStorageAddress(RIVER_ADDRESS_SLOT);\\n    }\\n\\n    /// @notice Sets the River Address\\n    /// @param _newValue New River Address\\n    function set(address _newValue) internal {\\n        LibSanitize._notZeroAddress(_newValue);\\n        LibUnstructuredStorage.setStorageAddress(RIVER_ADDRESS_SLOT, _newValue);\\n    }\\n}\\n\",\"keccak256\":\"0xf8e4d6ce9f7070232e15411daa2d9d3163f98a67f7257fb238911a8d4e51acdc\",\"license\":\"BUSL-1.1\"},\"contracts/src/state/shared/Version.sol\":{\"content\":\"//SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\nimport \\\"../../libraries/LibUnstructuredStorage.sol\\\";\\n\\n/// @title Version Storage\\n/// @notice Utility to manage the Version in storage\\nlibrary Version {\\n    /// @notice Storage slot of the Version\\n    bytes32 public constant VERSION_SLOT = bytes32(uint256(keccak256(\\\"river.state.version\\\")) - 1);\\n\\n    /// @notice Retrieve the Version\\n    /// @return The Version\\n    function get() internal view returns (uint256) {\\n        return LibUnstructuredStorage.getStorageUint256(VERSION_SLOT);\\n    }\\n\\n    /// @notice Sets the Version\\n    /// @param _newValue New Version\\n    function set(uint256 _newValue) internal {\\n        LibUnstructuredStorage.setStorageUint256(VERSION_SLOT, _newValue);\\n    }\\n}\\n\",\"keccak256\":\"0x011c09f065ea555f6fbaa99710c1388bcb047afef30ab6558ca1ee81980ebf01\",\"license\":\"BUSL-1.1\"},\"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\",\"keccak256\":\"0x287b55befed2961a7eabd7d7b1b2839cbca8a5b80ef8dcbb25ed3d4c2002c305\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60808060405234610092577f1809e49bba43f2d39fa57894b50cd6ccb428cc438230e065cac3eb24a1355a7190600019807f82055909238c0f5e63d6f174068ebb8f51bcec9bd37de63bb68f6551feec0cfc558152604060208201523660408201523660006060830137600060603683010152606081601f19601f3601168101030190a160405161033490816100988239f35b600080fdfe6080604081815260049182361015610028575b503615610026575163574b16a760e11b8152fd5b005b600090813560e01c9081635404dd79146101d35750806354fd4d50146101375763c8a6dfd30361001257919034610133576020366003190112610133577f1ec4138404500a2a0be2c2f9b103581c2a7fa783a934f91a6cc5cc924404973b546001600160a01b03169180353384900361011c5784904790818111156101145750935b846100b3575080f35b803b15610110578284518096819363efd6034760e01b83525af18015610106576100db578380f35b67ffffffffffffffff83116100f35750523880808380f35b634e487b7160e01b845260419052602483fd5b82513d86823e3d90fd5b5080fd5b9050936100aa565b50602491519063472511eb60e11b82523390820152fd5b8280fd5b5091346101335782600319360112610133578151908282019082821067ffffffffffffffff8311176101c05750825260058152602090640312e322e360dc1b8282015282519382859384528251928382860152825b8481106101aa57505050828201840152601f01601f19168101030190f35b818101830151888201880152879550820161018c565b634e487b7160e01b855260419052602484fd5b91929050346101335760203660031901126101335783356001600160a01b038116928382036102fa577f82055909238c0f5e63d6f174068ebb8f51bcec9bd37de63bb68f6551feec0cfc908154806102df5750506001905582156102cf577f1809e49bba43f2d39fa57894b50cd6ccb428cc438230e065cac3eb24a1355a719394507f1ec4138404500a2a0be2c2f9b103581c2a7fa783a934f91a6cc5cc924404973b558051917ffc0d749143b04e0d92a3b49edae84a45f6bc88b75e99d9118ec4d7e87fe626c58580a28382528060208301523690820152368360608301378260603683010152606081601f19601f3601168101030190a180f35b815163f6b2911f60e01b81528590fd5b631cfd276760e31b8252818801879052602482015260449150fd5b8480fdfea2646970667358221220155f69040f6d7e5fe0dc61318fd4a9db1f710499c7a498939e1e4331e927b50b64736f6c63430008140033",
  "deployedBytecode": "0x6080604081815260049182361015610028575b503615610026575163574b16a760e11b8152fd5b005b600090813560e01c9081635404dd79146101d35750806354fd4d50146101375763c8a6dfd30361001257919034610133576020366003190112610133577f1ec4138404500a2a0be2c2f9b103581c2a7fa783a934f91a6cc5cc924404973b546001600160a01b03169180353384900361011c5784904790818111156101145750935b846100b3575080f35b803b15610110578284518096819363efd6034760e01b83525af18015610106576100db578380f35b67ffffffffffffffff83116100f35750523880808380f35b634e487b7160e01b845260419052602483fd5b82513d86823e3d90fd5b5080fd5b9050936100aa565b50602491519063472511eb60e11b82523390820152fd5b8280fd5b5091346101335782600319360112610133578151908282019082821067ffffffffffffffff8311176101c05750825260058152602090640312e322e360dc1b8282015282519382859384528251928382860152825b8481106101aa57505050828201840152601f01601f19168101030190f35b818101830151888201880152879550820161018c565b634e487b7160e01b855260419052602484fd5b91929050346101335760203660031901126101335783356001600160a01b038116928382036102fa577f82055909238c0f5e63d6f174068ebb8f51bcec9bd37de63bb68f6551feec0cfc908154806102df5750506001905582156102cf577f1809e49bba43f2d39fa57894b50cd6ccb428cc438230e065cac3eb24a1355a719394507f1ec4138404500a2a0be2c2f9b103581c2a7fa783a934f91a6cc5cc924404973b558051917ffc0d749143b04e0d92a3b49edae84a45f6bc88b75e99d9118ec4d7e87fe626c58580a28382528060208301523690820152368360608301378260603683010152606081601f19601f3601168101030190a180f35b815163f6b2911f60e01b81528590fd5b631cfd276760e31b8252818801879052602482015260449150fd5b8480fdfea2646970667358221220155f69040f6d7e5fe0dc61318fd4a9db1f710499c7a498939e1e4331e927b50b64736f6c63430008140033",
  "devdoc": {
    "author": "Alluvial Finance Inc.",
    "errors": {
      "InvalidInitialization(uint256,uint256)": [
        {
          "params": {
            "expectedVersion": "The version that was expected",
            "version": "The version that was attempting to be initialized"
          }
        }
      ],
      "Unauthorized(address)": [
        {
          "params": {
            "caller": "Address performing the call"
          }
        }
      ]
    },
    "events": {
      "Initialize(uint256,bytes)": {
        "params": {
          "cdata": "Complete calldata that was used during the initialization",
          "version": "New version of the contracts"
        }
      },
      "SetRiver(address)": {
        "params": {
          "river": "The new river address"
        }
      }
    },
    "kind": "dev",
    "methods": {
      "initELFeeRecipientV1(address)": {
        "params": {
          "_riverAddress": "Address of River"
        }
      },
      "pullELFees(uint256)": {
        "details": "Only callable by the River contract",
        "params": {
          "_maxAmount": "The maximum amount to pull into the system"
        }
      },
      "version()": {
        "returns": {
          "_0": "Version of the contract"
        }
      }
    },
    "title": "Execution Layer Fee Recipient (v1)",
    "version": 1
  },
  "userdoc": {
    "errors": {
      "InvalidCall()": [
        {
          "notice": "The fallback has been triggered"
        }
      ],
      "InvalidInitialization(uint256,uint256)": [
        {
          "notice": "An error occured during the initialization"
        }
      ],
      "InvalidZeroAddress()": [
        {
          "notice": "The address is zero"
        }
      ],
      "Unauthorized(address)": [
        {
          "notice": "The operator is unauthorized for the caller"
        }
      ]
    },
    "events": {
      "Initialize(uint256,bytes)": {
        "notice": "Emitted when the contract is properly initialized"
      },
      "SetRiver(address)": {
        "notice": "The storage river address has changed"
      }
    },
    "kind": "user",
    "methods": {
      "initELFeeRecipientV1(address)": {
        "notice": "Initialize the fee recipient with the required arguments"
      },
      "pullELFees(uint256)": {
        "notice": "Pulls ETH to the River contract"
      },
      "version()": {
        "notice": "Retrieves the version of the contract"
      }
    },
    "notice": "This contract receives all the execution layer fees from the proposed blocks + bribes",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}