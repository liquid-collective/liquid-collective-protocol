{
  "address": "0x57Ce8e0AB7E9BD0489E9D2C0f297dfd85aF5cE33",
  "abi": [
    {
      "inputs": [],
      "name": "EmptyDonation",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidCall",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "version",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "expectedVersion",
          "type": "uint256"
        }
      ],
      "name": "InvalidInitialization",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidZeroAddress",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "caller",
          "type": "address"
        }
      ],
      "name": "Unauthorized",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "donator",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "Donate",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "version",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "cdata",
          "type": "bytes"
        }
      ],
      "name": "Initialize",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "river",
          "type": "address"
        }
      ],
      "name": "SetRiver",
      "type": "event"
    },
    {
      "stateMutability": "payable",
      "type": "fallback"
    },
    {
      "inputs": [],
      "name": "donate",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_riverAddress",
          "type": "address"
        }
      ],
      "name": "initCoverageFundV1",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_maxAmount",
          "type": "uint256"
        }
      ],
      "name": "pullCoverageFunds",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "version",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "stateMutability": "payable",
      "type": "receive"
    }
  ],
  "transactionHash": "0x38ddfb56b1fe0f21abf979da7ce9e79d3c2e7f486b0081cf4c7b4d74506778db",
  "receipt": {
    "to": null,
    "from": "0x341C40B94bF2afBFa42573cB78f16Ee15a056238",
    "contractAddress": "0x57Ce8e0AB7E9BD0489E9D2C0f297dfd85aF5cE33",
    "transactionIndex": 15,
    "gasUsed": "370273",
    "logsBloom": "0x00000000000040000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000020000000002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x3440f4234ed3bf0886fd052d747f10a9fab43066dd32b204e62dd9d0b4345556",
    "transactionHash": "0x38ddfb56b1fe0f21abf979da7ce9e79d3c2e7f486b0081cf4c7b4d74506778db",
    "logs": [
      {
        "transactionIndex": 15,
        "blockNumber": 2457941,
        "transactionHash": "0x38ddfb56b1fe0f21abf979da7ce9e79d3c2e7f486b0081cf4c7b4d74506778db",
        "address": "0x57Ce8e0AB7E9BD0489E9D2C0f297dfd85aF5cE33",
        "topics": [
          "0x1809e49bba43f2d39fa57894b50cd6ccb428cc438230e065cac3eb24a1355a71"
        ],
        "data": "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000",
        "logIndex": 40,
        "blockHash": "0x3440f4234ed3bf0886fd052d747f10a9fab43066dd32b204e62dd9d0b4345556"
      }
    ],
    "blockNumber": 2457941,
    "cumulativeGasUsed": "1599884",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "7ebc7ef25dc340660cce17b337ec071d",
  "metadata": "{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"EmptyDonation\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidCall\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expectedVersion\",\"type\":\"uint256\"}],\"name\":\"InvalidInitialization\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidZeroAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"donator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Donate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"cdata\",\"type\":\"bytes\"}],\"name\":\"Initialize\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"river\",\"type\":\"address\"}],\"name\":\"SetRiver\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"donate\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_riverAddress\",\"type\":\"address\"}],\"name\":\"initCoverageFundV1\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxAmount\",\"type\":\"uint256\"}],\"name\":\"pullCoverageFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}],\"devdoc\":{\"author\":\"Alluvial Finance Inc.\",\"errors\":{\"InvalidInitialization(uint256,uint256)\":[{\"params\":{\"expectedVersion\":\"The version that was expected\",\"version\":\"The version that was attempting to be initialized\"}}],\"Unauthorized(address)\":[{\"params\":{\"caller\":\"Address performing the call\"}}]},\"events\":{\"Donate(address,uint256)\":{\"params\":{\"amount\":\"The amount donated\",\"donator\":\"Address that performed the donation\"}},\"Initialize(uint256,bytes)\":{\"params\":{\"cdata\":\"Complete calldata that was used during the initialization\",\"version\":\"New version of the contracts\"}},\"SetRiver(address)\":{\"params\":{\"river\":\"The new river address\"}}},\"kind\":\"dev\",\"methods\":{\"initCoverageFundV1(address)\":{\"params\":{\"_riverAddress\":\"Address of River\"}},\"pullCoverageFunds(uint256)\":{\"details\":\"Only callable by the River contract\",\"params\":{\"_maxAmount\":\"The maximum amount to pull into the system\"}},\"version()\":{\"returns\":{\"_0\":\"Version of the contract\"}}},\"title\":\"Coverage Fund (v1)\",\"version\":1},\"userdoc\":{\"errors\":{\"EmptyDonation()\":[{\"notice\":\"A donation with 0 ETH has been performed\"}],\"InvalidCall()\":[{\"notice\":\"The fallback or receive callback has been triggered\"}],\"InvalidInitialization(uint256,uint256)\":[{\"notice\":\"An error occured during the initialization\"}],\"InvalidZeroAddress()\":[{\"notice\":\"The address is zero\"}],\"Unauthorized(address)\":[{\"notice\":\"The operator is unauthorized for the caller\"}]},\"events\":{\"Donate(address,uint256)\":{\"notice\":\"A donation has been made to the coverage fund\"},\"Initialize(uint256,bytes)\":{\"notice\":\"Emitted when the contract is properly initialized\"},\"SetRiver(address)\":{\"notice\":\"The storage river address has changed\"}},\"kind\":\"user\",\"methods\":{\"donate()\":{\"notice\":\"Donates ETH to the coverage fund contract\"},\"initCoverageFundV1(address)\":{\"notice\":\"Initialize the coverage fund with the required arguments\"},\"pullCoverageFunds(uint256)\":{\"notice\":\"Pulls ETH into the River contract\"},\"version()\":{\"notice\":\"Retrieves the version of the contract\"}},\"notice\":\"This contract receive donations for the slashing coverage fund and pull the funds into riverThis contract acts as a temporary buffer for funds that should be pulled in case of a loss of money on the consensus layer due to slashing events.There is no fee taken on these funds, they are entirely distributed to the LsETH holders, and no shares will get minted.Funds will be distributed by increasing the underlying value of every LsETH share.The fund will be called on every report and if eth is available in the contract, River will attempt to pull as muchETH as possible. This maximum is defined by the upper bound allowed by the Oracle. This means that it might take multiplereports for funds to be pulled entirely into the system due to this upper bound, ensuring a lower secondary market impact.The value provided to this contract is computed off-chain and provided manually by Alluvial or any authorized insurance entity.The Coverage funds are pulled upon an oracle report, after the ELFees have been pulled in the system, if there is a margin leftbefore crossing the upper bound. The reason behind this is to favor the revenue stream, that depends on market and network usage, whilethe coverage fund will be pulled after the revenue stream, and there won't be any commission on the eth pulled.Once a Slashing event occurs, the team will do its best to inject the recovery funds in at maximum 365 daysThe entities allowed to donate are selected by the team. It will mainly be treasury entities or insurance protocols able to fill this coverage fund properly.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/src/CoverageFund.1.sol\":\"CoverageFundV1\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":100},\"remappings\":[],\"viaIR\":true},\"sources\":{\"contracts/src/CoverageFund.1.sol\":{\"content\":\"//SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\nimport \\\"./interfaces/IRiver.1.sol\\\";\\nimport \\\"./interfaces/IAllowlist.1.sol\\\";\\nimport \\\"./interfaces/ICoverageFund.1.sol\\\";\\nimport \\\"./interfaces/IProtocolVersion.sol\\\";\\n\\nimport \\\"./libraries/LibUint256.sol\\\";\\nimport \\\"./libraries/LibAllowlistMasks.sol\\\";\\n\\nimport \\\"./Initializable.sol\\\";\\n\\nimport \\\"./state/shared/RiverAddress.sol\\\";\\nimport \\\"./state/slashingCoverage/BalanceForCoverage.sol\\\";\\n\\n/// @title Coverage Fund (v1)\\n/// @author Alluvial Finance Inc.\\n/// @notice This contract receive donations for the slashing coverage fund and pull the funds into river\\n/// @notice This contract acts as a temporary buffer for funds that should be pulled in case of a loss of money on the consensus layer due to slashing events.\\n/// @notice There is no fee taken on these funds, they are entirely distributed to the LsETH holders, and no shares will get minted.\\n/// @notice Funds will be distributed by increasing the underlying value of every LsETH share.\\n/// @notice The fund will be called on every report and if eth is available in the contract, River will attempt to pull as much\\n/// @notice ETH as possible. This maximum is defined by the upper bound allowed by the Oracle. This means that it might take multiple\\n/// @notice reports for funds to be pulled entirely into the system due to this upper bound, ensuring a lower secondary market impact.\\n/// @notice The value provided to this contract is computed off-chain and provided manually by Alluvial or any authorized insurance entity.\\n/// @notice The Coverage funds are pulled upon an oracle report, after the ELFees have been pulled in the system, if there is a margin left\\n/// @notice before crossing the upper bound. The reason behind this is to favor the revenue stream, that depends on market and network usage, while\\n/// @notice the coverage fund will be pulled after the revenue stream, and there won't be any commission on the eth pulled.\\n/// @notice Once a Slashing event occurs, the team will do its best to inject the recovery funds in at maximum 365 days\\n/// @notice The entities allowed to donate are selected by the team. It will mainly be treasury entities or insurance protocols able to fill this coverage fund properly.\\ncontract CoverageFundV1 is Initializable, ICoverageFundV1, IProtocolVersion {\\n    /// @inheritdoc ICoverageFundV1\\n    function initCoverageFundV1(address _riverAddress) external init(0) {\\n        RiverAddress.set(_riverAddress);\\n        emit SetRiver(_riverAddress);\\n    }\\n\\n    /// @inheritdoc ICoverageFundV1\\n    function pullCoverageFunds(uint256 _maxAmount) external {\\n        address river = RiverAddress.get();\\n        if (msg.sender != river) {\\n            revert LibErrors.Unauthorized(msg.sender);\\n        }\\n        uint256 amount = LibUint256.min(_maxAmount, BalanceForCoverage.get());\\n\\n        if (amount > 0) {\\n            BalanceForCoverage.set(BalanceForCoverage.get() - amount);\\n            IRiverV1(payable(river)).sendCoverageFunds{value: amount}();\\n        }\\n    }\\n\\n    /// @inheritdoc ICoverageFundV1\\n    function donate() external payable {\\n        if (msg.value == 0) {\\n            revert EmptyDonation();\\n        }\\n        BalanceForCoverage.set(BalanceForCoverage.get() + msg.value);\\n\\n        IAllowlistV1 allowlist = IAllowlistV1(IRiverV1(payable(RiverAddress.get())).getAllowlist());\\n        allowlist.onlyAllowed(msg.sender, LibAllowlistMasks.DONATE_MASK);\\n\\n        emit Donate(msg.sender, msg.value);\\n    }\\n\\n    /// @inheritdoc ICoverageFundV1\\n    receive() external payable {\\n        revert InvalidCall();\\n    }\\n\\n    /// @inheritdoc ICoverageFundV1\\n    fallback() external payable {\\n        revert InvalidCall();\\n    }\\n\\n    function version() external pure returns (string memory) {\\n        return \\\"1.2.1\\\";\\n    }\\n}\\n\",\"keccak256\":\"0x959e62eefa62c194a14057363b6e42f6926078aced5ddb069c773499716188ee\",\"license\":\"BUSL-1.1\"},\"contracts/src/Initializable.sol\":{\"content\":\"//SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\nimport \\\"./state/shared/Version.sol\\\";\\n\\n/// @title Initializable\\n/// @author Alluvial Finance Inc.\\n/// @notice This contract ensures that initializers are called only once per version\\ncontract Initializable {\\n    /// @notice Disable initialization on implementations\\n    constructor() {\\n        Version.set(type(uint256).max);\\n        emit Initialize(type(uint256).max, msg.data);\\n    }\\n\\n    /// @notice An error occured during the initialization\\n    /// @param version The version that was attempting to be initialized\\n    /// @param expectedVersion The version that was expected\\n    error InvalidInitialization(uint256 version, uint256 expectedVersion);\\n\\n    /// @notice Emitted when the contract is properly initialized\\n    /// @param version New version of the contracts\\n    /// @param cdata Complete calldata that was used during the initialization\\n    event Initialize(uint256 version, bytes cdata);\\n\\n    /// @notice Use this modifier on initializers along with a hard-coded version number\\n    /// @param _version Version to initialize\\n    modifier init(uint256 _version) {\\n        if (_version != Version.get()) {\\n            revert InvalidInitialization(_version, Version.get());\\n        }\\n        Version.set(_version + 1); // prevents reentrency on the called method\\n        _;\\n        emit Initialize(_version, msg.data);\\n    }\\n}\\n\",\"keccak256\":\"0xd371aeefbb5ed0d3d3b6efdd70044eb949161e6f534730fd0868f85a204c76c9\",\"license\":\"BUSL-1.1\"},\"contracts/src/interfaces/IAllowlist.1.sol\":{\"content\":\"//SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\n/// @title Allowlist Interface (v1)\\n/// @author Alluvial Finance Inc.\\n/// @notice This interface exposes methods to handle the list of allowed recipients.\\ninterface IAllowlistV1 {\\n    /// @notice The permissions of several accounts have changed\\n    /// @param accounts List of accounts\\n    /// @param permissions New permissions for each account at the same index\\n    event SetAllowlistPermissions(address[] accounts, uint256[] permissions);\\n\\n    /// @notice The stored allower address has been changed\\n    /// @param allower The new allower address\\n    event SetAllower(address indexed allower);\\n\\n    /// @notice The stored denier address has been changed\\n    /// @param denier The new denier address\\n    event SetDenier(address indexed denier);\\n\\n    /// @notice The provided accounts list is empty\\n    error InvalidCount();\\n\\n    /// @notice The account is denied access\\n    /// @param _account The denied account\\n    error Denied(address _account);\\n\\n    /// @notice The provided accounts and permissions list have different lengths\\n    error MismatchedArrayLengths();\\n\\n    /// @notice Allower can't set deny permission\\n    error AttemptToSetDenyPermission();\\n\\n    /// @notice Allower can't remove deny permission\\n    error AttemptToRemoveDenyPermission();\\n\\n    /// @notice Initializes the allowlist\\n    /// @param _admin Address of the Allowlist administrator\\n    /// @param _allower Address of the allower\\n    function initAllowlistV1(address _admin, address _allower) external;\\n\\n    /// @notice Initializes the allowlist denier\\n    /// @param _denier Address of the denier\\n    function initAllowlistV1_1(address _denier) external;\\n\\n    /// @notice Retrieves the allower address\\n    /// @return The address of the allower\\n    function getAllower() external view returns (address);\\n\\n    /// @notice Retrieves the denier address\\n    /// @return The address of the denier\\n    function getDenier() external view returns (address);\\n\\n    /// @notice This method returns true if the user has the expected permission and\\n    ///         is not in the deny list\\n    /// @param _account Recipient to verify\\n    /// @param _mask Combination of permissions to verify\\n    /// @return True if mask is respected and user is allowed\\n    function isAllowed(address _account, uint256 _mask) external view returns (bool);\\n\\n    /// @notice This method returns true if the user is in the deny list\\n    /// @param _account Recipient to verify\\n    /// @return True if user is denied access\\n    function isDenied(address _account) external view returns (bool);\\n\\n    /// @notice This method returns true if the user has the expected permission\\n    ///         ignoring any deny list membership\\n    /// @param _account Recipient to verify\\n    /// @param _mask Combination of permissions to verify\\n    /// @return True if mask is respected\\n    function hasPermission(address _account, uint256 _mask) external view returns (bool);\\n\\n    /// @notice This method retrieves the raw permission value\\n    /// @param _account Recipient to verify\\n    /// @return The raw permissions value of the account\\n    function getPermissions(address _account) external view returns (uint256);\\n\\n    /// @notice This method should be used as a modifier and is expected to revert\\n    ///         if the user hasn't got the required permission or if the user is\\n    ///         in the deny list.\\n    /// @param _account Recipient to verify\\n    /// @param _mask Combination of permissions to verify\\n    function onlyAllowed(address _account, uint256 _mask) external view;\\n\\n    /// @notice Changes the allower address\\n    /// @param _newAllowerAddress New address allowed to edit the allowlist\\n    function setAllower(address _newAllowerAddress) external;\\n\\n    /// @notice Changes the denier address\\n    /// @param _newDenierAddress New address allowed to edit the allowlist\\n    function setDenier(address _newDenierAddress) external;\\n\\n    /// @notice Sets the allow permissions for one or more accounts\\n    /// @dev This function is for allocating or removing deposit, redeem or donate permissions.\\n    ///      This function could be used to give any permissions that we come up with in the future.\\n    ///      An address which was denied has to be undenied first before they could be given any permission(s).\\n    /// @param _accounts Accounts to update\\n    /// @param _permissions New permission values\\n    function setAllowPermissions(address[] calldata _accounts, uint256[] calldata _permissions) external;\\n\\n    /// @notice Sets the deny permissions for one or more accounts\\n    /// @dev This function is for allocating or removing deny permissions.\\n    ///      An address which is undenied has to be given permissions again for them to be able to deposit, donate or redeem.\\n    /// @param _accounts Accounts to update\\n    /// @param _permissions New permission values\\n    function setDenyPermissions(address[] calldata _accounts, uint256[] calldata _permissions) external;\\n}\\n\",\"keccak256\":\"0xa091d5674c42bcfc05e5e35206dfd1235325a630aae6aeae60ff5df8864deab9\",\"license\":\"BUSL-1.1\"},\"contracts/src/interfaces/ICoverageFund.1.sol\":{\"content\":\"//SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\n/// @title Coverage Fund Interface (v1)\\n/// @author Alluvial Finance Inc.\\n/// @notice This interface exposes methods to receive donations for the slashing coverage fund and pull the funds into river\\ninterface ICoverageFundV1 {\\n    /// @notice The storage river address has changed\\n    /// @param river The new river address\\n    event SetRiver(address indexed river);\\n\\n    /// @notice A donation has been made to the coverage fund\\n    /// @param donator Address that performed the donation\\n    /// @param amount The amount donated\\n    event Donate(address indexed donator, uint256 amount);\\n\\n    /// @notice The fallback or receive callback has been triggered\\n    error InvalidCall();\\n\\n    /// @notice A donation with 0 ETH has been performed\\n    error EmptyDonation();\\n\\n    /// @notice Initialize the coverage fund with the required arguments\\n    /// @param _riverAddress Address of River\\n    function initCoverageFundV1(address _riverAddress) external;\\n\\n    /// @notice Pulls ETH into the River contract\\n    /// @dev Only callable by the River contract\\n    /// @param _maxAmount The maximum amount to pull into the system\\n    function pullCoverageFunds(uint256 _maxAmount) external;\\n\\n    /// @notice Donates ETH to the coverage fund contract\\n    function donate() external payable;\\n\\n    /// @notice Ether receiver\\n    receive() external payable;\\n\\n    /// @notice Invalid fallback detector\\n    fallback() external payable;\\n}\\n\",\"keccak256\":\"0x5ec3a216e7691dd40fc67a9e8f652eb20db1f1e2392f09a9af4dabddfa8d3ddf\",\"license\":\"BUSL-1.1\"},\"contracts/src/interfaces/IProtocolVersion.sol\":{\"content\":\"//SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\ninterface IProtocolVersion {\\n    /// @notice Retrieves the version of the contract\\n    /// @return Version of the contract\\n    function version() external pure returns (string memory);\\n}\\n\",\"keccak256\":\"0x2fc810a5c001d641d4b19c28631dac46201e3780e91dfeb5dc836f92f1aee8b3\",\"license\":\"BUSL-1.1\"},\"contracts/src/interfaces/IRiver.1.sol\":{\"content\":\"//SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\nimport \\\"../state/river/DailyCommittableLimits.sol\\\";\\n\\nimport \\\"./components/IConsensusLayerDepositManager.1.sol\\\";\\nimport \\\"./components/IOracleManager.1.sol\\\";\\nimport \\\"./components/ISharesManager.1.sol\\\";\\nimport \\\"./components/IUserDepositManager.1.sol\\\";\\n\\n/// @title River Interface (v1)\\n/// @author Alluvial Finance Inc.\\n/// @notice The main system interface\\ninterface IRiverV1 is IConsensusLayerDepositManagerV1, IUserDepositManagerV1, ISharesManagerV1, IOracleManagerV1 {\\n    /// @notice Funds have been pulled from the Execution Layer Fee Recipient\\n    /// @param amount The amount pulled\\n    event PulledELFees(uint256 amount);\\n\\n    /// @notice Funds have been pulled from the Coverage Fund\\n    /// @param amount The amount pulled\\n    event PulledCoverageFunds(uint256 amount);\\n\\n    /// @notice Emitted when funds are pulled from the redeem manager\\n    /// @param amount The amount pulled\\n    event PulledRedeemManagerExceedingEth(uint256 amount);\\n\\n    /// @notice Emitted when funds are pulled from the CL recipient\\n    /// @param pulledSkimmedEthAmount The amount of skimmed ETH pulled\\n    /// @param pullExitedEthAmount The amount of exited ETH pulled\\n    event PulledCLFunds(uint256 pulledSkimmedEthAmount, uint256 pullExitedEthAmount);\\n\\n    /// @notice The stored Execution Layer Fee Recipient has been changed\\n    /// @param elFeeRecipient The new Execution Layer Fee Recipient\\n    event SetELFeeRecipient(address indexed elFeeRecipient);\\n\\n    /// @notice The stored Coverage Fund has been changed\\n    /// @param coverageFund The new Coverage Fund\\n    event SetCoverageFund(address indexed coverageFund);\\n\\n    /// @notice The stored Collector has been changed\\n    /// @param collector The new Collector\\n    event SetCollector(address indexed collector);\\n\\n    /// @notice The stored Allowlist has been changed\\n    /// @param allowlist The new Allowlist\\n    event SetAllowlist(address indexed allowlist);\\n\\n    /// @notice The stored Global Fee has been changed\\n    /// @param fee The new Global Fee\\n    event SetGlobalFee(uint256 fee);\\n\\n    /// @notice The stored Operators Registry has been changed\\n    /// @param operatorRegistry The new Operators Registry\\n    event SetOperatorsRegistry(address indexed operatorRegistry);\\n\\n    /// @notice The stored Metadata URI string has been changed\\n    /// @param metadataURI The new Metadata URI string\\n    event SetMetadataURI(string metadataURI);\\n\\n    /// @notice The system underlying supply increased. This is a snapshot of the balances for accounting purposes\\n    /// @param _collector The address of the collector during this event\\n    /// @param _oldTotalUnderlyingBalance Old total ETH balance under management by River\\n    /// @param _oldTotalSupply Old total supply in shares\\n    /// @param _newTotalUnderlyingBalance New total ETH balance under management by River\\n    /// @param _newTotalSupply New total supply in shares\\n    event RewardsEarned(\\n        address indexed _collector,\\n        uint256 _oldTotalUnderlyingBalance,\\n        uint256 _oldTotalSupply,\\n        uint256 _newTotalUnderlyingBalance,\\n        uint256 _newTotalSupply\\n    );\\n\\n    /// @notice Emitted when the daily committable limits are changed\\n    /// @param minNetAmount The minimum amount that must be used as the daily committable amount\\n    /// @param maxRelativeAmount The maximum amount that can be used as the daily committable amount, relative to the total underlying supply\\n    event SetMaxDailyCommittableAmounts(uint256 minNetAmount, uint256 maxRelativeAmount);\\n\\n    /// @notice Emitted when the redeem manager address is changed\\n    /// @param redeemManager The address of the redeem manager\\n    event SetRedeemManager(address redeemManager);\\n\\n    /// @notice Emitted when the balance to deposit is updated\\n    /// @param oldAmount The old balance to deposit\\n    /// @param newAmount The new balance to deposit\\n    event SetBalanceToDeposit(uint256 oldAmount, uint256 newAmount);\\n\\n    /// @notice Emitted when the balance to redeem is updated\\n    /// @param oldAmount The old balance to redeem\\n    /// @param newAmount The new balance to redeem\\n    event SetBalanceToRedeem(uint256 oldAmount, uint256 newAmount);\\n\\n    /// @notice Emitted when the balance committed to deposit\\n    /// @param oldAmount The old balance committed to deposit\\n    /// @param newAmount The new balance committed to deposit\\n    event SetBalanceCommittedToDeposit(uint256 oldAmount, uint256 newAmount);\\n\\n    /// @notice Emitted when the redeem manager received a withdraw event report\\n    /// @param redeemManagerDemand The total demand in LsETH of the redeem manager\\n    /// @param suppliedRedeemManagerDemand The amount of LsETH demand actually supplied\\n    /// @param suppliedRedeemManagerDemandInEth The amount in ETH of the supplied demand\\n    event ReportedRedeemManager(\\n        uint256 redeemManagerDemand, uint256 suppliedRedeemManagerDemand, uint256 suppliedRedeemManagerDemandInEth\\n    );\\n\\n    /// @notice Thrown when the amount received from the Withdraw contract doe not match the requested amount\\n    /// @param requested The amount that was requested\\n    /// @param received The amount that was received\\n    error InvalidPulledClFundsAmount(uint256 requested, uint256 received);\\n\\n    /// @notice The computed amount of shares to mint is 0\\n    error ZeroMintedShares();\\n\\n    /// @notice The access was denied\\n    /// @param account The account that was denied\\n    error Denied(address account);\\n\\n    /// @notice Initializes the River system\\n    /// @param _depositContractAddress Address to make Consensus Layer deposits\\n    /// @param _elFeeRecipientAddress Address that receives the execution layer fees\\n    /// @param _withdrawalCredentials Credentials to use for every validator deposit\\n    /// @param _oracleAddress The address of the Oracle contract\\n    /// @param _systemAdministratorAddress Administrator address\\n    /// @param _allowlistAddress Address of the allowlist contract\\n    /// @param _operatorRegistryAddress Address of the operator registry\\n    /// @param _collectorAddress Address receiving the the global fee on revenue\\n    /// @param _globalFee Amount retained when the ETH balance increases and sent to the collector\\n    function initRiverV1(\\n        address _depositContractAddress,\\n        address _elFeeRecipientAddress,\\n        bytes32 _withdrawalCredentials,\\n        address _oracleAddress,\\n        address _systemAdministratorAddress,\\n        address _allowlistAddress,\\n        address _operatorRegistryAddress,\\n        address _collectorAddress,\\n        uint256 _globalFee\\n    ) external;\\n\\n    /// @notice Initialized version 1.1 of the River System\\n    /// @param _redeemManager The redeem manager address\\n    /// @param _epochsPerFrame The amounts of epochs in a frame\\n    /// @param _slotsPerEpoch The slots inside an epoch\\n    /// @param _secondsPerSlot The seconds inside a slot\\n    /// @param _genesisTime The genesis timestamp\\n    /// @param _epochsToAssumedFinality The number of epochs before an epoch is considered final on-chain\\n    /// @param _annualAprUpperBound The reporting upper bound\\n    /// @param _relativeLowerBound The reporting lower bound\\n    /// @param _maxDailyNetCommittableAmount_ The net daily committable limit\\n    /// @param _maxDailyRelativeCommittableAmount_ The relative daily committable limit\\n    function initRiverV1_1(\\n        address _redeemManager,\\n        uint64 _epochsPerFrame,\\n        uint64 _slotsPerEpoch,\\n        uint64 _secondsPerSlot,\\n        uint64 _genesisTime,\\n        uint64 _epochsToAssumedFinality,\\n        uint256 _annualAprUpperBound,\\n        uint256 _relativeLowerBound,\\n        uint128 _maxDailyNetCommittableAmount_,\\n        uint128 _maxDailyRelativeCommittableAmount_\\n    ) external;\\n\\n    /// @notice Initializes version 1.2 of the River System\\n    function initRiverV1_2() external;\\n\\n    /// @notice Get the current global fee\\n    /// @return The global fee\\n    function getGlobalFee() external view returns (uint256);\\n\\n    /// @notice Retrieve the allowlist address\\n    /// @return The allowlist address\\n    function getAllowlist() external view returns (address);\\n\\n    /// @notice Retrieve the collector address\\n    /// @return The collector address\\n    function getCollector() external view returns (address);\\n\\n    /// @notice Retrieve the execution layer fee recipient\\n    /// @return The execution layer fee recipient address\\n    function getELFeeRecipient() external view returns (address);\\n\\n    /// @notice Retrieve the coverage fund\\n    /// @return The coverage fund address\\n    function getCoverageFund() external view returns (address);\\n\\n    /// @notice Retrieve the redeem manager\\n    /// @return The redeem manager address\\n    function getRedeemManager() external view returns (address);\\n\\n    /// @notice Retrieve the operators registry\\n    /// @return The operators registry address\\n    function getOperatorsRegistry() external view returns (address);\\n\\n    /// @notice Retrieve the metadata uri string value\\n    /// @return The metadata uri string value\\n    function getMetadataURI() external view returns (string memory);\\n\\n    /// @notice Retrieve the configured daily committable limits\\n    /// @return The daily committable limits structure\\n    function getDailyCommittableLimits()\\n        external\\n        view\\n        returns (DailyCommittableLimits.DailyCommittableLimitsStruct memory);\\n\\n    /// @notice Resolves the provided redeem requests by calling the redeem manager\\n    /// @param _redeemRequestIds The list of redeem requests to resolve\\n    /// @return withdrawalEventIds The list of matching withdrawal events, or error codes\\n    function resolveRedeemRequests(uint32[] calldata _redeemRequestIds)\\n        external\\n        view\\n        returns (int64[] memory withdrawalEventIds);\\n\\n    /// @notice Set the daily committable limits\\n    /// @param _dcl The Daily Committable Limits structure\\n    function setDailyCommittableLimits(DailyCommittableLimits.DailyCommittableLimitsStruct memory _dcl) external;\\n\\n    /// @notice Retrieve the current balance to redeem\\n    /// @return The current balance to redeem\\n    function getBalanceToRedeem() external view returns (uint256);\\n\\n    /// @notice Performs a redeem request on the redeem manager\\n    /// @param _lsETHAmount The amount of LsETH to redeem\\n    /// @param _recipient The address that will own the redeem request\\n    /// @return redeemRequestId The ID of the newly created redeem request\\n    function requestRedeem(uint256 _lsETHAmount, address _recipient) external returns (uint32 redeemRequestId);\\n\\n    /// @notice Claims several redeem requests\\n    /// @param _redeemRequestIds The list of redeem requests to claim\\n    /// @param _withdrawalEventIds The list of resolved withdrawal event ids\\n    /// @return claimStatuses The operation status results\\n    function claimRedeemRequests(uint32[] calldata _redeemRequestIds, uint32[] calldata _withdrawalEventIds)\\n        external\\n        returns (uint8[] memory claimStatuses);\\n\\n    /// @notice Changes the global fee parameter\\n    /// @param _newFee New fee value\\n    function setGlobalFee(uint256 _newFee) external;\\n\\n    /// @notice Changes the allowlist address\\n    /// @param _newAllowlist New address for the allowlist\\n    function setAllowlist(address _newAllowlist) external;\\n\\n    /// @notice Changes the collector address\\n    /// @param _newCollector New address for the collector\\n    function setCollector(address _newCollector) external;\\n\\n    /// @notice Changes the execution layer fee recipient\\n    /// @param _newELFeeRecipient New address for the recipient\\n    function setELFeeRecipient(address _newELFeeRecipient) external;\\n\\n    /// @notice Changes the coverage fund\\n    /// @param _newCoverageFund New address for the fund\\n    function setCoverageFund(address _newCoverageFund) external;\\n\\n    /// @notice Sets the metadata uri string value\\n    /// @param _metadataURI The new metadata uri string value\\n    function setMetadataURI(string memory _metadataURI) external;\\n\\n    /// @notice Input for execution layer fee earnings\\n    function sendELFees() external payable;\\n\\n    /// @notice Input for consensus layer funds, containing both exit and skimming\\n    function sendCLFunds() external payable;\\n\\n    /// @notice Input for coverage funds\\n    function sendCoverageFunds() external payable;\\n\\n    /// @notice Input for the redeem manager funds\\n    function sendRedeemManagerExceedingFunds() external payable;\\n}\\n\",\"keccak256\":\"0xcb57b5480b1849e52fe74552c5aac448fe3c2232a6c72b7d56b34fa9bc878ea1\",\"license\":\"BUSL-1.1\"},\"contracts/src/interfaces/components/IConsensusLayerDepositManager.1.sol\":{\"content\":\"//SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\n/// @title Consensys Layer Deposit Manager Interface (v1)\\n/// @author Alluvial Finance Inc.\\n/// @notice This interface exposes methods to handle the interactions with the official deposit contract\\ninterface IConsensusLayerDepositManagerV1 {\\n    /// @notice The stored deposit contract address changed\\n    /// @param depositContract Address of the deposit contract\\n    event SetDepositContractAddress(address indexed depositContract);\\n\\n    /// @notice The stored withdrawal credentials changed\\n    /// @param withdrawalCredentials The withdrawal credentials to use for deposits\\n    event SetWithdrawalCredentials(bytes32 withdrawalCredentials);\\n\\n    /// @notice Emitted when the deposited validator count is updated\\n    /// @param oldDepositedValidatorCount The old deposited validator count value\\n    /// @param newDepositedValidatorCount The new deposited validator count value\\n    event SetDepositedValidatorCount(uint256 oldDepositedValidatorCount, uint256 newDepositedValidatorCount);\\n\\n    /// @notice Not enough funds to deposit one validator\\n    error NotEnoughFunds();\\n\\n    /// @notice The length of the BLS Public key is invalid during deposit\\n    error InconsistentPublicKeys();\\n\\n    /// @notice The length of the BLS Signature is invalid during deposit\\n    error InconsistentSignatures();\\n\\n    /// @notice The internal key retrieval returned no keys\\n    error NoAvailableValidatorKeys();\\n\\n    /// @notice The received count of public keys to deposit is invalid\\n    error InvalidPublicKeyCount();\\n\\n    /// @notice The received count of signatures to deposit is invalid\\n    error InvalidSignatureCount();\\n\\n    /// @notice The withdrawal credentials value is null\\n    error InvalidWithdrawalCredentials();\\n\\n    /// @notice An error occured during the deposit\\n    error ErrorOnDeposit();\\n\\n    /// @notice Invalid deposit root\\n    error InvalidDepositRoot();\\n\\n    // @notice Not keeper\\n    error OnlyKeeper();\\n\\n    /// @notice Returns the amount of ETH not yet committed for deposit\\n    /// @return The amount of ETH not yet committed for deposit\\n    function getBalanceToDeposit() external view returns (uint256);\\n\\n    /// @notice Returns the amount of ETH committed for deposit\\n    /// @return The amount of ETH committed for deposit\\n    function getCommittedBalance() external view returns (uint256);\\n\\n    /// @notice Retrieve the withdrawal credentials\\n    /// @return The withdrawal credentials\\n    function getWithdrawalCredentials() external view returns (bytes32);\\n\\n    /// @notice Get the deposited validator count (the count of deposits made by the contract)\\n    /// @return The deposited validator count\\n    function getDepositedValidatorCount() external view returns (uint256);\\n\\n    /// @notice Get the keeper address\\n    /// @return The keeper address\\n    function getKeeper() external view returns (address);\\n\\n    /// @notice Deposits current balance to the Consensus Layer by batches of 32 ETH\\n    /// @param _maxCount The maximum amount of validator keys to fund\\n    /// @param _depositRoot The root of the deposit tree\\n    function depositToConsensusLayerWithDepositRoot(uint256 _maxCount, bytes32 _depositRoot) external;\\n}\\n\",\"keccak256\":\"0xd7e41b30bdc6108f85633988ac53e9196285cee3d28c978054deb76b2268915d\",\"license\":\"BUSL-1.1\"},\"contracts/src/interfaces/components/IOracleManager.1.sol\":{\"content\":\"//SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\nimport \\\"../../state/river/CLSpec.sol\\\";\\nimport \\\"../../state/river/ReportBounds.sol\\\";\\n\\n/// @title Oracle Manager (v1)\\n/// @author Alluvial Finance Inc.\\n/// @notice This interface exposes methods to handle the inputs provided by the oracle\\ninterface IOracleManagerV1 {\\n    /// @notice The stored oracle address changed\\n    /// @param oracleAddress The new oracle address\\n    event SetOracle(address indexed oracleAddress);\\n\\n    /// @notice The consensus layer data provided by the oracle has been updated\\n    /// @param validatorCount The new count of validators running on the consensus layer\\n    /// @param validatorTotalBalance The new total balance sum of all validators\\n    /// @param roundId Round identifier\\n    event ConsensusLayerDataUpdate(uint256 validatorCount, uint256 validatorTotalBalance, bytes32 roundId);\\n\\n    /// @notice The Consensus Layer Spec is changed\\n    /// @param epochsPerFrame The number of epochs inside a frame\\n    /// @param slotsPerEpoch The number of slots inside an epoch\\n    /// @param secondsPerSlot The number of seconds inside a slot\\n    /// @param genesisTime The genesis timestamp\\n    /// @param epochsToAssumedFinality The number of epochs before an epoch is considered final\\n    event SetSpec(\\n        uint64 epochsPerFrame,\\n        uint64 slotsPerEpoch,\\n        uint64 secondsPerSlot,\\n        uint64 genesisTime,\\n        uint64 epochsToAssumedFinality\\n    );\\n\\n    /// @notice The Report Bounds are changed\\n    /// @param annualAprUpperBound The reporting upper bound\\n    /// @param relativeLowerBound The reporting lower bound\\n    event SetBounds(uint256 annualAprUpperBound, uint256 relativeLowerBound);\\n\\n    /// @notice The provided report has beend processed\\n    /// @param report The report that was provided\\n    /// @param trace The trace structure providing more insights on internals\\n    event ProcessedConsensusLayerReport(\\n        IOracleManagerV1.ConsensusLayerReport report, ConsensusLayerDataReportingTrace trace\\n    );\\n\\n    /// @notice The reported validator count is invalid\\n    /// @param providedValidatorCount The received validator count value\\n    /// @param depositedValidatorCount The number of deposits performed by the system\\n    /// @param lastReportedValidatorCount The last reported validator count\\n    error InvalidValidatorCountReport(\\n        uint256 providedValidatorCount, uint256 depositedValidatorCount, uint256 lastReportedValidatorCount\\n    );\\n\\n    /// @notice Thrown when an invalid epoch was reported\\n    /// @param epoch Invalid epoch\\n    error InvalidEpoch(uint256 epoch);\\n\\n    /// @notice The balance increase is higher than the maximum allowed by the upper bound\\n    /// @param prevTotalEthIncludingExited The previous total balance, including all exited balance\\n    /// @param postTotalEthIncludingExited The post-report total balance, including all exited balance\\n    /// @param timeElapsed The time in seconds since last report\\n    /// @param annualAprUpperBound The upper bound value that was used\\n    error TotalValidatorBalanceIncreaseOutOfBound(\\n        uint256 prevTotalEthIncludingExited,\\n        uint256 postTotalEthIncludingExited,\\n        uint256 timeElapsed,\\n        uint256 annualAprUpperBound\\n    );\\n\\n    /// @notice The balance decrease is higher than the maximum allowed by the lower bound\\n    /// @param prevTotalEthIncludingExited The previous total balance, including all exited balance\\n    /// @param postTotalEthIncludingExited The post-report total balance, including all exited balance\\n    /// @param timeElapsed The time in seconds since last report\\n    /// @param relativeLowerBound The lower bound value that was used\\n    error TotalValidatorBalanceDecreaseOutOfBound(\\n        uint256 prevTotalEthIncludingExited,\\n        uint256 postTotalEthIncludingExited,\\n        uint256 timeElapsed,\\n        uint256 relativeLowerBound\\n    );\\n\\n    /// @notice The total exited balance decreased\\n    /// @param currentValidatorsExitedBalance The current exited balance\\n    /// @param newValidatorsExitedBalance The new exited balance\\n    error InvalidDecreasingValidatorsExitedBalance(\\n        uint256 currentValidatorsExitedBalance, uint256 newValidatorsExitedBalance\\n    );\\n\\n    /// @notice The total skimmed balance decreased\\n    /// @param currentValidatorsSkimmedBalance The current exited balance\\n    /// @param newValidatorsSkimmedBalance The new exited balance\\n    error InvalidDecreasingValidatorsSkimmedBalance(\\n        uint256 currentValidatorsSkimmedBalance, uint256 newValidatorsSkimmedBalance\\n    );\\n\\n    /// @notice Trace structure emitted via logs during reporting\\n    struct ConsensusLayerDataReportingTrace {\\n        uint256 rewards;\\n        uint256 pulledELFees;\\n        uint256 pulledRedeemManagerExceedingEthBuffer;\\n        uint256 pulledCoverageFunds;\\n    }\\n\\n    /// @notice The format of the oracle report\\n    struct ConsensusLayerReport {\\n        // this is the epoch at which the report was performed\\n        // data should be fetched up to the state of this epoch by the oracles\\n        uint256 epoch;\\n        // the sum of all the validator balances on the consensus layer\\n        // when a validator enters the exit queue, the validator is considered stopped, its balance is accounted in both validatorsExitingBalance and validatorsBalance\\n        // when a validator leaves the exit queue and the funds are sweeped onto the execution layer, the balance is only accounted in validatorsExitedBalance and not in validatorsBalance\\n        // this value can decrease between reports\\n        uint256 validatorsBalance;\\n        // the sum of all the skimmings performed on the validators\\n        // these values can be found in the execution layer block bodies under the withdrawals field\\n        // a withdrawal is considered skimming if\\n        // - the epoch at which it happened is < validator.withdrawableEpoch\\n        // - the epoch at which it happened is >= validator.withdrawableEpoch and in that case we only account for what would be above 32 eth as skimming\\n        // this value cannot decrease over reports\\n        uint256 validatorsSkimmedBalance;\\n        // the sum of all the exits performed on the validators\\n        // these values can be found in the execution layer block bodies under the withdrawals field\\n        // a withdrawal is considered exit if\\n        // - the epoch at which it happened is >= validator.withdrawableEpoch and in that case we only account for what would be <= 32 eth as exit\\n        // this value cannot decrease over reports\\n        uint256 validatorsExitedBalance;\\n        // the sum of all the exiting balance, which is all the validators on their way to get sweeped and exited\\n        // this includes voluntary exits and slashings\\n        // this value can decrease between reports\\n        uint256 validatorsExitingBalance;\\n        // the count of activated validators\\n        // even validators that are exited are still accounted\\n        // this value cannot decrease over reports\\n        uint32 validatorsCount;\\n        // an array containing the count of stopped validators per operator\\n        // the first element of the array is the sum of all stopped validators\\n        // then index 1 would be operator 0\\n        // these values cannot decrease over reports\\n        uint32[] stoppedValidatorCountPerOperator;\\n        // flag enabled by the oracles when the buffer rebalancing is activated\\n        // the activation logic is written in the oracle specification and all oracle members must agree on the activation\\n        // when active, the eth in the deposit buffer can be used to pay for exits in the redeem manager\\n        bool rebalanceDepositToRedeemMode;\\n        // flag enabled by the oracles when the slashing containment is activated\\n        // the activation logic is written in the oracle specification and all oracle members must agree on the activation\\n        // This flag is activated when a pre-defined threshold of slashed validators in our set of validators is reached\\n        // This flag is deactivated when a bottom threshold is met, this means that when we reach the upper threshold and activate the flag, we will deactivate it when we reach the bottom threshold and not before\\n        // when active, no more validator exits can be requested by the protocol\\n        bool slashingContainmentMode;\\n    }\\n\\n    /// @notice The format of the oracle report in storage\\n    /// @notice These fields have the exact same function as the ones in ConsensusLayerReport, but this struct is optimized for storage\\n    struct StoredConsensusLayerReport {\\n        uint256 epoch;\\n        uint256 validatorsBalance;\\n        uint256 validatorsSkimmedBalance;\\n        uint256 validatorsExitedBalance;\\n        uint256 validatorsExitingBalance;\\n        uint32 validatorsCount;\\n        bool rebalanceDepositToRedeemMode;\\n        bool slashingContainmentMode;\\n    }\\n\\n    /// @notice Get oracle address\\n    /// @return The oracle address\\n    function getOracle() external view returns (address);\\n\\n    /// @notice Get CL validator total balance\\n    /// @return The CL Validator total balance\\n    function getCLValidatorTotalBalance() external view returns (uint256);\\n\\n    /// @notice Get CL validator count (the amount of validator reported by the oracles)\\n    /// @return The CL validator count\\n    function getCLValidatorCount() external view returns (uint256);\\n\\n    /// @notice Verifies if the provided epoch is valid\\n    /// @param epoch The epoch to lookup\\n    /// @return True if valid\\n    function isValidEpoch(uint256 epoch) external view returns (bool);\\n\\n    /// @notice Retrieve the block timestamp\\n    /// @return The current timestamp from the EVM context\\n    function getTime() external view returns (uint256);\\n\\n    /// @notice Retrieve expected epoch id\\n    /// @return The current expected epoch id\\n    function getExpectedEpochId() external view returns (uint256);\\n\\n    /// @notice Retrieve the last completed epoch id\\n    /// @return The last completed epoch id\\n    function getLastCompletedEpochId() external view returns (uint256);\\n\\n    /// @notice Retrieve the current epoch id based on block timestamp\\n    /// @return The current epoch id\\n    function getCurrentEpochId() external view returns (uint256);\\n\\n    /// @notice Retrieve the current cl spec\\n    /// @return The Consensus Layer Specification\\n    function getCLSpec() external view returns (CLSpec.CLSpecStruct memory);\\n\\n    /// @notice Retrieve the current frame details\\n    /// @return _startEpochId The epoch at the beginning of the frame\\n    /// @return _startTime The timestamp of the beginning of the frame in seconds\\n    /// @return _endTime The timestamp of the end of the frame in seconds\\n    function getCurrentFrame() external view returns (uint256 _startEpochId, uint256 _startTime, uint256 _endTime);\\n\\n    /// @notice Retrieve the first epoch id of the frame of the provided epoch id\\n    /// @param _epochId Epoch id used to get the frame\\n    /// @return The first epoch id of the frame containing the given epoch id\\n    function getFrameFirstEpochId(uint256 _epochId) external view returns (uint256);\\n\\n    /// @notice Retrieve the report bounds\\n    /// @return The report bounds\\n    function getReportBounds() external view returns (ReportBounds.ReportBoundsStruct memory);\\n\\n    /// @notice Retrieve the last consensus layer report\\n    /// @return The stored consensus layer report\\n    function getLastConsensusLayerReport() external view returns (IOracleManagerV1.StoredConsensusLayerReport memory);\\n\\n    /// @notice Set the oracle address\\n    /// @param _oracleAddress Address of the oracle\\n    function setOracle(address _oracleAddress) external;\\n\\n    /// @notice Set the consensus layer spec\\n    /// @param _newValue The new consensus layer spec value\\n    function setCLSpec(CLSpec.CLSpecStruct calldata _newValue) external;\\n\\n    /// @notice Set the report bounds\\n    /// @param _newValue The new report bounds value\\n    function setReportBounds(ReportBounds.ReportBoundsStruct calldata _newValue) external;\\n\\n    /// @notice Performs all the reporting logics\\n    /// @param _report The consensus layer report structure\\n    function setConsensusLayerData(ConsensusLayerReport calldata _report) external;\\n}\\n\",\"keccak256\":\"0x9109a0a200d62513d217b41d4904d7bbd2a87ec7d3f5a5e683e13ba76c8bcd2e\",\"license\":\"BUSL-1.1\"},\"contracts/src/interfaces/components/ISharesManager.1.sol\":{\"content\":\"//SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\nimport \\\"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/// @title Shares Manager Interface (v1)\\n/// @author Alluvial Finance Inc.\\n/// @notice This interface exposes methods to handle the shares of the depositor and the ERC20 interface\\ninterface ISharesManagerV1 is IERC20 {\\n    /// @notice Emitted when the total supply is changed\\n    event SetTotalSupply(uint256 totalSupply);\\n\\n    /// @notice Balance too low to perform operation\\n    error BalanceTooLow();\\n\\n    /// @notice Allowance too low to perform operation\\n    /// @param _from Account where funds are sent from\\n    /// @param _operator Account attempting the transfer\\n    /// @param _allowance Current allowance\\n    /// @param _value Requested transfer value in shares\\n    error AllowanceTooLow(address _from, address _operator, uint256 _allowance, uint256 _value);\\n\\n    /// @notice Invalid empty transfer\\n    error NullTransfer();\\n\\n    /// @notice Invalid transfer recipients\\n    /// @param _from Account sending the funds in the invalid transfer\\n    /// @param _to Account receiving the funds in the invalid transfer\\n    error UnauthorizedTransfer(address _from, address _to);\\n\\n    /// @notice Retrieve the token name\\n    /// @return The token name\\n    function name() external pure returns (string memory);\\n\\n    /// @notice Retrieve the token symbol\\n    /// @return The token symbol\\n    function symbol() external pure returns (string memory);\\n\\n    /// @notice Retrieve the decimal count\\n    /// @return The decimal count\\n    function decimals() external pure returns (uint8);\\n\\n    /// @notice Retrieve the total token supply\\n    /// @return The total supply in shares\\n    function totalSupply() external view returns (uint256);\\n\\n    /// @notice Retrieve the total underlying asset supply\\n    /// @return The total underlying asset supply\\n    function totalUnderlyingSupply() external view returns (uint256);\\n\\n    /// @notice Retrieve the balance of an account\\n    /// @param _owner Address to be checked\\n    /// @return The balance of the account in shares\\n    function balanceOf(address _owner) external view returns (uint256);\\n\\n    /// @notice Retrieve the underlying asset balance of an account\\n    /// @param _owner Address to be checked\\n    /// @return The underlying balance of the account\\n    function balanceOfUnderlying(address _owner) external view returns (uint256);\\n\\n    /// @notice Retrieve the underlying asset balance from an amount of shares\\n    /// @param _shares Amount of shares to convert\\n    /// @return The underlying asset balance represented by the shares\\n    function underlyingBalanceFromShares(uint256 _shares) external view returns (uint256);\\n\\n    /// @notice Retrieve the shares count from an underlying asset amount\\n    /// @param _underlyingAssetAmount Amount of underlying asset to convert\\n    /// @return The amount of shares worth the underlying asset amopunt\\n    function sharesFromUnderlyingBalance(uint256 _underlyingAssetAmount) external view returns (uint256);\\n\\n    /// @notice Retrieve the allowance value for a spender\\n    /// @param _owner Address that issued the allowance\\n    /// @param _spender Address that received the allowance\\n    /// @return The allowance in shares for a given spender\\n    function allowance(address _owner, address _spender) external view returns (uint256);\\n\\n    /// @notice Performs a transfer from the message sender to the provided account\\n    /// @param _to Address receiving the tokens\\n    /// @param _value Amount of shares to be sent\\n    /// @return True if success\\n    function transfer(address _to, uint256 _value) external returns (bool);\\n\\n    /// @notice Performs a transfer between two recipients\\n    /// @param _from Address sending the tokens\\n    /// @param _to Address receiving the tokens\\n    /// @param _value Amount of shares to be sent\\n    /// @return True if success\\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\\n\\n    /// @notice Approves an account for future spendings\\n    /// @dev An approved account can use transferFrom to transfer funds on behalf of the token owner\\n    /// @param _spender Address that is allowed to spend the tokens\\n    /// @param _value The allowed amount in shares, will override previous value\\n    /// @return True if success\\n    function approve(address _spender, uint256 _value) external returns (bool);\\n\\n    /// @notice Increase allowance to another account\\n    /// @param _spender Spender that receives the allowance\\n    /// @param _additionalValue Amount of shares to add\\n    /// @return True if success\\n    function increaseAllowance(address _spender, uint256 _additionalValue) external returns (bool);\\n\\n    /// @notice Decrease allowance to another account\\n    /// @param _spender Spender that receives the allowance\\n    /// @param _subtractableValue Amount of shares to subtract\\n    /// @return True if success\\n    function decreaseAllowance(address _spender, uint256 _subtractableValue) external returns (bool);\\n}\\n\",\"keccak256\":\"0xbbbc45cddcad60c43e2f78a0a075f3f171f9606a9142d692138f09093ef3f451\",\"license\":\"BUSL-1.1\"},\"contracts/src/interfaces/components/IUserDepositManager.1.sol\":{\"content\":\"//SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\n/// @title User Deposit Manager (v1)\\n/// @author Alluvial Finance Inc.\\n/// @notice This interface exposes methods to handle the inbound transfers cases or the explicit submissions\\ninterface IUserDepositManagerV1 {\\n    /// @notice User deposited ETH in the system\\n    /// @param depositor Address performing the deposit\\n    /// @param recipient Address receiving the minted shares\\n    /// @param amount Amount in ETH deposited\\n    event UserDeposit(address indexed depositor, address indexed recipient, uint256 amount);\\n\\n    /// @notice And empty deposit attempt was made\\n    error EmptyDeposit();\\n\\n    /// @notice Explicit deposit method to mint on msg.sender\\n    function deposit() external payable;\\n\\n    /// @notice Explicit deposit method to mint on msg.sender and transfer to _recipient\\n    /// @param _recipient Address receiving the minted LsETH\\n    function depositAndTransfer(address _recipient) external payable;\\n\\n    /// @notice Implicit deposit method, when the user performs a regular transfer to the contract\\n    receive() external payable;\\n\\n    /// @notice Invalid call, when the user sends a transaction with a data payload but no method matched\\n    fallback() external payable;\\n}\\n\",\"keccak256\":\"0x883f8d2b25d540915ac4cfededee1c4ee3f4ca90e3fe71748fd0e4b46d752c6a\",\"license\":\"BUSL-1.1\"},\"contracts/src/libraries/LibAllowlistMasks.sol\":{\"content\":\"//SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\n/// @title Lib Allowlist Masks\\n/// @notice Holds all the mask values\\nlibrary LibAllowlistMasks {\\n    /// @notice Mask used for denied accounts\\n    uint256 internal constant DENY_MASK = 0x1 << 255;\\n    /// @notice The mask for the deposit right\\n    uint256 internal constant DEPOSIT_MASK = 0x1;\\n    /// @notice The mask for the donation right\\n    uint256 internal constant DONATE_MASK = 0x1 << 1;\\n    /// @notice The mask for the redeem right\\n    uint256 internal constant REDEEM_MASK = 0x1 << 2;\\n}\\n\",\"keccak256\":\"0xa72bc9ec8a96a0eb01f207da9ac1c384415d43490cf2f53b89a190713ff8c359\",\"license\":\"BUSL-1.1\"},\"contracts/src/libraries/LibBasisPoints.sol\":{\"content\":\"//SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\n/// @title Lib Basis Points\\n/// @notice Holds the basis points max value\\nlibrary LibBasisPoints {\\n    /// @notice The max value for basis points (represents 100%)\\n    uint256 internal constant BASIS_POINTS_MAX = 10_000;\\n}\\n\",\"keccak256\":\"0x87e0393c2317b33ae449221747b42f7237362adf9b7a0902433d57574473303a\",\"license\":\"BUSL-1.1\"},\"contracts/src/libraries/LibErrors.sol\":{\"content\":\"//SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\n/// @title Lib Errors\\n/// @notice Library of common errors\\nlibrary LibErrors {\\n    /// @notice The operator is unauthorized for the caller\\n    /// @param caller Address performing the call\\n    error Unauthorized(address caller);\\n\\n    /// @notice The call was invalid\\n    error InvalidCall();\\n\\n    /// @notice The argument was invalid\\n    error InvalidArgument();\\n\\n    /// @notice The address is zero\\n    error InvalidZeroAddress();\\n\\n    /// @notice The string is empty\\n    error InvalidEmptyString();\\n\\n    /// @notice The fee is invalid\\n    error InvalidFee();\\n}\\n\",\"keccak256\":\"0xc6f936719c01ce7ee4ba9ef66e8af75ca8a09b216efd38c0d66d87d08b05bc95\",\"license\":\"BUSL-1.1\"},\"contracts/src/libraries/LibSanitize.sol\":{\"content\":\"//SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\nimport \\\"./LibErrors.sol\\\";\\nimport \\\"./LibBasisPoints.sol\\\";\\n\\n/// @title Lib Sanitize\\n/// @notice Utilities to sanitize input values\\nlibrary LibSanitize {\\n    /// @notice Reverts if address is 0\\n    /// @param _address Address to check\\n    function _notZeroAddress(address _address) internal pure {\\n        if (_address == address(0)) {\\n            revert LibErrors.InvalidZeroAddress();\\n        }\\n    }\\n\\n    /// @notice Reverts if string is empty\\n    /// @param _string String to check\\n    function _notEmptyString(string memory _string) internal pure {\\n        if (bytes(_string).length == 0) {\\n            revert LibErrors.InvalidEmptyString();\\n        }\\n    }\\n\\n    /// @notice Reverts if fee is invalid\\n    /// @param _fee Fee to check\\n    function _validFee(uint256 _fee) internal pure {\\n        if (_fee > LibBasisPoints.BASIS_POINTS_MAX) {\\n            revert LibErrors.InvalidFee();\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xce078083ab565058f68cd7be35ffeb0d88ab990a769c905094520a46edbccfee\",\"license\":\"BUSL-1.1\"},\"contracts/src/libraries/LibUint256.sol\":{\"content\":\"//SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\n/// @title Lib Uint256\\n/// @notice Utilities to perform uint operations\\nlibrary LibUint256 {\\n    /// @notice Converts a value to little endian (64 bits)\\n    /// @param _value The value to convert\\n    /// @return result The converted value\\n    function toLittleEndian64(uint256 _value) internal pure returns (uint256 result) {\\n        uint256 tempValue = _value;\\n        result = tempValue & 0xFF;\\n        tempValue >>= 8;\\n\\n        result = (result << 8) | (tempValue & 0xFF);\\n        tempValue >>= 8;\\n\\n        result = (result << 8) | (tempValue & 0xFF);\\n        tempValue >>= 8;\\n\\n        result = (result << 8) | (tempValue & 0xFF);\\n        tempValue >>= 8;\\n\\n        result = (result << 8) | (tempValue & 0xFF);\\n        tempValue >>= 8;\\n\\n        result = (result << 8) | (tempValue & 0xFF);\\n        tempValue >>= 8;\\n\\n        result = (result << 8) | (tempValue & 0xFF);\\n        tempValue >>= 8;\\n\\n        result = (result << 8) | (tempValue & 0xFF);\\n        tempValue >>= 8;\\n\\n        assert(0 == tempValue); // fully converted\\n        result <<= (24 * 8);\\n    }\\n\\n    /// @notice Returns the minimum value\\n    /// @param _a First value\\n    /// @param _b Second value\\n    /// @return Smallest value between _a and _b\\n    function min(uint256 _a, uint256 _b) internal pure returns (uint256) {\\n        return (_a > _b ? _b : _a);\\n    }\\n\\n    /// @notice Returns the max value\\n    /// @param _a First value\\n    /// @param _b Second value\\n    /// @return Highest value between _a and _b\\n    function max(uint256 _a, uint256 _b) internal pure returns (uint256) {\\n        return (_a < _b ? _b : _a);\\n    }\\n\\n    /// @notice Performs a ceiled division\\n    /// @param _a Numerator\\n    /// @param _b Denominator\\n    /// @return ceil(_a / _b)\\n    function ceil(uint256 _a, uint256 _b) internal pure returns (uint256) {\\n        return (_a / _b) + (_a % _b > 0 ? 1 : 0);\\n    }\\n}\\n\",\"keccak256\":\"0x18d3a772fd7ee36faa69bd6d97f0d3eeae39b90ff42c1f66352650f09a940e17\",\"license\":\"BUSL-1.1\"},\"contracts/src/libraries/LibUnstructuredStorage.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.20;\\n\\n/// @title Lib Unstructured Storage\\n/// @notice Utilities to work with unstructured storage\\nlibrary LibUnstructuredStorage {\\n    /// @notice Retrieve a bool value at a storage slot\\n    /// @param _position The storage slot to retrieve\\n    /// @return data The bool value\\n    function getStorageBool(bytes32 _position) internal view returns (bool data) {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            data := sload(_position)\\n        }\\n    }\\n\\n    /// @notice Retrieve an address value at a storage slot\\n    /// @param _position The storage slot to retrieve\\n    /// @return data The address value\\n    function getStorageAddress(bytes32 _position) internal view returns (address data) {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            data := sload(_position)\\n        }\\n    }\\n\\n    /// @notice Retrieve a bytes32 value at a storage slot\\n    /// @param _position The storage slot to retrieve\\n    /// @return data The bytes32 value\\n    function getStorageBytes32(bytes32 _position) internal view returns (bytes32 data) {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            data := sload(_position)\\n        }\\n    }\\n\\n    /// @notice Retrieve an uint256 value at a storage slot\\n    /// @param _position The storage slot to retrieve\\n    /// @return data The uint256 value\\n    function getStorageUint256(bytes32 _position) internal view returns (uint256 data) {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            data := sload(_position)\\n        }\\n    }\\n\\n    /// @notice Sets a bool value at a storage slot\\n    /// @param _position The storage slot to set\\n    /// @param _data The bool value to set\\n    function setStorageBool(bytes32 _position, bool _data) internal {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            sstore(_position, _data)\\n        }\\n    }\\n\\n    /// @notice Sets an address value at a storage slot\\n    /// @param _position The storage slot to set\\n    /// @param _data The address value to set\\n    function setStorageAddress(bytes32 _position, address _data) internal {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            sstore(_position, _data)\\n        }\\n    }\\n\\n    /// @notice Sets a bytes32 value at a storage slot\\n    /// @param _position The storage slot to set\\n    /// @param _data The bytes32 value to set\\n    function setStorageBytes32(bytes32 _position, bytes32 _data) internal {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            sstore(_position, _data)\\n        }\\n    }\\n\\n    /// @notice Sets an uint256 value at a storage slot\\n    /// @param _position The storage slot to set\\n    /// @param _data The uint256 value to set\\n    function setStorageUint256(bytes32 _position, uint256 _data) internal {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            sstore(_position, _data)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xe48b249b789acdd6f9e1b80f6b1dc3fc69d5593c8b836fad803b7d9fd10dd841\",\"license\":\"BUSL-1.1\"},\"contracts/src/state/river/CLSpec.sol\":{\"content\":\"//SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\n/// @title Consensus Layer Spec Storage\\n/// @notice Utility to manage the Consensus Layer Spec in storage\\nlibrary CLSpec {\\n    /// @notice Storage slot of the Consensus Layer Spec\\n    bytes32 internal constant CL_SPEC_SLOT = bytes32(uint256(keccak256(\\\"river.state.clSpec\\\")) - 1);\\n\\n    /// @notice The Consensus Layer Spec structure\\n    struct CLSpecStruct {\\n        /// @custom:attribute The count of epochs per frame, 225 means 24h\\n        uint64 epochsPerFrame;\\n        /// @custom:attribute The count of slots in an epoch (32 on mainnet)\\n        uint64 slotsPerEpoch;\\n        /// @custom:attribute The seconds in a slot (12 on mainnet)\\n        uint64 secondsPerSlot;\\n        /// @custom:attribute The block timestamp of the first consensus layer block\\n        uint64 genesisTime;\\n        /// @custom:attribute The count of epochs before considering an epoch final on-chain\\n        uint64 epochsToAssumedFinality;\\n    }\\n\\n    /// @notice The structure in storage\\n    struct Slot {\\n        /// @custom:attribute The structure in storage\\n        CLSpecStruct value;\\n    }\\n\\n    /// @notice Retrieve the Consensus Layer Spec from storage\\n    /// @return The Consensus Layer Spec\\n    function get() internal view returns (CLSpecStruct memory) {\\n        bytes32 slot = CL_SPEC_SLOT;\\n\\n        Slot storage r;\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n\\n        return r.value;\\n    }\\n\\n    /// @notice Set the Consensus Layer Spec value in storage\\n    /// @param _newCLSpec The new value to set in storage\\n    function set(CLSpecStruct memory _newCLSpec) internal {\\n        bytes32 slot = CL_SPEC_SLOT;\\n\\n        Slot storage r;\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n\\n        r.value = _newCLSpec;\\n    }\\n}\\n\",\"keccak256\":\"0x111bed0ac40bd03195b1091cb1d01b325af7390d5ec5297955cc5567f70fd2cc\",\"license\":\"BUSL-1.1\"},\"contracts/src/state/river/DailyCommittableLimits.sol\":{\"content\":\"//SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\nimport \\\"../../libraries/LibSanitize.sol\\\";\\n\\n/// @title Daily Committable Limits storage\\n/// @notice Utility to manage the Daily Committable Limits in storage\\nlibrary DailyCommittableLimits {\\n    /// @notice Storage slot of the Daily Committable Limits storage\\n    bytes32 internal constant DAILY_COMMITTABLE_LIMITS_SLOT =\\n        bytes32(uint256(keccak256(\\\"river.state.dailyCommittableLimits\\\")) - 1);\\n\\n    /// @notice The daily committable limits structure\\n    struct DailyCommittableLimitsStruct {\\n        uint128 minDailyNetCommittableAmount;\\n        uint128 maxDailyRelativeCommittableAmount;\\n    }\\n\\n    /// @notice The structure in storage\\n    struct Slot {\\n        /// @custom:attribute The structure in storage\\n        DailyCommittableLimitsStruct value;\\n    }\\n\\n    /// @notice Retrieve the Daily Committable Limits from storage\\n    /// @return The Daily Committable Limits\\n    function get() internal view returns (DailyCommittableLimitsStruct memory) {\\n        bytes32 slot = DAILY_COMMITTABLE_LIMITS_SLOT;\\n\\n        Slot storage r;\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n\\n        return r.value;\\n    }\\n\\n    /// @notice Set the Daily Committable Limits value in storage\\n    /// @param _newValue The new value to set in storage\\n    function set(DailyCommittableLimitsStruct memory _newValue) internal {\\n        bytes32 slot = DAILY_COMMITTABLE_LIMITS_SLOT;\\n\\n        Slot storage r;\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n\\n        r.value = _newValue;\\n    }\\n}\\n\",\"keccak256\":\"0x5299d5f41a6f24b09b81a1a00da6db15fbe2aa16718bc435ecb60016897f1f90\",\"license\":\"BUSL-1.1\"},\"contracts/src/state/river/ReportBounds.sol\":{\"content\":\"//SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\n/// @title Report Bounds Storage\\n/// @notice Utility to manage the Report Bounds in storage\\nlibrary ReportBounds {\\n    /// @notice Storage slot of the Report Bounds\\n    bytes32 internal constant REPORT_BOUNDS_SLOT = bytes32(uint256(keccak256(\\\"river.state.reportBounds\\\")) - 1);\\n\\n    /// @notice The Report Bounds structure\\n    struct ReportBoundsStruct {\\n        /// @custom:attribute The maximum allowed annual apr, checked before submitting a report to River\\n        uint256 annualAprUpperBound;\\n        /// @custom:attribute The maximum allowed balance decrease, also checked before submitting a report to River\\n        uint256 relativeLowerBound;\\n    }\\n\\n    /// @notice The structure in storage\\n    struct Slot {\\n        /// @custom:attribute The structure in storage\\n        ReportBoundsStruct value;\\n    }\\n\\n    /// @notice Retrieve the Report Bounds from storage\\n    /// @return The Report Bounds\\n    function get() internal view returns (ReportBoundsStruct memory) {\\n        bytes32 slot = REPORT_BOUNDS_SLOT;\\n\\n        Slot storage r;\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n\\n        return r.value;\\n    }\\n\\n    /// @notice Set the Report Bounds in storage\\n    /// @param _newReportBounds The new Report Bounds value\\n    function set(ReportBoundsStruct memory _newReportBounds) internal {\\n        bytes32 slot = REPORT_BOUNDS_SLOT;\\n\\n        Slot storage r;\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n\\n        r.value = _newReportBounds;\\n    }\\n}\\n\",\"keccak256\":\"0x032757c478e9132a66b7da31e2eb5f85f8f818503b51b3783c088d3625b3403a\",\"license\":\"BUSL-1.1\"},\"contracts/src/state/shared/RiverAddress.sol\":{\"content\":\"//SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\nimport \\\"../../libraries/LibSanitize.sol\\\";\\nimport \\\"../../libraries/LibUnstructuredStorage.sol\\\";\\n\\n/// @title River Address Storage\\n/// @notice Utility to manage the River Address in storage\\nlibrary RiverAddress {\\n    /// @notice Storage slot of the River Address\\n    bytes32 internal constant RIVER_ADDRESS_SLOT = bytes32(uint256(keccak256(\\\"river.state.riverAddress\\\")) - 1);\\n\\n    /// @notice Retrieve the River Address\\n    /// @return The River Address\\n    function get() internal view returns (address) {\\n        return LibUnstructuredStorage.getStorageAddress(RIVER_ADDRESS_SLOT);\\n    }\\n\\n    /// @notice Sets the River Address\\n    /// @param _newValue New River Address\\n    function set(address _newValue) internal {\\n        LibSanitize._notZeroAddress(_newValue);\\n        LibUnstructuredStorage.setStorageAddress(RIVER_ADDRESS_SLOT, _newValue);\\n    }\\n}\\n\",\"keccak256\":\"0xf8e4d6ce9f7070232e15411daa2d9d3163f98a67f7257fb238911a8d4e51acdc\",\"license\":\"BUSL-1.1\"},\"contracts/src/state/shared/Version.sol\":{\"content\":\"//SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\nimport \\\"../../libraries/LibUnstructuredStorage.sol\\\";\\n\\n/// @title Version Storage\\n/// @notice Utility to manage the Version in storage\\nlibrary Version {\\n    /// @notice Storage slot of the Version\\n    bytes32 public constant VERSION_SLOT = bytes32(uint256(keccak256(\\\"river.state.version\\\")) - 1);\\n\\n    /// @notice Retrieve the Version\\n    /// @return The Version\\n    function get() internal view returns (uint256) {\\n        return LibUnstructuredStorage.getStorageUint256(VERSION_SLOT);\\n    }\\n\\n    /// @notice Sets the Version\\n    /// @param _newValue New Version\\n    function set(uint256 _newValue) internal {\\n        LibUnstructuredStorage.setStorageUint256(VERSION_SLOT, _newValue);\\n    }\\n}\\n\",\"keccak256\":\"0x011c09f065ea555f6fbaa99710c1388bcb047afef30ab6558ca1ee81980ebf01\",\"license\":\"BUSL-1.1\"},\"contracts/src/state/slashingCoverage/BalanceForCoverage.sol\":{\"content\":\"//SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\nimport \\\"../../libraries/LibUnstructuredStorage.sol\\\";\\n\\n/// @title Balance For Coverage Value Storage\\n/// @notice Utility to manage the Balance For Coverrage value in storage\\nlibrary BalanceForCoverage {\\n    /// @notice Storage slot of the Balance For Coverage Address\\n    bytes32 internal constant BALANCE_FOR_COVERAGE_SLOT =\\n        bytes32(uint256(keccak256(\\\"river.state.balanceForCoverage\\\")) - 1);\\n\\n    /// @notice Get the Balance for Coverage value\\n    /// @return The balance for coverage value\\n    function get() internal view returns (uint256) {\\n        return LibUnstructuredStorage.getStorageUint256(BALANCE_FOR_COVERAGE_SLOT);\\n    }\\n\\n    /// @notice Sets the Balance for Coverage value\\n    /// @param _newValue New Balance for Coverage value\\n    function set(uint256 _newValue) internal {\\n        LibUnstructuredStorage.setStorageUint256(BALANCE_FOR_COVERAGE_SLOT, _newValue);\\n    }\\n}\\n\",\"keccak256\":\"0x97401efb6f10858668f2c2c540d9a212c52d080f5de647f3561d08d80cbcef40\",\"license\":\"BUSL-1.1\"},\"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\",\"keccak256\":\"0x287b55befed2961a7eabd7d7b1b2839cbca8a5b80ef8dcbb25ed3d4c2002c305\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60808060405234610092577f1809e49bba43f2d39fa57894b50cd6ccb428cc438230e065cac3eb24a1355a7190600019807f82055909238c0f5e63d6f174068ebb8f51bcec9bd37de63bb68f6551feec0cfc558152604060208201523660408201523660006060830137600060603683010152606081601f19601f3601168101030190a160405161054390816100988239f35b600080fdfe6080604081815260049182361015610033575b503615610026575163574b16a760e11b8152fd5b5163574b16a760e11b8152fd5b600090813560e01c90816335566ba9146103aa5750806354fd4d501461030e5780638ede6b6b146102185763ed88c68e0361001257918260031936011261017857341561020a577f3de1dea2e9e1b295da689a537f5463d5899dee73a7714a096299ff85f7bf49438054903482018092116101f557556000805160206104ee833981519152548251630c5eff3d60e41b81528492916001600160a01b03919060209082908590829086165afa9081156101eb57849161017c575b501690813b156101785782906044855180948193632d20488160e11b83523390830152600260248301525afa801561016b57610153575b5050513481527f0553260a2e46b0577270d8992db02d30856ca880144c72d6e9503760946aef1360203392a280f35b61015c906104c3565b610167578138610124565b5080fd5b50505051903d90823e3d90fd5b8280fd5b919293505060203d81116101e4575b601f8101601f1916820167ffffffffffffffff8111838210176101cf578287959493926020928852810103126101cb575181811681036101cb57386100ed565b8380fd5b604185634e487b7160e01b6000525260246000fd5b503d61018b565b85513d86823e3d90fd5b601183634e487b7160e01b6000525260246000fd5b90516389d209d760e01b8152fd5b509190346101785760203660031901126101785781359160018060a01b036000805160206104ee8339815191525416908133036102f7577f3de1dea2e9e1b295da689a537f5463d5899dee73a7714a096299ff85f7bf494380549094818111156102f1575080945b85610289578680f35b8582039182116102de5755849190813b1561017857835180958193633525c14960e21b83525af19081156102d557506102c6575b80808080808680f35b6102cf906104c3565b386102bd565b513d84823e3d90fd5b634e487b7160e01b875260118352602487fd5b94610280565b60249083519063472511eb60e11b82523390820152fd5b5091346101785782600319360112610178578151908282019082821067ffffffffffffffff831117610397575082526005815260209064312e322e3160d81b8282015282519382859384528251928382860152825b84811061038157505050828201840152601f01601f19168101030190f35b8181018301518882018801528795508201610363565b634e487b7160e01b855260419052602484fd5b91929050346101785760203660031901126101785783356001600160a01b038116928382036104bf577f82055909238c0f5e63d6f174068ebb8f51bcec9bd37de63bb68f6551feec0cfc908154806104a4575050600190558215610494577f1809e49bba43f2d39fa57894b50cd6ccb428cc438230e065cac3eb24a1355a719394506000805160206104ee833981519152558051917ffc0d749143b04e0d92a3b49edae84a45f6bc88b75e99d9118ec4d7e87fe626c58580a28382528060208301523690820152368360608301378260603683010152606081601f19601f3601168101030190a180f35b815163f6b2911f60e01b81528590fd5b631cfd276760e31b8252818801879052602482015260449150fd5b8480fd5b67ffffffffffffffff81116104d757604052565b634e487b7160e01b600052604160045260246000fdfe1ec4138404500a2a0be2c2f9b103581c2a7fa783a934f91a6cc5cc924404973ba26469706673582212206a8732f68a027f05808b9954f865696be0386b007102b2ed957683b71217dbda64736f6c63430008140033",
  "deployedBytecode": "0x6080604081815260049182361015610033575b503615610026575163574b16a760e11b8152fd5b5163574b16a760e11b8152fd5b600090813560e01c90816335566ba9146103aa5750806354fd4d501461030e5780638ede6b6b146102185763ed88c68e0361001257918260031936011261017857341561020a577f3de1dea2e9e1b295da689a537f5463d5899dee73a7714a096299ff85f7bf49438054903482018092116101f557556000805160206104ee833981519152548251630c5eff3d60e41b81528492916001600160a01b03919060209082908590829086165afa9081156101eb57849161017c575b501690813b156101785782906044855180948193632d20488160e11b83523390830152600260248301525afa801561016b57610153575b5050513481527f0553260a2e46b0577270d8992db02d30856ca880144c72d6e9503760946aef1360203392a280f35b61015c906104c3565b610167578138610124565b5080fd5b50505051903d90823e3d90fd5b8280fd5b919293505060203d81116101e4575b601f8101601f1916820167ffffffffffffffff8111838210176101cf578287959493926020928852810103126101cb575181811681036101cb57386100ed565b8380fd5b604185634e487b7160e01b6000525260246000fd5b503d61018b565b85513d86823e3d90fd5b601183634e487b7160e01b6000525260246000fd5b90516389d209d760e01b8152fd5b509190346101785760203660031901126101785781359160018060a01b036000805160206104ee8339815191525416908133036102f7577f3de1dea2e9e1b295da689a537f5463d5899dee73a7714a096299ff85f7bf494380549094818111156102f1575080945b85610289578680f35b8582039182116102de5755849190813b1561017857835180958193633525c14960e21b83525af19081156102d557506102c6575b80808080808680f35b6102cf906104c3565b386102bd565b513d84823e3d90fd5b634e487b7160e01b875260118352602487fd5b94610280565b60249083519063472511eb60e11b82523390820152fd5b5091346101785782600319360112610178578151908282019082821067ffffffffffffffff831117610397575082526005815260209064312e322e3160d81b8282015282519382859384528251928382860152825b84811061038157505050828201840152601f01601f19168101030190f35b8181018301518882018801528795508201610363565b634e487b7160e01b855260419052602484fd5b91929050346101785760203660031901126101785783356001600160a01b038116928382036104bf577f82055909238c0f5e63d6f174068ebb8f51bcec9bd37de63bb68f6551feec0cfc908154806104a4575050600190558215610494577f1809e49bba43f2d39fa57894b50cd6ccb428cc438230e065cac3eb24a1355a719394506000805160206104ee833981519152558051917ffc0d749143b04e0d92a3b49edae84a45f6bc88b75e99d9118ec4d7e87fe626c58580a28382528060208301523690820152368360608301378260603683010152606081601f19601f3601168101030190a180f35b815163f6b2911f60e01b81528590fd5b631cfd276760e31b8252818801879052602482015260449150fd5b8480fd5b67ffffffffffffffff81116104d757604052565b634e487b7160e01b600052604160045260246000fdfe1ec4138404500a2a0be2c2f9b103581c2a7fa783a934f91a6cc5cc924404973ba26469706673582212206a8732f68a027f05808b9954f865696be0386b007102b2ed957683b71217dbda64736f6c63430008140033",
  "devdoc": {
    "author": "Alluvial Finance Inc.",
    "errors": {
      "InvalidInitialization(uint256,uint256)": [
        {
          "params": {
            "expectedVersion": "The version that was expected",
            "version": "The version that was attempting to be initialized"
          }
        }
      ],
      "Unauthorized(address)": [
        {
          "params": {
            "caller": "Address performing the call"
          }
        }
      ]
    },
    "events": {
      "Donate(address,uint256)": {
        "params": {
          "amount": "The amount donated",
          "donator": "Address that performed the donation"
        }
      },
      "Initialize(uint256,bytes)": {
        "params": {
          "cdata": "Complete calldata that was used during the initialization",
          "version": "New version of the contracts"
        }
      },
      "SetRiver(address)": {
        "params": {
          "river": "The new river address"
        }
      }
    },
    "kind": "dev",
    "methods": {
      "initCoverageFundV1(address)": {
        "params": {
          "_riverAddress": "Address of River"
        }
      },
      "pullCoverageFunds(uint256)": {
        "details": "Only callable by the River contract",
        "params": {
          "_maxAmount": "The maximum amount to pull into the system"
        }
      },
      "version()": {
        "returns": {
          "_0": "Version of the contract"
        }
      }
    },
    "title": "Coverage Fund (v1)",
    "version": 1
  },
  "userdoc": {
    "errors": {
      "EmptyDonation()": [
        {
          "notice": "A donation with 0 ETH has been performed"
        }
      ],
      "InvalidCall()": [
        {
          "notice": "The fallback or receive callback has been triggered"
        }
      ],
      "InvalidInitialization(uint256,uint256)": [
        {
          "notice": "An error occured during the initialization"
        }
      ],
      "InvalidZeroAddress()": [
        {
          "notice": "The address is zero"
        }
      ],
      "Unauthorized(address)": [
        {
          "notice": "The operator is unauthorized for the caller"
        }
      ]
    },
    "events": {
      "Donate(address,uint256)": {
        "notice": "A donation has been made to the coverage fund"
      },
      "Initialize(uint256,bytes)": {
        "notice": "Emitted when the contract is properly initialized"
      },
      "SetRiver(address)": {
        "notice": "The storage river address has changed"
      }
    },
    "kind": "user",
    "methods": {
      "donate()": {
        "notice": "Donates ETH to the coverage fund contract"
      },
      "initCoverageFundV1(address)": {
        "notice": "Initialize the coverage fund with the required arguments"
      },
      "pullCoverageFunds(uint256)": {
        "notice": "Pulls ETH into the River contract"
      },
      "version()": {
        "notice": "Retrieves the version of the contract"
      }
    },
    "notice": "This contract receive donations for the slashing coverage fund and pull the funds into riverThis contract acts as a temporary buffer for funds that should be pulled in case of a loss of money on the consensus layer due to slashing events.There is no fee taken on these funds, they are entirely distributed to the LsETH holders, and no shares will get minted.Funds will be distributed by increasing the underlying value of every LsETH share.The fund will be called on every report and if eth is available in the contract, River will attempt to pull as muchETH as possible. This maximum is defined by the upper bound allowed by the Oracle. This means that it might take multiplereports for funds to be pulled entirely into the system due to this upper bound, ensuring a lower secondary market impact.The value provided to this contract is computed off-chain and provided manually by Alluvial or any authorized insurance entity.The Coverage funds are pulled upon an oracle report, after the ELFees have been pulled in the system, if there is a margin leftbefore crossing the upper bound. The reason behind this is to favor the revenue stream, that depends on market and network usage, whilethe coverage fund will be pulled after the revenue stream, and there won't be any commission on the eth pulled.Once a Slashing event occurs, the team will do its best to inject the recovery funds in at maximum 365 daysThe entities allowed to donate are selected by the team. It will mainly be treasury entities or insurance protocols able to fill this coverage fund properly.",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}