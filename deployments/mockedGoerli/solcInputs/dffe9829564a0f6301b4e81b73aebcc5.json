{
  "language": "Solidity",
  "sources": {
    "contracts/src/Allowlist.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"./Initializable.sol\";\nimport \"./libraries/Errors.sol\";\nimport \"./libraries/LibOwnable.sol\";\nimport \"./interfaces/IRiverOracleInput.sol\";\n\nimport \"./state/allowlist/AllowerAddress.sol\";\nimport \"./state/allowlist/Allowlist.sol\";\n\n/// @title Allowlist (v1)\n/// @author Kiln\n/// @notice This contract handles the list of allowed recipients.\ncontract AllowlistV1 is Initializable {\n    event ChangedAllowlistStatuses(address[] indexed accounts, uint256[] statuses);\n\n    error InvalidAlloweeCount();\n    error Denied(address _account);\n    error Unauthorized(address _account);\n    error MismatchedAlloweeAndStatusCount();\n\n    uint256 internal constant DENY_MASK = 0x1 << 255;\n\n    /// @notice Initializes the allowlist\n    /// @param _admin Address of the Allowlist administrator\n    /// @param _allower Address of the allower\n    function initAllowlistV1(address _admin, address _allower) external init(0) {\n        LibOwnable._setAdmin(_admin);\n        AllowerAddress.set(_allower);\n    }\n\n    /// @notice Prevents unauthorized calls\n    modifier onlyAdmin() virtual {\n        if (msg.sender != LibOwnable._getAdmin()) {\n            revert Errors.Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    /// @notice Changes the allower address\n    /// @param _newAllowerAddress New address allowed to edit the allowlist\n    function setAllower(address _newAllowerAddress) external onlyAdmin {\n        AllowerAddress.set(_newAllowerAddress);\n    }\n\n    /// @notice Retrieves the allower address\n    function getAllower() external view returns (address) {\n        return AllowerAddress.get();\n    }\n\n    /// @notice Sets the allowlisting status for one or more accounts\n    /// @param _accounts Accounts with statuses to edit\n    /// @param _statuses Allowlist statuses for each account, in the same order as _accounts\n    function allow(address[] calldata _accounts, uint256[] calldata _statuses) external {\n        if (msg.sender != AllowerAddress.get() && msg.sender != AdministratorAddress.get()) {\n            revert Errors.Unauthorized(msg.sender);\n        }\n\n        if (_accounts.length == 0) {\n            revert InvalidAlloweeCount();\n        }\n\n        if (_accounts.length != _statuses.length) {\n            revert MismatchedAlloweeAndStatusCount();\n        }\n\n        for (uint256 i = 0; i < _accounts.length; ) {\n            Allowlist.set(_accounts[i], _statuses[i]);\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit ChangedAllowlistStatuses(_accounts, _statuses);\n    }\n\n    /// @notice This method should be used as a modifier and is expected to revert\n    ///         if the user hasn't got the required permission or if the user is\n    ///         in the deny list.\n    /// @param _account Recipient to verify\n    /// @param _mask Combination of permissions to verify\n    function onlyAllowed(address _account, uint256 _mask) external view {\n        uint256 userPermissions = Allowlist.get(_account);\n        if (userPermissions & DENY_MASK == DENY_MASK) {\n            revert Denied(_account);\n        }\n        if (userPermissions & _mask != _mask) {\n            revert Unauthorized(_account);\n        }\n    }\n\n    /// @notice This method returns true if the user has the expected permission and\n    ///         is not in the deny list\n    /// @param _account Recipient to verify\n    /// @param _mask Combination of permissions to verify\n    function isAllowed(address _account, uint256 _mask) external view returns (bool) {\n        uint256 userPermissions = Allowlist.get(_account);\n        if (userPermissions & DENY_MASK == DENY_MASK) {\n            return false;\n        }\n        return userPermissions & _mask == _mask;\n    }\n\n    /// @notice This method returns true if the user is in the deny list\n    /// @param _account Recipient to verify\n    function isDenied(address _account) external view returns (bool) {\n        return Allowlist.get(_account) & DENY_MASK == DENY_MASK;\n    }\n\n    /// @notice This method returns true if the user has the expected permission\n    ///         ignoring any deny list membership\n    /// @param _account Recipient to verify\n    /// @param _mask Combination of permissions to verify\n    function hasPermission(address _account, uint256 _mask) external view returns (bool) {\n        return Allowlist.get(_account) & _mask == _mask;\n    }\n\n    /// @notice This method retrieves the raw permission value\n    /// @param _account Recipient to verify\n    function getPermissions(address _account) external view returns (uint256) {\n        return Allowlist.get(_account);\n    }\n}\n"
    },
    "contracts/src/Initializable.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"./state/shared/Version.sol\";\n\ncontract Initializable {\n    error InvalidInitialization(uint256 version, uint256 expectedVersion);\n\n    modifier init(uint256 version) {\n        if (version != Version.get()) {\n            revert InvalidInitialization(version, Version.get());\n        }\n        Version.set(version + 1); // prevents reentrency on the called method\n        _;\n    }\n}\n"
    },
    "contracts/src/libraries/Errors.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nlibrary Errors {\n    error Unauthorized(address caller);\n    error InvalidCall();\n    error InvalidArgument();\n}\n"
    },
    "contracts/src/libraries/LibOwnable.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../state/shared/AdministratorAddress.sol\";\n\nlibrary LibOwnable {\n    function _setAdmin(address newAdmin) internal {\n        AdministratorAddress.set(newAdmin);\n    }\n\n    function _getAdmin() internal view returns (address) {\n        return AdministratorAddress.get();\n    }\n}\n"
    },
    "contracts/src/interfaces/IRiverOracleInput.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\ninterface IRiverOracleInput {\n    function setBeaconData(\n        uint256 _validatorCount,\n        uint256 _validatorBalanceSum,\n        bytes32 _roundId\n    ) external;\n\n    function totalSupply() external returns (uint256);\n\n    function totalShares() external returns (uint256);\n}\n"
    },
    "contracts/src/state/allowlist/AllowerAddress.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/UnstructuredStorage.sol\";\n\nlibrary AllowerAddress {\n    bytes32 internal constant ALLOWER_ADDRESS_SLOT = bytes32(uint256(keccak256(\"river.state.allowerAddress\")) - 1);\n\n    function get() internal view returns (address) {\n        return UnstructuredStorage.getStorageAddress(ALLOWER_ADDRESS_SLOT);\n    }\n\n    function set(address newValue) internal {\n        UnstructuredStorage.setStorageAddress(ALLOWER_ADDRESS_SLOT, newValue);\n    }\n}\n"
    },
    "contracts/src/state/allowlist/Allowlist.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nlibrary Allowlist {\n    bytes32 internal constant ALLOWLIST_SLOT = bytes32(uint256(keccak256(\"river.state.allowlist\")) - 1);\n\n    struct Slot {\n        mapping(address => uint256) value;\n    }\n\n    function get(address account) internal view returns (uint256) {\n        bytes32 slot = ALLOWLIST_SLOT;\n\n        Slot storage r;\n\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value[account];\n    }\n\n    function set(address account, uint256 status) internal {\n        bytes32 slot = ALLOWLIST_SLOT;\n\n        Slot storage r;\n\n        assembly {\n            r.slot := slot\n        }\n\n        r.value[account] = status;\n    }\n}\n"
    },
    "contracts/src/state/shared/Version.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/UnstructuredStorage.sol\";\n\nlibrary Version {\n    bytes32 public constant VERSION_SLOT = bytes32(uint256(keccak256(\"river.state.version\")) - 1);\n\n    function get() internal view returns (uint256) {\n        return UnstructuredStorage.getStorageUint256(VERSION_SLOT);\n    }\n\n    function set(uint256 newValue) internal {\n        UnstructuredStorage.setStorageUint256(VERSION_SLOT, newValue);\n    }\n}\n"
    },
    "contracts/src/libraries/UnstructuredStorage.sol": {
      "content": "/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity 0.8.10;\n\nlibrary UnstructuredStorage {\n    function getStorageBool(bytes32 position) internal view returns (bool data) {\n        assembly {\n            data := sload(position)\n        }\n    }\n\n    function getStorageAddress(bytes32 position) internal view returns (address data) {\n        assembly {\n            data := sload(position)\n        }\n    }\n\n    function getStorageBytes32(bytes32 position) internal view returns (bytes32 data) {\n        assembly {\n            data := sload(position)\n        }\n    }\n\n    function getStorageUint256(bytes32 position) internal view returns (uint256 data) {\n        assembly {\n            data := sload(position)\n        }\n    }\n\n    function setStorageBool(bytes32 position, bool data) internal {\n        assembly {\n            sstore(position, data)\n        }\n    }\n\n    function setStorageAddress(bytes32 position, address data) internal {\n        assembly {\n            sstore(position, data)\n        }\n    }\n\n    function setStorageBytes32(bytes32 position, bytes32 data) internal {\n        assembly {\n            sstore(position, data)\n        }\n    }\n\n    function setStorageUint256(bytes32 position, uint256 data) internal {\n        assembly {\n            sstore(position, data)\n        }\n    }\n}\n"
    },
    "contracts/src/state/shared/AdministratorAddress.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/UnstructuredStorage.sol\";\n\nlibrary AdministratorAddress {\n    bytes32 public constant ADMINISTRATOR_ADDRESS_SLOT =\n        bytes32(uint256(keccak256(\"river.state.administratorAddress\")) - 1);\n\n    function get() internal view returns (address) {\n        return UnstructuredStorage.getStorageAddress(ADMINISTRATOR_ADDRESS_SLOT);\n    }\n\n    function set(address newValue) internal {\n        UnstructuredStorage.setStorageAddress(ADMINISTRATOR_ADDRESS_SLOT, newValue);\n    }\n}\n"
    },
    "contracts/src/state/river/GlobalFee.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/UnstructuredStorage.sol\";\n\nlibrary GlobalFee {\n    bytes32 internal constant GLOBAL_FEE_SLOT = bytes32(uint256(keccak256(\"river.state.globalFee\")) - 1);\n\n    function get() internal view returns (uint256) {\n        return UnstructuredStorage.getStorageUint256(GLOBAL_FEE_SLOT);\n    }\n\n    function set(uint256 newValue) internal {\n        UnstructuredStorage.setStorageUint256(GLOBAL_FEE_SLOT, newValue);\n    }\n}\n"
    },
    "contracts/src/River.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"./components/DepositManager.1.sol\";\nimport \"./components/TransferManager.1.sol\";\nimport \"./components/SharesManager.1.sol\";\nimport \"./components/OracleManager.1.sol\";\nimport \"./components/OperatorsManager.1.sol\";\nimport \"./Initializable.sol\";\nimport \"./libraries/LibOwnable.sol\";\n\nimport \"./state/shared/AdministratorAddress.sol\";\nimport \"./state/river/AllowlistAddress.sol\";\nimport \"./state/river/TreasuryAddress.sol\";\nimport \"./state/river/OperatorRewardsShare.sol\";\nimport \"./state/river/GlobalFee.sol\";\n\n/// @title River (v1)\n/// @author Kiln\n/// @notice This contract merges all the manager contracts and implements all the virtual methods stitching all components together\ncontract RiverV1 is\n    DepositManagerV1,\n    TransferManagerV1,\n    SharesManagerV1,\n    OracleManagerV1,\n    OperatorsManagerV1,\n    Initializable\n{\n    uint256 public constant BASE = 100000;\n    uint256 internal constant DEPOSIT_MASK = 0x1;\n    uint256 internal constant TRANSFER_MASK = 0;\n\n    /// @notice Prevents unauthorized calls\n    modifier onlyAdmin() override(OperatorsManagerV1, OracleManagerV1) {\n        if (msg.sender != LibOwnable._getAdmin()) {\n            revert Errors.Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    /// @notice Initializes the River system\n    /// @param _depositContractAddress Address to make Consensus Layer deposits\n    /// @param _withdrawalCredentials Credentials to use for every validator deposit\n    /// @param _systemAdministratorAddress Administrator address\n    /// @param _allowlistAddress Address of the allowlist contract\n    /// @param _treasuryAddress Address receiving the fee minus the operator share\n    /// @param _globalFee Amount retained when the eth balance increases, splitted between the treasury and the operators\n    /// @param _operatorRewardsShare Share of the global fee used to reward node operators\n    function initRiverV1(\n        address _depositContractAddress,\n        bytes32 _withdrawalCredentials,\n        address _oracleAddress,\n        address _systemAdministratorAddress,\n        address _allowlistAddress,\n        address _treasuryAddress,\n        uint256 _globalFee,\n        uint256 _operatorRewardsShare\n    ) external init(0) {\n        LibOwnable._setAdmin(_systemAdministratorAddress);\n        TreasuryAddress.set(_treasuryAddress);\n        GlobalFee.set(_globalFee);\n        OperatorRewardsShare.set(_operatorRewardsShare);\n\n        DepositManagerV1.initDepositManagerV1(_depositContractAddress, _withdrawalCredentials);\n        OracleManagerV1.initOracleManagerV1(_oracleAddress);\n        AllowlistAddress.set(_allowlistAddress);\n    }\n\n    /// @notice Changes the global fee parameter\n    /// @param newFee New fee value\n    function setGlobalFee(uint256 newFee) external onlyAdmin {\n        if (newFee > BASE) {\n            revert Errors.InvalidArgument();\n        }\n\n        GlobalFee.set(newFee);\n    }\n\n    /// @notice Changes the operator rewards share.\n    /// @param newOperatorRewardsShare New share value\n    function setOperatorRewardsShare(uint256 newOperatorRewardsShare) external onlyAdmin {\n        if (newOperatorRewardsShare > BASE) {\n            revert Errors.InvalidArgument();\n        }\n\n        OperatorRewardsShare.set(newOperatorRewardsShare);\n    }\n\n    /// @notice Changes the allowlist address\n    /// @param _newAllowlist New address for the allowlist\n    function setAllowlist(address _newAllowlist) external onlyAdmin {\n        AllowlistAddress.set(_newAllowlist);\n    }\n\n    /// @notice Retrieve the allowlist address\n    function getAllowlist() external view returns (address) {\n        return address(AllowlistAddress.get());\n    }\n\n    /// @notice Changes the treasury address\n    /// @param _newTreasury New address for the treasury\n    function setTreasury(address _newTreasury) external onlyAdmin {\n        TreasuryAddress.set(_newTreasury);\n    }\n\n    /// @notice Retrieve the treasury address\n    function getTreasury() external view returns (address) {\n        return TreasuryAddress.get();\n    }\n\n    /// @notice Changes the admin\n    /// @param _newAdmin New address for the admin\n    function setAdministrator(address _newAdmin) external onlyAdmin {\n        LibOwnable._setAdmin(_newAdmin);\n    }\n\n    /// @notice Retrieve system administrator address\n    function getAdministrator() external view returns (address) {\n        return LibOwnable._getAdmin();\n    }\n\n    /// @notice Handler called whenever a token transfer is triggered\n    /// @param _from Token sender\n    /// @param _to Token receiver\n    function _onTransfer(address _from, address _to) internal view override {\n        (AllowlistAddress.get()).onlyAllowed(_from, TRANSFER_MASK); // this call reverts if unauthorized or denied\n        (AllowlistAddress.get()).onlyAllowed(_to, TRANSFER_MASK); // this call reverts if unauthorized or denied\n    }\n\n    /// @notice Handler called whenever a user deposits ETH to the system. Mints the adequate amount of shares.\n    /// @param _depositor User address that made the deposit\n    /// @param _amount Amount of ETH deposited\n    function _onDeposit(\n        address _depositor,\n        address _recipient,\n        uint256 _amount\n    ) internal override {\n        SharesManagerV1._mintShares(_depositor, _amount);\n        if (_depositor == _recipient) {\n            (AllowlistAddress.get()).onlyAllowed(_depositor, DEPOSIT_MASK); // this call reverts if unauthorized or denied\n        } else {\n            (AllowlistAddress.get()).onlyAllowed(_depositor, DEPOSIT_MASK + TRANSFER_MASK); // this call reverts if unauthorized or denied\n            (AllowlistAddress.get()).onlyAllowed(_recipient, TRANSFER_MASK);\n            _transfer(_depositor, _recipient, _amount);\n        }\n    }\n\n    /// @notice Handler called whenever a deposit to the consensus layer is made. Should retrieve _requestedAmount or lower keys\n    /// @param _requestedAmount Amount of keys required. Contract is expected to send _requestedAmount or lower.\n    function _getNextValidators(uint256 _requestedAmount)\n        internal\n        override\n        returns (bytes[] memory publicKeys, bytes[] memory signatures)\n    {\n        return OperatorsManagerV1._getNextValidatorsFromActiveOperators(_requestedAmount);\n    }\n\n    /// @notice Internal utility managing reward distribution amongst node operators\n    /// @param _reward Amount of shares to split between operators\n    function _rewardOperators(uint256 _reward) internal returns (uint256) {\n        Operators.Operator[] memory operators = Operators.getAllActive();\n        uint256[] memory validatorCounts = new uint256[](operators.length);\n\n        uint256 totalActiveValidators = 0;\n        for (uint256 idx = 0; idx < operators.length; ++idx) {\n            uint256 operatorActiveValidatorCount = operators[idx].funded - operators[idx].stopped;\n            totalActiveValidators += operatorActiveValidatorCount;\n            validatorCounts[idx] = operatorActiveValidatorCount;\n        }\n\n        if (totalActiveValidators > 0) {\n            uint256 rewardsPerActiveValidator = _reward / totalActiveValidators;\n\n            for (uint256 idx = 0; idx < validatorCounts.length; ++idx) {\n                _mintRawShares(operators[idx].feeRecipient, validatorCounts[idx] * rewardsPerActiveValidator);\n            }\n        } else {\n            _reward = 0;\n        }\n\n        return _reward;\n    }\n\n    /// @notice Handler called whenever a donation of ETH has been made to the system. It calls the same logic as when revenues are earned.\n    /// @param _amount Additional eth donated\n    function _onDonation(uint256 _amount) internal override {\n        _onEarnings(_amount);\n    }\n\n    /// @notice Handler called whenever the balance of ETH handled by the system increases. Splits funds between operators and treasury.\n    /// @param _amount Additional eth received\n    function _onEarnings(uint256 _amount) internal override {\n        uint256 globalFee = GlobalFee.get();\n        uint256 sharesToMint = (_amount * _totalSupply() * globalFee) /\n            ((_assetBalance() * BASE) - (_amount * globalFee));\n\n        uint256 operatorRewards = (sharesToMint * OperatorRewardsShare.get()) / BASE;\n\n        uint256 mintedRewards = _rewardOperators(operatorRewards);\n\n        _mintRawShares(TreasuryAddress.get(), sharesToMint - mintedRewards);\n    }\n\n    /// @notice Handler called whenever the total balance of ETH is requested\n    function _assetBalance() internal view override returns (uint256) {\n        uint256 beaconValidatorCount = BeaconValidatorCount.get();\n        uint256 depositedValidatorCount = DepositedValidatorCount.get();\n        if (beaconValidatorCount < depositedValidatorCount) {\n            return\n                BeaconValidatorBalanceSum.get() +\n                address(this).balance +\n                (depositedValidatorCount - beaconValidatorCount) *\n                DepositManagerV1.DEPOSIT_SIZE;\n        } else {\n            return BeaconValidatorBalanceSum.get() + address(this).balance;\n        }\n    }\n}\n"
    },
    "contracts/src/components/DepositManager.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../interfaces/IDepositContract.sol\";\n\nimport \"../libraries/BytesLib.sol\";\nimport \"../libraries/Uint256Lib.sol\";\n\nimport \"../state/river/DepositContractAddress.sol\";\nimport \"../state/river/WithdrawalCredentials.sol\";\nimport \"../state/river/DepositedValidatorCount.sol\";\n\n/// @title Deposit Manager (v1)\n/// @author Kiln\n/// @notice This contract handles the interactions with the official deposit contract, funding all validators\n/// @dev _onValidatorKeyRequest must be overriden.\nabstract contract DepositManagerV1 {\n    event FundedValidatorKey(bytes publicKey);\n\n    error NotEnoughFunds();\n    error InconsistentPublicKeys();\n    error InconsistentSignatures();\n    error NoAvailableValidatorKeys();\n    error InvalidPublicKeyCount();\n    error InvalidSignatureCount();\n    error InvalidWithdrawalCredentials();\n\n    uint256 public constant PUBLIC_KEY_LENGTH = 48;\n    uint256 public constant SIGNATURE_LENGTH = 96;\n    uint256 public constant DEPOSIT_SIZE = 32 ether;\n\n    /// @notice Initializer to set the deposit contract address and the withdrawal credentials to use\n    /// @param _depositContractAddress The address of the deposit contract\n    /// @param _withdrawalCredentials The withdrawal credentials to apply to all deposits\n    function initDepositManagerV1(address _depositContractAddress, bytes32 _withdrawalCredentials) internal {\n        DepositContractAddress.set(IDepositContract(_depositContractAddress));\n\n        WithdrawalCredentials.set(_withdrawalCredentials);\n    }\n\n    /// @notice Retrieve the withdrawal credentials\n    function getWithdrawalCredentials() external view returns (bytes32) {\n        return WithdrawalCredentials.get();\n    }\n\n    /// @notice Internal helper to retrieve validator keys ready to be funded\n    /// @dev Must be overriden with an implementation that provides keyCount or less keys upon call\n    /// @param _keyCount The amount of keys (or less) to return.\n    function _getNextValidators(uint256 _keyCount)\n        internal\n        virtual\n        returns (bytes[] memory publicKeys, bytes[] memory signatures);\n\n    /// @notice Deposits current balance to the Consensus Layer by batches of 32 ETH\n    /// @param _maxCount The maximum amount of validator keys to fund\n    function depositToConsensusLayer(uint256 _maxCount) external {\n        uint256 validatorsToDeposit = Uint256Lib.min(address(this).balance / DEPOSIT_SIZE, _maxCount);\n\n        if (validatorsToDeposit == 0) {\n            revert NotEnoughFunds();\n        }\n\n        (bytes[] memory publicKeys, bytes[] memory signatures) = _getNextValidators(validatorsToDeposit);\n\n        uint256 receivedPublicKeyCount = publicKeys.length;\n\n        if (receivedPublicKeyCount == 0) {\n            revert NoAvailableValidatorKeys();\n        }\n\n        if (receivedPublicKeyCount > validatorsToDeposit) {\n            revert InvalidPublicKeyCount();\n        }\n\n        uint256 receivedSignatureCount = signatures.length;\n\n        if (receivedSignatureCount != receivedPublicKeyCount) {\n            revert InvalidSignatureCount();\n        }\n\n        bytes32 withdrawalCredentials = WithdrawalCredentials.get();\n\n        if (withdrawalCredentials == 0) {\n            revert InvalidWithdrawalCredentials();\n        }\n\n        for (uint256 idx = 0; idx < receivedPublicKeyCount; idx += 1) {\n            _depositValidator(publicKeys[idx], signatures[idx], withdrawalCredentials);\n        }\n\n        DepositedValidatorCount.set(DepositedValidatorCount.get() + receivedPublicKeyCount);\n    }\n\n    /// @notice Deposits 32 ETH to the official Deposit contract\n    /// @param _publicKey The public key of the validator\n    /// @param _signature The signature provided by the operator\n    /// @param _withdrawalCredentials The withdrawal credentials provided by River\n    function _depositValidator(\n        bytes memory _publicKey,\n        bytes memory _signature,\n        bytes32 _withdrawalCredentials\n    ) internal {\n        if (_publicKey.length != PUBLIC_KEY_LENGTH) {\n            revert InconsistentPublicKeys();\n        }\n\n        if (_signature.length != SIGNATURE_LENGTH) {\n            revert InconsistentSignatures();\n        }\n        uint256 value = DEPOSIT_SIZE;\n\n        uint256 depositAmount = value / 1000000000 wei;\n        assert(depositAmount * 1000000000 wei == value);\n\n        bytes32 pubkeyRoot = sha256(BytesLib.pad64(_publicKey));\n        bytes32 signatureRoot = sha256(\n            abi.encodePacked(\n                sha256(BytesLib.slice(_signature, 0, 64)),\n                sha256(BytesLib.pad64(BytesLib.slice(_signature, 64, SIGNATURE_LENGTH - 64)))\n            )\n        );\n\n        bytes32 depositDataRoot = sha256(\n            abi.encodePacked(\n                sha256(abi.encodePacked(pubkeyRoot, _withdrawalCredentials)),\n                sha256(abi.encodePacked(Uint256Lib.toLittleEndian64(depositAmount), signatureRoot))\n            )\n        );\n\n        uint256 targetBalance = address(this).balance - value;\n\n        DepositContractAddress.get().deposit{value: value}(\n            _publicKey,\n            abi.encodePacked(_withdrawalCredentials),\n            _signature,\n            depositDataRoot\n        );\n        require(address(this).balance == targetBalance, \"EXPECTING_DEPOSIT_TO_HAPPEN\");\n        emit FundedValidatorKey(_publicKey);\n    }\n\n    /// @notice Get the deposited validator count (the count of deposits made by the contract)\n    function getDepositedValidatorCount() external view returns (uint256 depositedValidatorCount) {\n        depositedValidatorCount = DepositedValidatorCount.get();\n    }\n}\n"
    },
    "contracts/src/components/TransferManager.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../libraries/Errors.sol\";\n\n/// @title Transfer Manager (v1)\n/// @author Kiln\n/// @notice This contract handles the inbound transfers cases or the explicit submissions\nabstract contract TransferManagerV1 {\n    event UserDeposit(address indexed depositor, address indexed recipient, uint256 amount);\n    event Donation(address donator, uint256 amount);\n\n    error EmptyDeposit();\n    error EmptyDonation();\n\n    /// @notice Handler called whenever a user has sent funds to the contract\n    /// @dev Must be overriden\n    /// @param _depositor Address that made the deposit\n    /// @param _recipient Address that receives the minted shares\n    /// @param _amount Amount deposited\n    function _onDeposit(\n        address _depositor,\n        address _recipient,\n        uint256 _amount\n    ) internal virtual;\n\n    /// @notice Handler called whenever a donation is received by the contract\n    /// @dev Must be overriden\n    /// @param _amount Amount donated\n    function _onDonation(uint256 _amount) internal virtual;\n\n    /// @notice Internal utility calling the deposit handler and emitting the deposit details\n    function _deposit(address _recipient) internal {\n        if (msg.value == 0) {\n            revert EmptyDeposit();\n        }\n\n        _onDeposit(msg.sender, _recipient, msg.value);\n\n        emit UserDeposit(msg.sender, _recipient, msg.value);\n    }\n\n    /// @notice Returns the amount of pending ETH\n    function getPendingEth() external view returns (uint256) {\n        return address(this).balance;\n    }\n\n    /// @notice Explicit deposit method to mint on msg.sender\n    function deposit() external payable {\n        _deposit(msg.sender);\n    }\n\n    /// @notice Explicit deposit method to mint on msg.sender and transfer to _recipient\n    /// @param _recipient Address receiving the minted lsETH\n    function depositAndTransfer(address _recipient) external payable {\n        _deposit(_recipient);\n    }\n\n    /// @notice Allows anyone to add ethers to river without minting new shares\n    /// @dev This method should be mainly used by the execution layer fee recipient to compound any collected fee\n    function donate() external payable {\n        if (msg.value == 0) {\n            revert EmptyDonation();\n        }\n\n        _onDonation(msg.value);\n\n        emit Donation(msg.sender, msg.value);\n    }\n\n    /// @notice Implicit deposit method, when the user performs a regular transfer to the contract\n    receive() external payable {\n        _deposit(msg.sender);\n    }\n\n    /// @notice Invalid call, when the user sends a transaction with a data payload but no method matched\n    fallback() external payable {\n        revert Errors.InvalidCall();\n    }\n}\n"
    },
    "contracts/src/components/SharesManager.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../interfaces/IERC20.sol\";\nimport \"../libraries/Errors.sol\";\n\nimport \"../state/river/Shares.sol\";\nimport \"../state/river/SharesPerOwner.sol\";\nimport \"../state/shared/ApprovalsPerOwner.sol\";\n\n/// @title Shares Manager (v1)\n/// @author Kiln\n/// @notice This contract handles the shares of the depositor and the rebasing effect depending on the oracle data\nabstract contract SharesManagerV1 is IERC20 {\n    error BalanceTooLow();\n    error AllowanceTooLow(address _from, address _operator, uint256 _allowance, uint256 _value);\n    error NullTransfer();\n\n    /// @notice Internal hook triggered on the external transfer call\n    /// @param _from Address of the sender\n    /// @param _to Address of the recipient\n    function _onTransfer(address _from, address _to) internal view virtual;\n\n    /// @notice Internal method to override to provide the total underlying asset balance\n    function _assetBalance() internal view virtual returns (uint256);\n\n    /// @notice Modifier used to ensure that the transfer is allowed by using the internal hook to perform internal checks\n    /// @param _from Address of the sender\n    /// @param _to Address of the recipient\n    modifier transferAllowed(address _from, address _to) {\n        _onTransfer(_from, _to);\n        _;\n    }\n\n    /// @notice Modifier used to ensure the amount transferred is not 0\n    /// @param _value Amount to check\n    modifier isNotZero(uint256 _value) {\n        if (_value == 0) {\n            revert NullTransfer();\n        }\n        _;\n    }\n\n    /// @notice Modifier used to ensure that the sender has enough funds for the transfer\n    /// @param _owner Address of the sender\n    /// @param _value Value that is required to be sent\n    modifier hasFunds(address _owner, uint256 _value) {\n        if (_balanceOf(_owner) < _value) {\n            revert BalanceTooLow();\n        }\n        _;\n    }\n\n    /// @notice Retrieve the token name\n    function name() external pure returns (string memory) {\n        return \"River Ether\";\n    }\n\n    /// @notice Retrieve the token symbol\n    function symbol() external pure returns (string memory) {\n        return \"lsETH\";\n    }\n\n    /// @notice Retrieve the decimal count\n    function decimals() external pure returns (uint8) {\n        return 18;\n    }\n\n    /// @notice Retrieve the total token supply\n    function totalSupply() external view returns (uint256) {\n        return _totalSupply();\n    }\n\n    /// @notice Retrieve the total underlying asset supply\n    function totalUnderlyingSupply() external view returns (uint256) {\n        return _assetBalance();\n    }\n\n    /// @notice Retrieve the balance of an account\n    /// @param _owner Address to be checked\n    function balanceOf(address _owner) external view returns (uint256 balance) {\n        return _balanceOf(_owner);\n    }\n\n    /// @notice Retrieve the underlying asset balance of an account\n    /// @param _owner Address to be checked\n    function balanceOfUnderlying(address _owner) public view returns (uint256 balance) {\n        return _balanceFromShares(SharesPerOwner.get(_owner));\n    }\n\n    function underlyingBalanceFromShares(uint256 shares) external view returns (uint256) {\n        return _balanceFromShares(shares);\n    }\n\n    function sharesFromUnderlyingBalance(uint256 underlyingBalance) external view returns (uint256) {\n        return _sharesFromBalance(underlyingBalance);\n    }\n\n    /// @notice Retrieve the allowance value for a spender\n    /// @notice _owner Address that issued the allowance\n    /// @notice _spender Address that received the allowance\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining) {\n        return ApprovalsPerOwner.get(_owner, _spender);\n    }\n\n    /// @notice Performs a transfer from the message sender to the provided account\n    /// @param _to Address receiving the tokens\n    /// @param _value Amount to be sent\n    function transfer(address _to, uint256 _value)\n        external\n        transferAllowed(msg.sender, _to)\n        isNotZero(_value)\n        hasFunds(msg.sender, _value)\n        returns (bool)\n    {\n        return _transfer(msg.sender, _to, _value);\n    }\n\n    /// @notice Performs a transfer between two recipients\n    /// @dev If the specified _from argument is the message sender, behaves like a regular transfer\n    /// @dev If the specified _from argument is not the message sender, checks that the message sender has been given enough allowance\n    /// @param _from Address sending the tokens\n    /// @param _to Address receiving the tokens\n    /// @param _value Amount to be sent\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) external transferAllowed(_from, _to) isNotZero(_value) hasFunds(_from, _value) returns (bool) {\n        if (_from != msg.sender) {\n            uint256 currentAllowance = ApprovalsPerOwner.get(_from, msg.sender);\n            if (currentAllowance < _value) {\n                revert AllowanceTooLow(_from, msg.sender, currentAllowance, _value);\n            }\n            ApprovalsPerOwner.set(_from, msg.sender, currentAllowance - _value);\n        }\n        return _transfer(_from, _to, _value);\n    }\n\n    /// @notice Approves an account for future spendings\n    /// @dev An approved account can use transferFrom to transfer funds on behalf of the token owner\n    /// @param _spender Address that is allowed to spend the tokens\n    /// @param _value The allowed amount, will override previous value\n    function approve(address _spender, uint256 _value) external returns (bool success) {\n        ApprovalsPerOwner.set(msg.sender, _spender, _value);\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    /// @notice Internal utility to retrieve the total supply of tokens\n    function _totalSupply() internal view returns (uint256) {\n        return Shares.get();\n    }\n\n    /// @notice Internal utility to perform an unchecked transfer\n    /// @param _from Address sending the tokens\n    /// @param _to Address receiving the tokens\n    /// @param _value Amount to be sent\n    function _transfer(\n        address _from,\n        address _to,\n        uint256 _value\n    ) internal returns (bool) {\n        SharesPerOwner.set(_from, SharesPerOwner.get(_from) - _value);\n        SharesPerOwner.set(_to, SharesPerOwner.get(_to) + _value);\n\n        emit Transfer(_from, _to, _value);\n\n        return true;\n    }\n\n    /// @notice Internal utility to retrieve the underlying asset balance for the given shares\n    /// @param _shares Amount of shares to convert\n    function _balanceFromShares(uint256 _shares) internal view returns (uint256) {\n        uint256 _totalSharesValue = Shares.get();\n\n        if (_totalSharesValue == 0) {\n            return 0;\n        }\n\n        return ((_shares * _assetBalance())) / _totalSharesValue;\n    }\n\n    /// @notice Internal utility to retrieve the shares count for a given underlying asset amount\n    /// @param _balance Amount of underlying asset balance to convert\n    function _sharesFromBalance(uint256 _balance) internal view returns (uint256) {\n        uint256 _totalSharesValue = Shares.get();\n\n        if (_totalSharesValue == 0) {\n            return 0;\n        }\n\n        return (_balance * _totalSharesValue) / _assetBalance();\n    }\n\n    /// @notice Internal utility to mint shares for the specified user\n    /// @dev This method assumes that funds received are now part of the _assetBalance()\n    /// @param _owner Account that should receive the new shares\n    /// @param _underlyingAssetValue Value of underlying asset received, to convert into shares\n    function _mintShares(address _owner, uint256 _underlyingAssetValue) internal {\n        uint256 assetBalance = _assetBalance();\n        uint256 oldTotalAssetBalance = _assetBalance() - _underlyingAssetValue;\n\n        if (oldTotalAssetBalance == 0) {\n            _mintRawShares(_owner, assetBalance);\n        } else {\n            uint256 sharesToMint = (_underlyingAssetValue * _totalSupply()) / oldTotalAssetBalance;\n            _mintRawShares(_owner, sharesToMint);\n        }\n    }\n\n    /// @notice Internal utility to mint shares without any conversion, and emits a mint Transfer event\n    /// @param _owner Account that should receive the new shares\n    /// @param _value Amount of shares to mint\n    function _mintRawShares(address _owner, uint256 _value) internal {\n        Shares.set(Shares.get() + _value);\n        SharesPerOwner.set(_owner, SharesPerOwner.get(_owner) + _value);\n        emit Transfer(address(0), _owner, _value);\n    }\n\n    /// @notice Internal utility to retrieve the amount of shares per owner\n    /// @param _owner Account to be checked\n    function _balanceOf(address _owner) internal view returns (uint256 balance) {\n        return SharesPerOwner.get(_owner);\n    }\n}\n"
    },
    "contracts/src/components/OracleManager.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../libraries/Errors.sol\";\nimport \"../libraries/LibOwnable.sol\";\n\nimport \"../state/river/OracleAddress.sol\";\nimport \"../state/river/LastOracleRoundId.sol\";\nimport \"../state/river/BeaconValidatorBalanceSum.sol\";\nimport \"../state/river/BeaconValidatorCount.sol\";\nimport \"../state/river/DepositedValidatorCount.sol\";\n\n/// @title Oracle Manager (v1)\n/// @author Kiln\n/// @notice This contract handles the inputs provided by the oracle\nabstract contract OracleManagerV1 {\n    event BeaconDataUpdate(uint256 validatorCount, uint256 validatorBalanceSum, bytes32 roundId);\n\n    error InvalidValidatorCountReport(uint256 _providedValidatorCount, uint256 _depositedValidatorCount);\n\n    /// @notice Handler called if the delta between the last and new validator balance sum is positive\n    /// @dev Must be overriden\n    /// @param _profits The positive increase in the validator balance sum (staking rewards)\n    function _onEarnings(uint256 _profits) internal virtual;\n\n    /// @notice Prevents unauthorized calls\n    modifier onlyAdmin() virtual {\n        if (msg.sender != LibOwnable._getAdmin()) {\n            revert Errors.Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    /// @notice Set the initial oracle address\n    /// @param _oracle Address of the oracle\n    function initOracleManagerV1(address _oracle) internal {\n        OracleAddress.set(_oracle);\n    }\n\n    /// @notice Sets the validator count and validator balance sum reported by the oracle\n    /// @dev Can only be called by the oracle address\n    /// @param _validatorCount The number of active validators on the consensus layer\n    /// @param _validatorBalanceSum The validator balance sum of the active validators on the consensus layer\n    /// @param _roundId An identifier for this update\n    function setBeaconData(\n        uint256 _validatorCount,\n        uint256 _validatorBalanceSum,\n        bytes32 _roundId\n    ) external {\n        if (msg.sender != OracleAddress.get()) {\n            revert Errors.Unauthorized(msg.sender);\n        }\n\n        if (_validatorCount > DepositedValidatorCount.get()) {\n            revert InvalidValidatorCountReport(_validatorCount, DepositedValidatorCount.get());\n        }\n\n        uint256 previousValidatorBalanceSum = BeaconValidatorBalanceSum.get();\n        uint256 newValidators = _validatorCount - BeaconValidatorCount.get();\n\n        BeaconValidatorBalanceSum.set(_validatorBalanceSum);\n        BeaconValidatorCount.set(_validatorCount);\n        LastOracleRoundId.set(_roundId);\n\n        if (previousValidatorBalanceSum < _validatorBalanceSum) {\n            _onEarnings(_validatorBalanceSum - previousValidatorBalanceSum - newValidators * 32 ether);\n        }\n\n        emit BeaconDataUpdate(_validatorCount, _validatorBalanceSum, _roundId);\n    }\n\n    /// @notice Get Oracle address\n    function getOracle() external view returns (address oracle) {\n        oracle = OracleAddress.get();\n    }\n\n    /// @notice Set Oracle address\n    /// @param _oracleAddress Address of the oracle\n    function setOracle(address _oracleAddress) external onlyAdmin {\n        OracleAddress.set(_oracleAddress);\n    }\n\n    /// @notice Get Beacon validator balance sum\n    function getBeaconValidatorBalanceSum() external view returns (uint256 beaconValidatorBalanceSum) {\n        beaconValidatorBalanceSum = BeaconValidatorBalanceSum.get();\n    }\n\n    /// @notice Get Beacon validator count (the amount of validator reported by the oracles)\n    function getBeaconValidatorCount() external view returns (uint256 beaconValidatorCount) {\n        beaconValidatorCount = BeaconValidatorCount.get();\n    }\n}\n"
    },
    "contracts/src/components/OperatorsManager.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../libraries/Errors.sol\";\nimport \"../libraries/Uint256Lib.sol\";\nimport \"../libraries/LibOwnable.sol\";\n\nimport \"../state/river/Operators.sol\";\nimport \"../state/river/ValidatorKeys.sol\";\n\n/// @title Operators Manager (v1)\n/// @author Kiln\n/// @notice This contract handles the operator and key list\ncontract OperatorsManagerV1 {\n    error OperatorAlreadyExists(string name);\n    error InactiveOperator(uint256 index);\n    error InvalidFundedKeyDeletionAttempt();\n    error InvalidUnsortedIndexes();\n    error InvalidArrayLengths();\n    error InvalidEmptyArray();\n    error InvalidKeyCount();\n    error InvalidPublicKeysLength();\n    error InvalidSignatureLength();\n    error InvalidIndexOutOfBounds();\n    error OperatorLimitTooHigh(uint256 limit, uint256 keyCount);\n\n    event AddedOperator(uint256 indexed index, string name, address operatorAddress, address feeRecipientAddress);\n    event SetOperatorStatus(uint256 indexed index, bool active);\n    event SetOperatorLimit(uint256 indexed index, uint256 newLimit);\n    event SetOperatorStoppedValidatorCount(uint256 indexed index, uint256 newStoppedValidatorCount);\n    event SetOperatorFeeRecipientAddress(uint256 indexed index, address newOperatorAddress);\n    event SetOperatorAddress(uint256 indexed index, address newOperatorAddress);\n    event AddedValidatorKeys(uint256 indexed index, bytes publicKeys);\n    event RemovedValidatorKey(uint256 indexed index, bytes publicKey);\n\n    /// @notice Prevents unauthorized calls\n    modifier onlyAdmin() virtual {\n        if (msg.sender != LibOwnable._getAdmin()) {\n            revert Errors.Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    /// @notice Prevents the call from working if the operator is not active\n    /// @param _index The name identifying the operator\n    modifier active(uint256 _index) {\n        if (Operators.getByIndex(_index).active == false) {\n            revert InactiveOperator(_index);\n        }\n        _;\n    }\n\n    /// @notice Prevents anyone except the admin or the given operator fee recipient to make the call. Also checks if operator is active\n    /// @param _index The name identifying the operator\n    modifier operatorFeeRecipientOrAdmin(uint256 _index) {\n        if (msg.sender == LibOwnable._getAdmin()) {\n            _;\n            return;\n        }\n        Operators.Operator storage operator = Operators.getByIndex(_index);\n        if (operator.active == false) {\n            revert InactiveOperator(_index);\n        }\n        if (msg.sender != operator.feeRecipient) {\n            revert Errors.Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    /// @notice Prevents anyone except the admin or the given operator to make the call. Also checks if operator is active\n    /// @param _index The name identifying the operator\n    modifier operatorOrAdmin(uint256 _index) {\n        if (msg.sender == LibOwnable._getAdmin()) {\n            _;\n            return;\n        }\n        Operators.Operator storage operator = Operators.getByIndex(_index);\n        if (operator.active == false) {\n            revert InactiveOperator(_index);\n        }\n        if (msg.sender != operator.operator) {\n            revert Errors.Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    /// @notice Retrieve the operator details from the operator name\n    /// @param _name Name of the operator\n    function getOperatorDetails(string calldata _name) external view returns (int256 _index, address _operatorAddress) {\n        _index = Operators.indexOf(_name);\n        _operatorAddress = Operators.get(_name).operator;\n    }\n\n    /// @notice Adds an operator to the registry\n    /// @dev Only callable by the administrator\n    /// @param _name The name identifying the operator\n    /// @param _operator The address representing the operator, receiving the rewards\n    /// @param _feeRecipient The address where the rewards are sent\n    function addOperator(\n        string calldata _name,\n        address _operator,\n        address _feeRecipient\n    ) external onlyAdmin {\n        if (Operators.exists(_name) == true) {\n            revert OperatorAlreadyExists(_name);\n        }\n\n        Operators.Operator memory newOperator = Operators.Operator({\n            active: true,\n            operator: _operator,\n            feeRecipient: _feeRecipient,\n            name: _name,\n            limit: 0,\n            funded: 0,\n            keys: 0,\n            stopped: 0\n        });\n\n        uint256 operatorIndex = Operators.set(_name, newOperator);\n\n        emit AddedOperator(operatorIndex, newOperator.name, newOperator.operator, newOperator.feeRecipient);\n    }\n\n    /// @notice Changes the operator address of an operator\n    /// @dev Only callable by the administrator or the previous operator address\n    /// @param _index The operator index\n    /// @param _newOperatorAddress The new address of the operator\n    function setOperatorAddress(uint256 _index, address _newOperatorAddress) external operatorOrAdmin(_index) {\n        Operators.Operator storage operator = Operators.getByIndex(_index);\n\n        operator.operator = _newOperatorAddress;\n\n        emit SetOperatorAddress(_index, _newOperatorAddress);\n    }\n\n    /// @notice Changes the operator fee recipient address\n    /// @dev Only callable by the administrator or the previous operator fee recipient address\n    /// @param _index The operator index\n    /// @param _newOperatorFeeRecipientAddress The new fee recipient address of the operator\n    function setOperatorFeeRecipientAddress(uint256 _index, address _newOperatorFeeRecipientAddress)\n        external\n        operatorFeeRecipientOrAdmin(_index)\n    {\n        Operators.Operator storage operator = Operators.getByIndex(_index);\n\n        operator.feeRecipient = _newOperatorFeeRecipientAddress;\n\n        emit SetOperatorFeeRecipientAddress(_index, _newOperatorFeeRecipientAddress);\n    }\n\n    /// @notice Changes the operator status\n    /// @dev Only callable by the administrator\n    /// @param _index The operator index\n    /// @param _newStatus The new status of the operator\n    function setOperatorStatus(uint256 _index, bool _newStatus) external onlyAdmin {\n        Operators.Operator storage operator = Operators.getByIndex(_index);\n\n        operator.active = _newStatus;\n\n        emit SetOperatorStatus(_index, _newStatus);\n    }\n\n    /// @notice Changes the operator stopped validator cound\n    /// @dev Only callable by the administrator\n    /// @param _index The operator index\n    /// @param _newStoppedValidatorCount The new stopped validator count of the operator\n    function setOperatorStoppedValidatorCount(uint256 _index, uint256 _newStoppedValidatorCount) external onlyAdmin {\n        Operators.Operator storage operator = Operators.getByIndex(_index);\n\n        if (_newStoppedValidatorCount > operator.funded) {\n            revert Errors.InvalidArgument();\n        }\n\n        operator.stopped = _newStoppedValidatorCount;\n\n        emit SetOperatorStoppedValidatorCount(_index, operator.stopped);\n    }\n\n    /// @notice Changes the operator staking limit\n    /// @dev Only callable by the administrator\n    /// @dev The limit cannot exceed the total key count of the operator\n    /// @dev The _indexes and _newLimits must have the same length.\n    /// @dev Each limit value is applied to the operator index at the same index in the _indexes array.\n    /// @param _operatorIndexes The operator indexes\n    /// @param _newLimits The new staking limit of the operators\n    function setOperatorLimits(uint256[] calldata _operatorIndexes, uint256[] calldata _newLimits) external onlyAdmin {\n        if (_operatorIndexes.length != _newLimits.length) {\n            revert InvalidArrayLengths();\n        }\n        if (_operatorIndexes.length == 0) {\n            revert InvalidEmptyArray();\n        }\n        for (uint256 idx = 0; idx < _operatorIndexes.length; ) {\n            Operators.Operator storage operator = Operators.getByIndex(_operatorIndexes[idx]);\n            if (_newLimits[idx] > operator.keys) {\n                revert OperatorLimitTooHigh(_newLimits[idx], operator.keys);\n            }\n\n            operator.limit = _newLimits[idx];\n\n            emit SetOperatorLimit(_operatorIndexes[idx], operator.limit);\n\n            unchecked {\n                ++idx;\n            }\n        }\n    }\n\n    /// @notice Adds new keys for an operator\n    /// @dev Only callable by the administrator or the operator address\n    /// @param _index The operator index\n    /// @param _keyCount The amount of keys provided\n    /// @param _publicKeys Public keys of the validator, concatenated\n    /// @param _signatures Signatures of the validator keys, concatenated\n    function addValidators(\n        uint256 _index,\n        uint256 _keyCount,\n        bytes calldata _publicKeys,\n        bytes calldata _signatures\n    ) external operatorOrAdmin(_index) {\n        if (_keyCount == 0) {\n            revert InvalidKeyCount();\n        }\n\n        if (_publicKeys.length != _keyCount * ValidatorKeys.PUBLIC_KEY_LENGTH) {\n            revert InvalidPublicKeysLength();\n        }\n\n        if (_signatures.length != _keyCount * ValidatorKeys.SIGNATURE_LENGTH) {\n            revert InvalidSignatureLength();\n        }\n\n        Operators.Operator storage operator = Operators.getByIndex(_index);\n\n        for (uint256 idx = 0; idx < _keyCount; ++idx) {\n            bytes memory publicKey = BytesLib.slice(\n                _publicKeys,\n                idx * ValidatorKeys.PUBLIC_KEY_LENGTH,\n                ValidatorKeys.PUBLIC_KEY_LENGTH\n            );\n            bytes memory signature = BytesLib.slice(\n                _signatures,\n                idx * ValidatorKeys.SIGNATURE_LENGTH,\n                ValidatorKeys.SIGNATURE_LENGTH\n            );\n            ValidatorKeys.set(_index, operator.keys + idx, publicKey, signature);\n        }\n\n        operator.keys += _keyCount;\n\n        emit AddedValidatorKeys(_index, _publicKeys);\n    }\n\n    /// @notice Remove validator keys\n    /// @dev Only callable by the administrator or the operator address\n    /// @dev The indexes must be provided sorted in decreasing order, otherwise the method will revert\n    /// @dev The operator limit will be set to the lowest deleted key index\n    /// @param _index The operator index\n    /// @param _indexes The indexes of the keys to remove\n    function removeValidators(uint256 _index, uint256[] calldata _indexes) external operatorOrAdmin(_index) {\n        Operators.Operator storage operator = Operators.getByIndex(_index);\n\n        if (_indexes.length == 0) {\n            revert InvalidKeyCount();\n        }\n\n        for (uint256 idx = 0; idx < _indexes.length; ++idx) {\n            uint256 keyIndex = _indexes[idx];\n\n            if (keyIndex < operator.funded) {\n                revert InvalidFundedKeyDeletionAttempt();\n            }\n\n            if (keyIndex >= operator.keys) {\n                revert InvalidIndexOutOfBounds();\n            }\n\n            if (idx > 0 && _indexes[idx] >= _indexes[idx - 1]) {\n                revert InvalidUnsortedIndexes();\n            }\n\n            uint256 lastKeyIndex = operator.keys - 1;\n            (bytes memory removedPublicKey, ) = ValidatorKeys.get(_index, keyIndex);\n            (bytes memory lastPublicKey, bytes memory lastSignature) = ValidatorKeys.get(_index, lastKeyIndex);\n            ValidatorKeys.set(_index, keyIndex, lastPublicKey, lastSignature);\n            ValidatorKeys.set(_index, lastKeyIndex, new bytes(0), new bytes(0));\n            operator.keys -= 1;\n            emit RemovedValidatorKey(_index, removedPublicKey);\n        }\n\n        if (_indexes[_indexes.length - 1] < operator.limit) {\n            operator.limit = _indexes[_indexes.length - 1];\n        }\n    }\n\n    /// @notice Get operator details by name\n    /// @param _name The name identifying the operator\n    function getOperatorByName(string calldata _name) external view returns (Operators.Operator memory) {\n        return Operators.get(_name);\n    }\n\n    /// @notice Get operator details\n    /// @param _index The index of the operator\n    function getOperator(uint256 _index) external view returns (Operators.Operator memory) {\n        return Operators.getByIndex(_index);\n    }\n\n    /// @notice Get operator count\n    function getOperatorCount() external view returns (uint256) {\n        return Operators.getCount();\n    }\n\n    /// @notice Get the details of a validator\n    /// @param _operatorIndex The index of the operator\n    /// @param _validatorIndex The index of the validator\n    function getValidator(uint256 _operatorIndex, uint256 _validatorIndex)\n        external\n        view\n        returns (\n            bytes memory publicKey,\n            bytes memory signature,\n            bool funded\n        )\n    {\n        (publicKey, signature) = ValidatorKeys.get(_operatorIndex, _validatorIndex);\n        funded = _validatorIndex < Operators.getByIndex(_operatorIndex).funded;\n    }\n\n    /// @notice Internal utility to concatenate bytes arrays together\n    function _concatenateByteArrays(bytes[] memory arr1, bytes[] memory arr2)\n        internal\n        pure\n        returns (bytes[] memory res)\n    {\n        res = new bytes[](arr1.length + arr2.length);\n        for (uint256 idx = 0; idx < arr1.length; ++idx) {\n            res[idx] = arr1[idx];\n        }\n        for (uint256 idx = 0; idx < arr2.length; ++idx) {\n            res[idx + arr1.length] = arr2[idx];\n        }\n    }\n\n    /// @notice Handler called whenever a deposit to the consensus layer is made. Should retrieve _requestedAmount or lower keys\n    /// @param _requestedAmount Amount of keys required. Contract is expected to send _requestedAmount or lower.\n    function _getNextValidatorsFromActiveOperators(uint256 _requestedAmount)\n        internal\n        returns (bytes[] memory publicKeys, bytes[] memory signatures)\n    {\n        Operators.CachedOperator[] memory operators = Operators.getAllFundable();\n\n        if (operators.length == 0) {\n            return (new bytes[](0), new bytes[](0));\n        }\n\n        uint256 selectedOperatorIndex = 0;\n        for (uint256 idx = 1; idx < operators.length; ++idx) {\n            if (\n                operators[idx].funded - operators[idx].stopped <\n                operators[selectedOperatorIndex].funded - operators[selectedOperatorIndex].stopped\n            ) {\n                selectedOperatorIndex = idx;\n            }\n        }\n\n        uint256 selectedOperatorAvailableKeys = Uint256Lib.min(\n            operators[selectedOperatorIndex].keys,\n            operators[selectedOperatorIndex].limit\n        ) - operators[selectedOperatorIndex].funded;\n\n        if (selectedOperatorAvailableKeys == 0) {\n            return (new bytes[](0), new bytes[](0));\n        }\n\n        Operators.Operator storage operator = Operators.get(operators[selectedOperatorIndex].name);\n        if (selectedOperatorAvailableKeys >= _requestedAmount) {\n            (publicKeys, signatures) = ValidatorKeys.getKeys(\n                operators[selectedOperatorIndex].index,\n                operators[selectedOperatorIndex].funded,\n                _requestedAmount\n            );\n            operator.funded += _requestedAmount;\n        } else {\n            (publicKeys, signatures) = ValidatorKeys.getKeys(\n                operators[selectedOperatorIndex].index,\n                operators[selectedOperatorIndex].funded,\n                selectedOperatorAvailableKeys\n            );\n            operator.funded += selectedOperatorAvailableKeys;\n            (\n                bytes[] memory additionalPublicKeys,\n                bytes[] memory additionalSignatures\n            ) = _getNextValidatorsFromActiveOperators(_requestedAmount - selectedOperatorAvailableKeys);\n            publicKeys = _concatenateByteArrays(publicKeys, additionalPublicKeys);\n            signatures = _concatenateByteArrays(signatures, additionalSignatures);\n        }\n    }\n}\n"
    },
    "contracts/src/state/river/AllowlistAddress.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/UnstructuredStorage.sol\";\nimport \"../../interfaces/IAllowlist.sol\";\n\nlibrary AllowlistAddress {\n    bytes32 internal constant ALLOWLIST_ADDRESS_SLOT = bytes32(uint256(keccak256(\"river.state.allowlistAddress\")) - 1);\n\n    function get() internal view returns (IAllowlist) {\n        return IAllowlist(UnstructuredStorage.getStorageAddress(ALLOWLIST_ADDRESS_SLOT));\n    }\n\n    function set(address newValue) internal {\n        UnstructuredStorage.setStorageAddress(ALLOWLIST_ADDRESS_SLOT, newValue);\n    }\n}\n"
    },
    "contracts/src/state/river/TreasuryAddress.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/UnstructuredStorage.sol\";\n\nlibrary TreasuryAddress {\n    bytes32 internal constant TREASURY_ADDRESS_SLOT = bytes32(uint256(keccak256(\"river.state.treasuryAddress\")) - 1);\n\n    function get() internal view returns (address) {\n        return UnstructuredStorage.getStorageAddress(TREASURY_ADDRESS_SLOT);\n    }\n\n    function set(address newValue) internal {\n        UnstructuredStorage.setStorageAddress(TREASURY_ADDRESS_SLOT, newValue);\n    }\n}\n"
    },
    "contracts/src/state/river/OperatorRewardsShare.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/UnstructuredStorage.sol\";\n\nlibrary OperatorRewardsShare {\n    bytes32 internal constant OPERATOR_REWARDS_SHARE_SLOT =\n        bytes32(uint256(keccak256(\"river.state.operatorRewardsShare\")) - 1);\n\n    function get() internal view returns (uint256) {\n        return UnstructuredStorage.getStorageUint256(OPERATOR_REWARDS_SHARE_SLOT);\n    }\n\n    function set(uint256 newValue) internal {\n        UnstructuredStorage.setStorageUint256(OPERATOR_REWARDS_SHARE_SLOT, newValue);\n    }\n}\n"
    },
    "contracts/src/interfaces/IDepositContract.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\ninterface IDepositContract {\n    function deposit(\n        bytes calldata pubkey,\n        bytes calldata withdrawalCredentials,\n        bytes calldata signature,\n        bytes32 depositDataRoot\n    ) external payable;\n}\n"
    },
    "contracts/src/libraries/BytesLib.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nlibrary BytesLib {\n    function pad64(bytes memory _b) internal pure returns (bytes memory) {\n        assert(_b.length >= 32 && _b.length <= 64);\n        if (64 == _b.length) return _b;\n\n        bytes memory zero32 = new bytes(32);\n        assembly {\n            mstore(add(zero32, 0x20), 0)\n        }\n\n        if (32 == _b.length) return BytesLib.concat(_b, zero32);\n        else return BytesLib.concat(_b, BytesLib.slice(zero32, 0, uint256(64) - _b.length));\n    }\n\n    function concat(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bytes memory) {\n        bytes memory tempBytes;\n\n        assembly {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n            // Store the length of the first bytes array at the beginning of\n            // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n            // Maintain a memory counter for the current write location in the\n            // temp bytes array by adding the 32 bytes for the array length to\n            // the starting location.\n            let mc := add(tempBytes, 0x20)\n            // Stop copying when the memory counter reaches the length of the\n            // first bytes array.\n            let end := add(mc, length)\n\n            for {\n                // Initialize a copy counter to the start of the _preBytes data,\n                // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                // Write the _preBytes data into the tempBytes memory 32 bytes\n                // at a time.\n                mstore(mc, mload(cc))\n            }\n\n            // Add the length of _postBytes to the current length of tempBytes\n            // and store it as the new length in the first 32 bytes of the\n            // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n            // Move the memory counter back from a multiple of 0x20 to the\n            // actual end of the _preBytes data.\n            mc := end\n            // Stop copying when the memory counter reaches the new combined\n            // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n            // Update the free-memory pointer by padding our last write location\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n            // next 32 byte block, then round down to the nearest multiple of\n            // 32. If the sum of the length of the two arrays is zero then add\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(\n                0x40,\n                and(\n                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n                    not(31) // Round down to the nearest 32 bytes.\n                )\n            )\n        }\n\n        return tempBytes;\n    }\n\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    ) internal pure returns (bytes memory) {\n        require(_length + 31 >= _length, \"slice_overflow\");\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n}\n"
    },
    "contracts/src/libraries/Uint256Lib.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nlibrary Uint256Lib {\n    function toLittleEndian64(uint256 _value) internal pure returns (uint256 result) {\n        result = 0;\n        uint256 temp_value = _value;\n        for (uint256 i = 0; i < 8; ++i) {\n            result = (result << 8) | (temp_value & 0xFF);\n            temp_value >>= 8;\n        }\n\n        assert(0 == temp_value); // fully converted\n        result <<= (24 * 8);\n    }\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256 max) {\n        return (a > b ? b : a);\n    }\n}\n"
    },
    "contracts/src/state/river/DepositContractAddress.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../interfaces/IDepositContract.sol\";\nimport \"../../libraries/UnstructuredStorage.sol\";\n\nlibrary DepositContractAddress {\n    bytes32 internal constant DEPOSIT_CONTRACT_ADDRESS_SLOT =\n        bytes32(uint256(keccak256(\"river.state.depositContractAddress\")) - 1);\n\n    function get() internal view returns (IDepositContract) {\n        return IDepositContract(UnstructuredStorage.getStorageAddress(DEPOSIT_CONTRACT_ADDRESS_SLOT));\n    }\n\n    function set(IDepositContract newValue) internal {\n        return UnstructuredStorage.setStorageAddress(DEPOSIT_CONTRACT_ADDRESS_SLOT, address(newValue));\n    }\n}\n"
    },
    "contracts/src/state/river/WithdrawalCredentials.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\nimport \"../../libraries/UnstructuredStorage.sol\";\n\nlibrary WithdrawalCredentials {\n    bytes32 internal constant WITHDRAWAL_CREDENTIALS_SLOT =\n        bytes32(uint256(keccak256(\"river.state.withdrawalCredentials\")) - 1);\n\n    function get() internal view returns (bytes32) {\n        return UnstructuredStorage.getStorageBytes32(WITHDRAWAL_CREDENTIALS_SLOT);\n    }\n\n    function set(bytes32 newValue) internal {\n        UnstructuredStorage.setStorageBytes32(WITHDRAWAL_CREDENTIALS_SLOT, newValue);\n    }\n}\n"
    },
    "contracts/src/state/river/DepositedValidatorCount.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/UnstructuredStorage.sol\";\n\nlibrary DepositedValidatorCount {\n    bytes32 internal constant DEPOSITED_VALIDATOR_COUNT_SLOT =\n        bytes32(uint256(keccak256(\"river.state.depositedValidatorCount\")) - 1);\n\n    function get() internal view returns (uint256) {\n        return UnstructuredStorage.getStorageUint256(DEPOSITED_VALIDATOR_COUNT_SLOT);\n    }\n\n    function set(uint256 newValue) internal {\n        UnstructuredStorage.setStorageUint256(DEPOSITED_VALIDATOR_COUNT_SLOT, newValue);\n    }\n}\n"
    },
    "contracts/src/interfaces/IERC20.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\ninterface IERC20 {\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address _owner) external view returns (uint256 balance);\n\n    function transfer(address _to, uint256 _value) external returns (bool success);\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) external returns (bool success);\n\n    function approve(address _spender, uint256 _value) external returns (bool success);\n\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\n}\n"
    },
    "contracts/src/state/river/Shares.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/UnstructuredStorage.sol\";\n\nlibrary Shares {\n    bytes32 internal constant SHARES_SLOT = bytes32(uint256(keccak256(\"river.state.shares\")) - 1);\n\n    function get() internal view returns (uint256) {\n        return UnstructuredStorage.getStorageUint256(SHARES_SLOT);\n    }\n\n    function set(uint256 newValue) internal {\n        UnstructuredStorage.setStorageUint256(SHARES_SLOT, newValue);\n    }\n}\n"
    },
    "contracts/src/state/river/SharesPerOwner.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nlibrary SharesPerOwner {\n    bytes32 internal constant SHARES_SLOT = bytes32(uint256(keccak256(\"river.state.sharesPerOwner\")) - 1);\n\n    struct Slot {\n        mapping(address => uint256) value;\n    }\n\n    function get(address owner) internal view returns (uint256) {\n        bytes32 slot = SHARES_SLOT;\n\n        Slot storage r;\n\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value[owner];\n    }\n\n    function set(address owner, uint256 newValue) internal {\n        bytes32 slot = SHARES_SLOT;\n\n        Slot storage r;\n\n        assembly {\n            r.slot := slot\n        }\n\n        r.value[owner] = newValue;\n    }\n}\n"
    },
    "contracts/src/state/shared/ApprovalsPerOwner.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nlibrary ApprovalsPerOwner {\n    bytes32 internal constant APPROVALS_PER_OWNER_SLOT =\n        bytes32(uint256(keccak256(\"river.state.approvalsPerOwner\")) - 1);\n\n    struct Slot {\n        mapping(address => mapping(address => uint256)) value;\n    }\n\n    function get(address owner, address operator) internal view returns (uint256) {\n        bytes32 slot = APPROVALS_PER_OWNER_SLOT;\n\n        Slot storage r;\n\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value[owner][operator];\n    }\n\n    function set(\n        address owner,\n        address operator,\n        uint256 newValue\n    ) internal {\n        bytes32 slot = APPROVALS_PER_OWNER_SLOT;\n\n        Slot storage r;\n\n        assembly {\n            r.slot := slot\n        }\n\n        r.value[owner][operator] = newValue;\n    }\n}\n"
    },
    "contracts/src/state/river/OracleAddress.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/UnstructuredStorage.sol\";\n\nlibrary OracleAddress {\n    bytes32 internal constant ORACLE_ADDRESS_SLOT = bytes32(uint256(keccak256(\"river.state.oracleAddress\")) - 1);\n\n    function get() internal view returns (address) {\n        return UnstructuredStorage.getStorageAddress(ORACLE_ADDRESS_SLOT);\n    }\n\n    function set(address newValue) internal {\n        UnstructuredStorage.setStorageAddress(ORACLE_ADDRESS_SLOT, newValue);\n    }\n}\n"
    },
    "contracts/src/state/river/LastOracleRoundId.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/UnstructuredStorage.sol\";\n\nlibrary LastOracleRoundId {\n    bytes32 internal constant LAST_ORACLE_ROUND_ID_SLOT =\n        bytes32(uint256(keccak256(\"river.state.lastOracleRoundId\")) - 1);\n\n    function get() internal view returns (bytes32) {\n        return UnstructuredStorage.getStorageBytes32(LAST_ORACLE_ROUND_ID_SLOT);\n    }\n\n    function set(bytes32 newValue) internal {\n        UnstructuredStorage.setStorageBytes32(LAST_ORACLE_ROUND_ID_SLOT, newValue);\n    }\n}\n"
    },
    "contracts/src/state/river/BeaconValidatorBalanceSum.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/UnstructuredStorage.sol\";\n\nlibrary BeaconValidatorBalanceSum {\n    bytes32 internal constant VALIDATOR_BALANCE_SUM_SLOT =\n        bytes32(uint256(keccak256(\"river.state.beaconValidatorBalanceSum\")) - 1);\n\n    function get() internal view returns (uint256) {\n        return UnstructuredStorage.getStorageUint256(VALIDATOR_BALANCE_SUM_SLOT);\n    }\n\n    function set(uint256 newValue) internal {\n        UnstructuredStorage.setStorageUint256(VALIDATOR_BALANCE_SUM_SLOT, newValue);\n    }\n}\n"
    },
    "contracts/src/state/river/BeaconValidatorCount.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/UnstructuredStorage.sol\";\n\nlibrary BeaconValidatorCount {\n    bytes32 internal constant BEACON_VALIDATOR_COUNT_SLOT =\n        bytes32(uint256(keccak256(\"river.state.beaconValidatorCount\")) - 1);\n\n    function get() internal view returns (uint256) {\n        return UnstructuredStorage.getStorageUint256(BEACON_VALIDATOR_COUNT_SLOT);\n    }\n\n    function set(uint256 newValue) internal {\n        UnstructuredStorage.setStorageUint256(BEACON_VALIDATOR_COUNT_SLOT, newValue);\n    }\n}\n"
    },
    "contracts/src/state/river/Operators.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nlibrary Operators {\n    bytes32 internal constant OPERATORS_SLOT = bytes32(uint256(keccak256(\"river.state.operators\")) - 1);\n\n    bytes32 internal constant OPERATORS_MAPPING_SLOT = bytes32(uint256(keccak256(\"river.state.operatorsMapping\")) - 1);\n\n    struct Operator {\n        bool active;\n        string name;\n        address operator;\n        address feeRecipient;\n        uint256 limit;\n        uint256 funded;\n        uint256 keys;\n        uint256 stopped;\n    }\n\n    struct CachedOperator {\n        bool active;\n        string name;\n        address operator;\n        address feeRecipient;\n        uint256 limit;\n        uint256 funded;\n        uint256 keys;\n        uint256 stopped;\n        uint256 index;\n    }\n\n    struct OperatorResolution {\n        bool active;\n        uint256 index;\n    }\n\n    struct SlotOperator {\n        Operator[] value;\n    }\n\n    struct SlotOperatorMapping {\n        mapping(string => OperatorResolution) value;\n    }\n\n    error OperatorNotFound(string name);\n    error OperatorNotFoundAtIndex(uint256 index);\n\n    function _getOperatorIndex(string memory name) internal view returns (uint256) {\n        bytes32 slot = OPERATORS_MAPPING_SLOT;\n\n        SlotOperatorMapping storage opm;\n\n        assembly {\n            opm.slot := slot\n        }\n\n        if (opm.value[name].active == false) {\n            revert OperatorNotFound(name);\n        }\n\n        return opm.value[name].index;\n    }\n\n    function _getOperatorActive(string memory name) internal view returns (bool) {\n        bytes32 slot = OPERATORS_MAPPING_SLOT;\n\n        SlotOperatorMapping storage opm;\n\n        assembly {\n            opm.slot := slot\n        }\n        return opm.value[name].active;\n    }\n\n    function _setOperatorIndex(\n        string memory name,\n        bool active,\n        uint256 index\n    ) internal {\n        bytes32 slot = OPERATORS_MAPPING_SLOT;\n\n        SlotOperatorMapping storage opm;\n\n        assembly {\n            opm.slot := slot\n        }\n        opm.value[name] = OperatorResolution({active: active, index: index});\n    }\n\n    function exists(string memory name) internal view returns (bool) {\n        return _getOperatorActive(name);\n    }\n\n    function indexOf(string memory name) internal view returns (int256) {\n        bytes32 slot = OPERATORS_MAPPING_SLOT;\n\n        SlotOperatorMapping storage opm;\n\n        assembly {\n            opm.slot := slot\n        }\n\n        if (opm.value[name].active == false) {\n            return -1;\n        }\n\n        return int256(opm.value[name].index);\n    }\n\n    function get(string memory name) internal view returns (Operator storage) {\n        bytes32 slot = OPERATORS_SLOT;\n        uint256 index = _getOperatorIndex(name);\n\n        SlotOperator storage r;\n\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value[index];\n    }\n\n    function getByIndex(uint256 index) internal view returns (Operator storage) {\n        bytes32 slot = OPERATORS_SLOT;\n\n        SlotOperator storage r;\n\n        assembly {\n            r.slot := slot\n        }\n\n        if (r.value.length <= index) {\n            revert OperatorNotFoundAtIndex(index);\n        }\n\n        return r.value[index];\n    }\n\n    function getCount() internal view returns (uint256) {\n        bytes32 slot = OPERATORS_SLOT;\n\n        SlotOperator storage r;\n\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value.length;\n    }\n\n    function _hasFundableKeys(Operators.Operator memory operator) internal pure returns (bool) {\n        return (operator.active &&\n            operator.keys > operator.funded - operator.stopped &&\n            operator.limit > operator.funded - operator.stopped);\n    }\n\n    function getAllActive() internal view returns (Operator[] memory) {\n        bytes32 slot = OPERATORS_SLOT;\n\n        SlotOperator storage r;\n\n        assembly {\n            r.slot := slot\n        }\n\n        uint256 activeCount = 0;\n\n        for (uint256 idx = 0; idx < r.value.length; ++idx) {\n            if (r.value[idx].active == true) {\n                ++activeCount;\n            }\n        }\n\n        Operator[] memory activeOperators = new Operator[](activeCount);\n\n        uint256 activeIdx = 0;\n        for (uint256 idx = 0; idx < r.value.length; ++idx) {\n            if (r.value[idx].active == true) {\n                activeOperators[activeIdx] = r.value[idx];\n                ++activeIdx;\n            }\n        }\n\n        return activeOperators;\n    }\n\n    function getAllFundable() internal view returns (CachedOperator[] memory) {\n        bytes32 slot = OPERATORS_SLOT;\n\n        SlotOperator storage r;\n\n        assembly {\n            r.slot := slot\n        }\n\n        uint256 activeCount = 0;\n\n        for (uint256 idx = 0; idx < r.value.length; ++idx) {\n            if (_hasFundableKeys(r.value[idx])) {\n                ++activeCount;\n            }\n        }\n\n        CachedOperator[] memory activeOperators = new CachedOperator[](activeCount);\n\n        uint256 activeIdx = 0;\n        for (uint256 idx = 0; idx < r.value.length; ++idx) {\n            Operator memory op = r.value[idx];\n            if (_hasFundableKeys(op)) {\n                activeOperators[activeIdx] = CachedOperator({\n                    active: op.active,\n                    name: op.name,\n                    operator: op.operator,\n                    feeRecipient: op.feeRecipient,\n                    limit: op.limit,\n                    funded: op.funded,\n                    keys: op.keys,\n                    stopped: op.stopped,\n                    index: idx\n                });\n                ++activeIdx;\n            }\n        }\n\n        return activeOperators;\n    }\n\n    function set(string memory name, Operator memory newValue) internal returns (uint256) {\n        bool opExists = _getOperatorActive(name);\n\n        bytes32 slot = OPERATORS_SLOT;\n\n        SlotOperator storage r;\n\n        assembly {\n            r.slot := slot\n        }\n\n        if (opExists == false) {\n            r.value.push(newValue);\n            _setOperatorIndex(name, newValue.active, r.value.length - 1);\n            return (r.value.length - 1);\n        } else {\n            uint256 index = _getOperatorIndex(name);\n            r.value[index] = newValue;\n            if (opExists != newValue.active) {\n                _setOperatorIndex(name, newValue.active, index);\n            }\n            return (index);\n        }\n    }\n}\n"
    },
    "contracts/src/state/river/ValidatorKeys.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/BytesLib.sol\";\n\nlibrary ValidatorKeys {\n    uint256 internal constant PUBLIC_KEY_LENGTH = 48;\n    uint256 internal constant SIGNATURE_LENGTH = 96;\n\n    error InvalidPublicKey();\n    error InvalidSignature();\n\n    bytes32 internal constant VALIDATOR_KEYS_SLOT = bytes32(uint256(keccak256(\"river.state.validatorKeys\")) - 1);\n\n    struct Slot {\n        mapping(uint256 => mapping(uint256 => bytes)) value;\n    }\n\n    function get(uint256 operatorIndex, uint256 idx)\n        internal\n        view\n        returns (bytes memory publicKey, bytes memory signature)\n    {\n        bytes32 slot = VALIDATOR_KEYS_SLOT;\n\n        Slot storage r;\n\n        assembly {\n            r.slot := slot\n        }\n\n        bytes storage entry = r.value[operatorIndex][idx];\n\n        publicKey = BytesLib.slice(entry, 0, PUBLIC_KEY_LENGTH);\n        signature = BytesLib.slice(entry, PUBLIC_KEY_LENGTH, SIGNATURE_LENGTH);\n    }\n\n    function getKeys(\n        uint256 operatorIndex,\n        uint256 startIdx,\n        uint256 amount\n    ) internal view returns (bytes[] memory publicKey, bytes[] memory signatures) {\n        publicKey = new bytes[](amount);\n        signatures = new bytes[](amount);\n\n        bytes32 slot = VALIDATOR_KEYS_SLOT;\n\n        Slot storage r;\n\n        assembly {\n            r.slot := slot\n        }\n\n        for (uint256 idx = startIdx; idx < startIdx + amount; ++idx) {\n            bytes memory rawCredentials = r.value[operatorIndex][idx];\n            publicKey[idx - startIdx] = BytesLib.slice(rawCredentials, 0, PUBLIC_KEY_LENGTH);\n            signatures[idx - startIdx] = BytesLib.slice(rawCredentials, PUBLIC_KEY_LENGTH, SIGNATURE_LENGTH);\n        }\n    }\n\n    function set(\n        uint256 operatorIndex,\n        uint256 idx,\n        bytes memory publicKey,\n        bytes memory signature\n    ) internal {\n        bytes memory concatenatedKeys = BytesLib.concat(publicKey, signature);\n\n        bytes32 slot = VALIDATOR_KEYS_SLOT;\n\n        Slot storage r;\n\n        assembly {\n            r.slot := slot\n        }\n\n        r.value[operatorIndex][idx] = concatenatedKeys;\n    }\n}\n"
    },
    "contracts/src/interfaces/IAllowlist.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\ninterface IAllowlist {\n    function onlyAllowed(address _account, uint256 _mask) external view;\n\n    function isAllowed(address _account, uint256 _mask) external view returns (bool);\n\n    function isDenied(address _account) external view returns (bool);\n\n    function hasPermission(address _account, uint256 _mask) external view returns (bool);\n}\n"
    },
    "contracts/src/Oracle.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"./Initializable.sol\";\nimport \"./libraries/Errors.sol\";\nimport \"./libraries/LibOwnable.sol\";\nimport \"./interfaces/IRiverOracleInput.sol\";\n\nimport \"./state/shared/AdministratorAddress.sol\";\nimport \"./state/shared/RiverAddress.sol\";\nimport \"./state/oracle/OracleMembers.sol\";\nimport \"./state/oracle/Quorum.sol\";\nimport \"./state/oracle/BeaconSpec.sol\";\nimport \"./state/oracle/BeaconReportBounds.sol\";\nimport \"./state/oracle/ExpectedEpochId.sol\";\nimport \"./state/oracle/LastEpochId.sol\";\nimport \"./state/oracle/ReportsPositions.sol\";\nimport \"./state/oracle/ReportsVariants.sol\";\n\n/// @title Oracle (v1)\n/// @author Kiln\n/// @notice This contract handles the input from the allowed oracle members. Highly inspired by Lido's implementation.\ncontract OracleV1 is Initializable {\n    event QuorumChanged(uint256 _newQuorum);\n    event ExpectedEpochIdUpdated(uint256 _epochId);\n    event BeaconReported(\n        uint256 _epochId,\n        uint128 _newBeaconBalance,\n        uint32 _newBeaconValidatorCount,\n        address _oracleMember\n    );\n    event PostTotalShares(uint256 _postTotalEth, uint256 _prevTotalEth, uint256 _timeElapsed, uint256 _totalShares);\n\n    error EpochTooOld(uint256 _providedEpochId, uint256 _minExpectedEpochId);\n    error NotFrameFirstEpochId(uint256 _providedEpochId, uint256 _expectedFrameFirstEpochId);\n    error AlreadyReported(uint256 _epochId, address _member);\n    error BeaconBalanceIncreaseOutOfBounds(\n        uint256 _prevTotalEth,\n        uint256 _postTotalEth,\n        uint256 _timeElapsed,\n        uint256 _annualAprUpperBound\n    );\n    error BeaconBalanceDecreaseOutOfBounds(\n        uint256 _prevTotalEth,\n        uint256 _postTotalEth,\n        uint256 _timeElapsed,\n        uint256 _relativeLowerBound\n    );\n\n    /// @notice Received ETH input has only 9 decimals\n    uint128 internal constant DENOMINATION_OFFSET = 1e9;\n\n    /// @notice Initializes the oracle\n    /// @param _riverContractAddress Address of the River contract, able to receive oracle input data after quorum is met\n    /// @param _administratorAddress Address able to call administrative methods\n    /// @param _epochsPerFrame Beacon spec parameter. Number of epochs in a frame.\n    /// @param _slotsPerEpoch Beacon spec parameter. Number of slots in one epoch.\n    /// @param _secondsPerSlot Beacon spec parameter. Number of seconds between slots.\n    /// @param _genesisTime Beacon spec parameter. Timestamp of the genesis slot.\n    /// @param _annualAprUpperBound Beacon bound parameter. Maximum apr allowed for balance increase. Delta between updates is extrapolated on a year time frame.\n    /// @param _relativeLowerBound Beacon bound parameter. Maximum relative balance decrease.\n    function initOracleV1(\n        address _riverContractAddress,\n        address _administratorAddress,\n        uint64 _epochsPerFrame,\n        uint64 _slotsPerEpoch,\n        uint64 _secondsPerSlot,\n        uint64 _genesisTime,\n        uint256 _annualAprUpperBound,\n        uint256 _relativeLowerBound\n    ) external init(0) {\n        LibOwnable._setAdmin(_administratorAddress);\n        RiverAddress.set(_riverContractAddress);\n        BeaconSpec.set(\n            BeaconSpec.BeaconSpecStruct({\n                epochsPerFrame: _epochsPerFrame,\n                slotsPerEpoch: _slotsPerEpoch,\n                secondsPerSlot: _secondsPerSlot,\n                genesisTime: _genesisTime\n            })\n        );\n        BeaconReportBounds.set(\n            BeaconReportBounds.BeaconReportBoundsStruct({\n                annualAprUpperBound: _annualAprUpperBound,\n                relativeLowerBound: _relativeLowerBound\n            })\n        );\n        Quorum.set(1);\n    }\n\n    /// @notice Retrieve system administrator address\n    function getAdministrator() external view returns (address) {\n        return LibOwnable._getAdmin();\n    }\n\n    /// @notice Retrieve River address\n    function getRiver() external view returns (address) {\n        return RiverAddress.get();\n    }\n\n    /// @notice Prevents unauthorized calls\n    modifier onlyAdmin() {\n        if (msg.sender != LibOwnable._getAdmin()) {\n            revert Errors.Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    /// @notice Retrieve the block timestamp\n    function getTime() external view returns (uint256) {\n        return _getTime();\n    }\n\n    /// @notice Retrieve expected epoch id\n    function getExpectedEpochId() external view returns (uint256) {\n        return ExpectedEpochId.get();\n    }\n\n    /// @notice Retrieve member report status\n    /// @param _oracleMember Address of member to check\n    function getMemberReportStatus(address _oracleMember) external view returns (bool) {\n        int256 memberIndex = OracleMembers.indexOf(_oracleMember);\n        return ReportsPositions.get(uint256(memberIndex));\n    }\n\n    /// @notice Retrieve member report status\n    function getGlobalReportStatus() external view returns (uint256) {\n        return ReportsPositions.getRaw();\n    }\n\n    /// @notice Retrieve report variants count\n    function getReportVariantsCount() external view returns (uint256) {\n        return ReportsVariants.get().length;\n    }\n\n    /// @notice Retrieve decoded report at provided index\n    /// @param _idx Index of report\n    function getReportVariant(uint256 _idx)\n        external\n        view\n        returns (\n            uint64 _beaconBalance,\n            uint32 _beaconValidators,\n            uint16 _reportCount\n        )\n    {\n        uint256 report = ReportsVariants.get()[_idx];\n        (_beaconBalance, _beaconValidators) = _decodeReport(report);\n        _reportCount = _getReportCount(report);\n    }\n\n    /// @notice Retrieve the last completed epoch id\n    function getLastCompletedEpochId() external view returns (uint256) {\n        return LastEpochId.get();\n    }\n\n    /// @notice Retrieve the current epoch id based on block timestamp\n    function getCurrentEpochId() external view returns (uint256) {\n        BeaconSpec.BeaconSpecStruct memory beaconSpec = BeaconSpec.get();\n        return _getCurrentEpochId(beaconSpec);\n    }\n\n    /// @notice Retrieve the current quorum\n    function getQuorum() external view returns (uint256) {\n        return Quorum.get();\n    }\n\n    /// @notice Retrieve the current beacon spec\n    function getBeaconSpec() external view returns (BeaconSpec.BeaconSpecStruct memory) {\n        return BeaconSpec.get();\n    }\n\n    /// @notice Retrieve the current frame details\n    function getCurrentFrame()\n        external\n        view\n        returns (\n            uint256 _startEpochId,\n            uint256 _startTime,\n            uint256 _endTime\n        )\n    {\n        BeaconSpec.BeaconSpecStruct memory beaconSpec = BeaconSpec.get();\n        _startEpochId = _getFrameFirstEpochId(_getCurrentEpochId(beaconSpec), beaconSpec);\n        _startTime = beaconSpec.genesisTime + _startEpochId * beaconSpec.secondsPerSlot * beaconSpec.slotsPerEpoch;\n        _endTime = _startTime + beaconSpec.secondsPerSlot * beaconSpec.slotsPerEpoch * beaconSpec.epochsPerFrame - 1;\n    }\n\n    /// @notice Retrieve the first epoch id of the frame of the provided epoch id\n    /// @param _epochId Epoch id used to get the frame\n    function getFrameFirstEpochId(uint256 _epochId) external view returns (uint256) {\n        BeaconSpec.BeaconSpecStruct memory beaconSpec = BeaconSpec.get();\n        return _getFrameFirstEpochId(_epochId, beaconSpec);\n    }\n\n    function getBeaconBounds() external view returns (BeaconReportBounds.BeaconReportBoundsStruct memory) {\n        return BeaconReportBounds.get();\n    }\n\n    function getOracleMembers() external view returns (address[] memory) {\n        return OracleMembers.get();\n    }\n\n    /// @notice Returns true if address is member\n    /// @dev Performs a naive search, do not call this on-chain, used as an off-chain helper\n    /// @param _memberAddress Address of the member\n    function isMember(address _memberAddress) external view returns (bool) {\n        address[] memory members = OracleMembers.get();\n        for (uint256 idx = 0; idx < members.length; ++idx) {\n            if (members[idx] == _memberAddress) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /// @notice Adds new address as oracle member, giving the ability to push beacon reports.\n    /// @dev Only callable by the adminstrator\n    /// @param _newOracleMember Address of the new member\n    function addMember(address _newOracleMember) external onlyAdmin {\n        int256 memberIdx = OracleMembers.indexOf(_newOracleMember);\n        if (memberIdx >= 0) {\n            revert Errors.InvalidCall();\n        }\n        OracleMembers.push(_newOracleMember);\n    }\n\n    /// @notice Removes an address from the oracle members.\n    /// @dev Only callable by the adminstrator\n    /// @param _oracleMember Address to remove\n    function removeMember(address _oracleMember) external onlyAdmin {\n        int256 memberIdx = OracleMembers.indexOf(_oracleMember);\n        if (memberIdx < 0) {\n            revert Errors.InvalidCall();\n        }\n        OracleMembers.deleteItem(uint256(memberIdx));\n    }\n\n    /// @notice Edits the beacon spec parameters\n    /// @dev Only callable by the adminstrator\n    /// @param _epochsPerFrame Number of epochs in a frame.\n    /// @param _slotsPerEpoch Number of slots in one epoch.\n    /// @param _secondsPerSlot Number of seconds between slots.\n    /// @param _genesisTime Timestamp of the genesis slot.\n    function setBeaconSpec(\n        uint64 _epochsPerFrame,\n        uint64 _slotsPerEpoch,\n        uint64 _secondsPerSlot,\n        uint64 _genesisTime\n    ) external onlyAdmin {\n        BeaconSpec.set(\n            BeaconSpec.BeaconSpecStruct({\n                epochsPerFrame: _epochsPerFrame,\n                slotsPerEpoch: _slotsPerEpoch,\n                secondsPerSlot: _secondsPerSlot,\n                genesisTime: _genesisTime\n            })\n        );\n    }\n\n    /// @notice Edits the beacon bounds parameters\n    /// @dev Only callable by the adminstrator\n    /// @param _annualAprUpperBound Maximum apr allowed for balance increase. Delta between updates is extrapolated on a year time frame.\n    /// @param _relativeLowerBound Maximum relative balance decrease.\n    function setBeaconBounds(uint256 _annualAprUpperBound, uint256 _relativeLowerBound) external onlyAdmin {\n        BeaconReportBounds.set(\n            BeaconReportBounds.BeaconReportBoundsStruct({\n                annualAprUpperBound: _annualAprUpperBound,\n                relativeLowerBound: _relativeLowerBound\n            })\n        );\n    }\n\n    /// @notice Edits the quorum required to forward beacon data to River\n    /// @dev Only callable by the adminstrator\n    /// @param _newQuorum New quorum parameter\n    function setQuorum(uint256 _newQuorum) external onlyAdmin {\n        if (_newQuorum == 0) {\n            revert Errors.InvalidArgument();\n        }\n        uint256 previousQuorum = Quorum.get();\n        if (_newQuorum == previousQuorum) {\n            revert Errors.InvalidCall();\n        }\n        Quorum.set(_newQuorum);\n        emit QuorumChanged(_newQuorum);\n        if (previousQuorum > _newQuorum) {\n            (bool isQuorum, uint256 report) = _getQuorumReport(_newQuorum);\n            if (isQuorum) {\n                (uint64 beaconBalance, uint32 beaconValidators) = _decodeReport(report);\n                _pushToRiver(\n                    ExpectedEpochId.get(),\n                    DENOMINATION_OFFSET * uint128(beaconBalance),\n                    beaconValidators,\n                    BeaconSpec.get()\n                );\n            }\n        }\n    }\n\n    /// @notice Report beacon chain data\n    /// @dev Only callable by an oracle member\n    /// @param _epochId Epoch where the balance and validator count has been computed\n    /// @param _beaconBalance Total balance of River validators\n    /// @param _beaconValidators Total River validator count\n    function reportBeacon(\n        uint256 _epochId,\n        uint64 _beaconBalance,\n        uint32 _beaconValidators\n    ) external {\n        BeaconSpec.BeaconSpecStruct memory beaconSpec = BeaconSpec.get();\n        uint256 expectedEpochId = ExpectedEpochId.get();\n        if (_epochId < expectedEpochId) {\n            revert EpochTooOld(_epochId, expectedEpochId);\n        }\n\n        if (_epochId > expectedEpochId) {\n            uint256 frameFirstEpochId = _getFrameFirstEpochId(_getCurrentEpochId(beaconSpec), beaconSpec);\n            if (_epochId != frameFirstEpochId) {\n                revert NotFrameFirstEpochId(_epochId, frameFirstEpochId);\n            }\n            _clearReporting(_epochId);\n        }\n\n        uint128 beaconBalanceEth1 = DENOMINATION_OFFSET * uint128(_beaconBalance);\n        emit BeaconReported(_epochId, beaconBalanceEth1, _beaconValidators, msg.sender);\n\n        int256 memberIndex = OracleMembers.indexOf(msg.sender);\n        if (memberIndex == -1) {\n            revert Errors.Unauthorized(msg.sender);\n        }\n        if (ReportsPositions.get(uint256(memberIndex))) {\n            revert AlreadyReported(_epochId, msg.sender);\n        }\n        ReportsPositions.register(uint256(memberIndex));\n\n        uint256 report = _encodeReport(_beaconBalance, _beaconValidators);\n        int256 reportIndex = ReportsVariants.indexOfReport(report);\n        uint256 quorum = Quorum.get();\n\n        if (reportIndex >= 0) {\n            uint256 registeredReport = ReportsVariants.get()[uint256(reportIndex)];\n            if (_getReportCount(registeredReport) + 1 >= quorum) {\n                _pushToRiver(_epochId, beaconBalanceEth1, _beaconValidators, beaconSpec);\n            } else {\n                ReportsVariants.set(uint256(reportIndex), registeredReport + 1);\n            }\n        } else {\n            if (quorum == 1) {\n                _pushToRiver(_epochId, beaconBalanceEth1, _beaconValidators, beaconSpec);\n            } else {\n                ReportsVariants.push(report + 1);\n            }\n        }\n    }\n\n    /// @notice Retrieve the report that has the highest number of \"votes\"\n    /// @param _quorum The quorum used for the query\n    function _getQuorumReport(uint256 _quorum) internal view returns (bool isQuorum, uint256 report) {\n        // check most frequent cases first: all reports are the same or no reports yet\n        uint256[] memory variants = ReportsVariants.get();\n        if (variants.length == 1) {\n            return (_getReportCount(variants[0]) >= _quorum, variants[0]);\n        } else if (variants.length == 0) {\n            return (false, 0);\n        }\n\n        // if more than 2 kind of reports exist, choose the most frequent\n        uint256 maxind = 0;\n        uint256 repeat = 0;\n        uint16 maxval = 0;\n        uint16 cur = 0;\n        for (uint256 i = 0; i < variants.length; ++i) {\n            cur = _getReportCount(variants[i]);\n            if (cur >= maxval) {\n                if (cur == maxval) {\n                    ++repeat;\n                } else {\n                    maxind = i;\n                    maxval = cur;\n                    repeat = 0;\n                }\n            }\n        }\n        return (maxval >= _quorum && repeat == 0, variants[maxind]);\n    }\n\n    /// @notice Retrieve the block timestamp\n    function _getTime() internal view returns (uint256) {\n        return block.timestamp; // solhint-disable-line not-rely-on-time\n    }\n\n    /// @notice Retrieve the current epoch id based on block timestamp\n    /// @param _beaconSpec Beacon spec parameters\n    function _getCurrentEpochId(BeaconSpec.BeaconSpecStruct memory _beaconSpec) internal view returns (uint256) {\n        return (_getTime() - _beaconSpec.genesisTime) / (_beaconSpec.slotsPerEpoch * _beaconSpec.secondsPerSlot);\n    }\n\n    /// @notice Retrieve the first epoch id of the frame of the provided epoch id\n    /// @param _epochId Epoch id used to get the frame\n    /// @param _beaconSpec Beacon spec parameters\n    function _getFrameFirstEpochId(uint256 _epochId, BeaconSpec.BeaconSpecStruct memory _beaconSpec)\n        internal\n        pure\n        returns (uint256)\n    {\n        return (_epochId / _beaconSpec.epochsPerFrame) * _beaconSpec.epochsPerFrame;\n    }\n\n    /// @notice Clear reporting data\n    /// @param _epochId Next expected epoch id (first epoch of the next frame)\n    function _clearReporting(uint256 _epochId) internal {\n        ReportsPositions.clear();\n        ReportsVariants.clear();\n        ExpectedEpochId.set(_epochId);\n        emit ExpectedEpochIdUpdated(_epochId);\n    }\n\n    /// @notice Encode report into one slot. Last 16 bits are free to use for vote counting.\n    /// @param _beaconBalance Total validator balance\n    /// @param _beaconValidators Total validator count\n    function _encodeReport(uint64 _beaconBalance, uint32 _beaconValidators) internal pure returns (uint256) {\n        return (uint256(_beaconBalance) << 48) | (uint256(_beaconValidators) << 16);\n    }\n\n    /// @notice Decode report from one slot to two variables, ignoring the last 16 bits\n    /// @param _value Encoded report\n    function _decodeReport(uint256 _value) internal pure returns (uint64 _beaconBalance, uint32 _beaconValidators) {\n        _beaconBalance = uint64(_value >> 48);\n        _beaconValidators = uint32(_value >> 16);\n    }\n\n    /// @notice Retrieve the vote count from the encoded report (last 16 bits)\n    /// @param _report Encoded report\n    function _getReportCount(uint256 _report) internal pure returns (uint16) {\n        return uint16(_report);\n    }\n\n    /// @notice Performs sanity checks to prevent an erroneous update to the River system\n    /// @param _postTotalEth Total validator balance after update\n    /// @param _prevTotalEth Total validator balance before update\n    /// @param _timeElapsed Time since last update\n    function _sanityChecks(\n        uint256 _postTotalEth,\n        uint256 _prevTotalEth,\n        uint256 _timeElapsed\n    ) internal view {\n        if (_postTotalEth >= _prevTotalEth) {\n            // increase                 = _postTotalPooledEther - _preTotalPooledEther,\n            // relativeIncrease         = increase / _preTotalPooledEther,\n            // annualRelativeIncrease   = relativeIncrease / (timeElapsed / 365 days),\n            // annualRelativeIncreaseBp = annualRelativeIncrease * 10000, in basis points 0.01% (1e-4)\n            uint256 annualAprUpperBound = BeaconReportBounds.get().annualAprUpperBound;\n            // check that annualRelativeIncreaseBp <= allowedAnnualRelativeIncreaseBp\n            if (\n                uint256(10000 * 365 days) * (_postTotalEth - _prevTotalEth) >\n                annualAprUpperBound * _prevTotalEth * _timeElapsed\n            ) {\n                revert BeaconBalanceIncreaseOutOfBounds(\n                    _prevTotalEth,\n                    _postTotalEth,\n                    _timeElapsed,\n                    annualAprUpperBound\n                );\n            }\n        } else {\n            // decrease           = _preTotalPooledEther - _postTotalPooledEther\n            // relativeDecrease   = decrease / _preTotalPooledEther\n            // relativeDecreaseBp = relativeDecrease * 10000, in basis points 0.01% (1e-4)\n            uint256 relativeLowerBound = BeaconReportBounds.get().relativeLowerBound;\n            // check that relativeDecreaseBp <= allowedRelativeDecreaseBp\n            if (uint256(10000) * (_prevTotalEth - _postTotalEth) > relativeLowerBound * _prevTotalEth) {\n                revert BeaconBalanceDecreaseOutOfBounds(_prevTotalEth, _postTotalEth, _timeElapsed, relativeLowerBound);\n            }\n        }\n    }\n\n    /// @notice Push the new beacon data to the river system and performs sanity checks\n    /// @param _epochId Id of the epoch\n    /// @param _balanceSum Total validator balance\n    /// @param _validatorCount Total validator count\n    /// @param _beaconSpec Beacon spec parameters\n    function _pushToRiver(\n        uint256 _epochId,\n        uint128 _balanceSum,\n        uint32 _validatorCount,\n        BeaconSpec.BeaconSpecStruct memory _beaconSpec\n    ) internal {\n        _clearReporting(_epochId + _beaconSpec.epochsPerFrame);\n\n        IRiverOracleInput riverAddress = IRiverOracleInput(RiverAddress.get());\n        uint256 prevTotalEth = riverAddress.totalSupply();\n        riverAddress.setBeaconData(_validatorCount, _balanceSum, bytes32(_epochId));\n        uint256 postTotalEth = riverAddress.totalSupply();\n\n        uint256 timeElapsed = (_epochId - LastEpochId.get()) * _beaconSpec.slotsPerEpoch * _beaconSpec.secondsPerSlot;\n\n        _sanityChecks(postTotalEth, prevTotalEth, timeElapsed);\n        LastEpochId.set(_epochId);\n\n        emit PostTotalShares(postTotalEth, prevTotalEth, timeElapsed, riverAddress.totalShares());\n    }\n}\n"
    },
    "contracts/src/state/shared/RiverAddress.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/UnstructuredStorage.sol\";\n\nlibrary RiverAddress {\n    bytes32 internal constant RIVER_ADDRESS_SLOT = bytes32(uint256(keccak256(\"river.state.riverAddress\")) - 1);\n\n    function get() internal view returns (address) {\n        return UnstructuredStorage.getStorageAddress(RIVER_ADDRESS_SLOT);\n    }\n\n    function set(address newValue) internal {\n        UnstructuredStorage.setStorageAddress(RIVER_ADDRESS_SLOT, newValue);\n    }\n}\n"
    },
    "contracts/src/state/oracle/OracleMembers.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nlibrary OracleMembers {\n    bytes32 internal constant ORACLE_MEMBERS_SLOT = bytes32(uint256(keccak256(\"river.state.oracleMembers\")) - 1);\n\n    struct Slot {\n        address[] value;\n    }\n\n    function get() internal view returns (address[] memory) {\n        bytes32 slot = ORACLE_MEMBERS_SLOT;\n\n        Slot storage r;\n\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value;\n    }\n\n    function push(address newOracleMember) internal {\n        bytes32 slot = ORACLE_MEMBERS_SLOT;\n\n        Slot storage r;\n\n        assembly {\n            r.slot := slot\n        }\n\n        r.value.push(newOracleMember);\n    }\n\n    function indexOf(address memberAddress) internal view returns (int256) {\n        bytes32 slot = ORACLE_MEMBERS_SLOT;\n\n        Slot storage r;\n\n        assembly {\n            r.slot := slot\n        }\n\n        for (uint256 idx = 0; idx < r.value.length; ++idx) {\n            if (r.value[idx] == memberAddress) {\n                return int256(idx);\n            }\n        }\n\n        return int256(-1);\n    }\n\n    function deleteItem(uint256 idx) internal {\n        bytes32 slot = ORACLE_MEMBERS_SLOT;\n\n        Slot storage r;\n\n        assembly {\n            r.slot := slot\n        }\n\n        uint256 lastIdx = r.value.length - 1;\n        if (lastIdx != idx) {\n            r.value[idx] = r.value[lastIdx];\n        }\n\n        r.value.pop();\n    }\n}\n"
    },
    "contracts/src/state/oracle/Quorum.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/UnstructuredStorage.sol\";\n\nlibrary Quorum {\n    bytes32 internal constant QUORUM_SLOT = bytes32(uint256(keccak256(\"river.state.quorum\")) - 1);\n\n    function get() internal view returns (uint256) {\n        return UnstructuredStorage.getStorageUint256(QUORUM_SLOT);\n    }\n\n    function set(uint256 newValue) internal {\n        return UnstructuredStorage.setStorageUint256(QUORUM_SLOT, newValue);\n    }\n}\n"
    },
    "contracts/src/state/oracle/BeaconSpec.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nlibrary BeaconSpec {\n    // Lido Finance beacon spec data structure\n    struct BeaconSpecStruct {\n        uint64 epochsPerFrame;\n        uint64 slotsPerEpoch;\n        uint64 secondsPerSlot;\n        uint64 genesisTime;\n    }\n\n    bytes32 internal constant BEACON_SPEC_SLOT = bytes32(uint256(keccak256(\"river.state.beaconSpec\")) - 1);\n\n    struct Slot {\n        BeaconSpecStruct value;\n    }\n\n    function get() internal view returns (BeaconSpecStruct memory) {\n        bytes32 slot = BEACON_SPEC_SLOT;\n\n        Slot storage r;\n\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value;\n    }\n\n    function set(BeaconSpecStruct memory newBeaconSpec) internal {\n        bytes32 slot = BEACON_SPEC_SLOT;\n\n        Slot storage r;\n\n        assembly {\n            r.slot := slot\n        }\n\n        r.value = newBeaconSpec;\n    }\n}\n"
    },
    "contracts/src/state/oracle/BeaconReportBounds.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nlibrary BeaconReportBounds {\n    // Lido Finance beacon spec data structure\n    struct BeaconReportBoundsStruct {\n        uint256 annualAprUpperBound;\n        uint256 relativeLowerBound;\n    }\n\n    uint256 public constant DELTA_BASE = 10_000;\n\n    bytes32 internal constant BEACON_REPORT_BOUNDS_SLOT =\n        bytes32(uint256(keccak256(\"river.state.beaconReportBounds\")) - 1);\n\n    struct Slot {\n        BeaconReportBoundsStruct value;\n    }\n\n    function get() internal view returns (BeaconReportBoundsStruct memory) {\n        bytes32 slot = BEACON_REPORT_BOUNDS_SLOT;\n\n        Slot storage r;\n\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value;\n    }\n\n    function set(BeaconReportBoundsStruct memory newBeaconReportBounds) internal {\n        bytes32 slot = BEACON_REPORT_BOUNDS_SLOT;\n\n        Slot storage r;\n\n        assembly {\n            r.slot := slot\n        }\n\n        r.value = newBeaconReportBounds;\n    }\n}\n"
    },
    "contracts/src/state/oracle/ExpectedEpochId.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/UnstructuredStorage.sol\";\n\nlibrary ExpectedEpochId {\n    bytes32 internal constant EXPECTED_EPOCH_ID_SLOT = bytes32(uint256(keccak256(\"river.state.expectedEpochId\")) - 1);\n\n    function get() internal view returns (uint256) {\n        return UnstructuredStorage.getStorageUint256(EXPECTED_EPOCH_ID_SLOT);\n    }\n\n    function set(uint256 newValue) internal {\n        UnstructuredStorage.setStorageUint256(EXPECTED_EPOCH_ID_SLOT, newValue);\n    }\n}\n"
    },
    "contracts/src/state/oracle/LastEpochId.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/UnstructuredStorage.sol\";\n\nlibrary LastEpochId {\n    bytes32 internal constant LAST_EPOCH_ID_SLOT = bytes32(uint256(keccak256(\"river.state.lastEpochId\")) - 1);\n\n    function get() internal view returns (uint256) {\n        return UnstructuredStorage.getStorageUint256(LAST_EPOCH_ID_SLOT);\n    }\n\n    function set(uint256 newValue) internal {\n        UnstructuredStorage.setStorageUint256(LAST_EPOCH_ID_SLOT, newValue);\n    }\n}\n"
    },
    "contracts/src/state/oracle/ReportsPositions.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/UnstructuredStorage.sol\";\n\nlibrary ReportsPositions {\n    bytes32 internal constant REPORTS_POSITIONS_SLOT = bytes32(uint256(keccak256(\"river.state.reportsPositions\")) - 1);\n\n    function get(uint256 idx) internal view returns (bool) {\n        uint256 mask = 1 << idx;\n        return UnstructuredStorage.getStorageUint256(REPORTS_POSITIONS_SLOT) & mask == mask;\n    }\n\n    function getRaw() internal view returns (uint256) {\n        return UnstructuredStorage.getStorageUint256(REPORTS_POSITIONS_SLOT);\n    }\n\n    function register(uint256 idx) internal {\n        uint256 mask = 1 << idx;\n        return\n            UnstructuredStorage.setStorageUint256(\n                REPORTS_POSITIONS_SLOT,\n                UnstructuredStorage.getStorageUint256(REPORTS_POSITIONS_SLOT) | mask\n            );\n    }\n\n    function clear() internal {\n        return UnstructuredStorage.setStorageUint256(REPORTS_POSITIONS_SLOT, 0);\n    }\n}\n"
    },
    "contracts/src/state/oracle/ReportsVariants.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nlibrary ReportsVariants {\n    uint256 internal constant COUNT_OUTMASK = 0xFFFFFFFFFFFFFFFFFFFFFFFF0000;\n\n    bytes32 internal constant REPORTS_VARIANTS_SLOT = bytes32(uint256(keccak256(\"river.state.reportsVariants\")) - 1);\n\n    struct Slot {\n        uint256[] value;\n    }\n\n    function get() internal view returns (uint256[] memory) {\n        bytes32 slot = REPORTS_VARIANTS_SLOT;\n\n        Slot storage r;\n\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value;\n    }\n\n    function set(uint256 idx, uint256 val) internal {\n        bytes32 slot = REPORTS_VARIANTS_SLOT;\n\n        Slot storage r;\n\n        assembly {\n            r.slot := slot\n        }\n\n        r.value[idx] = val;\n    }\n\n    function push(uint256 variant) internal {\n        bytes32 slot = REPORTS_VARIANTS_SLOT;\n\n        Slot storage r;\n\n        assembly {\n            r.slot := slot\n        }\n\n        r.value.push(variant);\n    }\n\n    function indexOfReport(uint256 variant) internal view returns (int256) {\n        bytes32 slot = REPORTS_VARIANTS_SLOT;\n\n        Slot storage r;\n\n        assembly {\n            r.slot := slot\n        }\n\n        for (uint256 idx = 0; idx < r.value.length; ++idx) {\n            if (r.value[idx] & COUNT_OUTMASK == variant) {\n                return int256(idx);\n            }\n        }\n\n        return int256(-1);\n    }\n\n    function clear() internal {\n        bytes32 slot = REPORTS_VARIANTS_SLOT;\n\n        Slot storage r;\n\n        assembly {\n            r.slot := slot\n        }\n\n        delete r.value;\n    }\n}\n"
    },
    "contracts/src/WLSETH.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"./Initializable.sol\";\nimport \"./interfaces/IRiverToken.sol\";\n\nimport \"./state/shared/RiverAddress.sol\";\nimport \"./state/shared/ApprovalsPerOwner.sol\";\nimport \"./state/wlseth/BalanceOf.sol\";\n\n/// @title Wrapped lsETH v1\n/// @author Kiln\n/// @notice This contract wraps the lsETH token into a rebase token, more suitable for some DeFi use-cases\n///         like stable swaps.\ncontract WLSETHV1 is Initializable {\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    error BalanceTooLow();\n    error UnauthorizedOperation();\n    error AllowanceTooLow(address _from, address _operator, uint256 _allowance, uint256 _value);\n    error NullTransfer();\n\n    modifier isNotNull(uint256 _value) {\n        if (_value == 0) {\n            revert NullTransfer();\n        }\n        _;\n    }\n\n    modifier hasFunds(address _owner, uint256 _value) {\n        if (_balanceOf(_owner) < _value) {\n            revert BalanceTooLow();\n        }\n        _;\n    }\n\n    /// @notice Initializes the wrapped token contract\n    /// @param _river Address of the River contract\n    function initWLSETHV1(address _river) external init(0) {\n        RiverAddress.set(_river);\n    }\n\n    /// @notice Retrieves the token full name\n    function name() external pure returns (string memory) {\n        return \"Wrapped Alluvial Ether\";\n    }\n\n    /// @notice Retrieves the token ticker\n    function symbol() external pure returns (string memory) {\n        return \"wlsETH\";\n    }\n\n    /// @notice Retrieves the token decimal count\n    function decimals() external pure returns (uint8) {\n        return 18;\n    }\n\n    /// @notice Retrieves the token total supply\n    function totalSupply() external view returns (uint256) {\n        return IRiverToken(RiverAddress.get()).balanceOfUnderlying(address(this));\n    }\n\n    /// @notice Retrieves the token balance of the specified user\n    /// @param _owner Owner to check the balance\n    function balanceOf(address _owner) external view returns (uint256 balance) {\n        return _balanceOf(_owner);\n    }\n\n    /// @notice Retrieves the token allowance given from one address to another\n    /// @param _owner Owner that gave the allowance\n    /// @param _spender Spender that received the allowance\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining) {\n        return ApprovalsPerOwner.get(_owner, _spender);\n    }\n\n    /// @notice Transfers tokens between the message sender and a recipient\n    /// @param _to Recipient of the transfer\n    /// @param _value Amount to transfer\n    function transfer(address _to, uint256 _value)\n        external\n        isNotNull(_value)\n        hasFunds(msg.sender, _value)\n        returns (bool)\n    {\n        return _transfer(msg.sender, _to, _value);\n    }\n\n    /// @notice Transfers tokens between two accounts\n    /// @dev If _from is not the message sender, then it is expected that _from has given at leave _value allowance to msg.sender\n    /// @param _from Sender account\n    /// @param _to Recipient of the transfer\n    /// @param _value Amount to transfer\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) external isNotNull(_value) hasFunds(_from, _value) returns (bool) {\n        if (_from != msg.sender) {\n            uint256 currentAllowance = ApprovalsPerOwner.get(_from, msg.sender);\n            if (currentAllowance < _value) {\n                revert AllowanceTooLow(_from, msg.sender, currentAllowance, _value);\n            }\n            ApprovalsPerOwner.set(_from, msg.sender, currentAllowance - _value);\n        }\n        return _transfer(_from, _to, _value);\n    }\n\n    /// @notice Approves another account to transfer tokens\n    /// @param _spender Spender that receives the allowance\n    /// @param _value Amount to allow\n    function approve(address _spender, uint256 _value) external returns (bool success) {\n        ApprovalsPerOwner.set(msg.sender, _spender, _value);\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    /// @notice Mint tokens by providing River tokens\n    /// @dev Minted tokens are sent to recipient but are minted from the message sender balance\n    /// @dev It is expected that the message sender approves _value amount of River token to\n    /// @dev this contract before calling\n    /// @param _recipient Spender that receives the allowance\n    /// @param _value Amount of river token to give to the mint\n    function mint(address _recipient, uint256 _value) external {\n        BalanceOf.set(_recipient, BalanceOf.get(_recipient) + _value);\n        IRiverToken(RiverAddress.get()).transferFrom(msg.sender, address(this), _value);\n    }\n\n    /// @notice Burn tokens and retrieve underlying River tokens\n    /// @dev Burned tokens are sent to recipient but are minted from the message sender balance\n    /// @dev No approval required from the message sender\n    /// @param _recipient Spender that receives the allowance\n    /// @param _value Amount of wrapped token to give to the burn\n    function burn(address _recipient, uint256 _value) external {\n        uint256 callerUnderlyingBalance = IRiverToken(RiverAddress.get()).underlyingBalanceFromShares(\n            BalanceOf.get(msg.sender)\n        );\n        if (_value > callerUnderlyingBalance) {\n            revert BalanceTooLow();\n        }\n        uint256 sharesAmount = IRiverToken(RiverAddress.get()).sharesFromUnderlyingBalance(_value);\n        BalanceOf.set(msg.sender, BalanceOf.get(msg.sender) - sharesAmount);\n        IRiverToken(RiverAddress.get()).transfer(_recipient, sharesAmount);\n    }\n\n    function _balanceOf(address _owner) internal view returns (uint256 balance) {\n        return IRiverToken(RiverAddress.get()).underlyingBalanceFromShares(BalanceOf.get(_owner));\n    }\n\n    function _transfer(\n        address _from,\n        address _to,\n        uint256 _value\n    ) internal returns (bool) {\n        uint256 valueToShares = IRiverToken(RiverAddress.get()).sharesFromUnderlyingBalance(_value);\n        BalanceOf.set(_from, BalanceOf.get(_from) - valueToShares);\n        BalanceOf.set(_to, BalanceOf.get(_to) + valueToShares);\n\n        emit Transfer(_from, _to, _value);\n\n        return true;\n    }\n}\n"
    },
    "contracts/src/interfaces/IRiverToken.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\ninterface IRiverToken {\n    function balanceOfUnderlying(address _owner) external view returns (uint256 balance);\n\n    function underlyingBalanceFromShares(uint256 shares) external view returns (uint256);\n\n    function sharesFromUnderlyingBalance(uint256 underlyingBalance) external view returns (uint256);\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) external returns (bool);\n\n    function transfer(address _to, uint256 _value) external returns (bool);\n}\n"
    },
    "contracts/src/state/wlseth/BalanceOf.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nlibrary BalanceOf {\n    bytes32 internal constant BALANCE_OF_SLOT = bytes32(uint256(keccak256(\"river.state.balanceOf\")) - 1);\n\n    struct Slot {\n        mapping(address => uint256) value;\n    }\n\n    function get(address owner) internal view returns (uint256) {\n        bytes32 slot = BALANCE_OF_SLOT;\n\n        Slot storage r;\n\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value[owner];\n    }\n\n    function set(address owner, uint256 newValue) internal {\n        bytes32 slot = BALANCE_OF_SLOT;\n\n        Slot storage r;\n\n        assembly {\n            r.slot := slot\n        }\n\n        r.value[owner] = newValue;\n    }\n}\n"
    },
    "contracts/src/Firewall.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"./libraries/Errors.sol\";\n\n/// @title Firewall\n/// @author Figment\n/// @notice This contract accepts calls to admin-level functions of an underlying contract, and\n///         ensures the caller holds an appropriate role for calling that function. There are two roles:\n///          - A Governor can call anything\n///          - An Executor can call specific functions specified at construction\n///         Random callers cannot call anything through this contract, even if the underlying function\n///         is unpermissioned in the underlying contract.\n///         Calls to non-admin functions should be called at the underlying contract directly.\ncontract Firewall {\n    mapping(bytes4 => bool) internal executorCanCall;\n\n    address public governor;\n    address public executor;\n    address internal destination;\n\n    // governor_ should be the most trustworthy entity in the underlying protocol - often, a DAO governor\n    // executor_ should be a trustworthy entity that takes care of time-sensitive actions in the underlying protocol\n    constructor(\n        address governor_,\n        address executor_,\n        address destination_,\n        bytes4[] memory executorCallableSelectors_\n    ) {\n        governor = governor_;\n        executor = executor_;\n        destination = destination_;\n        for (uint256 i; i < executorCallableSelectors_.length; ) {\n            executorCanCall[executorCallableSelectors_[i]] = true;\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    modifier ifGovernor() {\n        if (msg.sender == governor) {\n            _;\n        } else {\n            revert Errors.Unauthorized(msg.sender);\n        }\n    }\n\n    modifier ifGovernorOrExecutor() {\n        if (msg.sender == governor || msg.sender == executor) {\n            _;\n        } else {\n            revert Errors.Unauthorized(msg.sender);\n        }\n    }\n\n    /// @dev Change the governor\n    function changeGovernor(address newGovernor) external ifGovernor {\n        governor = newGovernor;\n    }\n\n    /// @dev Change the executor\n    function changeExecutor(address newExecutor) external ifGovernorOrExecutor {\n        executor = newExecutor;\n    }\n\n    /// @dev make a function either only callable by the governor, or callable by gov and executor.\n    function permissionFunction(bytes4 functionSelector, bool executorCanCall_) external ifGovernor {\n        executorCanCall[functionSelector] = executorCanCall_;\n    }\n\n    /// @dev Validate that the caller is allowed to make the call in msg.sig\n    function _checkCallerRole() internal view {\n        if (msg.sender == governor || (executorCanCall[msg.sig] && msg.sender == executor)) {\n            return;\n        }\n        revert Errors.Unauthorized(msg.sender);\n    }\n\n    /// @dev Forwards the current call to `destination`.\n    ///      This function does not return to its internal call site, it will return directly to the external caller.\n    function _forward(address destination_, uint256 value) internal {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the destination.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := call(gas(), destination_, value, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // call returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    function _fallback() internal virtual {\n        _checkCallerRole();\n        _forward(destination, msg.value);\n    }\n\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    receive() external payable virtual {\n        _fallback();\n    }\n}\n"
    },
    "contracts/src/ELFeeRecipient.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"./Initializable.sol\";\nimport \"./libraries/Errors.sol\";\nimport \"./libraries/LibOwnable.sol\";\nimport \"./interfaces/IRiverDonationInput.sol\";\n\nimport \"./state/shared/RiverAddress.sol\";\n\n/// @title Execution Layer Fee Recipient\n/// @author Kiln\n/// @notice This contract receives all the execution layer fees from the proposed blocks + bribes\ncontract ELFeeRecipientV1 is Initializable {\n    error InvalidCall();\n\n    /// @notice Initialize the fee recipient with the required arguments\n    /// @param _riverAddress Address of River\n    function initELFeeRecipientV1(address _riverAddress) external init(0) {\n        RiverAddress.set(_riverAddress);\n    }\n\n    /// @notice Counpounds all the current balance inside river\n    function compound() external {\n        IRiverDonationInput river = IRiverDonationInput(RiverAddress.get());\n        river.donate{value: address(this).balance}();\n    }\n\n    /// @notice Ether receiver\n    receive() external payable {\n        this;\n    }\n\n    /// @notice Invalid fallback detector\n    fallback() external payable {\n        revert InvalidCall();\n    }\n}\n"
    },
    "contracts/src/interfaces/IRiverDonationInput.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\ninterface IRiverDonationInput {\n    function donate() external payable;\n}\n"
    },
    "contracts/src/mock/DepositContractMock.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../interfaces/IDepositContract.sol\";\n\ncontract DepositContractMock is IDepositContract {\n    event DepositEvent(bytes pubkey, bytes withdrawal_credentials, bytes amount, bytes signature, bytes index);\n\n    uint256 public depositCount;\n    address public receiver;\n\n    constructor(address _receiver) {\n        receiver = _receiver;\n    }\n\n    function to_little_endian_64(uint64 value) internal pure returns (bytes memory ret) {\n        ret = new bytes(8);\n        bytes8 bytesValue = bytes8(value);\n        // Byteswapping during copying to bytes.\n        ret[0] = bytesValue[7];\n        ret[1] = bytesValue[6];\n        ret[2] = bytesValue[5];\n        ret[3] = bytesValue[4];\n        ret[4] = bytesValue[3];\n        ret[5] = bytesValue[2];\n        ret[6] = bytesValue[1];\n        ret[7] = bytesValue[0];\n    }\n\n    function deposit(\n        bytes calldata pubkey,\n        bytes calldata withdrawalCredentials,\n        bytes calldata signature,\n        bytes32\n    ) external payable {\n        emit DepositEvent(\n            pubkey,\n            withdrawalCredentials,\n            to_little_endian_64(uint64(msg.value / 1 gwei)),\n            signature,\n            to_little_endian_64(uint64(depositCount))\n        );\n        depositCount += 1;\n        (bool sent, ) = receiver.call{value: address(this).balance}(\"\");\n        require(sent, \"Fund transfer failed\");\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "devdoc",
          "userdoc",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}