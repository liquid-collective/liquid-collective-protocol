{
  "language": "Solidity",
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 100
    }
  },
  "sources": {
    "contracts/src/Administrable.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"./interfaces/IAdministrable.sol\";\n\nimport \"./libraries/LibAdministrable.sol\";\nimport \"./libraries/LibSanitize.sol\";\n\n/// @title Administrable\n/// @author Kiln\n/// @notice This contract handles the administration of the contracts\nabstract contract Administrable is IAdministrable {\n    /// @notice Prevents unauthorized calls\n    modifier onlyAdmin() {\n        if (msg.sender != LibAdministrable._getAdmin()) {\n            revert LibErrors.Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    /// @notice Prevents unauthorized calls\n    modifier onlyPendingAdmin() {\n        if (msg.sender != LibAdministrable._getPendingAdmin()) {\n            revert LibErrors.Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    /// @inheritdoc IAdministrable\n    function getAdmin() external view returns (address) {\n        return LibAdministrable._getAdmin();\n    }\n\n    /// @inheritdoc IAdministrable\n    function getPendingAdmin() external view returns (address) {\n        return LibAdministrable._getPendingAdmin();\n    }\n\n    /// @inheritdoc IAdministrable\n    function proposeAdmin(address _newAdmin) external onlyAdmin {\n        _setPendingAdmin(_newAdmin);\n    }\n\n    /// @inheritdoc IAdministrable\n    function acceptAdmin() external onlyPendingAdmin {\n        _setAdmin(LibAdministrable._getPendingAdmin());\n        _setPendingAdmin(address(0));\n    }\n\n    /// @notice Internal utility to set the admin address\n    /// @param _admin Address to set as admin\n    function _setAdmin(address _admin) internal {\n        LibSanitize._notZeroAddress(_admin);\n        LibAdministrable._setAdmin(_admin);\n        emit SetAdmin(_admin);\n    }\n\n    /// @notice Internal utility to set the pending admin address\n    /// @param _pendingAdmin Address to set as pending admin\n    function _setPendingAdmin(address _pendingAdmin) internal {\n        LibAdministrable._setPendingAdmin(_pendingAdmin);\n        emit SetPendingAdmin(_pendingAdmin);\n    }\n\n    /// @notice Internal utility to retrieve the address of the current admin\n    /// @return The address of admin\n    function _getAdmin() internal view returns (address) {\n        return LibAdministrable._getAdmin();\n    }\n}\n"
    },
    "contracts/src/Initializable.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"./state/shared/Version.sol\";\n\n/// @title Initializable\n/// @author Kiln\n/// @notice This contract ensures that initializers are called only once per version\ncontract Initializable {\n    /// @notice Disable initialization on implementations\n    constructor() {\n        Version.set(type(uint256).max);\n        emit Initialize(type(uint256).max, msg.data);\n    }\n\n    /// @notice An error occured during the initialization\n    /// @param version The version that was attempting to be initialized\n    /// @param expectedVersion The version that was expected\n    error InvalidInitialization(uint256 version, uint256 expectedVersion);\n\n    /// @notice Emitted when the contract is properly initialized\n    /// @param version New version of the contracts\n    /// @param cdata Complete calldata that was used during the initialization\n    event Initialize(uint256 version, bytes cdata);\n\n    /// @notice Use this modifier on initializers along with a hard-coded version number\n    /// @param _version Version to initialize\n    modifier init(uint256 _version) {\n        if (_version != Version.get()) {\n            revert InvalidInitialization(_version, Version.get());\n        }\n        Version.set(_version + 1); // prevents reentrency on the called method\n        _;\n        emit Initialize(_version, msg.data);\n    }\n}\n"
    },
    "contracts/src/Oracle.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"./interfaces/IRiver.1.sol\";\nimport \"./interfaces/IOracle.1.sol\";\n\nimport \"./Administrable.sol\";\nimport \"./Initializable.sol\";\n\nimport \"./state/shared/RiverAddress.sol\";\n\nimport \"./state/oracle/LastEpochId.sol\";\nimport \"./state/oracle/OracleMembers.sol\";\nimport \"./state/oracle/Quorum.sol\";\nimport \"./state/oracle/ReportsPositions.sol\";\n\n/// @title Oracle (v1)\n/// @author Kiln\n/// @notice This contract handles the input from the allowed oracle members. Highly inspired by Lido's implementation.\ncontract OracleV1 is IOracleV1, Initializable, Administrable {\n    modifier onlyAdminOrMember(address _oracleMember) {\n        if (msg.sender != _getAdmin() \u0026\u0026 msg.sender != _oracleMember) {\n            revert LibErrors.Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    /// @inheritdoc IOracleV1\n    function initOracleV1(\n        address _riverAddress,\n        address _administratorAddress,\n        uint64 _epochsPerFrame,\n        uint64 _slotsPerEpoch,\n        uint64 _secondsPerSlot,\n        uint64 _genesisTime,\n        uint256 _annualAprUpperBound,\n        uint256 _relativeLowerBound\n    ) external init(0) {\n        _setAdmin(_administratorAddress);\n        RiverAddress.set(_riverAddress);\n        emit SetRiver(_riverAddress);\n        CLSpec.set(\n            CLSpec.CLSpecStruct({\n                epochsPerFrame: _epochsPerFrame,\n                slotsPerEpoch: _slotsPerEpoch,\n                secondsPerSlot: _secondsPerSlot,\n                genesisTime: _genesisTime,\n                epochsToAssumedFinality: 0\n            })\n        );\n        emit SetSpec(_epochsPerFrame, _slotsPerEpoch, _secondsPerSlot, _genesisTime);\n        ReportBounds.set(\n            ReportBounds.ReportBoundsStruct({\n                annualAprUpperBound: _annualAprUpperBound,\n                relativeLowerBound: _relativeLowerBound\n            })\n        );\n        emit SetBounds(_annualAprUpperBound, _relativeLowerBound);\n        Quorum.set(0);\n        emit SetQuorum(0);\n    }\n\n    /// @inheritdoc IOracleV1\n    function initOracleV1_1() external init(1) {\n        _clearReports();\n    }\n\n    /// @inheritdoc IOracleV1\n    function getRiver() external view returns (address) {\n        return RiverAddress.get();\n    }\n\n    /// @inheritdoc IOracleV1\n    function getMemberReportStatus(address _oracleMember) external view returns (bool) {\n        int256 memberIndex = OracleMembers.indexOf(_oracleMember);\n        return memberIndex != -1 \u0026\u0026 ReportsPositions.get(uint256(memberIndex));\n    }\n\n    /// @inheritdoc IOracleV1\n    function getGlobalReportStatus() external view returns (uint256) {\n        return ReportsPositions.getRaw();\n    }\n\n    /// @inheritdoc IOracleV1\n    function getReportVariantsCount() external view returns (uint256) {\n        return ReportsVariants.get().length;\n    }\n\n    /// @inheritdoc IOracleV1\n    function getReportVariantDetails(uint256 _idx)\n        external\n        view\n        returns (ReportsVariants.ReportVariantDetails memory)\n    {\n        if (ReportsVariants.get().length \u003c= _idx) {\n            revert ReportIndexOutOfBounds(_idx, ReportsVariants.get().length);\n        }\n        return ReportsVariants.get()[_idx];\n    }\n\n    /// @inheritdoc IOracleV1\n    function getQuorum() external view returns (uint256) {\n        return Quorum.get();\n    }\n\n    /// @inheritdoc IOracleV1\n    function getOracleMembers() external view returns (address[] memory) {\n        return OracleMembers.get();\n    }\n\n    /// @inheritdoc IOracleV1\n    function isMember(address _memberAddress) external view returns (bool) {\n        return OracleMembers.indexOf(_memberAddress) \u003e= 0;\n    }\n\n    /// @inheritdoc IOracleV1\n    function getLastReportedEpochId() external view returns (uint256) {\n        return LastEpochId.get();\n    }\n\n    /// @inheritdoc IOracleV1\n    function addMember(address _newOracleMember, uint256 _newQuorum) external onlyAdmin {\n        int256 memberIdx = OracleMembers.indexOf(_newOracleMember);\n        if (memberIdx \u003e= 0) {\n            revert AddressAlreadyInUse(_newOracleMember);\n        }\n        OracleMembers.push(_newOracleMember);\n        uint256 previousQuorum = Quorum.get();\n        _clearReportsAndSetQuorum(_newQuorum, previousQuorum);\n        emit AddMember(_newOracleMember);\n    }\n\n    /// @inheritdoc IOracleV1\n    function removeMember(address _oracleMember, uint256 _newQuorum) external onlyAdmin {\n        int256 memberIdx = OracleMembers.indexOf(_oracleMember);\n        if (memberIdx \u003c 0) {\n            revert LibErrors.InvalidCall();\n        }\n        OracleMembers.deleteItem(uint256(memberIdx));\n        uint256 previousQuorum = Quorum.get();\n        _clearReportsAndSetQuorum(_newQuorum, previousQuorum);\n        emit RemoveMember(_oracleMember);\n    }\n\n    /// @inheritdoc IOracleV1\n    function setMember(address _oracleMember, address _newAddress) external onlyAdminOrMember(_oracleMember) {\n        LibSanitize._notZeroAddress(_newAddress);\n        if (OracleMembers.indexOf(_newAddress) \u003e= 0) {\n            revert AddressAlreadyInUse(_newAddress);\n        }\n        int256 memberIdx = OracleMembers.indexOf(_oracleMember);\n        if (memberIdx \u003c 0) {\n            revert LibErrors.InvalidCall();\n        }\n        OracleMembers.set(uint256(memberIdx), _newAddress);\n        emit SetMember(_oracleMember, _newAddress);\n    }\n\n    /// @inheritdoc IOracleV1\n    function setQuorum(uint256 _newQuorum) external onlyAdmin {\n        uint256 previousQuorum = Quorum.get();\n        if (previousQuorum == _newQuorum) {\n            revert LibErrors.InvalidArgument();\n        }\n        _clearReportsAndSetQuorum(_newQuorum, previousQuorum);\n    }\n\n    /// @inheritdoc IOracleV1\n    function reportConsensusLayerData(IRiverV1.ConsensusLayerReport calldata _report) external {\n        // retrieve member index and revert if not oracle member\n        int256 memberIndex = OracleMembers.indexOf(msg.sender);\n        if (memberIndex == -1) {\n            revert LibErrors.Unauthorized(msg.sender);\n        }\n\n        // store last reported epoch to stack\n        uint256 lastReportedEpochValue = LastEpochId.get();\n\n        // checks that the report epoch is not too old\n        if (_report.epoch \u003c lastReportedEpochValue) {\n            revert EpochTooOld(_report.epoch, LastEpochId.get());\n        }\n        IRiverV1 river = IRiverV1(payable(RiverAddress.get()));\n        // checks that the report epoch is not invalid\n        if (!river.isValidEpoch(_report.epoch)) {\n            revert InvalidEpoch(_report.epoch);\n        }\n        // if valid and greater than the lastReportedEpoch, we clear the reporting data\n        if (_report.epoch \u003e lastReportedEpochValue) {\n            _clearReports();\n            LastEpochId.set(_report.epoch);\n            emit SetLastReportedEpoch(_report.epoch);\n        }\n        // we retrieve the voting status of the caller, and revert if already voted\n        if (ReportsPositions.get(uint256(memberIndex))) {\n            revert AlreadyReported(_report.epoch, msg.sender);\n        }\n        // we register the caller\n        ReportsPositions.register(uint256(memberIndex));\n\n        // we compute the variant by hashing the report\n        bytes32 variant = _reportChecksum(_report);\n        // we retrieve the details for the given variant\n        (int256 variantIndex, uint256 variantVotes) = _getReportVariantIndexAndVotes(variant);\n        // we retrieve the quorum to stack\n        uint256 quorum = Quorum.get();\n\n        emit ReportedConsensusLayerData(msg.sender, variant, _report, variantVotes + 1, quorum);\n\n        // if adding this vote reaches quorum\n        if (variantVotes + 1 \u003e= quorum) {\n            // we clear the reporting data\n            _clearReports();\n            // we increment the lastReportedEpoch to force reports to be on the last frame\n            LastEpochId.set(_report.epoch + 1);\n            // we push the report to river\n            river.setConsensusLayerData(_report);\n            emit SetLastReportedEpoch(_report.epoch + 1);\n        } else if (variantVotes == 0) {\n            // if we have no votes for the variant, we create the variant details\n            ReportsVariants.push(ReportsVariants.ReportVariantDetails({variant: variant, votes: 1}));\n        } else {\n            // otherwise we increment the vote\n            ReportsVariants.get()[uint256(variantIndex)].votes += 1;\n        }\n    }\n\n    /// @notice Internal utility to clear all the reports and edit the quorum if a new value is provided\n    /// @dev Ensures that the quorum respects invariants\n    /// @dev The admin is in charge of providing a proper quorum based on the oracle member count\n    /// @dev The quorum value Q should respect the following invariant, where O is oracle member count\n    /// @dev (O / 2) + 1 \u003c= Q \u003c= O\n    /// @param _newQuorum New quorum value\n    /// @param _previousQuorum The old quorum value\n    function _clearReportsAndSetQuorum(uint256 _newQuorum, uint256 _previousQuorum) internal {\n        uint256 memberCount = OracleMembers.get().length;\n        if ((_newQuorum == 0 \u0026\u0026 memberCount \u003e 0) || _newQuorum \u003e memberCount) {\n            revert LibErrors.InvalidArgument();\n        }\n        _clearReports();\n        if (_newQuorum != _previousQuorum) {\n            Quorum.set(_newQuorum);\n            emit SetQuorum(_newQuorum);\n        }\n    }\n\n    /// @notice Internal utility to hash and retrieve the variant id of a report\n    /// @param _report The reported data structure\n    /// @return The report variant\n    function _reportChecksum(IRiverV1.ConsensusLayerReport calldata _report) internal pure returns (bytes32) {\n        return keccak256(abi.encode(_report));\n    }\n\n    /// @notice Internal utility to clear all reporting details\n    function _clearReports() internal {\n        ReportsVariants.clear();\n        ReportsPositions.clear();\n        emit ClearedReporting();\n    }\n\n    /// @notice Internal utility to retrieve index and vote count for a given variant\n    /// @param _variant The variant to lookup\n    /// @return The index of the variant, -1 if not found\n    /// @return The vote count of the variant\n    function _getReportVariantIndexAndVotes(bytes32 _variant) internal view returns (int256, uint256) {\n        uint256 reportVariantsLength = ReportsVariants.get().length;\n        for (uint256 idx = 0; idx \u003c reportVariantsLength;) {\n            if (ReportsVariants.get()[idx].variant == _variant) {\n                return (int256(idx), ReportsVariants.get()[idx].votes);\n            }\n            unchecked {\n                ++idx;\n            }\n        }\n        return (-1, 0);\n    }\n\n    /// @notice Internal utility to retrieve a casted River interface\n    /// @return The casted River interface\n    function _river() internal view returns (IRiverV1) {\n        return IRiverV1(payable(RiverAddress.get()));\n    }\n}\n"
    },
    "contracts/src/interfaces/IAdministrable.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\n/// @title Administrable Interface\n/// @author Kiln\n/// @notice This interface exposes methods to handle the ownership of the contracts\ninterface IAdministrable {\n    /// @notice The pending admin address changed\n    /// @param pendingAdmin New pending admin address\n    event SetPendingAdmin(address indexed pendingAdmin);\n\n    /// @notice The admin address changed\n    /// @param admin New admin address\n    event SetAdmin(address indexed admin);\n\n    /// @notice Retrieves the current admin address\n    /// @return The admin address\n    function getAdmin() external view returns (address);\n\n    /// @notice Retrieve the current pending admin address\n    /// @return The pending admin address\n    function getPendingAdmin() external view returns (address);\n\n    /// @notice Proposes a new address as admin\n    /// @dev This security prevents setting an invalid address as an admin. The pending\n    /// @dev admin has to claim its ownership of the contract, and prove that the new\n    /// @dev address is able to perform regular transactions.\n    /// @param _newAdmin New admin address\n    function proposeAdmin(address _newAdmin) external;\n\n    /// @notice Accept the transfer of ownership\n    /// @dev Only callable by the pending admin. Resets the pending admin if succesful.\n    function acceptAdmin() external;\n}\n"
    },
    "contracts/src/interfaces/IOracle.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"./IRiver.1.sol\";\nimport \"../state/oracle/ReportsVariants.sol\";\n\n/// @title Oracle Interface (v1)\n/// @author Kiln\n/// @notice This interface exposes methods to handle the input from the allowed oracle members.\n/// @notice Highly inspired by Lido's implementation.\ninterface IOracleV1 {\n    /// @notice The storage quorum value has been changed\n    /// @param newQuorum The new quorum value\n    event SetQuorum(uint256 newQuorum);\n\n    /// @notice A member has been added to the oracle member list\n    /// @param member The address of the member\n    event AddMember(address indexed member);\n\n    /// @notice A member has been removed from the oracle member list\n    /// @param member The address of the member\n    event RemoveMember(address indexed member);\n\n    /// @notice A member address has been edited\n    /// @param oldAddress The previous member address\n    /// @param newAddress The new member address\n    event SetMember(address indexed oldAddress, address indexed newAddress);\n\n    /// @notice The storage river address value has been changed\n    /// @param _river The new river address\n    event SetRiver(address _river);\n\n    /// @notice The consensus layer spec has been changed\n    /// @param epochsPerFrame The number of epochs inside a frame (225 = 24 hours)\n    /// @param slotsPerEpoch The number of slots inside an epoch (32 on ethereum mainnet)\n    /// @param secondsPerSlot The time between two slots (12 seconds on ethereum mainnet)\n    /// @param genesisTime The timestamp of block #0\n    event SetSpec(uint64 epochsPerFrame, uint64 slotsPerEpoch, uint64 secondsPerSlot, uint64 genesisTime);\n\n    /// @notice The report bounds have been changed\n    /// @param annualAprUpperBound The maximum allowed apr. 10% means increases in balance extrapolated to a year should not exceed 10%.\n    /// @param relativeLowerBound The maximum allowed balance decrease as a relative % of the total balance\n    event SetBounds(uint256 annualAprUpperBound, uint256 relativeLowerBound);\n\n    /// @notice An oracle member performed a report\n    /// @param member The oracle member\n    /// @param variant The variant of the report\n    /// @param report The raw report structure\n    /// @param voteCount The vote count\n    event ReportedConsensusLayerData(\n        address indexed member,\n        bytes32 indexed variant,\n        IRiverV1.ConsensusLayerReport report,\n        uint256 voteCount,\n        uint256 quorum\n    );\n\n    /// @notice The last reported epoch has changed\n    event SetLastReportedEpoch(uint256 lastReportedEpoch);\n\n    /// @notice Cleared reporting data\n    event ClearedReporting();\n\n    /// @notice The provided epoch is too old compared to the expected epoch id\n    /// @param providedEpochId The epoch id provided as input\n    /// @param minExpectedEpochId The minimum epoch id expected\n    error EpochTooOld(uint256 providedEpochId, uint256 minExpectedEpochId);\n\n    /// @notice Thrown when the reported epoch is invalid\n    /// @param epoch The invalid epoch\n    error InvalidEpoch(uint256 epoch);\n\n    /// @notice Thrown when the report indexs fetched is out of bounds\n    /// @param index Requested index\n    /// @param length Size of the variant array\n    error ReportIndexOutOfBounds(uint256 index, uint256 length);\n\n    /// @notice The member already reported on the given epoch id\n    /// @param epochId The epoch id provided as input\n    /// @param member The oracle member\n    error AlreadyReported(uint256 epochId, address member);\n\n    /// @notice The address is already in use by an oracle member\n    /// @param newAddress The address already in use\n    error AddressAlreadyInUse(address newAddress);\n\n    /// @notice Initializes the oracle\n    /// @param _river Address of the River contract, able to receive oracle input data after quorum is met\n    /// @param _administratorAddress Address able to call administrative methods\n    /// @param _epochsPerFrame CL spec parameter. Number of epochs in a frame.\n    /// @param _slotsPerEpoch CL spec parameter. Number of slots in one epoch.\n    /// @param _secondsPerSlot CL spec parameter. Number of seconds between slots.\n    /// @param _genesisTime CL spec parameter. Timestamp of the genesis slot.\n    /// @param _annualAprUpperBound CL bound parameter. Maximum apr allowed for balance increase. Delta between updates is extrapolated on a year time frame.\n    /// @param _relativeLowerBound CL bound parameter. Maximum relative balance decrease.\n    function initOracleV1(\n        address _river,\n        address _administratorAddress,\n        uint64 _epochsPerFrame,\n        uint64 _slotsPerEpoch,\n        uint64 _secondsPerSlot,\n        uint64 _genesisTime,\n        uint256 _annualAprUpperBound,\n        uint256 _relativeLowerBound\n    ) external;\n\n    /// @notice Initializes the oracle\n    function initOracleV1_1() external;\n\n    /// @notice Retrieve River address\n    /// @return The address of River\n    function getRiver() external view returns (address);\n\n    /// @notice Retrieve member report status\n    /// @param _oracleMember Address of member to check\n    /// @return True if member has reported\n    function getMemberReportStatus(address _oracleMember) external view returns (bool);\n\n    /// @notice Retrieve member report status\n    /// @return The raw report status value\n    function getGlobalReportStatus() external view returns (uint256);\n\n    /// @notice Retrieve report variants count\n    /// @return The count of report variants\n    function getReportVariantsCount() external view returns (uint256);\n\n    /// @notice Retrieve the details of a report variant\n    /// @param _idx The index of the report variant\n    /// @return The report variant details\n    function getReportVariantDetails(uint256 _idx)\n        external\n        view\n        returns (ReportsVariants.ReportVariantDetails memory);\n\n    /// @notice Retrieve the current quorum\n    /// @return The current quorum\n    function getQuorum() external view returns (uint256);\n\n    /// @notice Retrieve the list of oracle members\n    /// @return The oracle members\n    function getOracleMembers() external view returns (address[] memory);\n\n    /// @notice Returns true if address is member\n    /// @dev Performs a naive search, do not call this on-chain, used as an off-chain helper\n    /// @param _memberAddress Address of the member\n    /// @return True if address is a member\n    function isMember(address _memberAddress) external view returns (bool);\n\n    /// @notice Retrieve the last reported epoch id\n    /// @dev The Oracle contracts expects reports on an epoch id \u003e= that the returned value\n    /// @return The last reported epoch id\n    function getLastReportedEpochId() external view returns (uint256);\n\n    /// @notice Adds new address as oracle member, giving the ability to push cl reports.\n    /// @dev Only callable by the adminstrator\n    /// @dev Modifying the quorum clears all the reporting data\n    /// @param _newOracleMember Address of the new member\n    /// @param _newQuorum New quorum value\n    function addMember(address _newOracleMember, uint256 _newQuorum) external;\n\n    /// @notice Removes an address from the oracle members.\n    /// @dev Only callable by the adminstrator\n    /// @dev Modifying the quorum clears all the reporting data\n    /// @dev Remaining members that have already voted should vote again for the same frame.\n    /// @param _oracleMember Address to remove\n    /// @param _newQuorum New quorum value\n    function removeMember(address _oracleMember, uint256 _newQuorum) external;\n\n    /// @notice Changes the address of an oracle member\n    /// @dev Only callable by the adminitrator or the member itself\n    /// @dev Cannot use an address already in use\n    /// @param _oracleMember Address to change\n    /// @param _newAddress New address for the member\n    function setMember(address _oracleMember, address _newAddress) external;\n\n    /// @notice Edits the quorum required to forward cl data to River\n    /// @dev Modifying the quorum clears all the reporting data\n    /// @param _newQuorum New quorum parameter\n    function setQuorum(uint256 _newQuorum) external;\n\n    /// @notice Submit a report as an oracle member\n    /// @param _report The report structure\n    function reportConsensusLayerData(IRiverV1.ConsensusLayerReport calldata _report) external;\n}\n"
    },
    "contracts/src/interfaces/IRiver.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../state/river/DailyCommittableLimits.sol\";\n\nimport \"./components/IConsensusLayerDepositManager.1.sol\";\nimport \"./components/IOracleManager.1.sol\";\nimport \"./components/ISharesManager.1.sol\";\nimport \"./components/IUserDepositManager.1.sol\";\n\n/// @title River Interface (v1)\n/// @author Kiln\n/// @notice The main system interface\ninterface IRiverV1 is IConsensusLayerDepositManagerV1, IUserDepositManagerV1, ISharesManagerV1, IOracleManagerV1 {\n    /// @notice Funds have been pulled from the Execution Layer Fee Recipient\n    /// @param amount The amount pulled\n    event PulledELFees(uint256 amount);\n\n    /// @notice Funds have been pulled from the Coverage Fund\n    /// @param amount The amount pulled\n    event PulledCoverageFunds(uint256 amount);\n\n    /// @notice Emitted when funds are pulled from the redeem manager\n    /// @param amount The amount pulled\n    event PulledRedeemManagerExceedingEth(uint256 amount);\n\n    /// @notice Emitted when funds are pulled from the CL recipient\n    /// @param pulledSkimmedEthAmount The amount of skimmed ETH pulled\n    /// @param pullExitedEthAmount The amount of exited ETH pulled\n    event PulledCLFunds(uint256 pulledSkimmedEthAmount, uint256 pullExitedEthAmount);\n\n    /// @notice The stored Execution Layer Fee Recipient has been changed\n    /// @param elFeeRecipient The new Execution Layer Fee Recipient\n    event SetELFeeRecipient(address indexed elFeeRecipient);\n\n    /// @notice The stored Coverage Fund has been changed\n    /// @param coverageFund The new Coverage Fund\n    event SetCoverageFund(address indexed coverageFund);\n\n    /// @notice The stored Collector has been changed\n    /// @param collector The new Collector\n    event SetCollector(address indexed collector);\n\n    /// @notice The stored Allowlist has been changed\n    /// @param allowlist The new Allowlist\n    event SetAllowlist(address indexed allowlist);\n\n    /// @notice The stored Global Fee has been changed\n    /// @param fee The new Global Fee\n    event SetGlobalFee(uint256 fee);\n\n    /// @notice The stored Operators Registry has been changed\n    /// @param operatorRegistry The new Operators Registry\n    event SetOperatorsRegistry(address indexed operatorRegistry);\n\n    /// @notice The stored Metadata URI string has been changed\n    /// @param metadataURI The new Metadata URI string\n    event SetMetadataURI(string metadataURI);\n\n    /// @notice The system underlying supply increased. This is a snapshot of the balances for accounting purposes\n    /// @param _collector The address of the collector during this event\n    /// @param _oldTotalUnderlyingBalance Old total ETH balance under management by River\n    /// @param _oldTotalSupply Old total supply in shares\n    /// @param _newTotalUnderlyingBalance New total ETH balance under management by River\n    /// @param _newTotalSupply New total supply in shares\n    event RewardsEarned(\n        address indexed _collector,\n        uint256 _oldTotalUnderlyingBalance,\n        uint256 _oldTotalSupply,\n        uint256 _newTotalUnderlyingBalance,\n        uint256 _newTotalSupply\n    );\n\n    /// @notice Emitted when the daily committable limits are changed\n    /// @param minNetAmount The minimum amount that must be used as the daily committable amount\n    /// @param maxRelativeAmount The maximum amount that can be used as the daily committable amount, relative to the total underlying supply\n    event SetMaxDailyCommittableAmounts(uint256 minNetAmount, uint256 maxRelativeAmount);\n\n    /// @notice Emitted when the redeem manager address is changed\n    /// @param redeemManager The address of the redeem manager\n    event SetRedeemManager(address redeemManager);\n\n    /// @notice Emitted when the balance to deposit is updated\n    /// @param oldAmount The old balance to deposit\n    /// @param newAmount The new balance to deposit\n    event SetBalanceToDeposit(uint256 oldAmount, uint256 newAmount);\n\n    /// @notice Emitted when the balance to redeem is updated\n    /// @param oldAmount The old balance to redeem\n    /// @param newAmount The new balance to redeem\n    event SetBalanceToRedeem(uint256 oldAmount, uint256 newAmount);\n\n    /// @notice Emitted when the balance committed to deposit\n    /// @param oldAmount The old balance committed to deposit\n    /// @param newAmount The new balance committed to deposit\n    event SetBalanceCommittedToDeposit(uint256 oldAmount, uint256 newAmount);\n\n    /// @notice Emitted when the redeem manager received a withdraw event report\n    /// @param redeemManagerDemand The total demand in LsETH of the redeem manager\n    /// @param suppliedRedeemManagerDemand The amount of LsETH demand actually supplied\n    /// @param suppliedRedeemManagerDemandInEth The amount in ETH of the supplied demand\n    event ReportedRedeemManager(\n        uint256 redeemManagerDemand, uint256 suppliedRedeemManagerDemand, uint256 suppliedRedeemManagerDemandInEth\n    );\n\n    /// @notice Thrown when the amount received from the Withdraw contract doe not match the requested amount\n    /// @param requested The amount that was requested\n    /// @param received The amount that was received\n    error InvalidPulledClFundsAmount(uint256 requested, uint256 received);\n\n    /// @notice The computed amount of shares to mint is 0\n    error ZeroMintedShares();\n\n    /// @notice The access was denied\n    /// @param account The account that was denied\n    error Denied(address account);\n\n    /// @notice Initializes the River system\n    /// @param _depositContractAddress Address to make Consensus Layer deposits\n    /// @param _elFeeRecipientAddress Address that receives the execution layer fees\n    /// @param _withdrawalCredentials Credentials to use for every validator deposit\n    /// @param _oracleAddress The address of the Oracle contract\n    /// @param _systemAdministratorAddress Administrator address\n    /// @param _allowlistAddress Address of the allowlist contract\n    /// @param _operatorRegistryAddress Address of the operator registry\n    /// @param _collectorAddress Address receiving the the global fee on revenue\n    /// @param _globalFee Amount retained when the ETH balance increases and sent to the collector\n    function initRiverV1(\n        address _depositContractAddress,\n        address _elFeeRecipientAddress,\n        bytes32 _withdrawalCredentials,\n        address _oracleAddress,\n        address _systemAdministratorAddress,\n        address _allowlistAddress,\n        address _operatorRegistryAddress,\n        address _collectorAddress,\n        uint256 _globalFee\n    ) external;\n\n    /// @notice Initialized version 1.1 of the River System\n    /// @param _redeemManager The redeem manager address\n    /// @param _epochsPerFrame The amounts of epochs in a frame\n    /// @param _slotsPerEpoch The slots inside an epoch\n    /// @param _secondsPerSlot The seconds inside a slot\n    /// @param _genesisTime The genesis timestamp\n    /// @param _epochsToAssumedFinality The number of epochs before an epoch is considered final on-chain\n    /// @param _annualAprUpperBound The reporting upper bound\n    /// @param _relativeLowerBound The reporting lower bound\n    /// @param _maxDailyNetCommittableAmount_ The net daily committable limit\n    /// @param _maxDailyRelativeCommittableAmount_ The relative daily committable limit\n    function initRiverV1_1(\n        address _redeemManager,\n        uint64 _epochsPerFrame,\n        uint64 _slotsPerEpoch,\n        uint64 _secondsPerSlot,\n        uint64 _genesisTime,\n        uint64 _epochsToAssumedFinality,\n        uint256 _annualAprUpperBound,\n        uint256 _relativeLowerBound,\n        uint128 _maxDailyNetCommittableAmount_,\n        uint128 _maxDailyRelativeCommittableAmount_\n    ) external;\n\n    /// @notice Get the current global fee\n    /// @return The global fee\n    function getGlobalFee() external view returns (uint256);\n\n    /// @notice Retrieve the allowlist address\n    /// @return The allowlist address\n    function getAllowlist() external view returns (address);\n\n    /// @notice Retrieve the collector address\n    /// @return The collector address\n    function getCollector() external view returns (address);\n\n    /// @notice Retrieve the execution layer fee recipient\n    /// @return The execution layer fee recipient address\n    function getELFeeRecipient() external view returns (address);\n\n    /// @notice Retrieve the coverage fund\n    /// @return The coverage fund address\n    function getCoverageFund() external view returns (address);\n\n    /// @notice Retrieve the redeem manager\n    /// @return The redeem manager address\n    function getRedeemManager() external view returns (address);\n\n    /// @notice Retrieve the operators registry\n    /// @return The operators registry address\n    function getOperatorsRegistry() external view returns (address);\n\n    /// @notice Retrieve the metadata uri string value\n    /// @return The metadata uri string value\n    function getMetadataURI() external view returns (string memory);\n\n    /// @notice Retrieve the configured daily committable limits\n    /// @return The daily committable limits structure\n    function getDailyCommittableLimits()\n        external\n        view\n        returns (DailyCommittableLimits.DailyCommittableLimitsStruct memory);\n\n    /// @notice Resolves the provided redeem requests by calling the redeem manager\n    /// @param _redeemRequestIds The list of redeem requests to resolve\n    /// @return withdrawalEventIds The list of matching withdrawal events, or error codes\n    function resolveRedeemRequests(uint32[] calldata _redeemRequestIds)\n        external\n        view\n        returns (int64[] memory withdrawalEventIds);\n\n    /// @notice Set the daily committable limits\n    /// @param _dcl The Daily Committable Limits structure\n    function setDailyCommittableLimits(DailyCommittableLimits.DailyCommittableLimitsStruct memory _dcl) external;\n\n    /// @notice Retrieve the current balance to redeem\n    /// @return The current balance to redeem\n    function getBalanceToRedeem() external view returns (uint256);\n\n    /// @notice Performs a redeem request on the redeem manager\n    /// @param _lsETHAmount The amount of LsETH to redeem\n    /// @param _recipient The address that will own the redeem request\n    /// @return redeemRequestId The ID of the newly created redeem request\n    function requestRedeem(uint256 _lsETHAmount, address _recipient) external returns (uint32 redeemRequestId);\n\n    /// @notice Claims several redeem requests\n    /// @param _redeemRequestIds The list of redeem requests to claim\n    /// @param _withdrawalEventIds The list of resolved withdrawal event ids\n    /// @return claimStatuses The operation status results\n    function claimRedeemRequests(uint32[] calldata _redeemRequestIds, uint32[] calldata _withdrawalEventIds)\n        external\n        returns (uint8[] memory claimStatuses);\n\n    /// @notice Changes the global fee parameter\n    /// @param _newFee New fee value\n    function setGlobalFee(uint256 _newFee) external;\n\n    /// @notice Changes the allowlist address\n    /// @param _newAllowlist New address for the allowlist\n    function setAllowlist(address _newAllowlist) external;\n\n    /// @notice Changes the collector address\n    /// @param _newCollector New address for the collector\n    function setCollector(address _newCollector) external;\n\n    /// @notice Changes the execution layer fee recipient\n    /// @param _newELFeeRecipient New address for the recipient\n    function setELFeeRecipient(address _newELFeeRecipient) external;\n\n    /// @notice Changes the coverage fund\n    /// @param _newCoverageFund New address for the fund\n    function setCoverageFund(address _newCoverageFund) external;\n\n    /// @notice Sets the metadata uri string value\n    /// @param _metadataURI The new metadata uri string value\n    function setMetadataURI(string memory _metadataURI) external;\n\n    /// @notice Input for execution layer fee earnings\n    function sendELFees() external payable;\n\n    /// @notice Input for consensus layer funds, containing both exit and skimming\n    function sendCLFunds() external payable;\n\n    /// @notice Input for coverage funds\n    function sendCoverageFunds() external payable;\n\n    /// @notice Input for the redeem manager funds\n    function sendRedeemManagerExceedingFunds() external payable;\n}\n"
    },
    "contracts/src/interfaces/components/IConsensusLayerDepositManager.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\n/// @title Consensys Layer Deposit Manager Interface (v1)\n/// @author Kiln\n/// @notice This interface exposes methods to handle the interactions with the official deposit contract\ninterface IConsensusLayerDepositManagerV1 {\n    /// @notice The stored deposit contract address changed\n    /// @param depositContract Address of the deposit contract\n    event SetDepositContractAddress(address indexed depositContract);\n\n    /// @notice The stored withdrawal credentials changed\n    /// @param withdrawalCredentials The withdrawal credentials to use for deposits\n    event SetWithdrawalCredentials(bytes32 withdrawalCredentials);\n\n    /// @notice Emitted when the deposited validator count is updated\n    /// @param oldDepositedValidatorCount The old deposited validator count value\n    /// @param newDepositedValidatorCount The new deposited validator count value\n    event SetDepositedValidatorCount(uint256 oldDepositedValidatorCount, uint256 newDepositedValidatorCount);\n\n    /// @notice Not enough funds to deposit one validator\n    error NotEnoughFunds();\n\n    /// @notice The length of the BLS Public key is invalid during deposit\n    error InconsistentPublicKeys();\n\n    /// @notice The length of the BLS Signature is invalid during deposit\n    error InconsistentSignatures();\n\n    /// @notice The internal key retrieval returned no keys\n    error NoAvailableValidatorKeys();\n\n    /// @notice The received count of public keys to deposit is invalid\n    error InvalidPublicKeyCount();\n\n    /// @notice The received count of signatures to deposit is invalid\n    error InvalidSignatureCount();\n\n    /// @notice The withdrawal credentials value is null\n    error InvalidWithdrawalCredentials();\n\n    /// @notice An error occured during the deposit\n    error ErrorOnDeposit();\n\n    /// @notice Returns the amount of ETH not yet committed for deposit\n    /// @return The amount of ETH not yet committed for deposit\n    function getBalanceToDeposit() external view returns (uint256);\n\n    /// @notice Returns the amount of ETH committed for deposit\n    /// @return The amount of ETH committed for deposit\n    function getCommittedBalance() external view returns (uint256);\n\n    /// @notice Retrieve the withdrawal credentials\n    /// @return The withdrawal credentials\n    function getWithdrawalCredentials() external view returns (bytes32);\n\n    /// @notice Get the deposited validator count (the count of deposits made by the contract)\n    /// @return The deposited validator count\n    function getDepositedValidatorCount() external view returns (uint256);\n\n    /// @notice Deposits current balance to the Consensus Layer by batches of 32 ETH\n    /// @param _maxCount The maximum amount of validator keys to fund\n    function depositToConsensusLayer(uint256 _maxCount) external;\n}\n"
    },
    "contracts/src/interfaces/components/IOracleManager.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../state/river/CLSpec.sol\";\nimport \"../../state/river/ReportBounds.sol\";\n\n/// @title Oracle Manager (v1)\n/// @author Kiln\n/// @notice This interface exposes methods to handle the inputs provided by the oracle\ninterface IOracleManagerV1 {\n    /// @notice The stored oracle address changed\n    /// @param oracleAddress The new oracle address\n    event SetOracle(address indexed oracleAddress);\n\n    /// @notice The consensus layer data provided by the oracle has been updated\n    /// @param validatorCount The new count of validators running on the consensus layer\n    /// @param validatorTotalBalance The new total balance sum of all validators\n    /// @param roundId Round identifier\n    event ConsensusLayerDataUpdate(uint256 validatorCount, uint256 validatorTotalBalance, bytes32 roundId);\n\n    /// @notice The Consensus Layer Spec is changed\n    /// @param epochsPerFrame The number of epochs inside a frame\n    /// @param slotsPerEpoch The number of slots inside an epoch\n    /// @param secondsPerSlot The number of seconds inside a slot\n    /// @param genesisTime The genesis timestamp\n    /// @param epochsToAssumedFinality The number of epochs before an epoch is considered final\n    event SetSpec(\n        uint64 epochsPerFrame,\n        uint64 slotsPerEpoch,\n        uint64 secondsPerSlot,\n        uint64 genesisTime,\n        uint64 epochsToAssumedFinality\n    );\n\n    /// @notice The Report Bounds are changed\n    /// @param annualAprUpperBound The reporting upper bound\n    /// @param relativeLowerBound The reporting lower bound\n    event SetBounds(uint256 annualAprUpperBound, uint256 relativeLowerBound);\n\n    /// @notice The provided report has beend processed\n    /// @param report The report that was provided\n    /// @param trace The trace structure providing more insights on internals\n    event ProcessedConsensusLayerReport(\n        IOracleManagerV1.ConsensusLayerReport report, ConsensusLayerDataReportingTrace trace\n    );\n\n    /// @notice The reported validator count is invalid\n    /// @param providedValidatorCount The received validator count value\n    /// @param depositedValidatorCount The number of deposits performed by the system\n    /// @param lastReportedValidatorCount The last reported validator count\n    error InvalidValidatorCountReport(\n        uint256 providedValidatorCount, uint256 depositedValidatorCount, uint256 lastReportedValidatorCount\n    );\n\n    /// @notice Thrown when an invalid epoch was reported\n    /// @param epoch Invalid epoch\n    error InvalidEpoch(uint256 epoch);\n\n    /// @notice The balance increase is higher than the maximum allowed by the upper bound\n    /// @param prevTotalEthIncludingExited The previous total balance, including all exited balance\n    /// @param postTotalEthIncludingExited The post-report total balance, including all exited balance\n    /// @param timeElapsed The time in seconds since last report\n    /// @param annualAprUpperBound The upper bound value that was used\n    error TotalValidatorBalanceIncreaseOutOfBound(\n        uint256 prevTotalEthIncludingExited,\n        uint256 postTotalEthIncludingExited,\n        uint256 timeElapsed,\n        uint256 annualAprUpperBound\n    );\n\n    /// @notice The balance decrease is higher than the maximum allowed by the lower bound\n    /// @param prevTotalEthIncludingExited The previous total balance, including all exited balance\n    /// @param postTotalEthIncludingExited The post-report total balance, including all exited balance\n    /// @param timeElapsed The time in seconds since last report\n    /// @param relativeLowerBound The lower bound value that was used\n    error TotalValidatorBalanceDecreaseOutOfBound(\n        uint256 prevTotalEthIncludingExited,\n        uint256 postTotalEthIncludingExited,\n        uint256 timeElapsed,\n        uint256 relativeLowerBound\n    );\n\n    /// @notice The total exited balance decreased\n    /// @param currentValidatorsExitedBalance The current exited balance\n    /// @param newValidatorsExitedBalance The new exited balance\n    error InvalidDecreasingValidatorsExitedBalance(\n        uint256 currentValidatorsExitedBalance, uint256 newValidatorsExitedBalance\n    );\n\n    /// @notice The total skimmed balance decreased\n    /// @param currentValidatorsSkimmedBalance The current exited balance\n    /// @param newValidatorsSkimmedBalance The new exited balance\n    error InvalidDecreasingValidatorsSkimmedBalance(\n        uint256 currentValidatorsSkimmedBalance, uint256 newValidatorsSkimmedBalance\n    );\n\n    /// @notice Trace structure emitted via logs during reporting\n    struct ConsensusLayerDataReportingTrace {\n        uint256 rewards;\n        uint256 pulledELFees;\n        uint256 pulledRedeemManagerExceedingEthBuffer;\n        uint256 pulledCoverageFunds;\n    }\n\n    /// @notice The format of the oracle report\n    struct ConsensusLayerReport {\n        // this is the epoch at which the report was performed\n        // data should be fetched up to the state of this epoch by the oracles\n        uint256 epoch;\n        // the sum of all the validator balances on the consensus layer\n        // when a validator enters the exit queue, the validator is considered stopped, its balance is accounted in both validatorsExitingBalance and validatorsBalance\n        // when a validator leaves the exit queue and the funds are sweeped onto the execution layer, the balance is only accounted in validatorsExitedBalance and not in validatorsBalance\n        // this value can decrease between reports\n        uint256 validatorsBalance;\n        // the sum of all the skimmings performed on the validators\n        // these values can be found in the execution layer block bodies under the withdrawals field\n        // a withdrawal is considered skimming if\n        // - the epoch at which it happened is \u003c validator.withdrawableEpoch\n        // - the epoch at which it happened is \u003e= validator.withdrawableEpoch and in that case we only account for what would be above 32 eth as skimming\n        // this value cannot decrease over reports\n        uint256 validatorsSkimmedBalance;\n        // the sum of all the exits performed on the validators\n        // these values can be found in the execution layer block bodies under the withdrawals field\n        // a withdrawal is considered exit if\n        // - the epoch at which it happened is \u003e= validator.withdrawableEpoch and in that case we only account for what would be \u003c= 32 eth as exit\n        // this value cannot decrease over reports\n        uint256 validatorsExitedBalance;\n        // the sum of all the exiting balance, which is all the validators on their way to get sweeped and exited\n        // this includes voluntary exits and slashings\n        // this value can decrease between reports\n        uint256 validatorsExitingBalance;\n        // the count of activated validators\n        // even validators that are exited are still accounted\n        // this value cannot decrease over reports\n        uint32 validatorsCount;\n        // an array containing the count of stopped validators per operator\n        // the first element of the array is the sum of all stopped validators\n        // then index 1 would be operator 0\n        // these values cannot decrease over reports\n        uint32[] stoppedValidatorCountPerOperator;\n        // flag enabled by the oracles when the buffer rebalancing is activated\n        // the activation logic is written in the oracle specification and all oracle members must agree on the activation\n        // when active, the eth in the deposit buffer can be used to pay for exits in the redeem manager\n        bool rebalanceDepositToRedeemMode;\n        // flag enabled by the oracles when the slashing containment is activated\n        // the activation logic is written in the oracle specification and all oracle members must agree on the activation\n        // This flag is activated when a pre-defined threshold of slashed validators in our set of validators is reached\n        // This flag is deactivated when a bottom threshold is met, this means that when we reach the upper threshold and activate the flag, we will deactivate it when we reach the bottom threshold and not before\n        // when active, no more validator exits can be requested by the protocol\n        bool slashingContainmentMode;\n    }\n\n    /// @notice The format of the oracle report in storage\n    /// @notice These fields have the exact same function as the ones in ConsensusLayerReport, but this struct is optimized for storage\n    struct StoredConsensusLayerReport {\n        uint256 epoch;\n        uint256 validatorsBalance;\n        uint256 validatorsSkimmedBalance;\n        uint256 validatorsExitedBalance;\n        uint256 validatorsExitingBalance;\n        uint32 validatorsCount;\n        bool rebalanceDepositToRedeemMode;\n        bool slashingContainmentMode;\n    }\n\n    /// @notice Get oracle address\n    /// @return The oracle address\n    function getOracle() external view returns (address);\n\n    /// @notice Get CL validator total balance\n    /// @return The CL Validator total balance\n    function getCLValidatorTotalBalance() external view returns (uint256);\n\n    /// @notice Get CL validator count (the amount of validator reported by the oracles)\n    /// @return The CL validator count\n    function getCLValidatorCount() external view returns (uint256);\n\n    /// @notice Verifies if the provided epoch is valid\n    /// @param epoch The epoch to lookup\n    /// @return True if valid\n    function isValidEpoch(uint256 epoch) external view returns (bool);\n\n    /// @notice Retrieve the block timestamp\n    /// @return The current timestamp from the EVM context\n    function getTime() external view returns (uint256);\n\n    /// @notice Retrieve expected epoch id\n    /// @return The current expected epoch id\n    function getExpectedEpochId() external view returns (uint256);\n\n    /// @notice Retrieve the last completed epoch id\n    /// @return The last completed epoch id\n    function getLastCompletedEpochId() external view returns (uint256);\n\n    /// @notice Retrieve the current epoch id based on block timestamp\n    /// @return The current epoch id\n    function getCurrentEpochId() external view returns (uint256);\n\n    /// @notice Retrieve the current cl spec\n    /// @return The Consensus Layer Specification\n    function getCLSpec() external view returns (CLSpec.CLSpecStruct memory);\n\n    /// @notice Retrieve the current frame details\n    /// @return _startEpochId The epoch at the beginning of the frame\n    /// @return _startTime The timestamp of the beginning of the frame in seconds\n    /// @return _endTime The timestamp of the end of the frame in seconds\n    function getCurrentFrame() external view returns (uint256 _startEpochId, uint256 _startTime, uint256 _endTime);\n\n    /// @notice Retrieve the first epoch id of the frame of the provided epoch id\n    /// @param _epochId Epoch id used to get the frame\n    /// @return The first epoch id of the frame containing the given epoch id\n    function getFrameFirstEpochId(uint256 _epochId) external view returns (uint256);\n\n    /// @notice Retrieve the report bounds\n    /// @return The report bounds\n    function getReportBounds() external view returns (ReportBounds.ReportBoundsStruct memory);\n\n    /// @notice Retrieve the last consensus layer report\n    /// @return The stored consensus layer report\n    function getLastConsensusLayerReport() external view returns (IOracleManagerV1.StoredConsensusLayerReport memory);\n\n    /// @notice Set the oracle address\n    /// @param _oracleAddress Address of the oracle\n    function setOracle(address _oracleAddress) external;\n\n    /// @notice Set the consensus layer spec\n    /// @param _newValue The new consensus layer spec value\n    function setCLSpec(CLSpec.CLSpecStruct calldata _newValue) external;\n\n    /// @notice Set the report bounds\n    /// @param _newValue The new report bounds value\n    function setReportBounds(ReportBounds.ReportBoundsStruct calldata _newValue) external;\n\n    /// @notice Performs all the reporting logics\n    /// @param _report The consensus layer report structure\n    function setConsensusLayerData(ConsensusLayerReport calldata _report) external;\n}\n"
    },
    "contracts/src/interfaces/components/ISharesManager.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\n\n/// @title Shares Manager Interface (v1)\n/// @author Kiln\n/// @notice This interface exposes methods to handle the shares of the depositor and the ERC20 interface\ninterface ISharesManagerV1 is IERC20 {\n    /// @notice Emitted when the total supply is changed\n    event SetTotalSupply(uint256 totalSupply);\n\n    /// @notice Balance too low to perform operation\n    error BalanceTooLow();\n\n    /// @notice Allowance too low to perform operation\n    /// @param _from Account where funds are sent from\n    /// @param _operator Account attempting the transfer\n    /// @param _allowance Current allowance\n    /// @param _value Requested transfer value in shares\n    error AllowanceTooLow(address _from, address _operator, uint256 _allowance, uint256 _value);\n\n    /// @notice Invalid empty transfer\n    error NullTransfer();\n\n    /// @notice Invalid transfer recipients\n    /// @param _from Account sending the funds in the invalid transfer\n    /// @param _to Account receiving the funds in the invalid transfer\n    error UnauthorizedTransfer(address _from, address _to);\n\n    /// @notice Retrieve the token name\n    /// @return The token name\n    function name() external pure returns (string memory);\n\n    /// @notice Retrieve the token symbol\n    /// @return The token symbol\n    function symbol() external pure returns (string memory);\n\n    /// @notice Retrieve the decimal count\n    /// @return The decimal count\n    function decimals() external pure returns (uint8);\n\n    /// @notice Retrieve the total token supply\n    /// @return The total supply in shares\n    function totalSupply() external view returns (uint256);\n\n    /// @notice Retrieve the total underlying asset supply\n    /// @return The total underlying asset supply\n    function totalUnderlyingSupply() external view returns (uint256);\n\n    /// @notice Retrieve the balance of an account\n    /// @param _owner Address to be checked\n    /// @return The balance of the account in shares\n    function balanceOf(address _owner) external view returns (uint256);\n\n    /// @notice Retrieve the underlying asset balance of an account\n    /// @param _owner Address to be checked\n    /// @return The underlying balance of the account\n    function balanceOfUnderlying(address _owner) external view returns (uint256);\n\n    /// @notice Retrieve the underlying asset balance from an amount of shares\n    /// @param _shares Amount of shares to convert\n    /// @return The underlying asset balance represented by the shares\n    function underlyingBalanceFromShares(uint256 _shares) external view returns (uint256);\n\n    /// @notice Retrieve the shares count from an underlying asset amount\n    /// @param _underlyingAssetAmount Amount of underlying asset to convert\n    /// @return The amount of shares worth the underlying asset amopunt\n    function sharesFromUnderlyingBalance(uint256 _underlyingAssetAmount) external view returns (uint256);\n\n    /// @notice Retrieve the allowance value for a spender\n    /// @param _owner Address that issued the allowance\n    /// @param _spender Address that received the allowance\n    /// @return The allowance in shares for a given spender\n    function allowance(address _owner, address _spender) external view returns (uint256);\n\n    /// @notice Performs a transfer from the message sender to the provided account\n    /// @param _to Address receiving the tokens\n    /// @param _value Amount of shares to be sent\n    /// @return True if success\n    function transfer(address _to, uint256 _value) external returns (bool);\n\n    /// @notice Performs a transfer between two recipients\n    /// @param _from Address sending the tokens\n    /// @param _to Address receiving the tokens\n    /// @param _value Amount of shares to be sent\n    /// @return True if success\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\n\n    /// @notice Approves an account for future spendings\n    /// @dev An approved account can use transferFrom to transfer funds on behalf of the token owner\n    /// @param _spender Address that is allowed to spend the tokens\n    /// @param _value The allowed amount in shares, will override previous value\n    /// @return True if success\n    function approve(address _spender, uint256 _value) external returns (bool);\n\n    /// @notice Increase allowance to another account\n    /// @param _spender Spender that receives the allowance\n    /// @param _additionalValue Amount of shares to add\n    /// @return True if success\n    function increaseAllowance(address _spender, uint256 _additionalValue) external returns (bool);\n\n    /// @notice Decrease allowance to another account\n    /// @param _spender Spender that receives the allowance\n    /// @param _subtractableValue Amount of shares to subtract\n    /// @return True if success\n    function decreaseAllowance(address _spender, uint256 _subtractableValue) external returns (bool);\n}\n"
    },
    "contracts/src/interfaces/components/IUserDepositManager.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\n/// @title User Deposit Manager (v1)\n/// @author Kiln\n/// @notice This interface exposes methods to handle the inbound transfers cases or the explicit submissions\ninterface IUserDepositManagerV1 {\n    /// @notice User deposited ETH in the system\n    /// @param depositor Address performing the deposit\n    /// @param recipient Address receiving the minted shares\n    /// @param amount Amount in ETH deposited\n    event UserDeposit(address indexed depositor, address indexed recipient, uint256 amount);\n\n    /// @notice And empty deposit attempt was made\n    error EmptyDeposit();\n\n    /// @notice Explicit deposit method to mint on msg.sender\n    function deposit() external payable;\n\n    /// @notice Explicit deposit method to mint on msg.sender and transfer to _recipient\n    /// @param _recipient Address receiving the minted LsETH\n    function depositAndTransfer(address _recipient) external payable;\n\n    /// @notice Implicit deposit method, when the user performs a regular transfer to the contract\n    receive() external payable;\n\n    /// @notice Invalid call, when the user sends a transaction with a data payload but no method matched\n    fallback() external payable;\n}\n"
    },
    "contracts/src/libraries/LibAdministrable.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"../state/shared/AdministratorAddress.sol\";\nimport \"../state/shared/PendingAdministratorAddress.sol\";\n\n/// @title Lib Administrable\n/// @author Kiln\n/// @notice This library handles the admin and pending admin storage vars\nlibrary LibAdministrable {\n    /// @notice Retrieve the system admin\n    /// @return The address of the system admin\n    function _getAdmin() internal view returns (address) {\n        return AdministratorAddress.get();\n    }\n\n    /// @notice Retrieve the pending system admin\n    /// @return The adress of the pending system admin\n    function _getPendingAdmin() internal view returns (address) {\n        return PendingAdministratorAddress.get();\n    }\n\n    /// @notice Sets the system admin\n    /// @param _admin New system admin\n    function _setAdmin(address _admin) internal {\n        AdministratorAddress.set(_admin);\n    }\n\n    /// @notice Sets the pending system admin\n    /// @param _pendingAdmin New pending system admin\n    function _setPendingAdmin(address _pendingAdmin) internal {\n        PendingAdministratorAddress.set(_pendingAdmin);\n    }\n}\n"
    },
    "contracts/src/libraries/LibBasisPoints.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\n/// @title Lib Basis Points\n/// @notice Holds the basis points max value\nlibrary LibBasisPoints {\n    /// @notice The max value for basis points (represents 100%)\n    uint256 internal constant BASIS_POINTS_MAX = 10_000;\n}\n"
    },
    "contracts/src/libraries/LibErrors.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\n/// @title Lib Errors\n/// @notice Library of common errors\nlibrary LibErrors {\n    /// @notice The operator is unauthorized for the caller\n    /// @param caller Address performing the call\n    error Unauthorized(address caller);\n\n    /// @notice The call was invalid\n    error InvalidCall();\n\n    /// @notice The argument was invalid\n    error InvalidArgument();\n\n    /// @notice The address is zero\n    error InvalidZeroAddress();\n\n    /// @notice The string is empty\n    error InvalidEmptyString();\n\n    /// @notice The fee is invalid\n    error InvalidFee();\n}\n"
    },
    "contracts/src/libraries/LibSanitize.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"./LibErrors.sol\";\nimport \"./LibBasisPoints.sol\";\n\n/// @title Lib Sanitize\n/// @notice Utilities to sanitize input values\nlibrary LibSanitize {\n    /// @notice Reverts if address is 0\n    /// @param _address Address to check\n    function _notZeroAddress(address _address) internal pure {\n        if (_address == address(0)) {\n            revert LibErrors.InvalidZeroAddress();\n        }\n    }\n\n    /// @notice Reverts if string is empty\n    /// @param _string String to check\n    function _notEmptyString(string memory _string) internal pure {\n        if (bytes(_string).length == 0) {\n            revert LibErrors.InvalidEmptyString();\n        }\n    }\n\n    /// @notice Reverts if fee is invalid\n    /// @param _fee Fee to check\n    function _validFee(uint256 _fee) internal pure {\n        if (_fee \u003e LibBasisPoints.BASIS_POINTS_MAX) {\n            revert LibErrors.InvalidFee();\n        }\n    }\n}\n"
    },
    "contracts/src/libraries/LibUnstructuredStorage.sol": {
      "content": "// SPDX-License-Identifier:    MIT\n\npragma solidity 0.8.10;\n\n/// @title Lib Unstructured Storage\n/// @notice Utilities to work with unstructured storage\nlibrary LibUnstructuredStorage {\n    /// @notice Retrieve a bool value at a storage slot\n    /// @param _position The storage slot to retrieve\n    /// @return data The bool value\n    function getStorageBool(bytes32 _position) internal view returns (bool data) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            data := sload(_position)\n        }\n    }\n\n    /// @notice Retrieve an address value at a storage slot\n    /// @param _position The storage slot to retrieve\n    /// @return data The address value\n    function getStorageAddress(bytes32 _position) internal view returns (address data) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            data := sload(_position)\n        }\n    }\n\n    /// @notice Retrieve a bytes32 value at a storage slot\n    /// @param _position The storage slot to retrieve\n    /// @return data The bytes32 value\n    function getStorageBytes32(bytes32 _position) internal view returns (bytes32 data) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            data := sload(_position)\n        }\n    }\n\n    /// @notice Retrieve an uint256 value at a storage slot\n    /// @param _position The storage slot to retrieve\n    /// @return data The uint256 value\n    function getStorageUint256(bytes32 _position) internal view returns (uint256 data) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            data := sload(_position)\n        }\n    }\n\n    /// @notice Sets a bool value at a storage slot\n    /// @param _position The storage slot to set\n    /// @param _data The bool value to set\n    function setStorageBool(bytes32 _position, bool _data) internal {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(_position, _data)\n        }\n    }\n\n    /// @notice Sets an address value at a storage slot\n    /// @param _position The storage slot to set\n    /// @param _data The address value to set\n    function setStorageAddress(bytes32 _position, address _data) internal {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(_position, _data)\n        }\n    }\n\n    /// @notice Sets a bytes32 value at a storage slot\n    /// @param _position The storage slot to set\n    /// @param _data The bytes32 value to set\n    function setStorageBytes32(bytes32 _position, bytes32 _data) internal {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(_position, _data)\n        }\n    }\n\n    /// @notice Sets an uint256 value at a storage slot\n    /// @param _position The storage slot to set\n    /// @param _data The uint256 value to set\n    function setStorageUint256(bytes32 _position, uint256 _data) internal {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(_position, _data)\n        }\n    }\n}\n"
    },
    "contracts/src/state/oracle/LastEpochId.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\n\n/// @title Last Epoch Id Storage\n/// @notice Utility to manage the Last Epoch Id in storage\nlibrary LastEpochId {\n    /// @notice Storage slot of the Last Epoch Id\n    bytes32 internal constant LAST_EPOCH_ID_SLOT = bytes32(uint256(keccak256(\"river.state.lastEpochId\")) - 1);\n\n    /// @notice Retrieve the Last Epoch Id\n    /// @return The Last Epoch Id\n    function get() internal view returns (uint256) {\n        return LibUnstructuredStorage.getStorageUint256(LAST_EPOCH_ID_SLOT);\n    }\n\n    /// @notice Sets the Last Epoch Id\n    /// @param _newValue New Last Epoch Id\n    function set(uint256 _newValue) internal {\n        LibUnstructuredStorage.setStorageUint256(LAST_EPOCH_ID_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/oracle/OracleMembers.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibSanitize.sol\";\n\n/// @title Oracle Members Storage\n/// @notice Utility to manage the Oracle Members in storage\n/// @dev There can only be up to 256 oracle members. This is due to how report statuses are stored in Reports Positions\nlibrary OracleMembers {\n    /// @notice Storage slot of the Oracle Members\n    bytes32 internal constant ORACLE_MEMBERS_SLOT = bytes32(uint256(keccak256(\"river.state.oracleMembers\")) - 1);\n\n    /// @notice The structure in storage\n    struct Slot {\n        /// @custom:attribute The array of oracle members\n        address[] value;\n    }\n\n    /// @notice Retrieve the list of oracle members\n    /// @return List of oracle members\n    function get() internal view returns (address[] memory) {\n        bytes32 slot = ORACLE_MEMBERS_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value;\n    }\n\n    /// @notice Add a new oracle member to the list\n    /// @param _newOracleMember Address of the new oracle member\n    function push(address _newOracleMember) internal {\n        LibSanitize._notZeroAddress(_newOracleMember);\n\n        bytes32 slot = ORACLE_MEMBERS_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        r.value.push(_newOracleMember);\n    }\n\n    /// @notice Set an address in the oracle member list\n    /// @param _index The index to edit\n    /// @param _newOracleAddress The new value of the oracle member\n    function set(uint256 _index, address _newOracleAddress) internal {\n        bytes32 slot = ORACLE_MEMBERS_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        r.value[_index] = _newOracleAddress;\n    }\n\n    /// @notice Retrieve the index of the oracle member\n    /// @param _memberAddress The address to lookup\n    /// @return The index of the member, -1 if not found\n    function indexOf(address _memberAddress) internal view returns (int256) {\n        bytes32 slot = ORACLE_MEMBERS_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        for (uint256 idx = 0; idx \u003c r.value.length;) {\n            if (r.value[idx] == _memberAddress) {\n                return int256(idx);\n            }\n            unchecked {\n                ++idx;\n            }\n        }\n\n        return int256(-1);\n    }\n\n    /// @notice Delete the oracle member at the given index\n    /// @param _idx The index of the member to remove\n    function deleteItem(uint256 _idx) internal {\n        bytes32 slot = ORACLE_MEMBERS_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        uint256 lastIdx = r.value.length - 1;\n        if (lastIdx != _idx) {\n            r.value[_idx] = r.value[lastIdx];\n        }\n\n        r.value.pop();\n    }\n}\n"
    },
    "contracts/src/state/oracle/Quorum.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\n\n/// @title Quorum Storage\n/// @notice Utility to manage the Quorum in storage\nlibrary Quorum {\n    /// @notice Storage slot of the Quorum\n    bytes32 internal constant QUORUM_SLOT = bytes32(uint256(keccak256(\"river.state.quorum\")) - 1);\n\n    /// @notice Retrieve the Quorum\n    /// @return The Quorum\n    function get() internal view returns (uint256) {\n        return LibUnstructuredStorage.getStorageUint256(QUORUM_SLOT);\n    }\n\n    /// @notice Sets the Quorum\n    /// @param _newValue New Quorum\n    function set(uint256 _newValue) internal {\n        return LibUnstructuredStorage.setStorageUint256(QUORUM_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/oracle/ReportsPositions.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\n\n/// @title Reports Positions Storage\n/// @notice Utility to manage the Reports Positions in storage\n/// @dev Each bit in the stored uint256 value tells if the member at a given index has reported\nlibrary ReportsPositions {\n    /// @notice Storage slot of the Reports Positions\n    bytes32 internal constant REPORTS_POSITIONS_SLOT = bytes32(uint256(keccak256(\"river.state.reportsPositions\")) - 1);\n\n    /// @notice Retrieve the Reports Positions at index\n    /// @param _idx The index to retrieve\n    /// @return True if already reported\n    function get(uint256 _idx) internal view returns (bool) {\n        uint256 mask = 1 \u003c\u003c _idx;\n        return LibUnstructuredStorage.getStorageUint256(REPORTS_POSITIONS_SLOT) \u0026 mask == mask;\n    }\n\n    /// @notice Retrieve the raw Reports Positions from storage\n    /// @return Raw Reports Positions\n    function getRaw() internal view returns (uint256) {\n        return LibUnstructuredStorage.getStorageUint256(REPORTS_POSITIONS_SLOT);\n    }\n\n    /// @notice Register an index as reported\n    /// @param _idx The index to register\n    function register(uint256 _idx) internal {\n        uint256 mask = 1 \u003c\u003c _idx;\n        return LibUnstructuredStorage.setStorageUint256(\n            REPORTS_POSITIONS_SLOT, LibUnstructuredStorage.getStorageUint256(REPORTS_POSITIONS_SLOT) | mask\n        );\n    }\n\n    /// @notice Clears all the report positions in storage\n    function clear() internal {\n        return LibUnstructuredStorage.setStorageUint256(REPORTS_POSITIONS_SLOT, 0);\n    }\n}\n"
    },
    "contracts/src/state/oracle/ReportsVariants.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\n/// @title Reports Variants Storage\n/// @notice Utility to manage the Reports Variants in storage\nlibrary ReportsVariants {\n    /// @notice Storage slot of the Reports Variants\n    bytes32 internal constant REPORT_VARIANTS_SLOT = bytes32(uint256(keccak256(\"river.state.reportsVariants\")) - 1);\n\n    struct ReportVariantDetails {\n        bytes32 variant;\n        uint256 votes;\n    }\n\n    /// @notice Structure in storage\n    struct Slot {\n        /// @custom:attribute The list of variants\n        ReportVariantDetails[] value;\n    }\n\n    /// @notice Retrieve the Reports Variants from storage\n    /// @return The Reports Variants\n    function get() internal view returns (ReportVariantDetails[] storage) {\n        bytes32 slot = REPORT_VARIANTS_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value;\n    }\n\n    /// @notice Set the Reports Variants value at index\n    /// @param _idx The index to set\n    /// @param _val The value to set\n    function set(uint256 _idx, ReportVariantDetails memory _val) internal {\n        bytes32 slot = REPORT_VARIANTS_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        r.value[_idx] = _val;\n    }\n\n    /// @notice Add a new variant in the list\n    /// @param _variant The new variant to add\n    function push(ReportVariantDetails memory _variant) internal {\n        bytes32 slot = REPORT_VARIANTS_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        r.value.push(_variant);\n    }\n\n    /// @notice Retrieve the index of a specific variant, ignoring the count field\n    /// @param _variant Variant value to lookup\n    /// @return The index of the variant, -1 if not found\n    function indexOfReport(bytes32 _variant) internal view returns (int256) {\n        bytes32 slot = REPORT_VARIANTS_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        for (uint256 idx = 0; idx \u003c r.value.length;) {\n            if (r.value[idx].variant == _variant) {\n                return int256(idx);\n            }\n            unchecked {\n                ++idx;\n            }\n        }\n\n        return int256(-1);\n    }\n\n    /// @notice Clear all variants from storage\n    function clear() internal {\n        bytes32 slot = REPORT_VARIANTS_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        delete r.value;\n    }\n}\n"
    },
    "contracts/src/state/river/CLSpec.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\n/// @title Consensus Layer Spec Storage\n/// @notice Utility to manage the Consensus Layer Spec in storage\nlibrary CLSpec {\n    /// @notice Storage slot of the Consensus Layer Spec\n    bytes32 internal constant CL_SPEC_SLOT = bytes32(uint256(keccak256(\"river.state.clSpec\")) - 1);\n\n    /// @notice The Consensus Layer Spec structure\n    struct CLSpecStruct {\n        /// @custom:attribute The count of epochs per frame, 225 means 24h\n        uint64 epochsPerFrame;\n        /// @custom:attribute The count of slots in an epoch (32 on mainnet)\n        uint64 slotsPerEpoch;\n        /// @custom:attribute The seconds in a slot (12 on mainnet)\n        uint64 secondsPerSlot;\n        /// @custom:attribute The block timestamp of the first consensus layer block\n        uint64 genesisTime;\n        /// @custom:attribute The count of epochs before considering an epoch final on-chain\n        uint64 epochsToAssumedFinality;\n    }\n\n    /// @notice The structure in storage\n    struct Slot {\n        /// @custom:attribute The structure in storage\n        CLSpecStruct value;\n    }\n\n    /// @notice Retrieve the Consensus Layer Spec from storage\n    /// @return The Consensus Layer Spec\n    function get() internal view returns (CLSpecStruct memory) {\n        bytes32 slot = CL_SPEC_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value;\n    }\n\n    /// @notice Set the Consensus Layer Spec value in storage\n    /// @param _newCLSpec The new value to set in storage\n    function set(CLSpecStruct memory _newCLSpec) internal {\n        bytes32 slot = CL_SPEC_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        r.value = _newCLSpec;\n    }\n}\n"
    },
    "contracts/src/state/river/DailyCommittableLimits.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibSanitize.sol\";\n\n/// @title Daily Committable Limits storage\n/// @notice Utility to manage the Daily Committable Limits in storage\nlibrary DailyCommittableLimits {\n    /// @notice Storage slot of the Daily Committable Limits storage\n    bytes32 internal constant DAILY_COMMITTABLE_LIMITS_SLOT =\n        bytes32(uint256(keccak256(\"river.state.dailyCommittableLimits\")) - 1);\n\n    /// @notice The daily committable limits structure\n    struct DailyCommittableLimitsStruct {\n        uint128 minDailyNetCommittableAmount;\n        uint128 maxDailyRelativeCommittableAmount;\n    }\n\n    /// @notice The structure in storage\n    struct Slot {\n        /// @custom:attribute The structure in storage\n        DailyCommittableLimitsStruct value;\n    }\n\n    /// @notice Retrieve the Daily Committable Limits from storage\n    /// @return The Daily Committable Limits\n    function get() internal view returns (DailyCommittableLimitsStruct memory) {\n        bytes32 slot = DAILY_COMMITTABLE_LIMITS_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value;\n    }\n\n    /// @notice Set the Daily Committable Limits value in storage\n    /// @param _newValue The new value to set in storage\n    function set(DailyCommittableLimitsStruct memory _newValue) internal {\n        bytes32 slot = DAILY_COMMITTABLE_LIMITS_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        r.value = _newValue;\n    }\n}\n"
    },
    "contracts/src/state/river/ReportBounds.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\n/// @title Report Bounds Storage\n/// @notice Utility to manage the Report Bounds in storage\nlibrary ReportBounds {\n    /// @notice Storage slot of the Report Bounds\n    bytes32 internal constant REPORT_BOUNDS_SLOT = bytes32(uint256(keccak256(\"river.state.reportBounds\")) - 1);\n\n    /// @notice The Report Bounds structure\n    struct ReportBoundsStruct {\n        /// @custom:attribute The maximum allowed annual apr, checked before submitting a report to River\n        uint256 annualAprUpperBound;\n        /// @custom:attribute The maximum allowed balance decrease, also checked before submitting a report to River\n        uint256 relativeLowerBound;\n    }\n\n    /// @notice The structure in storage\n    struct Slot {\n        /// @custom:attribute The structure in storage\n        ReportBoundsStruct value;\n    }\n\n    /// @notice Retrieve the Report Bounds from storage\n    /// @return The Report Bounds\n    function get() internal view returns (ReportBoundsStruct memory) {\n        bytes32 slot = REPORT_BOUNDS_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value;\n    }\n\n    /// @notice Set the Report Bounds in storage\n    /// @param _newReportBounds The new Report Bounds value\n    function set(ReportBoundsStruct memory _newReportBounds) internal {\n        bytes32 slot = REPORT_BOUNDS_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        r.value = _newReportBounds;\n    }\n}\n"
    },
    "contracts/src/state/shared/AdministratorAddress.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\nimport \"../../libraries/LibSanitize.sol\";\n\n/// @title Administrator Address Storage\n/// @notice Utility to manage the Administrator Address in storage\nlibrary AdministratorAddress {\n    /// @notice Storage slot of the Administrator Address\n    bytes32 public constant ADMINISTRATOR_ADDRESS_SLOT =\n        bytes32(uint256(keccak256(\"river.state.administratorAddress\")) - 1);\n\n    /// @notice Retrieve the Administrator Address\n    /// @return The Administrator Address\n    function get() internal view returns (address) {\n        return LibUnstructuredStorage.getStorageAddress(ADMINISTRATOR_ADDRESS_SLOT);\n    }\n\n    /// @notice Sets the Administrator Address\n    /// @param _newValue New Administrator Address\n    function set(address _newValue) internal {\n        LibSanitize._notZeroAddress(_newValue);\n        LibUnstructuredStorage.setStorageAddress(ADMINISTRATOR_ADDRESS_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/shared/PendingAdministratorAddress.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\n\n/// @title Pending Administrator Address Storage\n/// @notice Utility to manage the Pending Administrator Address in storage\nlibrary PendingAdministratorAddress {\n    /// @notice Storage slot of the Pending Administrator Address\n    bytes32 public constant PENDING_ADMINISTRATOR_ADDRESS_SLOT =\n        bytes32(uint256(keccak256(\"river.state.pendingAdministratorAddress\")) - 1);\n\n    /// @notice Retrieve the Pending Administrator Address\n    /// @return The Pending Administrator Address\n    function get() internal view returns (address) {\n        return LibUnstructuredStorage.getStorageAddress(PENDING_ADMINISTRATOR_ADDRESS_SLOT);\n    }\n\n    /// @notice Sets the Pending Administrator Address\n    /// @param _newValue New Pending Administrator Address\n    function set(address _newValue) internal {\n        LibUnstructuredStorage.setStorageAddress(PENDING_ADMINISTRATOR_ADDRESS_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/shared/RiverAddress.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibSanitize.sol\";\nimport \"../../libraries/LibUnstructuredStorage.sol\";\n\n/// @title River Address Storage\n/// @notice Utility to manage the River Address in storage\nlibrary RiverAddress {\n    /// @notice Storage slot of the River Address\n    bytes32 internal constant RIVER_ADDRESS_SLOT = bytes32(uint256(keccak256(\"river.state.riverAddress\")) - 1);\n\n    /// @notice Retrieve the River Address\n    /// @return The River Address\n    function get() internal view returns (address) {\n        return LibUnstructuredStorage.getStorageAddress(RIVER_ADDRESS_SLOT);\n    }\n\n    /// @notice Sets the River Address\n    /// @param _newValue New River Address\n    function set(address _newValue) internal {\n        LibSanitize._notZeroAddress(_newValue);\n        LibUnstructuredStorage.setStorageAddress(RIVER_ADDRESS_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/shared/Version.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\n\n/// @title Version Storage\n/// @notice Utility to manage the Version in storage\nlibrary Version {\n    /// @notice Storage slot of the Version\n    bytes32 public constant VERSION_SLOT = bytes32(uint256(keccak256(\"river.state.version\")) - 1);\n\n    /// @notice Retrieve the Version\n    /// @return The Version\n    function get() internal view returns (uint256) {\n        return LibUnstructuredStorage.getStorageUint256(VERSION_SLOT);\n    }\n\n    /// @notice Sets the Version\n    /// @param _newValue New Version\n    function set(uint256 _newValue) internal {\n        LibUnstructuredStorage.setStorageUint256(VERSION_SLOT, _newValue);\n    }\n}\n"
    },
    "openzeppelin-contracts/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    }
  }
}