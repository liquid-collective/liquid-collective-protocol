{
  "language": "Solidity",
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 100
    }
  },
  "sources": {
    "contracts/src/Administrable.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"./interfaces/IAdministrable.sol\";\n\nimport \"./libraries/LibAdministrable.sol\";\nimport \"./libraries/LibSanitize.sol\";\n\n/// @title Administrable\n/// @author Kiln\n/// @notice This contract handles the administration of the contracts\nabstract contract Administrable is IAdministrable {\n    /// @notice Prevents unauthorized calls\n    modifier onlyAdmin() {\n        if (msg.sender != LibAdministrable._getAdmin()) {\n            revert LibErrors.Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    /// @notice Prevents unauthorized calls\n    modifier onlyPendingAdmin() {\n        if (msg.sender != LibAdministrable._getPendingAdmin()) {\n            revert LibErrors.Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    /// @inheritdoc IAdministrable\n    function getAdmin() external view returns (address) {\n        return LibAdministrable._getAdmin();\n    }\n\n    /// @inheritdoc IAdministrable\n    function getPendingAdmin() external view returns (address) {\n        return LibAdministrable._getPendingAdmin();\n    }\n\n    /// @inheritdoc IAdministrable\n    function proposeAdmin(address _newAdmin) external onlyAdmin {\n        _setPendingAdmin(_newAdmin);\n    }\n\n    /// @inheritdoc IAdministrable\n    function acceptAdmin() external onlyPendingAdmin {\n        _setAdmin(LibAdministrable._getPendingAdmin());\n        _setPendingAdmin(address(0));\n    }\n\n    /// @notice Internal utility to set the admin address\n    /// @param _admin Address to set as admin\n    function _setAdmin(address _admin) internal {\n        LibSanitize._notZeroAddress(_admin);\n        LibAdministrable._setAdmin(_admin);\n        emit SetAdmin(_admin);\n    }\n\n    /// @notice Internal utility to set the pending admin address\n    /// @param _pendingAdmin Address to set as pending admin\n    function _setPendingAdmin(address _pendingAdmin) internal {\n        LibAdministrable._setPendingAdmin(_pendingAdmin);\n        emit SetPendingAdmin(_pendingAdmin);\n    }\n\n    /// @notice Internal utility to retrieve the address of the current admin\n    /// @return The address of admin\n    function _getAdmin() internal view returns (address) {\n        return LibAdministrable._getAdmin();\n    }\n}\n"
    },
    "contracts/src/Initializable.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"./state/shared/Version.sol\";\n\n/// @title Initializable\n/// @author Kiln\n/// @notice This contract ensures that initializers are called only once per version\ncontract Initializable {\n    /// @notice Disable initialization on implementations\n    constructor() {\n        Version.set(type(uint256).max);\n        emit Initialize(type(uint256).max, msg.data);\n    }\n\n    /// @notice An error occured during the initialization\n    /// @param version The version that was attempting to be initialized\n    /// @param expectedVersion The version that was expected\n    error InvalidInitialization(uint256 version, uint256 expectedVersion);\n\n    /// @notice Emitted when the contract is properly initialized\n    /// @param version New version of the contracts\n    /// @param cdata Complete calldata that was used during the initialization\n    event Initialize(uint256 version, bytes cdata);\n\n    /// @notice Use this modifier on initializers along with a hard-coded version number\n    /// @param _version Version to initialize\n    modifier init(uint256 _version) {\n        if (_version != Version.get()) {\n            revert InvalidInitialization(_version, Version.get());\n        }\n        Version.set(_version + 1); // prevents reentrency on the called method\n        _;\n        emit Initialize(_version, msg.data);\n    }\n}\n"
    },
    "contracts/src/River.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"./interfaces/IAllowlist.1.sol\";\nimport \"./interfaces/IOperatorRegistry.1.sol\";\nimport \"./interfaces/IRiver.1.sol\";\nimport \"./interfaces/IWithdraw.1.sol\";\nimport \"./interfaces/IELFeeRecipient.1.sol\";\nimport \"./interfaces/ICoverageFund.1.sol\";\n\nimport \"./components/ConsensusLayerDepositManager.1.sol\";\nimport \"./components/UserDepositManager.1.sol\";\nimport \"./components/SharesManager.1.sol\";\nimport \"./components/OracleManager.1.sol\";\nimport \"./Initializable.sol\";\nimport \"./Administrable.sol\";\n\nimport \"./libraries/LibAllowlistMasks.sol\";\n\nimport \"./state/river/AllowlistAddress.sol\";\nimport \"./state/river/RedeemManagerAddress.sol\";\nimport \"./state/river/OperatorsRegistryAddress.sol\";\nimport \"./state/river/CollectorAddress.sol\";\nimport \"./state/river/ELFeeRecipientAddress.sol\";\nimport \"./state/river/CoverageFundAddress.sol\";\nimport \"./state/river/BalanceToRedeem.sol\";\nimport \"./state/river/GlobalFee.sol\";\nimport \"./state/river/MetadataURI.sol\";\nimport \"./state/river/LastConsensusLayerReport.sol\";\n\n/// @title River (v1)\n/// @author Kiln\n/// @notice This contract merges all the manager contracts and implements all the virtual methods stitching all components together\ncontract RiverV1 is\n    ConsensusLayerDepositManagerV1,\n    UserDepositManagerV1,\n    SharesManagerV1,\n    OracleManagerV1,\n    Initializable,\n    Administrable,\n    IRiverV1\n{\n    /// @inheritdoc IRiverV1\n    function initRiverV1(\n        address _depositContractAddress,\n        address _elFeeRecipientAddress,\n        bytes32 _withdrawalCredentials,\n        address _oracleAddress,\n        address _systemAdministratorAddress,\n        address _allowlistAddress,\n        address _operatorRegistryAddress,\n        address _collectorAddress,\n        uint256 _globalFee\n    ) external init(0) {\n        _setAdmin(_systemAdministratorAddress);\n\n        CollectorAddress.set(_collectorAddress);\n        emit SetCollector(_collectorAddress);\n\n        GlobalFee.set(_globalFee);\n        emit SetGlobalFee(_globalFee);\n\n        ELFeeRecipientAddress.set(_elFeeRecipientAddress);\n        emit SetELFeeRecipient(_elFeeRecipientAddress);\n\n        AllowlistAddress.set(_allowlistAddress);\n        emit SetAllowlist(_allowlistAddress);\n\n        OperatorsRegistryAddress.set(_operatorRegistryAddress);\n        emit SetOperatorsRegistry(_operatorRegistryAddress);\n\n        ConsensusLayerDepositManagerV1.initConsensusLayerDepositManagerV1(\n            _depositContractAddress, _withdrawalCredentials\n        );\n\n        OracleManagerV1.initOracleManagerV1(_oracleAddress);\n    }\n\n    /// @inheritdoc IRiverV1\n    function initRiverV1_1(\n        address _redeemManager,\n        uint64 _epochsPerFrame,\n        uint64 _slotsPerEpoch,\n        uint64 _secondsPerSlot,\n        uint64 _genesisTime,\n        uint64 _epochsToAssumedFinality,\n        uint256 _annualAprUpperBound,\n        uint256 _relativeLowerBound,\n        uint128 _minDailyNetCommittableAmount_,\n        uint128 _maxDailyRelativeCommittableAmount_\n    ) external init(1) {\n        RedeemManagerAddress.set(_redeemManager);\n        emit SetRedeemManager(_redeemManager);\n\n        _setDailyCommittableLimits(\n            DailyCommittableLimits.DailyCommittableLimitsStruct({\n                minDailyNetCommittableAmount: _minDailyNetCommittableAmount_,\n                maxDailyRelativeCommittableAmount: _maxDailyRelativeCommittableAmount_\n            })\n        );\n\n        initOracleManagerV1_1(\n            _epochsPerFrame,\n            _slotsPerEpoch,\n            _secondsPerSlot,\n            _genesisTime,\n            _epochsToAssumedFinality,\n            _annualAprUpperBound,\n            _relativeLowerBound\n        );\n\n        _approve(address(this), _redeemManager, type(uint256).max);\n    }\n\n    /// @inheritdoc IRiverV1\n    function getGlobalFee() external view returns (uint256) {\n        return GlobalFee.get();\n    }\n\n    /// @inheritdoc IRiverV1\n    function getAllowlist() external view returns (address) {\n        return AllowlistAddress.get();\n    }\n\n    /// @inheritdoc IRiverV1\n    function getCollector() external view returns (address) {\n        return CollectorAddress.get();\n    }\n\n    /// @inheritdoc IRiverV1\n    function getELFeeRecipient() external view returns (address) {\n        return ELFeeRecipientAddress.get();\n    }\n\n    /// @inheritdoc IRiverV1\n    function getCoverageFund() external view returns (address) {\n        return CoverageFundAddress.get();\n    }\n\n    /// @inheritdoc IRiverV1\n    function getRedeemManager() external view returns (address) {\n        return RedeemManagerAddress.get();\n    }\n\n    /// @inheritdoc IRiverV1\n    function getMetadataURI() external view returns (string memory) {\n        return MetadataURI.get();\n    }\n\n    /// @inheritdoc IRiverV1\n    function getDailyCommittableLimits()\n        external\n        view\n        returns (DailyCommittableLimits.DailyCommittableLimitsStruct memory)\n    {\n        return DailyCommittableLimits.get();\n    }\n\n    /// @inheritdoc IRiverV1\n    function setDailyCommittableLimits(DailyCommittableLimits.DailyCommittableLimitsStruct memory _dcl)\n        external\n        onlyAdmin\n    {\n        _setDailyCommittableLimits(_dcl);\n    }\n\n    /// @inheritdoc IRiverV1\n    function getBalanceToRedeem() external view returns (uint256) {\n        return BalanceToRedeem.get();\n    }\n\n    /// @inheritdoc IRiverV1\n    function resolveRedeemRequests(uint32[] calldata _redeemRequestIds)\n        external\n        view\n        returns (int64[] memory withdrawalEventIds)\n    {\n        return IRedeemManagerV1(RedeemManagerAddress.get()).resolveRedeemRequests(_redeemRequestIds);\n    }\n\n    /// @inheritdoc IRiverV1\n    function requestRedeem(uint256 _lsETHAmount, address _recipient) external returns (uint32 _redeemRequestId) {\n        IAllowlistV1(AllowlistAddress.get()).onlyAllowed(msg.sender, LibAllowlistMasks.REDEEM_MASK);\n        _transfer(msg.sender, address(this), _lsETHAmount);\n        return IRedeemManagerV1(RedeemManagerAddress.get()).requestRedeem(_lsETHAmount, _recipient);\n    }\n\n    /// @inheritdoc IRiverV1\n    function claimRedeemRequests(uint32[] calldata _redeemRequestIds, uint32[] calldata _withdrawalEventIds)\n        external\n        returns (uint8[] memory claimStatuses)\n    {\n        return IRedeemManagerV1(RedeemManagerAddress.get()).claimRedeemRequests(\n            _redeemRequestIds, _withdrawalEventIds, true, type(uint16).max\n        );\n    }\n\n    /// @inheritdoc IRiverV1\n    function setGlobalFee(uint256 _newFee) external onlyAdmin {\n        GlobalFee.set(_newFee);\n        emit SetGlobalFee(_newFee);\n    }\n\n    /// @inheritdoc IRiverV1\n    function setAllowlist(address _newAllowlist) external onlyAdmin {\n        AllowlistAddress.set(_newAllowlist);\n        emit SetAllowlist(_newAllowlist);\n    }\n\n    /// @inheritdoc IRiverV1\n    function setCollector(address _newCollector) external onlyAdmin {\n        CollectorAddress.set(_newCollector);\n        emit SetCollector(_newCollector);\n    }\n\n    /// @inheritdoc IRiverV1\n    function setELFeeRecipient(address _newELFeeRecipient) external onlyAdmin {\n        ELFeeRecipientAddress.set(_newELFeeRecipient);\n        emit SetELFeeRecipient(_newELFeeRecipient);\n    }\n\n    /// @inheritdoc IRiverV1\n    function setCoverageFund(address _newCoverageFund) external onlyAdmin {\n        CoverageFundAddress.set(_newCoverageFund);\n        emit SetCoverageFund(_newCoverageFund);\n    }\n\n    /// @inheritdoc IRiverV1\n    function setMetadataURI(string memory _metadataURI) external onlyAdmin {\n        LibSanitize._notEmptyString(_metadataURI);\n        MetadataURI.set(_metadataURI);\n        emit SetMetadataURI(_metadataURI);\n    }\n\n    /// @inheritdoc IRiverV1\n    function getOperatorsRegistry() external view returns (address) {\n        return OperatorsRegistryAddress.get();\n    }\n\n    /// @inheritdoc IRiverV1\n    function sendELFees() external payable {\n        if (msg.sender != ELFeeRecipientAddress.get()) {\n            revert LibErrors.Unauthorized(msg.sender);\n        }\n    }\n\n    /// @inheritdoc IRiverV1\n    function sendCLFunds() external payable {\n        if (msg.sender != WithdrawalCredentials.getAddress()) {\n            revert LibErrors.Unauthorized(msg.sender);\n        }\n    }\n\n    /// @inheritdoc IRiverV1\n    function sendCoverageFunds() external payable {\n        if (msg.sender != CoverageFundAddress.get()) {\n            revert LibErrors.Unauthorized(msg.sender);\n        }\n    }\n\n    /// @inheritdoc IRiverV1\n    function sendRedeemManagerExceedingFunds() external payable {\n        if (msg.sender != RedeemManagerAddress.get()) {\n            revert LibErrors.Unauthorized(msg.sender);\n        }\n    }\n\n    /// @notice Overridden handler to pass the system admin inside components\n    /// @return The address of the admin\n    function _getRiverAdmin()\n        internal\n        view\n        override(OracleManagerV1, ConsensusLayerDepositManagerV1)\n        returns (address)\n    {\n        return Administrable._getAdmin();\n    }\n\n    /// @notice Overridden handler called whenever a token transfer is triggered\n    /// @param _from Token sender\n    /// @param _to Token receiver\n    function _onTransfer(address _from, address _to) internal view override {\n        IAllowlistV1 allowlist = IAllowlistV1(AllowlistAddress.get());\n        if (allowlist.isDenied(_from)) {\n            revert Denied(_from);\n        }\n        if (allowlist.isDenied(_to)) {\n            revert Denied(_to);\n        }\n    }\n\n    /// @notice Overridden handler called whenever a user deposits ETH to the system. Mints the adequate amount of shares.\n    /// @param _depositor User address that made the deposit\n    /// @param _amount Amount of ETH deposited\n    function _onDeposit(address _depositor, address _recipient, uint256 _amount) internal override {\n        uint256 mintedShares = SharesManagerV1._mintShares(_depositor, _amount);\n        IAllowlistV1 allowlist = IAllowlistV1(AllowlistAddress.get());\n        if (_depositor == _recipient) {\n            allowlist.onlyAllowed(_depositor, LibAllowlistMasks.DEPOSIT_MASK); // this call reverts if unauthorized or denied\n        } else {\n            allowlist.onlyAllowed(_depositor, LibAllowlistMasks.DEPOSIT_MASK); // this call reverts if unauthorized or denied\n            if (allowlist.isDenied(_recipient)) {\n                revert Denied(_recipient);\n            }\n            _transfer(_depositor, _recipient, mintedShares);\n        }\n    }\n\n    /// @notice Overridden handler called whenever a deposit to the consensus layer is made. Should retrieve _requestedAmount or lower keys\n    /// @param _requestedAmount Amount of keys required. Contract is expected to send _requestedAmount or lower.\n    /// @return publicKeys Array of fundable public keys\n    /// @return signatures Array of signatures linked to the public keys\n    function _getNextValidators(uint256 _requestedAmount)\n        internal\n        override\n        returns (bytes[] memory publicKeys, bytes[] memory signatures)\n    {\n        return IOperatorsRegistryV1(OperatorsRegistryAddress.get()).pickNextValidatorsToDeposit(_requestedAmount);\n    }\n\n    /// @notice Overridden handler to pull funds from the execution layer fee recipient to River and return the delta in the balance\n    /// @param _max The maximum amount to pull from the execution layer fee recipient\n    /// @return The amount pulled from the execution layer fee recipient\n    function _pullELFees(uint256 _max) internal override returns (uint256) {\n        address elFeeRecipient = ELFeeRecipientAddress.get();\n        uint256 initialBalance = address(this).balance;\n        IELFeeRecipientV1(payable(elFeeRecipient)).pullELFees(_max);\n        uint256 collectedELFees = address(this).balance - initialBalance;\n        if (collectedELFees \u003e 0) {\n            _setBalanceToDeposit(BalanceToDeposit.get() + collectedELFees);\n        }\n        emit PulledELFees(collectedELFees);\n        return collectedELFees;\n    }\n\n    /// @notice Overridden handler to pull funds from the coverage fund to River and return the delta in the balance\n    /// @param _max The maximum amount to pull from the coverage fund\n    /// @return The amount pulled from the coverage fund\n    function _pullCoverageFunds(uint256 _max) internal override returns (uint256) {\n        address coverageFund = CoverageFundAddress.get();\n        if (coverageFund == address(0)) {\n            return 0;\n        }\n        uint256 initialBalance = address(this).balance;\n        ICoverageFundV1(payable(coverageFund)).pullCoverageFunds(_max);\n        uint256 collectedCoverageFunds = address(this).balance - initialBalance;\n        if (collectedCoverageFunds \u003e 0) {\n            _setBalanceToDeposit(BalanceToDeposit.get() + collectedCoverageFunds);\n        }\n        emit PulledCoverageFunds(collectedCoverageFunds);\n        return collectedCoverageFunds;\n    }\n\n    /// @notice Overridden handler called whenever the balance of ETH handled by the system increases. Computes the fees paid to the collector\n    /// @param _amount Additional ETH received\n    function _onEarnings(uint256 _amount) internal override {\n        uint256 oldTotalSupply = _totalSupply();\n        if (oldTotalSupply == 0) {\n            revert ZeroMintedShares();\n        }\n        uint256 newTotalBalance = _assetBalance();\n        uint256 globalFee = GlobalFee.get();\n        uint256 numerator = _amount * oldTotalSupply * globalFee;\n        uint256 denominator = (newTotalBalance * LibBasisPoints.BASIS_POINTS_MAX) - (_amount * globalFee);\n        uint256 sharesToMint = denominator == 0 ? 0 : (numerator / denominator);\n\n        if (sharesToMint \u003e 0) {\n            address collector = CollectorAddress.get();\n            _mintRawShares(collector, sharesToMint);\n            uint256 newTotalSupply = _totalSupply();\n            uint256 oldTotalBalance = newTotalBalance - _amount;\n            emit RewardsEarned(collector, oldTotalBalance, oldTotalSupply, newTotalBalance, newTotalSupply);\n        }\n    }\n\n    /// @notice Overridden handler called whenever the total balance of ETH is requested\n    /// @return The current total asset balance managed by River\n    function _assetBalance() internal view override(SharesManagerV1, OracleManagerV1) returns (uint256) {\n        IOracleManagerV1.StoredConsensusLayerReport storage storedReport = LastConsensusLayerReport.get();\n        uint256 clValidatorCount = storedReport.validatorsCount;\n        uint256 depositedValidatorCount = DepositedValidatorCount.get();\n        if (clValidatorCount \u003c depositedValidatorCount) {\n            return storedReport.validatorsBalance + BalanceToDeposit.get() + CommittedBalance.get()\n                + BalanceToRedeem.get()\n                + (depositedValidatorCount - clValidatorCount) * ConsensusLayerDepositManagerV1.DEPOSIT_SIZE;\n        } else {\n            return\n                storedReport.validatorsBalance + BalanceToDeposit.get() + CommittedBalance.get() + BalanceToRedeem.get();\n        }\n    }\n\n    /// @notice Internal utility to set the daily committable limits\n    /// @param _dcl The new daily committable limits\n    function _setDailyCommittableLimits(DailyCommittableLimits.DailyCommittableLimitsStruct memory _dcl) internal {\n        DailyCommittableLimits.set(_dcl);\n        emit SetMaxDailyCommittableAmounts(_dcl.minDailyNetCommittableAmount, _dcl.maxDailyRelativeCommittableAmount);\n    }\n\n    /// @notice Sets the balance to deposit, but not yet committed\n    /// @param _newBalanceToDeposit The new balance to deposit value\n    function _setBalanceToDeposit(uint256 _newBalanceToDeposit) internal override(UserDepositManagerV1) {\n        emit SetBalanceToDeposit(BalanceToDeposit.get(), _newBalanceToDeposit);\n        BalanceToDeposit.set(_newBalanceToDeposit);\n    }\n\n    /// @notice Sets the balance to redeem, to be used to satisfy redeem requests on the redeem manager\n    /// @param _newBalanceToRedeem The new balance to redeem value\n    function _setBalanceToRedeem(uint256 _newBalanceToRedeem) internal {\n        emit SetBalanceToRedeem(BalanceToRedeem.get(), _newBalanceToRedeem);\n        BalanceToRedeem.set(_newBalanceToRedeem);\n    }\n\n    /// @notice Sets the committed balance, ready to be deposited to the consensus layer\n    /// @param _newCommittedBalance The new committed balance value\n    function _setCommittedBalance(uint256 _newCommittedBalance) internal override(ConsensusLayerDepositManagerV1) {\n        emit SetBalanceCommittedToDeposit(CommittedBalance.get(), _newCommittedBalance);\n        CommittedBalance.set(_newCommittedBalance);\n    }\n\n    /// @notice Pulls funds from the Withdraw contract, and adds funds to deposit and redeem balances\n    /// @param _skimmedEthAmount The new amount of skimmed eth to pull\n    /// @param _exitedEthAmount The new amount of exited eth to pull\n    function _pullCLFunds(uint256 _skimmedEthAmount, uint256 _exitedEthAmount) internal override {\n        uint256 currentBalance = address(this).balance;\n        uint256 totalAmountToPull = _skimmedEthAmount + _exitedEthAmount;\n        IWithdrawV1(WithdrawalCredentials.getAddress()).pullEth(totalAmountToPull);\n        uint256 collectedCLFunds = address(this).balance - currentBalance;\n        if (collectedCLFunds != _skimmedEthAmount + _exitedEthAmount) {\n            revert InvalidPulledClFundsAmount(_skimmedEthAmount + _exitedEthAmount, collectedCLFunds);\n        }\n        if (_skimmedEthAmount \u003e 0) {\n            _setBalanceToDeposit(BalanceToDeposit.get() + _skimmedEthAmount);\n        }\n        if (_exitedEthAmount \u003e 0) {\n            _setBalanceToRedeem(BalanceToRedeem.get() + _exitedEthAmount);\n        }\n        emit PulledCLFunds(_skimmedEthAmount, _exitedEthAmount);\n    }\n\n    /// @notice Pulls funds from the redeem manager exceeding eth buffer\n    /// @param _max The maximum amount to pull\n    function _pullRedeemManagerExceedingEth(uint256 _max) internal override returns (uint256) {\n        uint256 currentBalance = address(this).balance;\n        IRedeemManagerV1(RedeemManagerAddress.get()).pullExceedingEth(_max);\n        uint256 collectedExceedingEth = address(this).balance - currentBalance;\n        if (collectedExceedingEth \u003e 0) {\n            _setBalanceToDeposit(BalanceToDeposit.get() + collectedExceedingEth);\n        }\n        emit PulledRedeemManagerExceedingEth(collectedExceedingEth);\n        return collectedExceedingEth;\n    }\n\n    /// @notice Use the balance to redeem to report a withdrawal event on the redeem manager\n    function _reportWithdrawToRedeemManager() internal override {\n        IRedeemManagerV1 redeemManager_ = IRedeemManagerV1(RedeemManagerAddress.get());\n        uint256 underlyingAssetBalance = _assetBalance();\n        uint256 totalSupply = _totalSupply();\n\n        if (underlyingAssetBalance \u003e 0 \u0026\u0026 totalSupply \u003e 0) {\n            // we compute the redeem manager demands in eth and lsEth based on current conversion rate\n            uint256 redeemManagerDemand = redeemManager_.getRedeemDemand();\n            uint256 suppliedRedeemManagerDemand = redeemManagerDemand;\n            uint256 suppliedRedeemManagerDemandInEth = _balanceFromShares(suppliedRedeemManagerDemand);\n            uint256 availableBalanceToRedeem = BalanceToRedeem.get();\n\n            // if demand is higher than available eth, we update demand values to use the available eth\n            if (suppliedRedeemManagerDemandInEth \u003e availableBalanceToRedeem) {\n                suppliedRedeemManagerDemandInEth = availableBalanceToRedeem;\n                suppliedRedeemManagerDemand = _sharesFromBalance(suppliedRedeemManagerDemandInEth);\n            }\n\n            emit ReportedRedeemManager(\n                redeemManagerDemand, suppliedRedeemManagerDemand, suppliedRedeemManagerDemandInEth\n            );\n\n            if (suppliedRedeemManagerDemandInEth \u003e 0) {\n                // the available balance to redeem is updated\n                _setBalanceToRedeem(availableBalanceToRedeem - suppliedRedeemManagerDemandInEth);\n\n                // we burn the shares of the redeem manager associated with the amount of eth provided\n                _burnRawShares(address(redeemManager_), suppliedRedeemManagerDemand);\n\n                // perform a report withdraw call to the redeem manager\n                redeemManager_.reportWithdraw{value: suppliedRedeemManagerDemandInEth}(suppliedRedeemManagerDemand);\n            }\n        }\n    }\n\n    /// @notice Requests exits of validators after possibly rebalancing deposit and redeem balances\n    /// @param _exitingBalance The currently exiting funds, soon to be received on the execution layer\n    /// @param _depositToRedeemRebalancingAllowed True if rebalancing from deposit to redeem is allowed\n    function _requestExitsBasedOnRedeemDemandAfterRebalancings(\n        uint256 _exitingBalance,\n        uint32[] memory _stoppedValidatorCounts,\n        bool _depositToRedeemRebalancingAllowed,\n        bool _slashingContainmentModeEnabled\n    ) internal override {\n        IOperatorsRegistryV1(OperatorsRegistryAddress.get()).reportStoppedValidatorCounts(\n            _stoppedValidatorCounts, DepositedValidatorCount.get()\n        );\n\n        if (_slashingContainmentModeEnabled) {\n            return;\n        }\n\n        uint256 totalSupply = _totalSupply();\n        if (totalSupply \u003e 0) {\n            uint256 availableBalanceToRedeem = BalanceToRedeem.get();\n            uint256 availableBalanceToDeposit = BalanceToDeposit.get();\n            uint256 redeemManagerDemandInEth =\n                _balanceFromShares(IRedeemManagerV1(RedeemManagerAddress.get()).getRedeemDemand());\n\n            // if after all rebalancings, the redeem manager demand is still higher than the balance to redeem and exiting eth, we compute\n            // the amount of validators to exit in order to cover the remaining demand\n            if (availableBalanceToRedeem + _exitingBalance \u003c redeemManagerDemandInEth) {\n                // if reblancing is enabled and the redeem manager demand is higher than exiting eth, we add eth for deposit buffer to redeem buffer\n                if (_depositToRedeemRebalancingAllowed \u0026\u0026 availableBalanceToDeposit \u003e 0) {\n                    uint256 rebalancingAmount = LibUint256.min(\n                        availableBalanceToDeposit, redeemManagerDemandInEth - _exitingBalance - availableBalanceToRedeem\n                    );\n                    if (rebalancingAmount \u003e 0) {\n                        availableBalanceToRedeem += rebalancingAmount;\n                        _setBalanceToRedeem(availableBalanceToRedeem);\n                        _setBalanceToDeposit(availableBalanceToDeposit - rebalancingAmount);\n                    }\n                }\n\n                IOperatorsRegistryV1 or = IOperatorsRegistryV1(OperatorsRegistryAddress.get());\n\n                (uint256 totalStoppedValidatorCount, uint256 totalRequestedExitsCount) =\n                    or.getStoppedAndRequestedExitCounts();\n\n                // what we are calling pre-exiting balance is the amount of eth that should soon enter the exiting balance\n                // because exit requests have been made and operators might have a lag to process them\n                // we take them into account to not exit too many validators\n                uint256 preExitingBalance = (\n                    totalRequestedExitsCount \u003e totalStoppedValidatorCount\n                        ? (totalRequestedExitsCount - totalStoppedValidatorCount)\n                        : 0\n                ) * DEPOSIT_SIZE;\n\n                if (availableBalanceToRedeem + _exitingBalance + preExitingBalance \u003c redeemManagerDemandInEth) {\n                    uint256 validatorCountToExit = LibUint256.ceil(\n                        redeemManagerDemandInEth - (availableBalanceToRedeem + _exitingBalance + preExitingBalance),\n                        DEPOSIT_SIZE\n                    );\n\n                    or.demandValidatorExits(validatorCountToExit, DepositedValidatorCount.get());\n                }\n            }\n        }\n    }\n\n    /// @notice Skims the redeem balance and sends remaining funds to the deposit balance\n    function _skimExcessBalanceToRedeem() internal override {\n        uint256 availableBalanceToRedeem = BalanceToRedeem.get();\n\n        // if the available balance to redeem is not 0, it means that all the redeem requests are fulfilled, we should redirect funds for deposits\n        if (availableBalanceToRedeem \u003e 0) {\n            _setBalanceToDeposit(BalanceToDeposit.get() + availableBalanceToRedeem);\n            _setBalanceToRedeem(0);\n        }\n    }\n\n    /// @notice Commits the deposit balance up to the allowed daily limit\n    /// @notice Committed funds are funds waiting to be deposited but that cannot be used to fund the redeem manager anymore\n    /// @notice This two step process is required to prevent possible out of gas issues we would have from actually funding the validators at this point\n    /// @param _period The period between current and last report\n    function _commitBalanceToDeposit(uint256 _period) internal override {\n        uint256 underlyingAssetBalance = _assetBalance();\n        uint256 currentBalanceToDeposit = BalanceToDeposit.get();\n        DailyCommittableLimits.DailyCommittableLimitsStruct memory dcl = DailyCommittableLimits.get();\n\n        // we compute the max daily committable amount by taking the asset balance without the balance to deposit into account\n        // this value is the daily maximum amount we can commit for deposits\n        // we take the maximum value between a net amount and an amount relative to the asset balance\n        // this ensures that the amount we can commit is not too low in the beginning and that it is not too high when volumes grow\n        // the relative amount is computed from the committed and activated funds (on the CL or committed to be on the CL soon) and not\n        // the deposit balance\n        // this value is computed by subtracting the current balance to deposit from the underlying asset balance\n        uint256 currentMaxDailyCommittableAmount = LibUint256.max(\n            dcl.minDailyNetCommittableAmount,\n            (uint256(dcl.maxDailyRelativeCommittableAmount) * (underlyingAssetBalance - currentBalanceToDeposit))\n                / LibBasisPoints.BASIS_POINTS_MAX\n        );\n        // we adapt the value for the reporting period by using the asset balance as upper bound\n        uint256 currentMaxCommittableAmount =\n            LibUint256.min((currentMaxDailyCommittableAmount * _period) / 1 days, currentBalanceToDeposit);\n\n        if (currentMaxCommittableAmount \u003e 0) {\n            _setCommittedBalance(CommittedBalance.get() + currentMaxCommittableAmount);\n            _setBalanceToDeposit(currentBalanceToDeposit - currentMaxCommittableAmount);\n        }\n    }\n}\n"
    },
    "contracts/src/components/ConsensusLayerDepositManager.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../interfaces/components/IConsensusLayerDepositManager.1.sol\";\nimport \"../interfaces/IDepositContract.sol\";\n\nimport \"../libraries/LibBytes.sol\";\nimport \"../libraries/LibUint256.sol\";\n\nimport \"../state/river/DepositContractAddress.sol\";\nimport \"../state/river/WithdrawalCredentials.sol\";\nimport \"../state/river/DepositedValidatorCount.sol\";\nimport \"../state/river/BalanceToDeposit.sol\";\nimport \"../state/river/CommittedBalance.sol\";\n\n/// @title Consensus Layer Deposit Manager (v1)\n/// @author Kiln\n/// @notice This contract handles the interactions with the official deposit contract, funding all validators\n/// @notice Whenever a deposit to the consensus layer is requested, this contract computed the amount of keys\n/// @notice that could be deposited depending on the amount available in the contract. It then tries to retrieve\n/// @notice validator keys by calling its internal virtual method _getNextValidators. This method should be\n/// @notice overridden by the implementing contract to provide [0; _keyCount] keys when invoked.\nabstract contract ConsensusLayerDepositManagerV1 is IConsensusLayerDepositManagerV1 {\n    /// @notice Size of a BLS Public key in bytes\n    uint256 public constant PUBLIC_KEY_LENGTH = 48;\n    /// @notice Size of a BLS Signature in bytes\n    uint256 public constant SIGNATURE_LENGTH = 96;\n    /// @notice Size of a deposit in ETH\n    uint256 public constant DEPOSIT_SIZE = 32 ether;\n\n    /// @notice Handler called to retrieve the internal River admin address\n    /// @dev Must be Overridden\n    function _getRiverAdmin() internal view virtual returns (address);\n\n    /// @notice Handler called to change the committed balance to deposit\n    /// @param newCommittedBalance The new committed balance value\n    function _setCommittedBalance(uint256 newCommittedBalance) internal virtual;\n\n    /// @notice Internal helper to retrieve validator keys ready to be funded\n    /// @dev Must be overridden\n    /// @param _keyCount The amount of keys (or less) to return.\n    function _getNextValidators(uint256 _keyCount)\n        internal\n        virtual\n        returns (bytes[] memory publicKeys, bytes[] memory signatures);\n\n    /// @notice Initializer to set the deposit contract address and the withdrawal credentials to use\n    /// @param _depositContractAddress The address of the deposit contract\n    /// @param _withdrawalCredentials The withdrawal credentials to apply to all deposits\n    function initConsensusLayerDepositManagerV1(address _depositContractAddress, bytes32 _withdrawalCredentials)\n        internal\n    {\n        DepositContractAddress.set(_depositContractAddress);\n        emit SetDepositContractAddress(_depositContractAddress);\n\n        WithdrawalCredentials.set(_withdrawalCredentials);\n        emit SetWithdrawalCredentials(_withdrawalCredentials);\n    }\n\n    /// @inheritdoc IConsensusLayerDepositManagerV1\n    function getCommittedBalance() external view returns (uint256) {\n        return CommittedBalance.get();\n    }\n\n    /// @inheritdoc IConsensusLayerDepositManagerV1\n    function getBalanceToDeposit() external view returns (uint256) {\n        return BalanceToDeposit.get();\n    }\n\n    /// @inheritdoc IConsensusLayerDepositManagerV1\n    function getWithdrawalCredentials() external view returns (bytes32) {\n        return WithdrawalCredentials.get();\n    }\n\n    /// @inheritdoc IConsensusLayerDepositManagerV1\n    function getDepositedValidatorCount() external view returns (uint256) {\n        return DepositedValidatorCount.get();\n    }\n\n    /// @inheritdoc IConsensusLayerDepositManagerV1\n    function depositToConsensusLayer(uint256 _maxCount) external {\n        uint256 committedBalance = CommittedBalance.get();\n        uint256 keyToDepositCount = LibUint256.min(committedBalance / DEPOSIT_SIZE, _maxCount);\n\n        if (keyToDepositCount == 0) {\n            revert NotEnoughFunds();\n        }\n\n        // it's up to the internal overriden _getNextValidators method to provide two array of the same\n        // size for the publicKeys and the signatures\n        (bytes[] memory publicKeys, bytes[] memory signatures) = _getNextValidators(keyToDepositCount);\n\n        uint256 receivedPublicKeyCount = publicKeys.length;\n\n        if (receivedPublicKeyCount == 0) {\n            revert NoAvailableValidatorKeys();\n        }\n\n        if (receivedPublicKeyCount \u003e keyToDepositCount) {\n            revert InvalidPublicKeyCount();\n        }\n\n        bytes32 withdrawalCredentials = WithdrawalCredentials.get();\n\n        if (withdrawalCredentials == 0) {\n            revert InvalidWithdrawalCredentials();\n        }\n\n        for (uint256 idx = 0; idx \u003c receivedPublicKeyCount;) {\n            _depositValidator(publicKeys[idx], signatures[idx], withdrawalCredentials);\n            unchecked {\n                ++idx;\n            }\n        }\n        _setCommittedBalance(committedBalance - DEPOSIT_SIZE * receivedPublicKeyCount);\n        uint256 currentDepositedValidatorCount = DepositedValidatorCount.get();\n        DepositedValidatorCount.set(currentDepositedValidatorCount + receivedPublicKeyCount);\n        emit SetDepositedValidatorCount(\n            currentDepositedValidatorCount, currentDepositedValidatorCount + receivedPublicKeyCount\n        );\n    }\n\n    /// @notice Deposits 32 ETH to the official Deposit contract\n    /// @param _publicKey The public key of the validator\n    /// @param _signature The signature provided by the operator\n    /// @param _withdrawalCredentials The withdrawal credentials provided by River\n    function _depositValidator(bytes memory _publicKey, bytes memory _signature, bytes32 _withdrawalCredentials)\n        internal\n    {\n        if (_publicKey.length != PUBLIC_KEY_LENGTH) {\n            revert InconsistentPublicKeys();\n        }\n\n        if (_signature.length != SIGNATURE_LENGTH) {\n            revert InconsistentSignatures();\n        }\n        uint256 value = DEPOSIT_SIZE;\n\n        uint256 depositAmount = value / 1 gwei;\n\n        bytes32 pubkeyRoot = sha256(bytes.concat(_publicKey, bytes16(0)));\n        bytes32 signatureRoot = sha256(\n            bytes.concat(\n                sha256(LibBytes.slice(_signature, 0, 64)),\n                sha256(bytes.concat(LibBytes.slice(_signature, 64, SIGNATURE_LENGTH - 64), bytes32(0)))\n            )\n        );\n\n        bytes32 depositDataRoot = sha256(\n            bytes.concat(\n                sha256(bytes.concat(pubkeyRoot, _withdrawalCredentials)),\n                sha256(bytes.concat(bytes32(LibUint256.toLittleEndian64(depositAmount)), signatureRoot))\n            )\n        );\n\n        uint256 targetBalance = address(this).balance - value;\n\n        IDepositContract(DepositContractAddress.get()).deposit{value: value}(\n            _publicKey, abi.encodePacked(_withdrawalCredentials), _signature, depositDataRoot\n        );\n        if (address(this).balance != targetBalance) {\n            revert ErrorOnDeposit();\n        }\n    }\n}\n"
    },
    "contracts/src/components/OracleManager.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../interfaces/components/IOracleManager.1.sol\";\nimport \"../interfaces/IRedeemManager.1.sol\";\n\nimport \"../libraries/LibUint256.sol\";\n\nimport \"../state/river/LastConsensusLayerReport.sol\";\nimport \"../state/river/OracleAddress.sol\";\nimport \"../state/river/CLValidatorTotalBalance.sol\";\nimport \"../state/river/CLValidatorCount.sol\";\nimport \"../state/river/DepositedValidatorCount.sol\";\nimport \"../state/river/LastOracleRoundId.sol\";\n\n/// @title Oracle Manager (v1)\n/// @author Kiln\n/// @notice This contract handles the inputs provided by the oracle\n/// @notice The Oracle contract is plugged to this contract and is in charge of pushing\n/// @notice data whenever a new report has been deemed valid. The report consists in two\n/// @notice values: the sum of all balances of all deposited validators and the count of\n/// @notice validators that have been activated on the consensus layer.\nabstract contract OracleManagerV1 is IOracleManagerV1 {\n    uint256 internal constant ONE_YEAR = 365 days;\n    /// @notice Size of a deposit in ETH\n    uint256 public constant _DEPOSIT_SIZE = 32 ether;\n\n    /// @notice Handler called if the delta between the last and new validator balance sum is positive\n    /// @dev Must be overridden\n    /// @param _profits The positive increase in the validator balance sum (staking rewards)\n    function _onEarnings(uint256 _profits) internal virtual;\n\n    /// @notice Handler called to pull the Execution layer fees from the recipient\n    /// @dev Must be overridden\n    /// @param _max The maximum amount to pull inside the system\n    /// @return The amount pulled inside the system\n    function _pullELFees(uint256 _max) internal virtual returns (uint256);\n\n    /// @notice Handler called to pull the coverage funds\n    /// @dev Must be overridden\n    /// @param _max The maximum amount to pull inside the system\n    /// @return The amount pulled inside the system\n    function _pullCoverageFunds(uint256 _max) internal virtual returns (uint256);\n\n    /// @notice Handler called to retrieve the system administrator address\n    /// @dev Must be overridden\n    /// @return The system administrator address\n    function _getRiverAdmin() internal view virtual returns (address);\n\n    /// @notice Overridden handler called whenever the total balance of ETH is requested\n    /// @return The current total asset balance managed by River\n    function _assetBalance() internal view virtual returns (uint256);\n\n    /// @notice Pulls funds from the Withdraw contract, and adds funds to deposit and redeem balances\n    /// @param _skimmedEthAmount The new amount of skimmed eth to pull\n    /// @param _exitedEthAmount The new amount of exited eth to pull\n    function _pullCLFunds(uint256 _skimmedEthAmount, uint256 _exitedEthAmount) internal virtual;\n\n    /// @notice Pulls funds from the redeem manager exceeding eth buffer\n    /// @param _max The maximum amount to pull\n    /// @return The amount pulled\n    function _pullRedeemManagerExceedingEth(uint256 _max) internal virtual returns (uint256);\n\n    /// @notice Use the balance to redeem to report a withdrawal event on the redeem manager\n    function _reportWithdrawToRedeemManager() internal virtual;\n\n    /// @notice Requests exits of validators after possibly rebalancing deposit and redeem balances\n    /// @param _exitingBalance The currently exiting funds, soon to be received on the execution layer\n    /// @param _depositToRedeemRebalancingAllowed True if rebalancing from deposit to redeem is allowed\n    function _requestExitsBasedOnRedeemDemandAfterRebalancings(\n        uint256 _exitingBalance,\n        uint32[] memory _stoppedValidatorCounts,\n        bool _depositToRedeemRebalancingAllowed,\n        bool _slashingContainmentModeEnabled\n    ) internal virtual;\n\n    /// @notice Skims the redeem balance and sends remaining funds to the deposit balance\n    function _skimExcessBalanceToRedeem() internal virtual;\n\n    /// @notice Commits the deposit balance up to the allowed daily limit\n    /// @param _period The period between current and last report\n    function _commitBalanceToDeposit(uint256 _period) internal virtual;\n\n    /// @notice Prevents unauthorized calls\n    modifier onlyAdmin_OMV1() {\n        if (msg.sender != _getRiverAdmin()) {\n            revert LibErrors.Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    /// @notice Set the initial oracle address\n    /// @param _oracle Address of the oracle\n    function initOracleManagerV1(address _oracle) internal {\n        OracleAddress.set(_oracle);\n        emit SetOracle(_oracle);\n    }\n\n    /// @notice Initializes version 1.1 of the oracle manager\n    /// @param _epochsPerFrame The amounts of epochs in a frame\n    /// @param _slotsPerEpoch The slots inside an epoch\n    /// @param _secondsPerSlot The seconds inside a slot\n    /// @param _genesisTime The genesis timestamp\n    /// @param _epochsToAssumedFinality The number of epochs before an epoch is considered final on-chain\n    /// @param _annualAprUpperBound The reporting upper bound\n    /// @param _relativeLowerBound The reporting lower bound\n    function initOracleManagerV1_1(\n        uint64 _epochsPerFrame,\n        uint64 _slotsPerEpoch,\n        uint64 _secondsPerSlot,\n        uint64 _genesisTime,\n        uint64 _epochsToAssumedFinality,\n        uint256 _annualAprUpperBound,\n        uint256 _relativeLowerBound\n    ) internal {\n        CLSpec.set(\n            CLSpec.CLSpecStruct({\n                epochsPerFrame: _epochsPerFrame,\n                slotsPerEpoch: _slotsPerEpoch,\n                secondsPerSlot: _secondsPerSlot,\n                genesisTime: _genesisTime,\n                epochsToAssumedFinality: _epochsToAssumedFinality\n            })\n        );\n        emit SetSpec(_epochsPerFrame, _slotsPerEpoch, _secondsPerSlot, _genesisTime, _epochsToAssumedFinality);\n        ReportBounds.set(\n            ReportBounds.ReportBoundsStruct({\n                annualAprUpperBound: _annualAprUpperBound,\n                relativeLowerBound: _relativeLowerBound\n            })\n        );\n        emit SetBounds(_annualAprUpperBound, _relativeLowerBound);\n\n        IOracleManagerV1.StoredConsensusLayerReport memory storedReport;\n        storedReport.epoch = uint256(LastOracleRoundId.get());\n        storedReport.validatorsBalance = CLValidatorTotalBalance.get();\n        storedReport.validatorsSkimmedBalance = 0;\n        storedReport.validatorsExitedBalance = 0;\n        storedReport.validatorsExitingBalance = 0;\n        storedReport.validatorsCount = uint32(CLValidatorCount.get());\n        storedReport.rebalanceDepositToRedeemMode = false;\n        storedReport.slashingContainmentMode = false;\n        LastConsensusLayerReport.set(storedReport);\n    }\n\n    /// @inheritdoc IOracleManagerV1\n    function getOracle() external view returns (address) {\n        return OracleAddress.get();\n    }\n\n    /// @inheritdoc IOracleManagerV1\n    function getCLValidatorTotalBalance() external view returns (uint256) {\n        return LastConsensusLayerReport.get().validatorsBalance;\n    }\n\n    /// @inheritdoc IOracleManagerV1\n    function getCLValidatorCount() external view returns (uint256) {\n        return LastConsensusLayerReport.get().validatorsCount;\n    }\n\n    /// @inheritdoc IOracleManagerV1\n    function getExpectedEpochId() external view returns (uint256) {\n        CLSpec.CLSpecStruct memory cls = CLSpec.get();\n        uint256 currentEpoch = _currentEpoch(cls);\n        return LibUint256.max(\n            LastConsensusLayerReport.get().epoch + cls.epochsPerFrame,\n            currentEpoch - (currentEpoch % cls.epochsPerFrame)\n        );\n    }\n\n    /// @inheritdoc IOracleManagerV1\n    function isValidEpoch(uint256 _epoch) external view returns (bool) {\n        return _isValidEpoch(CLSpec.get(), _epoch);\n    }\n\n    /// @inheritdoc IOracleManagerV1\n    function getTime() external view returns (uint256) {\n        return block.timestamp;\n    }\n\n    /// @inheritdoc IOracleManagerV1\n    function getLastCompletedEpochId() external view returns (uint256) {\n        return LastConsensusLayerReport.get().epoch;\n    }\n\n    /// @inheritdoc IOracleManagerV1\n    function getCurrentEpochId() external view returns (uint256) {\n        return _currentEpoch(CLSpec.get());\n    }\n\n    /// @inheritdoc IOracleManagerV1\n    function getCLSpec() external view returns (CLSpec.CLSpecStruct memory) {\n        return CLSpec.get();\n    }\n\n    /// @inheritdoc IOracleManagerV1\n    function getCurrentFrame() external view returns (uint256 _startEpochId, uint256 _startTime, uint256 _endTime) {\n        CLSpec.CLSpecStruct memory cls = CLSpec.get();\n        uint256 currentEpoch = _currentEpoch(cls);\n        _startEpochId = currentEpoch - (currentEpoch % cls.epochsPerFrame);\n        _startTime = _startEpochId * cls.slotsPerEpoch * cls.secondsPerSlot;\n        _endTime = (_startEpochId + cls.epochsPerFrame) * cls.slotsPerEpoch * cls.secondsPerSlot - 1;\n    }\n\n    /// @inheritdoc IOracleManagerV1\n    function getFrameFirstEpochId(uint256 _epochId) external view returns (uint256) {\n        return _epochId - (_epochId % CLSpec.get().epochsPerFrame);\n    }\n\n    /// @inheritdoc IOracleManagerV1\n    function getReportBounds() external view returns (ReportBounds.ReportBoundsStruct memory) {\n        return ReportBounds.get();\n    }\n\n    /// @inheritdoc IOracleManagerV1\n    function getLastConsensusLayerReport() external view returns (IOracleManagerV1.StoredConsensusLayerReport memory) {\n        return LastConsensusLayerReport.get();\n    }\n\n    /// @inheritdoc IOracleManagerV1\n    function setOracle(address _oracleAddress) external onlyAdmin_OMV1 {\n        OracleAddress.set(_oracleAddress);\n        emit SetOracle(_oracleAddress);\n    }\n\n    /// @inheritdoc IOracleManagerV1\n    function setCLSpec(CLSpec.CLSpecStruct calldata _newValue) external onlyAdmin_OMV1 {\n        CLSpec.set(_newValue);\n        emit SetSpec(\n            _newValue.epochsPerFrame,\n            _newValue.slotsPerEpoch,\n            _newValue.secondsPerSlot,\n            _newValue.genesisTime,\n            _newValue.epochsToAssumedFinality\n        );\n    }\n\n    /// @inheritdoc IOracleManagerV1\n    function setReportBounds(ReportBounds.ReportBoundsStruct calldata _newValue) external onlyAdmin_OMV1 {\n        ReportBounds.set(_newValue);\n        emit SetBounds(_newValue.annualAprUpperBound, _newValue.relativeLowerBound);\n    }\n\n    /// @notice Structure holding internal variables used during reporting\n    struct ConsensusLayerDataReportingVariables {\n        uint256 preReportUnderlyingBalance;\n        uint256 postReportUnderlyingBalance;\n        uint256 lastReportExitedBalance;\n        uint256 lastReportSkimmedBalance;\n        uint256 exitedAmountIncrease;\n        uint256 skimmedAmountIncrease;\n        uint256 timeElapsedSinceLastReport;\n        uint256 availableAmountToUpperBound;\n        uint256 redeemManagerDemand;\n        ConsensusLayerDataReportingTrace trace;\n    }\n\n    /// @inheritdoc IOracleManagerV1\n    function setConsensusLayerData(IOracleManagerV1.ConsensusLayerReport calldata _report) external {\n        // only the oracle is allowed to call this endpoint\n        if (msg.sender != OracleAddress.get()) {\n            revert LibErrors.Unauthorized(msg.sender);\n        }\n\n        CLSpec.CLSpecStruct memory cls = CLSpec.get();\n\n        // we start by verifying that the reported epoch is valid based on the consensus layer spec\n        if (!_isValidEpoch(cls, _report.epoch)) {\n            revert InvalidEpoch(_report.epoch);\n        }\n\n        ConsensusLayerDataReportingVariables memory vars;\n\n        {\n            IOracleManagerV1.StoredConsensusLayerReport storage lastStoredReport = LastConsensusLayerReport.get();\n\n            vars.lastReportExitedBalance = lastStoredReport.validatorsExitedBalance;\n\n            // we ensure that the reported total exited balance is not decreasing\n            if (_report.validatorsExitedBalance \u003c vars.lastReportExitedBalance) {\n                revert InvalidDecreasingValidatorsExitedBalance(\n                    vars.lastReportExitedBalance, _report.validatorsExitedBalance\n                );\n            }\n\n            // we compute the exited amount increase by taking the delta between reports\n            vars.exitedAmountIncrease = _report.validatorsExitedBalance - vars.lastReportExitedBalance;\n\n            vars.lastReportSkimmedBalance = lastStoredReport.validatorsSkimmedBalance;\n\n            // we ensure that the reported total skimmed balance is not decreasing\n            if (_report.validatorsSkimmedBalance \u003c vars.lastReportSkimmedBalance) {\n                revert InvalidDecreasingValidatorsSkimmedBalance(\n                    vars.lastReportSkimmedBalance, _report.validatorsSkimmedBalance\n                );\n            }\n\n            // we ensure that the reported validator count is not decreasing\n            if (\n                _report.validatorsCount \u003e DepositedValidatorCount.get()\n                    || _report.validatorsCount \u003c lastStoredReport.validatorsCount\n            ) {\n                revert InvalidValidatorCountReport(\n                    _report.validatorsCount, DepositedValidatorCount.get(), lastStoredReport.validatorsCount\n                );\n            }\n\n            // we compute the new skimmed amount by taking the delta between reports\n            vars.skimmedAmountIncrease = _report.validatorsSkimmedBalance - vars.lastReportSkimmedBalance;\n\n            vars.timeElapsedSinceLastReport = _timeBetweenEpochs(cls, lastStoredReport.epoch, _report.epoch);\n        }\n\n        // we retrieve the current total underlying balance before any reporting data is applied to the system\n        vars.preReportUnderlyingBalance = _assetBalance();\n\n        // if we have new exited / skimmed eth available, we pull funds from the consensus layer recipient\n        if (vars.exitedAmountIncrease + vars.skimmedAmountIncrease \u003e 0) {\n            // this method pulls and updates ethToDeposit / ethToRedeem accordingly\n            _pullCLFunds(vars.skimmedAmountIncrease, vars.exitedAmountIncrease);\n        }\n\n        {\n            // we update the system parameters, this will have an impact on how the total underlying balance is computed\n            IOracleManagerV1.StoredConsensusLayerReport memory storedReport;\n\n            storedReport.epoch = _report.epoch;\n            storedReport.validatorsBalance = _report.validatorsBalance;\n            storedReport.validatorsSkimmedBalance = _report.validatorsSkimmedBalance;\n            storedReport.validatorsExitedBalance = _report.validatorsExitedBalance;\n            storedReport.validatorsExitingBalance = _report.validatorsExitingBalance;\n            storedReport.validatorsCount = _report.validatorsCount;\n            storedReport.rebalanceDepositToRedeemMode = _report.rebalanceDepositToRedeemMode;\n            storedReport.slashingContainmentMode = _report.slashingContainmentMode;\n            LastConsensusLayerReport.set(storedReport);\n        }\n\n        ReportBounds.ReportBoundsStruct memory rb = ReportBounds.get();\n\n        // we compute the maximum allowed increase in balance based on the pre report value\n        uint256 maxIncrease = _maxIncrease(rb, vars.preReportUnderlyingBalance, vars.timeElapsedSinceLastReport);\n\n        // we retrieve the new total underlying balance after system parameters are changed\n        vars.postReportUnderlyingBalance = _assetBalance();\n\n        // we can now compute the earned rewards from the consensus layer balances\n        // in order to properly account for the balance increase, we compare the sums of current balances, skimmed balance and exited balances\n        // we also synthetically increase the current balance by 32 eth per new activated validator, this way we have no discrepency due\n        // to currently activating funds that were not yet accounted in the consensus layer balances\n        if (vars.postReportUnderlyingBalance \u003e= vars.preReportUnderlyingBalance) {\n            // if this happens, we revert and the reporting process is cancelled\n            if (vars.postReportUnderlyingBalance \u003e vars.preReportUnderlyingBalance + maxIncrease) {\n                revert TotalValidatorBalanceIncreaseOutOfBound(\n                    vars.preReportUnderlyingBalance,\n                    vars.postReportUnderlyingBalance,\n                    vars.timeElapsedSinceLastReport,\n                    rb.annualAprUpperBound\n                );\n            }\n\n            // we update the rewards based on the balance delta\n            vars.trace.rewards = vars.postReportUnderlyingBalance - vars.preReportUnderlyingBalance;\n\n            // we update the available amount to upper bound (the amount of eth we can still pull and stay below the upper reporting bound)\n            vars.availableAmountToUpperBound = maxIncrease - vars.trace.rewards;\n        } else {\n            // otherwise if the balance has decreased, we verify that we are not exceeding the lower reporting bound\n\n            // we compute the maximum allowed decrease in balance\n            uint256 maxDecrease = _maxDecrease(rb, vars.preReportUnderlyingBalance);\n\n            // we verify that the bound is not crossed\n            if (\n                vars.postReportUnderlyingBalance\n                    \u003c vars.preReportUnderlyingBalance - LibUint256.min(maxDecrease, vars.preReportUnderlyingBalance)\n            ) {\n                revert TotalValidatorBalanceDecreaseOutOfBound(\n                    vars.preReportUnderlyingBalance,\n                    vars.postReportUnderlyingBalance,\n                    vars.timeElapsedSinceLastReport,\n                    rb.relativeLowerBound\n                );\n            }\n\n            // we update the available amount to upper bound to be equal to the maximum allowed increase plus the negative delta due to the loss\n            vars.availableAmountToUpperBound =\n                maxIncrease + (vars.preReportUnderlyingBalance - vars.postReportUnderlyingBalance);\n        }\n\n        // if we have available amount to upper bound after the reporting values are applied\n        if (vars.availableAmountToUpperBound \u003e 0) {\n            // we pull the funds from the execution layer fee recipient\n            vars.trace.pulledELFees = _pullELFees(vars.availableAmountToUpperBound);\n            // we update the rewards\n            vars.trace.rewards += vars.trace.pulledELFees;\n            // we update the available amount accordingly\n            vars.availableAmountToUpperBound -= vars.trace.pulledELFees;\n        }\n\n        // if we have available amount to upper bound after the execution layer fees are pulled\n        if (vars.availableAmountToUpperBound \u003e 0) {\n            // we pull the funds from the exceeding eth buffer of the redeem manager\n            vars.trace.pulledRedeemManagerExceedingEthBuffer =\n                _pullRedeemManagerExceedingEth(vars.availableAmountToUpperBound);\n            // we update the available amount accordingly\n            vars.availableAmountToUpperBound -= vars.trace.pulledRedeemManagerExceedingEthBuffer;\n        }\n\n        // if we have available amount to upper bound after pulling the exceeding eth buffer, we attempt to pull coverage funds\n        if (vars.availableAmountToUpperBound \u003e 0) {\n            // we pull the funds from the coverage recipient\n            vars.trace.pulledCoverageFunds = _pullCoverageFunds(vars.availableAmountToUpperBound);\n            // we do not update the rewards as coverage is not considered rewards\n            // we do not update the available amount as there are no more pulling actions to perform afterwards\n        }\n\n        // if our rewards are not null, we dispatch the fee to the collector\n        if (vars.trace.rewards \u003e 0) {\n            _onEarnings(vars.trace.rewards);\n        }\n\n        _requestExitsBasedOnRedeemDemandAfterRebalancings(\n            _report.validatorsExitingBalance,\n            _report.stoppedValidatorCountPerOperator,\n            _report.rebalanceDepositToRedeemMode,\n            _report.slashingContainmentMode\n        );\n\n        // we use the updated balanceToRedeem value to report a withdraw event on the redeem manager\n        _reportWithdrawToRedeemManager();\n\n        // if funds are left in the balance to redeem, we move them to the deposit balance\n        _skimExcessBalanceToRedeem();\n\n        // we update the committable amount based on daily maximum allowed\n        _commitBalanceToDeposit(vars.timeElapsedSinceLastReport);\n\n        // we emit a summary event with all the reporting details\n        emit ProcessedConsensusLayerReport(_report, vars.trace);\n    }\n\n    /// @notice Retrieve the current epoch based on the current timestamp\n    /// @param _cls The consensus layer spec struct\n    /// @return The current epoch\n    function _currentEpoch(CLSpec.CLSpecStruct memory _cls) internal view returns (uint256) {\n        return ((block.timestamp - _cls.genesisTime) / _cls.secondsPerSlot) / _cls.slotsPerEpoch;\n    }\n\n    /// @notice Verifies if the given epoch is valid\n    /// @param _cls The consensus layer spec struct\n    /// @param _epoch The epoch to verify\n    /// @return True if valid\n    function _isValidEpoch(CLSpec.CLSpecStruct memory _cls, uint256 _epoch) internal view returns (bool) {\n        return (\n            _currentEpoch(_cls) \u003e= _epoch + _cls.epochsToAssumedFinality\n                \u0026\u0026 _epoch \u003e LastConsensusLayerReport.get().epoch \u0026\u0026 _epoch % _cls.epochsPerFrame == 0\n        );\n    }\n\n    /// @notice Retrieves the maximum increase in balance based on current total underlying supply and period since last report\n    /// @param _rb The report bounds struct\n    /// @param _prevTotalEth The total underlying supply during reporting\n    /// @param _timeElapsed The time since last report\n    /// @return The maximum allowed increase in balance\n    function _maxIncrease(ReportBounds.ReportBoundsStruct memory _rb, uint256 _prevTotalEth, uint256 _timeElapsed)\n        internal\n        pure\n        returns (uint256)\n    {\n        return (_prevTotalEth * _rb.annualAprUpperBound * _timeElapsed) / (LibBasisPoints.BASIS_POINTS_MAX * ONE_YEAR);\n    }\n\n    /// @notice Retrieves the maximum decrease in balance based on current total underlying supply\n    /// @param _rb The report bounds struct\n    /// @param _prevTotalEth The total underlying supply during reporting\n    /// @return The maximum allowed decrease in balance\n    function _maxDecrease(ReportBounds.ReportBoundsStruct memory _rb, uint256 _prevTotalEth)\n        internal\n        pure\n        returns (uint256)\n    {\n        return (_prevTotalEth * _rb.relativeLowerBound) / LibBasisPoints.BASIS_POINTS_MAX;\n    }\n\n    /// @notice Retrieve the number of seconds between two epochs\n    /// @param _cls The consensus layer spec struct\n    /// @param _epochPast The starting epoch\n    /// @param _epochNow The current epoch\n    /// @return The number of seconds between the two epochs\n    function _timeBetweenEpochs(CLSpec.CLSpecStruct memory _cls, uint256 _epochPast, uint256 _epochNow)\n        internal\n        pure\n        returns (uint256)\n    {\n        return (_epochNow - _epochPast) * (_cls.secondsPerSlot * _cls.slotsPerEpoch);\n    }\n}\n"
    },
    "contracts/src/components/SharesManager.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../interfaces/components/ISharesManager.1.sol\";\n\nimport \"../libraries/LibSanitize.sol\";\n\nimport \"../state/river/Shares.sol\";\nimport \"../state/river/SharesPerOwner.sol\";\nimport \"../state/shared/ApprovalsPerOwner.sol\";\n\n/// @title Shares Manager (v1)\n/// @author Kiln\n/// @notice This contract handles the shares of the depositor and the ERC20 interface\nabstract contract SharesManagerV1 is ISharesManagerV1 {\n    /// @notice Internal hook triggered on the external transfer call\n    /// @dev Must be overridden\n    /// @param _from Address of the sender\n    /// @param _to Address of the recipient\n    function _onTransfer(address _from, address _to) internal view virtual;\n\n    /// @notice Internal method to override to provide the total underlying asset balance\n    /// @dev Must be overridden\n    /// @return The total asset balance of the system\n    function _assetBalance() internal view virtual returns (uint256);\n\n    /// @notice Modifier used to ensure that the transfer is allowed by using the internal hook to perform internal checks\n    /// @param _from Address of the sender\n    /// @param _to Address of the recipient\n    modifier transferAllowed(address _from, address _to) {\n        _onTransfer(_from, _to);\n        _;\n    }\n\n    /// @notice Modifier used to ensure the amount transferred is not 0\n    /// @param _value Amount to check\n    modifier isNotZero(uint256 _value) {\n        if (_value == 0) {\n            revert NullTransfer();\n        }\n        _;\n    }\n\n    /// @notice Modifier used to ensure that the sender has enough funds for the transfer\n    /// @param _owner Address of the sender\n    /// @param _value Value that is required to be sent\n    modifier hasFunds(address _owner, uint256 _value) {\n        if (_balanceOf(_owner) \u003c _value) {\n            revert BalanceTooLow();\n        }\n        _;\n    }\n\n    /// @inheritdoc ISharesManagerV1\n    function name() external pure returns (string memory) {\n        return \"Liquid Staked ETH\";\n    }\n\n    /// @inheritdoc ISharesManagerV1\n    function symbol() external pure returns (string memory) {\n        return \"LsETH\";\n    }\n\n    /// @inheritdoc ISharesManagerV1\n    function decimals() external pure returns (uint8) {\n        return 18;\n    }\n\n    /// @inheritdoc ISharesManagerV1\n    function totalSupply() external view returns (uint256) {\n        return _totalSupply();\n    }\n\n    /// @inheritdoc ISharesManagerV1\n    function totalUnderlyingSupply() external view returns (uint256) {\n        return _assetBalance();\n    }\n\n    /// @inheritdoc ISharesManagerV1\n    function balanceOf(address _owner) external view returns (uint256) {\n        return _balanceOf(_owner);\n    }\n\n    /// @inheritdoc ISharesManagerV1\n    function balanceOfUnderlying(address _owner) public view returns (uint256) {\n        return _balanceFromShares(SharesPerOwner.get(_owner));\n    }\n\n    /// @inheritdoc ISharesManagerV1\n    function underlyingBalanceFromShares(uint256 _shares) external view returns (uint256) {\n        return _balanceFromShares(_shares);\n    }\n\n    /// @inheritdoc ISharesManagerV1\n    function sharesFromUnderlyingBalance(uint256 _underlyingAssetAmount) external view returns (uint256) {\n        return _sharesFromBalance(_underlyingAssetAmount);\n    }\n\n    /// @inheritdoc ISharesManagerV1\n    function allowance(address _owner, address _spender) external view returns (uint256) {\n        return ApprovalsPerOwner.get(_owner, _spender);\n    }\n\n    /// @inheritdoc ISharesManagerV1\n    function transfer(address _to, uint256 _value)\n        external\n        transferAllowed(msg.sender, _to)\n        isNotZero(_value)\n        hasFunds(msg.sender, _value)\n        returns (bool)\n    {\n        if (_to == address(0)) {\n            revert UnauthorizedTransfer(msg.sender, address(0));\n        }\n        return _transfer(msg.sender, _to, _value);\n    }\n\n    /// @inheritdoc ISharesManagerV1\n    function transferFrom(address _from, address _to, uint256 _value)\n        external\n        transferAllowed(_from, _to)\n        isNotZero(_value)\n        hasFunds(_from, _value)\n        returns (bool)\n    {\n        if (_to == address(0)) {\n            revert UnauthorizedTransfer(_from, address(0));\n        }\n        _spendAllowance(_from, _value);\n        return _transfer(_from, _to, _value);\n    }\n\n    /// @inheritdoc ISharesManagerV1\n    function approve(address _spender, uint256 _value) external returns (bool) {\n        _approve(msg.sender, _spender, _value);\n        return true;\n    }\n\n    /// @inheritdoc ISharesManagerV1\n    function increaseAllowance(address _spender, uint256 _additionalValue) external returns (bool) {\n        _approve(msg.sender, _spender, ApprovalsPerOwner.get(msg.sender, _spender) + _additionalValue);\n        return true;\n    }\n\n    /// @inheritdoc ISharesManagerV1\n    function decreaseAllowance(address _spender, uint256 _subtractableValue) external returns (bool) {\n        _approve(msg.sender, _spender, ApprovalsPerOwner.get(msg.sender, _spender) - _subtractableValue);\n        return true;\n    }\n\n    /// @notice Internal utility to spend the allowance of an account from the message sender\n    /// @param _from Address owning the allowance\n    /// @param _value Amount of allowance in shares to spend\n    function _spendAllowance(address _from, uint256 _value) internal {\n        uint256 currentAllowance = ApprovalsPerOwner.get(_from, msg.sender);\n        if (currentAllowance \u003c _value) {\n            revert AllowanceTooLow(_from, msg.sender, currentAllowance, _value);\n        }\n        if (currentAllowance != type(uint256).max) {\n            _approve(_from, msg.sender, currentAllowance - _value);\n        }\n    }\n\n    /// @notice Internal utility to change the allowance of an owner to a spender\n    /// @param _owner The owner of the shares\n    /// @param _spender The allowed spender of the shares\n    /// @param _value The new allowance value\n    function _approve(address _owner, address _spender, uint256 _value) internal {\n        LibSanitize._notZeroAddress(_owner);\n        LibSanitize._notZeroAddress(_spender);\n        ApprovalsPerOwner.set(_owner, _spender, _value);\n        emit Approval(_owner, _spender, _value);\n    }\n\n    /// @notice Internal utility to retrieve the total supply of tokens\n    /// @return The total supply\n    function _totalSupply() internal view returns (uint256) {\n        return Shares.get();\n    }\n\n    /// @notice Internal utility to perform an unchecked transfer\n    /// @param _from Address sending the tokens\n    /// @param _to Address receiving the tokens\n    /// @param _value Amount of shares to be sent\n    /// @return True if success\n    function _transfer(address _from, address _to, uint256 _value) internal returns (bool) {\n        SharesPerOwner.set(_from, SharesPerOwner.get(_from) - _value);\n        SharesPerOwner.set(_to, SharesPerOwner.get(_to) + _value);\n\n        emit Transfer(_from, _to, _value);\n\n        return true;\n    }\n\n    /// @notice Internal utility to retrieve the underlying asset balance for the given shares\n    /// @param _shares Amount of shares to convert\n    /// @return The balance from the given shares\n    function _balanceFromShares(uint256 _shares) internal view returns (uint256) {\n        uint256 _totalSharesValue = Shares.get();\n\n        if (_totalSharesValue == 0) {\n            return 0;\n        }\n\n        return ((_shares * _assetBalance())) / _totalSharesValue;\n    }\n\n    /// @notice Internal utility to retrieve the shares count for a given underlying asset amount\n    /// @param _balance Amount of underlying asset balance to convert\n    /// @return The shares from the given balance\n    function _sharesFromBalance(uint256 _balance) internal view returns (uint256) {\n        uint256 _totalSharesValue = Shares.get();\n\n        if (_totalSharesValue == 0) {\n            return 0;\n        }\n\n        return (_balance * _totalSharesValue) / _assetBalance();\n    }\n\n    /// @notice Internal utility to mint shares for the specified user\n    /// @dev This method assumes that funds received are now part of the _assetBalance()\n    /// @param _owner Account that should receive the new shares\n    /// @param _underlyingAssetValue Value of underlying asset received, to convert into shares\n    /// @return sharesToMint The amnount of minted shares\n    function _mintShares(address _owner, uint256 _underlyingAssetValue) internal returns (uint256 sharesToMint) {\n        uint256 oldTotalAssetBalance = _assetBalance() - _underlyingAssetValue;\n\n        if (oldTotalAssetBalance == 0) {\n            sharesToMint = _underlyingAssetValue;\n            _mintRawShares(_owner, _underlyingAssetValue);\n        } else {\n            sharesToMint = (_underlyingAssetValue * _totalSupply()) / oldTotalAssetBalance;\n            _mintRawShares(_owner, sharesToMint);\n        }\n    }\n\n    /// @notice Internal utility to retrieve the amount of shares per owner\n    /// @param _owner Account to be checked\n    /// @return The balance of the account in shares\n    function _balanceOf(address _owner) internal view returns (uint256) {\n        return SharesPerOwner.get(_owner);\n    }\n\n    /// @notice Internal utility to mint shares without any conversion, and emits a mint Transfer event\n    /// @param _owner Account that should receive the new shares\n    /// @param _value Amount of shares to mint\n    function _mintRawShares(address _owner, uint256 _value) internal {\n        _setTotalSupply(Shares.get() + _value);\n        SharesPerOwner.set(_owner, SharesPerOwner.get(_owner) + _value);\n        emit Transfer(address(0), _owner, _value);\n    }\n\n    /// @notice Internal utility to burn shares without any conversion, and emits a burn Transfer event\n    /// @param _owner Account that should burn its shares\n    /// @param _value Amount of shares to burn\n    function _burnRawShares(address _owner, uint256 _value) internal {\n        _setTotalSupply(Shares.get() - _value);\n        SharesPerOwner.set(_owner, SharesPerOwner.get(_owner) - _value);\n        emit Transfer(_owner, address(0), _value);\n    }\n\n    /// @notice Internal utility to set the total supply and emit an event\n    /// @param newTotalSupply The new total supply value\n    function _setTotalSupply(uint256 newTotalSupply) internal {\n        Shares.set(newTotalSupply);\n        emit SetTotalSupply(newTotalSupply);\n    }\n}\n"
    },
    "contracts/src/components/UserDepositManager.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../interfaces/components/IUserDepositManager.1.sol\";\n\nimport \"../libraries/LibSanitize.sol\";\n\nimport \"../state/river/BalanceToDeposit.sol\";\n\n/// @title User Deposit Manager (v1)\n/// @author Kiln\n/// @notice This contract handles the inbound transfers cases or the explicit submissions\nabstract contract UserDepositManagerV1 is IUserDepositManagerV1 {\n    /// @notice Handler called whenever a user has sent funds to the contract\n    /// @dev Must be overridden\n    /// @param _depositor Address that made the deposit\n    /// @param _recipient Address that receives the minted shares\n    /// @param _amount Amount deposited\n    function _onDeposit(address _depositor, address _recipient, uint256 _amount) internal virtual;\n    function _setBalanceToDeposit(uint256 newBalanceToDeposit) internal virtual;\n\n    /// @inheritdoc IUserDepositManagerV1\n    function deposit() external payable {\n        _deposit(msg.sender);\n    }\n\n    /// @inheritdoc IUserDepositManagerV1\n    function depositAndTransfer(address _recipient) external payable {\n        LibSanitize._notZeroAddress(_recipient);\n        _deposit(_recipient);\n    }\n\n    /// @inheritdoc IUserDepositManagerV1\n    receive() external payable {\n        _deposit(msg.sender);\n    }\n\n    /// @inheritdoc IUserDepositManagerV1\n    fallback() external payable {\n        revert LibErrors.InvalidCall();\n    }\n\n    /// @notice Internal utility calling the deposit handler and emitting the deposit details\n    /// @param _recipient The account receiving the minted shares\n    function _deposit(address _recipient) internal {\n        if (msg.value == 0) {\n            revert EmptyDeposit();\n        }\n\n        _setBalanceToDeposit(BalanceToDeposit.get() + msg.value);\n\n        _onDeposit(msg.sender, _recipient, msg.value);\n\n        emit UserDeposit(msg.sender, _recipient, msg.value);\n    }\n}\n"
    },
    "contracts/src/interfaces/IAdministrable.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\n/// @title Administrable Interface\n/// @author Kiln\n/// @notice This interface exposes methods to handle the ownership of the contracts\ninterface IAdministrable {\n    /// @notice The pending admin address changed\n    /// @param pendingAdmin New pending admin address\n    event SetPendingAdmin(address indexed pendingAdmin);\n\n    /// @notice The admin address changed\n    /// @param admin New admin address\n    event SetAdmin(address indexed admin);\n\n    /// @notice Retrieves the current admin address\n    /// @return The admin address\n    function getAdmin() external view returns (address);\n\n    /// @notice Retrieve the current pending admin address\n    /// @return The pending admin address\n    function getPendingAdmin() external view returns (address);\n\n    /// @notice Proposes a new address as admin\n    /// @dev This security prevents setting an invalid address as an admin. The pending\n    /// @dev admin has to claim its ownership of the contract, and prove that the new\n    /// @dev address is able to perform regular transactions.\n    /// @param _newAdmin New admin address\n    function proposeAdmin(address _newAdmin) external;\n\n    /// @notice Accept the transfer of ownership\n    /// @dev Only callable by the pending admin. Resets the pending admin if succesful.\n    function acceptAdmin() external;\n}\n"
    },
    "contracts/src/interfaces/IAllowlist.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\n/// @title Allowlist Interface (v1)\n/// @author Kiln\n/// @notice This interface exposes methods to handle the list of allowed recipients.\ninterface IAllowlistV1 {\n    /// @notice The permissions of several accounts have changed\n    /// @param accounts List of accounts\n    /// @param permissions New permissions for each account at the same index\n    event SetAllowlistPermissions(address[] accounts, uint256[] permissions);\n\n    /// @notice The stored allower address has been changed\n    /// @param allower The new allower address\n    event SetAllower(address indexed allower);\n\n    /// @notice The provided accounts list is empty\n    error InvalidAlloweeCount();\n\n    /// @notice The account is denied access\n    /// @param _account The denied account\n    error Denied(address _account);\n\n    /// @notice The provided accounts and permissions list have different lengths\n    error MismatchedAlloweeAndStatusCount();\n\n    /// @notice Initializes the allowlist\n    /// @param _admin Address of the Allowlist administrator\n    /// @param _allower Address of the allower\n    function initAllowlistV1(address _admin, address _allower) external;\n\n    /// @notice Retrieves the allower address\n    /// @return The address of the allower\n    function getAllower() external view returns (address);\n\n    /// @notice This method returns true if the user has the expected permission and\n    ///         is not in the deny list\n    /// @param _account Recipient to verify\n    /// @param _mask Combination of permissions to verify\n    /// @return True if mask is respected and user is allowed\n    function isAllowed(address _account, uint256 _mask) external view returns (bool);\n\n    /// @notice This method returns true if the user is in the deny list\n    /// @param _account Recipient to verify\n    /// @return True if user is denied access\n    function isDenied(address _account) external view returns (bool);\n\n    /// @notice This method returns true if the user has the expected permission\n    ///         ignoring any deny list membership\n    /// @param _account Recipient to verify\n    /// @param _mask Combination of permissions to verify\n    /// @return True if mask is respected\n    function hasPermission(address _account, uint256 _mask) external view returns (bool);\n\n    /// @notice This method retrieves the raw permission value\n    /// @param _account Recipient to verify\n    /// @return The raw permissions value of the account\n    function getPermissions(address _account) external view returns (uint256);\n\n    /// @notice This method should be used as a modifier and is expected to revert\n    ///         if the user hasn't got the required permission or if the user is\n    ///         in the deny list.\n    /// @param _account Recipient to verify\n    /// @param _mask Combination of permissions to verify\n    function onlyAllowed(address _account, uint256 _mask) external view;\n\n    /// @notice Changes the allower address\n    /// @param _newAllowerAddress New address allowed to edit the allowlist\n    function setAllower(address _newAllowerAddress) external;\n\n    /// @notice Sets the allowlisting status for one or more accounts\n    /// @dev The permission value is overridden and not updated\n    /// @param _accounts Accounts with statuses to edit\n    /// @param _permissions Allowlist permissions for each account, in the same order as _accounts\n    function allow(address[] calldata _accounts, uint256[] calldata _permissions) external;\n}\n"
    },
    "contracts/src/interfaces/ICoverageFund.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\n/// @title Coverage Fund Interface (v1)\n/// @author Kiln\n/// @notice This interface exposes methods to receive donations for the slashing coverage fund and pull the funds into river\ninterface ICoverageFundV1 {\n    /// @notice The storage river address has changed\n    /// @param river The new river address\n    event SetRiver(address indexed river);\n\n    /// @notice A donation has been made to the coverage fund\n    /// @param donator Address that performed the donation\n    /// @param amount The amount donated\n    event Donate(address indexed donator, uint256 amount);\n\n    /// @notice The fallback or receive callback has been triggered\n    error InvalidCall();\n\n    /// @notice A donation with 0 ETH has been performed\n    error EmptyDonation();\n\n    /// @notice Initialize the coverage fund with the required arguments\n    /// @param _riverAddress Address of River\n    function initCoverageFundV1(address _riverAddress) external;\n\n    /// @notice Pulls ETH into the River contract\n    /// @dev Only callable by the River contract\n    /// @param _maxAmount The maximum amount to pull into the system\n    function pullCoverageFunds(uint256 _maxAmount) external;\n\n    /// @notice Donates ETH to the coverage fund contract\n    function donate() external payable;\n\n    /// @notice Ether receiver\n    receive() external payable;\n\n    /// @notice Invalid fallback detector\n    fallback() external payable;\n}\n"
    },
    "contracts/src/interfaces/IDepositContract.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\n/// @title Deposit Contract Interface\n/// @notice This interface exposes methods to perform validator deposits\ninterface IDepositContract {\n    /// @notice Official deposit method to activate a validator on the consensus layer\n    /// @param pubkey The 48 bytes long BLS Public key representing the validator\n    /// @param withdrawalCredentials The 32 bytes long withdrawal credentials, configures the withdrawal recipient\n    /// @param signature The 96 bytes long BLS Signature performed by the pubkey's private key\n    /// @param depositDataRoot The root hash of the whole deposit data structure\n    function deposit(\n        bytes calldata pubkey,\n        bytes calldata withdrawalCredentials,\n        bytes calldata signature,\n        bytes32 depositDataRoot\n    ) external payable;\n}\n"
    },
    "contracts/src/interfaces/IELFeeRecipient.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\n/// @title Execution Layer Fee Recipient Interface (v1)\n/// @author Kiln\n/// @notice This interface exposes methods to receive all the execution layer fees from the proposed blocks + bribes\ninterface IELFeeRecipientV1 {\n    /// @notice The storage river address has changed\n    /// @param river The new river address\n    event SetRiver(address indexed river);\n\n    /// @notice The fallback has been triggered\n    error InvalidCall();\n\n    /// @notice Initialize the fee recipient with the required arguments\n    /// @param _riverAddress Address of River\n    function initELFeeRecipientV1(address _riverAddress) external;\n\n    /// @notice Pulls ETH to the River contract\n    /// @dev Only callable by the River contract\n    /// @param _maxAmount The maximum amount to pull into the system\n    function pullELFees(uint256 _maxAmount) external;\n\n    /// @notice Ether receiver\n    receive() external payable;\n\n    /// @notice Invalid fallback detector\n    fallback() external payable;\n}\n"
    },
    "contracts/src/interfaces/IOperatorRegistry.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../state/operatorsRegistry/Operators.2.sol\";\n\n/// @title Operators Registry Interface (v1)\n/// @author Kiln\n/// @notice This interface exposes methods to handle the list of operators and their keys\ninterface IOperatorsRegistryV1 {\n    /// @notice A new operator has been added to the registry\n    /// @param index The operator index\n    /// @param name The operator display name\n    /// @param operatorAddress The operator address\n    event AddedOperator(uint256 indexed index, string name, address indexed operatorAddress);\n\n    /// @notice The operator status has been changed\n    /// @param index The operator index\n    /// @param active True if the operator is active\n    event SetOperatorStatus(uint256 indexed index, bool active);\n\n    /// @notice The operator limit has been changed\n    /// @param index The operator index\n    /// @param newLimit The new operator staking limit\n    event SetOperatorLimit(uint256 indexed index, uint256 newLimit);\n\n    /// @notice The operator stopped validator count has been changed\n    /// @param index The operator index\n    /// @param newStoppedValidatorCount The new stopped validator count\n    event SetOperatorStoppedValidatorCount(uint256 indexed index, uint256 newStoppedValidatorCount);\n\n    /// @notice The operator address has been changed\n    /// @param index The operator index\n    /// @param newOperatorAddress The new operator address\n    event SetOperatorAddress(uint256 indexed index, address indexed newOperatorAddress);\n\n    /// @notice The operator display name has been changed\n    /// @param index The operator index\n    /// @param newName The new display name\n    event SetOperatorName(uint256 indexed index, string newName);\n\n    /// @notice The operator or the admin added new validator keys and signatures\n    /// @dev The public keys and signatures are concatenated\n    /// @dev A public key is 48 bytes long\n    /// @dev A signature is 96 bytes long\n    /// @dev [P1, S1, P2, S2, ..., PN, SN] where N is the bytes length divided by (96 + 48)\n    /// @param index The operator index\n    /// @param publicKeysAndSignatures The concatenated public keys and signatures\n    event AddedValidatorKeys(uint256 indexed index, bytes publicKeysAndSignatures);\n\n    /// @notice The operator or the admin removed a public key and its signature from the registry\n    /// @param index The operator index\n    /// @param publicKey The BLS public key that has been removed\n    event RemovedValidatorKey(uint256 indexed index, bytes publicKey);\n\n    /// @notice The stored river address has been changed\n    /// @param river The new river address\n    event SetRiver(address indexed river);\n\n    /// @notice The operator edited its keys after the snapshot block\n    /// @dev This means that we cannot assume that its key set is checked by the snapshot\n    /// @dev This happens only if the limit was meant to be increased\n    /// @param index The operator index\n    /// @param currentLimit The current operator limit\n    /// @param newLimit The new operator limit that was attempted to be set\n    /// @param latestKeysEditBlockNumber The last block number at which the operator changed its keys\n    /// @param snapshotBlock The block number of the snapshot\n    event OperatorEditsAfterSnapshot(\n        uint256 indexed index,\n        uint256 currentLimit,\n        uint256 newLimit,\n        uint256 indexed latestKeysEditBlockNumber,\n        uint256 indexed snapshotBlock\n    );\n\n    /// @notice The call didn't alter the limit of the operator\n    /// @param index The operator index\n    /// @param limit The limit of the operator\n    event OperatorLimitUnchanged(uint256 indexed index, uint256 limit);\n\n    /// @notice The stopped validator array has been changed\n    /// @notice A validator is considered stopped if exiting, exited or slashed\n    /// @notice This event is emitted when the oracle reports new stopped validators counts\n    /// @param stoppedValidatorCounts The new stopped validator counts\n    event UpdatedStoppedValidators(uint32[] stoppedValidatorCounts);\n\n    /// @notice The requested exit count has been updated\n    /// @param index The operator index\n    /// @param count The count of requested exits\n    event RequestedValidatorExits(uint256 indexed index, uint256 count);\n\n    /// @notice The exit request demand has been updated\n    /// @param previousValidatorExitsDemand The previous exit request demand\n    /// @param nextValidatorExitsDemand The new exit request demand\n    event SetCurrentValidatorExitsDemand(uint256 previousValidatorExitsDemand, uint256 nextValidatorExitsDemand);\n\n    /// @notice The total requested exit has been updated\n    /// @param previousTotalValidatorExitsRequested The previous total requested exit\n    /// @param newTotalValidatorExitsRequested The new total requested exit\n    event SetTotalValidatorExitsRequested(\n        uint256 previousTotalValidatorExitsRequested, uint256 newTotalValidatorExitsRequested\n    );\n\n    /// @notice A validator key got funded on the deposit contract\n    /// @notice This event was introduced during a contract upgrade, in order to cover all possible public keys, this event\n    /// @notice will be replayed for past funded keys in order to have a complete coverage of all the funded public keys.\n    /// @notice In this particuliar scenario, the deferred value will be set to true, to indicate that we are not going to have\n    /// @notice the expected additional events and side effects in the same transaction (deposit to official DepositContract etc ...) because\n    /// @notice the event was synthetically crafted.\n    /// @param index The operator index\n    /// @param publicKeys BLS Public key that got funded\n    /// @param deferred True if event has been replayed in the context of a migration\n    event FundedValidatorKeys(uint256 indexed index, bytes[] publicKeys, bool deferred);\n\n    /// @notice The requested exit count has been update to fill the gap with the reported stopped count\n    /// @param index The operator index\n    /// @param oldRequestedExits The old requested exit count\n    /// @param newRequestedExits The new requested exit count\n    event UpdatedRequestedValidatorExitsUponStopped(\n        uint256 indexed index, uint32 oldRequestedExits, uint32 newRequestedExits\n    );\n\n    /// @notice The calling operator is inactive\n    /// @param index The operator index\n    error InactiveOperator(uint256 index);\n\n    /// @notice A funded key deletion has been attempted\n    error InvalidFundedKeyDeletionAttempt();\n\n    /// @notice The index provided are not sorted properly (descending order)\n    error InvalidUnsortedIndexes();\n\n    /// @notice The provided operator and limits array have different lengths\n    error InvalidArrayLengths();\n\n    /// @notice The provided operator and limits array are empty\n    error InvalidEmptyArray();\n\n    /// @notice The provided key count is 0\n    error InvalidKeyCount();\n\n    /// @notice The provided concatenated keys do not have the expected length\n    error InvalidKeysLength();\n\n    /// @notice The index that is removed is out of bounds\n    error InvalidIndexOutOfBounds();\n\n    /// @notice The value for the operator limit is too high\n    /// @param index The operator index\n    /// @param limit The new limit provided\n    /// @param keyCount The operator key count\n    error OperatorLimitTooHigh(uint256 index, uint256 limit, uint256 keyCount);\n\n    /// @notice The value for the limit is too low\n    /// @param index The operator index\n    /// @param limit The new limit provided\n    /// @param fundedKeyCount The operator funded key count\n    error OperatorLimitTooLow(uint256 index, uint256 limit, uint256 fundedKeyCount);\n\n    /// @notice The provided list of operators is not in increasing order\n    error UnorderedOperatorList();\n\n    /// @notice Thrown when an invalid empty stopped validator array is provided\n    error InvalidEmptyStoppedValidatorCountsArray();\n\n    /// @notice Thrown when the sum of stopped validators is invalid\n    error InvalidStoppedValidatorCountsSum();\n\n    /// @notice Throw when an element in the stopped validator array is decreasing\n    error StoppedValidatorCountsDecreased();\n\n    /// @notice Thrown when the number of elements in the array is too high compared to operator count\n    error StoppedValidatorCountsTooHigh();\n\n    /// @notice Thrown when no exit requests can be performed\n    error NoExitRequestsToPerform();\n\n    /// @notice The provided stopped validator count array is shrinking\n    error StoppedValidatorCountArrayShrinking();\n\n    /// @notice The provided stopped validator count of an operator is above its funded validator count\n    error StoppedValidatorCountAboveFundedCount(uint256 operatorIndex, uint32 stoppedCount, uint32 fundedCount);\n\n    /// @notice Initializes the operators registry\n    /// @param _admin Admin in charge of managing operators\n    /// @param _river Address of River system\n    function initOperatorsRegistryV1(address _admin, address _river) external;\n\n    /// @notice Initializes the operators registry for V1_1\n    function initOperatorsRegistryV1_1() external;\n\n    /// @notice Retrieve the River address\n    /// @return The address of River\n    function getRiver() external view returns (address);\n\n    /// @notice Get operator details\n    /// @param _index The index of the operator\n    /// @return The details of the operator\n    function getOperator(uint256 _index) external view returns (OperatorsV2.Operator memory);\n\n    /// @notice Get operator count\n    /// @return The operator count\n    function getOperatorCount() external view returns (uint256);\n\n    /// @notice Retrieve the stopped validator count for an operator index\n    /// @param _idx The index of the operator\n    /// @return The stopped validator count of the operator\n    function getOperatorStoppedValidatorCount(uint256 _idx) external view returns (uint32);\n\n    /// @notice Retrieve the total stopped validator count\n    /// @return The total stopped validator count\n    function getTotalStoppedValidatorCount() external view returns (uint32);\n\n    /// @notice Retrieve the total requested exit count\n    /// @notice This value is the amount of exit requests that have been performed, emitting an event for operators to catch\n    /// @return The total requested exit count\n    function getTotalValidatorExitsRequested() external view returns (uint256);\n\n    /// @notice Get the current exit request demand waiting to be triggered\n    /// @notice This value is the amount of exit requests that are demanded and not yet performed by the contract\n    /// @return The current exit request demand\n    function getCurrentValidatorExitsDemand() external view returns (uint256);\n\n    /// @notice Retrieve the total stopped and requested exit count\n    /// @return The total stopped count\n    /// @return The total requested exit count\n    function getStoppedAndRequestedExitCounts() external view returns (uint32, uint256);\n\n    /// @notice Retrieve the raw stopped validators array from storage\n    /// @return The stopped validator array\n    function getStoppedValidatorCountPerOperator() external view returns (uint32[] memory);\n\n    /// @notice Get the details of a validator\n    /// @param _operatorIndex The index of the operator\n    /// @param _validatorIndex The index of the validator\n    /// @return publicKey The public key of the validator\n    /// @return signature The signature used during deposit\n    /// @return funded True if validator has been funded\n    function getValidator(uint256 _operatorIndex, uint256 _validatorIndex)\n        external\n        view\n        returns (bytes memory publicKey, bytes memory signature, bool funded);\n\n    /// @notice Retrieve the active operator set\n    /// @return The list of active operators and their details\n    function listActiveOperators() external view returns (OperatorsV2.Operator[] memory);\n\n    /// @notice Allows river to override the stopped validators array\n    /// @notice This actions happens during the Oracle report processing\n    /// @param _stoppedValidatorCounts The new stopped validators array\n    /// @param _depositedValidatorCount The total deposited validator count\n    function reportStoppedValidatorCounts(uint32[] calldata _stoppedValidatorCounts, uint256 _depositedValidatorCount)\n        external;\n\n    /// @notice Adds an operator to the registry\n    /// @dev Only callable by the administrator\n    /// @param _name The name identifying the operator\n    /// @param _operator The address representing the operator, receiving the rewards\n    /// @return The index of the new operator\n    function addOperator(string calldata _name, address _operator) external returns (uint256);\n\n    /// @notice Changes the operator address of an operator\n    /// @dev Only callable by the administrator or the previous operator address\n    /// @param _index The operator index\n    /// @param _newOperatorAddress The new address of the operator\n    function setOperatorAddress(uint256 _index, address _newOperatorAddress) external;\n\n    /// @notice Changes the operator name\n    /// @dev Only callable by the administrator or the operator\n    /// @param _index The operator index\n    /// @param _newName The new operator name\n    function setOperatorName(uint256 _index, string calldata _newName) external;\n\n    /// @notice Changes the operator status\n    /// @dev Only callable by the administrator\n    /// @param _index The operator index\n    /// @param _newStatus The new status of the operator\n    function setOperatorStatus(uint256 _index, bool _newStatus) external;\n\n    /// @notice Changes the operator staking limit\n    /// @dev Only callable by the administrator\n    /// @dev The operator indexes must be in increasing order and contain no duplicate\n    /// @dev The limit cannot exceed the total key count of the operator\n    /// @dev The _indexes and _newLimits must have the same length.\n    /// @dev Each limit value is applied to the operator index at the same index in the _indexes array.\n    /// @param _operatorIndexes The operator indexes, in increasing order and duplicate free\n    /// @param _newLimits The new staking limit of the operators\n    /// @param _snapshotBlock The block number at which the snapshot was computed\n    function setOperatorLimits(\n        uint256[] calldata _operatorIndexes,\n        uint32[] calldata _newLimits,\n        uint256 _snapshotBlock\n    ) external;\n\n    /// @notice Adds new keys for an operator\n    /// @dev Only callable by the administrator or the operator address\n    /// @param _index The operator index\n    /// @param _keyCount The amount of keys provided\n    /// @param _publicKeysAndSignatures Public keys of the validator, concatenated\n    function addValidators(uint256 _index, uint32 _keyCount, bytes calldata _publicKeysAndSignatures) external;\n\n    /// @notice Remove validator keys\n    /// @dev Only callable by the administrator or the operator address\n    /// @dev The indexes must be provided sorted in decreasing order and duplicate-free, otherwise the method will revert\n    /// @dev The operator limit will be set to the lowest deleted key index if the operator's limit wasn't equal to its total key count\n    /// @dev The operator or the admin cannot remove funded keys\n    /// @dev When removing validators, the indexes of specific unfunded keys can be changed in order to properly\n    /// @dev remove the keys from the storage array. Beware of this specific behavior when chaining calls as the\n    /// @dev targeted public key indexes can point to a different key after a first call was made and performed\n    /// @dev some swaps\n    /// @param _index The operator index\n    /// @param _indexes The indexes of the keys to remove\n    function removeValidators(uint256 _index, uint256[] calldata _indexes) external;\n\n    /// @notice Retrieve validator keys based on operator statuses\n    /// @param _count Max amount of keys requested\n    /// @return publicKeys An array of public keys\n    /// @return signatures An array of signatures linked to the public keys\n    function pickNextValidatorsToDeposit(uint256 _count)\n        external\n        returns (bytes[] memory publicKeys, bytes[] memory signatures);\n\n    /// @notice Public endpoint to consume the exit request demand and perform the actual exit requests\n    /// @notice The selection algorithm will pick validators based on their active validator counts\n    /// @notice This value is computed by using the count of funded keys and taking into account the stopped validator counts and exit requests\n    /// @param _count Max amount of exits to request\n    function requestValidatorExits(uint256 _count) external;\n\n    /// @notice Increases the exit request demand\n    /// @dev This method is only callable by the river contract, and to actually forward the information to the node operators via event emission, the unprotected requestValidatorExits method must be called\n    /// @param _count The amount of exit requests to add to the demand\n    /// @param _depositedValidatorCount The total deposited validator count\n    function demandValidatorExits(uint256 _count, uint256 _depositedValidatorCount) external;\n}\n"
    },
    "contracts/src/interfaces/IRedeemManager.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../state/redeemManager/RedeemQueue.sol\";\nimport \"../state/redeemManager/WithdrawalStack.sol\";\n\n/// @title Redeem Manager Interface (v1)\n/// @author Kiln\n/// @notice This contract handles the redeem requests of all users\ninterface IRedeemManagerV1 {\n    /// @notice Emitted when a redeem request is created\n    /// @param owner The owner of the redeem request\n    /// @param height The height of the redeem request in LsETH\n    /// @param amount The amount of the redeem request in LsETH\n    /// @param maxRedeemableEth The maximum amount of eth that can be redeemed from this request\n    /// @param id The id of the new redeem request\n    event RequestedRedeem(address indexed owner, uint256 height, uint256 amount, uint256 maxRedeemableEth, uint32 id);\n\n    /// @notice Emitted when a withdrawal event is created\n    /// @param height The height of the withdrawal event in LsETH\n    /// @param amount The amount of the withdrawal event in LsETH\n    /// @param ethAmount The amount of eth to distrubute to claimers\n    /// @param id The id of the withdrawal event\n    event ReportedWithdrawal(uint256 height, uint256 amount, uint256 ethAmount, uint32 id);\n\n    /// @notice Emitted when a redeem request has been satisfied and filled (even partially) from a withdrawal event\n    /// @param redeemRequestId The id of the redeem request\n    /// @param withdrawalEventId The id of the withdrawal event used to fill the request\n    /// @param lsEthAmountSatisfied The amount of LsETH filled\n    /// @param ethAmountSatisfied The amount of ETH filled\n    /// @param lsEthAmountRemaining The amount of LsETH remaining\n    /// @param ethAmountExceeding The amount of eth added to the exceeding buffer\n    event SatisfiedRedeemRequest(\n        uint32 indexed redeemRequestId,\n        uint32 indexed withdrawalEventId,\n        uint256 lsEthAmountSatisfied,\n        uint256 ethAmountSatisfied,\n        uint256 lsEthAmountRemaining,\n        uint256 ethAmountExceeding\n    );\n\n    /// @notice Emitted when a redeem request claim has been processed and matched at least once and funds are sent to the recipient\n    /// @param redeemRequestId The id of the redeem request\n    /// @param recipient The address receiving the redeem request funds\n    /// @param ethAmount The amount of eth retrieved\n    /// @param lsEthAmount The total amount of LsETH used to redeem the eth\n    /// @param remainingLsEthAmount The amount of LsETH remaining\n    event ClaimedRedeemRequest(\n        uint32 indexed redeemRequestId,\n        address indexed recipient,\n        uint256 ethAmount,\n        uint256 lsEthAmount,\n        uint256 remainingLsEthAmount\n    );\n\n    /// @notice Emitted when the redeem demand is set\n    /// @param oldRedeemDemand The old redeem demand\n    /// @param newRedeemDemand The new redeem demand\n    event SetRedeemDemand(uint256 oldRedeemDemand, uint256 newRedeemDemand);\n\n    /// @notice Emitted when the River address is set\n    /// @param river The new river address\n    event SetRiver(address river);\n\n    /// @notice Thrown When a zero value is provided\n    error InvalidZeroAmount();\n\n    /// @notice Thrown when a transfer error occured with LsETH\n    error TransferError();\n\n    /// @notice Thrown when the provided arrays don't have matching lengths\n    error IncompatibleArrayLengths();\n\n    /// @notice Thrown when the provided redeem request id is out of bounds\n    /// @param id The redeem request id\n    error RedeemRequestOutOfBounds(uint256 id);\n\n    /// @notice Thrown when the withdrawal request id if out of bounds\n    /// @param id The withdrawal event id\n    error WithdrawalEventOutOfBounds(uint256 id);\n\n    /// @notice Thrown when\tthe redeem request id is already claimed\n    /// @param id The redeem request id\n    error RedeemRequestAlreadyClaimed(uint256 id);\n\n    /// @notice Thrown when the redeem request and withdrawal event are not matching during claim\n    /// @param redeemRequestId The provided redeem request id\n    /// @param withdrawalEventId The provided associated withdrawal event id\n    error DoesNotMatch(uint256 redeemRequestId, uint256 withdrawalEventId);\n\n    /// @notice Thrown when the provided withdrawal event exceeds the redeem demand\n    /// @param withdrawalAmount The amount of the withdrawal event\n    /// @param redeemDemand The current redeem demand\n    error WithdrawalExceedsRedeemDemand(uint256 withdrawalAmount, uint256 redeemDemand);\n\n    /// @notice Thrown when the payment after a claim failed\n    /// @param recipient The recipient of the payment\n    /// @param rdata The revert data\n    error ClaimRedeemFailed(address recipient, bytes rdata);\n\n    /// @param _river The address of the River contract\n    function initializeRedeemManagerV1(address _river) external;\n\n    /// @notice Retrieve the global count of redeem requests\n    function getRedeemRequestCount() external view returns (uint256);\n\n    /// @notice Retrieve the details of a specific redeem request\n    /// @param _redeemRequestId The id of the request\n    /// @return The redeem request details\n    function getRedeemRequestDetails(uint32 _redeemRequestId)\n        external\n        view\n        returns (RedeemQueue.RedeemRequest memory);\n\n    /// @notice Retrieve the global count of withdrawal events\n    function getWithdrawalEventCount() external view returns (uint256);\n\n    /// @notice Retrieve the details of a specific withdrawal event\n    /// @param _withdrawalEventId The id of the withdrawal event\n    /// @return The withdrawal event details\n    function getWithdrawalEventDetails(uint32 _withdrawalEventId)\n        external\n        view\n        returns (WithdrawalStack.WithdrawalEvent memory);\n\n    /// @notice Retrieve the amount of redeemed LsETH pending to be supplied with withdrawn ETH\n    /// @return The amount of eth in the buffer\n    function getBufferedExceedingEth() external view returns (uint256);\n\n    /// @notice Retrieve the amount of LsETH waiting to be exited\n    /// @return The amount of LsETH waiting to be exited\n    function getRedeemDemand() external view returns (uint256);\n\n    /// @notice Resolves the provided list of redeem request ids\n    /// @dev The result is an array of equal length with ids or error code\n    /// @dev -1 means that the request is not satisfied yet\n    /// @dev -2 means that the request is out of bounds\n    /// @dev -3 means that the request has already been claimed\n    /// @dev This call was created to be called by an off-chain interface, the output could then be used to perform the claimRewards call in a regular transaction\n    /// @param _redeemRequestIds The list of redeem requests to resolve\n    /// @return withdrawalEventIds The list of withdrawal events matching every redeem request (or error codes)\n    function resolveRedeemRequests(uint32[] calldata _redeemRequestIds)\n        external\n        view\n        returns (int64[] memory withdrawalEventIds);\n\n    /// @notice Creates a redeem request\n    /// @param _lsETHAmount The amount of LsETH to redeem\n    /// @param _recipient The recipient owning the redeem request\n    /// @return redeemRequestId The id of the redeem request\n    function requestRedeem(uint256 _lsETHAmount, address _recipient) external returns (uint32 redeemRequestId);\n\n    /// @notice Creates a redeem request using msg.sender as recipient\n    /// @param _lsETHAmount The amount of LsETH to redeem\n    /// @return redeemRequestId The id of the redeem request\n    function requestRedeem(uint256 _lsETHAmount) external returns (uint32 redeemRequestId);\n\n    /// @notice Claims the rewards of the provided redeem request ids\n    /// @param _redeemRequestIds The list of redeem requests to claim\n    /// @param _withdrawalEventIds The list of withdrawal events to use for every redeem request claim\n    /// @param _skipAlreadyClaimed True if the call should not revert on claiming of already claimed requests\n    /// @param _depth The maximum recursive depth for the resolution of the redeem requests\n    /// @return claimStatuses The list of claim statuses. 0 for fully claimed, 1 for partially claimed, 2 for skipped\n    function claimRedeemRequests(\n        uint32[] calldata _redeemRequestIds,\n        uint32[] calldata _withdrawalEventIds,\n        bool _skipAlreadyClaimed,\n        uint16 _depth\n    ) external returns (uint8[] memory claimStatuses);\n\n    /// @notice Claims the rewards of the provided redeem request ids\n    /// @param _redeemRequestIds The list of redeem requests to claim\n    /// @param _withdrawalEventIds The list of withdrawal events to use for every redeem request claim\n    /// @return claimStatuses The list of claim statuses. 0 for fully claimed, 1 for partially claimed, 2 for skipped\n    function claimRedeemRequests(uint32[] calldata _redeemRequestIds, uint32[] calldata _withdrawalEventIds)\n        external\n        returns (uint8[] memory claimStatuses);\n\n    /// @notice Reports a withdraw event from River\n    /// @param _lsETHWithdrawable The amount of LsETH that can be redeemed due to this new withdraw event\n    function reportWithdraw(uint256 _lsETHWithdrawable) external payable;\n\n    /// @notice Pulls exceeding buffer eth\n    /// @param _max The maximum amount that should be pulled\n    function pullExceedingEth(uint256 _max) external;\n}\n"
    },
    "contracts/src/interfaces/IRiver.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../state/river/DailyCommittableLimits.sol\";\n\nimport \"./components/IConsensusLayerDepositManager.1.sol\";\nimport \"./components/IOracleManager.1.sol\";\nimport \"./components/ISharesManager.1.sol\";\nimport \"./components/IUserDepositManager.1.sol\";\n\n/// @title River Interface (v1)\n/// @author Kiln\n/// @notice The main system interface\ninterface IRiverV1 is IConsensusLayerDepositManagerV1, IUserDepositManagerV1, ISharesManagerV1, IOracleManagerV1 {\n    /// @notice Funds have been pulled from the Execution Layer Fee Recipient\n    /// @param amount The amount pulled\n    event PulledELFees(uint256 amount);\n\n    /// @notice Funds have been pulled from the Coverage Fund\n    /// @param amount The amount pulled\n    event PulledCoverageFunds(uint256 amount);\n\n    /// @notice Emitted when funds are pulled from the redeem manager\n    /// @param amount The amount pulled\n    event PulledRedeemManagerExceedingEth(uint256 amount);\n\n    /// @notice Emitted when funds are pulled from the CL recipient\n    /// @param pulledSkimmedEthAmount The amount of skimmed ETH pulled\n    /// @param pullExitedEthAmount The amount of exited ETH pulled\n    event PulledCLFunds(uint256 pulledSkimmedEthAmount, uint256 pullExitedEthAmount);\n\n    /// @notice The stored Execution Layer Fee Recipient has been changed\n    /// @param elFeeRecipient The new Execution Layer Fee Recipient\n    event SetELFeeRecipient(address indexed elFeeRecipient);\n\n    /// @notice The stored Coverage Fund has been changed\n    /// @param coverageFund The new Coverage Fund\n    event SetCoverageFund(address indexed coverageFund);\n\n    /// @notice The stored Collector has been changed\n    /// @param collector The new Collector\n    event SetCollector(address indexed collector);\n\n    /// @notice The stored Allowlist has been changed\n    /// @param allowlist The new Allowlist\n    event SetAllowlist(address indexed allowlist);\n\n    /// @notice The stored Global Fee has been changed\n    /// @param fee The new Global Fee\n    event SetGlobalFee(uint256 fee);\n\n    /// @notice The stored Operators Registry has been changed\n    /// @param operatorRegistry The new Operators Registry\n    event SetOperatorsRegistry(address indexed operatorRegistry);\n\n    /// @notice The stored Metadata URI string has been changed\n    /// @param metadataURI The new Metadata URI string\n    event SetMetadataURI(string metadataURI);\n\n    /// @notice The system underlying supply increased. This is a snapshot of the balances for accounting purposes\n    /// @param _collector The address of the collector during this event\n    /// @param _oldTotalUnderlyingBalance Old total ETH balance under management by River\n    /// @param _oldTotalSupply Old total supply in shares\n    /// @param _newTotalUnderlyingBalance New total ETH balance under management by River\n    /// @param _newTotalSupply New total supply in shares\n    event RewardsEarned(\n        address indexed _collector,\n        uint256 _oldTotalUnderlyingBalance,\n        uint256 _oldTotalSupply,\n        uint256 _newTotalUnderlyingBalance,\n        uint256 _newTotalSupply\n    );\n\n    /// @notice Emitted when the daily committable limits are changed\n    /// @param minNetAmount The minimum amount that must be used as the daily committable amount\n    /// @param maxRelativeAmount The maximum amount that can be used as the daily committable amount, relative to the total underlying supply\n    event SetMaxDailyCommittableAmounts(uint256 minNetAmount, uint256 maxRelativeAmount);\n\n    /// @notice Emitted when the redeem manager address is changed\n    /// @param redeemManager The address of the redeem manager\n    event SetRedeemManager(address redeemManager);\n\n    /// @notice Emitted when the balance to deposit is updated\n    /// @param oldAmount The old balance to deposit\n    /// @param newAmount The new balance to deposit\n    event SetBalanceToDeposit(uint256 oldAmount, uint256 newAmount);\n\n    /// @notice Emitted when the balance to redeem is updated\n    /// @param oldAmount The old balance to redeem\n    /// @param newAmount The new balance to redeem\n    event SetBalanceToRedeem(uint256 oldAmount, uint256 newAmount);\n\n    /// @notice Emitted when the balance committed to deposit\n    /// @param oldAmount The old balance committed to deposit\n    /// @param newAmount The new balance committed to deposit\n    event SetBalanceCommittedToDeposit(uint256 oldAmount, uint256 newAmount);\n\n    /// @notice Emitted when the redeem manager received a withdraw event report\n    /// @param redeemManagerDemand The total demand in LsETH of the redeem manager\n    /// @param suppliedRedeemManagerDemand The amount of LsETH demand actually supplied\n    /// @param suppliedRedeemManagerDemandInEth The amount in ETH of the supplied demand\n    event ReportedRedeemManager(\n        uint256 redeemManagerDemand, uint256 suppliedRedeemManagerDemand, uint256 suppliedRedeemManagerDemandInEth\n    );\n\n    /// @notice Thrown when the amount received from the Withdraw contract doe not match the requested amount\n    /// @param requested The amount that was requested\n    /// @param received The amount that was received\n    error InvalidPulledClFundsAmount(uint256 requested, uint256 received);\n\n    /// @notice The computed amount of shares to mint is 0\n    error ZeroMintedShares();\n\n    /// @notice The access was denied\n    /// @param account The account that was denied\n    error Denied(address account);\n\n    /// @notice Initializes the River system\n    /// @param _depositContractAddress Address to make Consensus Layer deposits\n    /// @param _elFeeRecipientAddress Address that receives the execution layer fees\n    /// @param _withdrawalCredentials Credentials to use for every validator deposit\n    /// @param _oracleAddress The address of the Oracle contract\n    /// @param _systemAdministratorAddress Administrator address\n    /// @param _allowlistAddress Address of the allowlist contract\n    /// @param _operatorRegistryAddress Address of the operator registry\n    /// @param _collectorAddress Address receiving the the global fee on revenue\n    /// @param _globalFee Amount retained when the ETH balance increases and sent to the collector\n    function initRiverV1(\n        address _depositContractAddress,\n        address _elFeeRecipientAddress,\n        bytes32 _withdrawalCredentials,\n        address _oracleAddress,\n        address _systemAdministratorAddress,\n        address _allowlistAddress,\n        address _operatorRegistryAddress,\n        address _collectorAddress,\n        uint256 _globalFee\n    ) external;\n\n    /// @notice Initialized version 1.1 of the River System\n    /// @param _redeemManager The redeem manager address\n    /// @param _epochsPerFrame The amounts of epochs in a frame\n    /// @param _slotsPerEpoch The slots inside an epoch\n    /// @param _secondsPerSlot The seconds inside a slot\n    /// @param _genesisTime The genesis timestamp\n    /// @param _epochsToAssumedFinality The number of epochs before an epoch is considered final on-chain\n    /// @param _annualAprUpperBound The reporting upper bound\n    /// @param _relativeLowerBound The reporting lower bound\n    /// @param _maxDailyNetCommittableAmount_ The net daily committable limit\n    /// @param _maxDailyRelativeCommittableAmount_ The relative daily committable limit\n    function initRiverV1_1(\n        address _redeemManager,\n        uint64 _epochsPerFrame,\n        uint64 _slotsPerEpoch,\n        uint64 _secondsPerSlot,\n        uint64 _genesisTime,\n        uint64 _epochsToAssumedFinality,\n        uint256 _annualAprUpperBound,\n        uint256 _relativeLowerBound,\n        uint128 _maxDailyNetCommittableAmount_,\n        uint128 _maxDailyRelativeCommittableAmount_\n    ) external;\n\n    /// @notice Get the current global fee\n    /// @return The global fee\n    function getGlobalFee() external view returns (uint256);\n\n    /// @notice Retrieve the allowlist address\n    /// @return The allowlist address\n    function getAllowlist() external view returns (address);\n\n    /// @notice Retrieve the collector address\n    /// @return The collector address\n    function getCollector() external view returns (address);\n\n    /// @notice Retrieve the execution layer fee recipient\n    /// @return The execution layer fee recipient address\n    function getELFeeRecipient() external view returns (address);\n\n    /// @notice Retrieve the coverage fund\n    /// @return The coverage fund address\n    function getCoverageFund() external view returns (address);\n\n    /// @notice Retrieve the redeem manager\n    /// @return The redeem manager address\n    function getRedeemManager() external view returns (address);\n\n    /// @notice Retrieve the operators registry\n    /// @return The operators registry address\n    function getOperatorsRegistry() external view returns (address);\n\n    /// @notice Retrieve the metadata uri string value\n    /// @return The metadata uri string value\n    function getMetadataURI() external view returns (string memory);\n\n    /// @notice Retrieve the configured daily committable limits\n    /// @return The daily committable limits structure\n    function getDailyCommittableLimits()\n        external\n        view\n        returns (DailyCommittableLimits.DailyCommittableLimitsStruct memory);\n\n    /// @notice Resolves the provided redeem requests by calling the redeem manager\n    /// @param _redeemRequestIds The list of redeem requests to resolve\n    /// @return withdrawalEventIds The list of matching withdrawal events, or error codes\n    function resolveRedeemRequests(uint32[] calldata _redeemRequestIds)\n        external\n        view\n        returns (int64[] memory withdrawalEventIds);\n\n    /// @notice Set the daily committable limits\n    /// @param _dcl The Daily Committable Limits structure\n    function setDailyCommittableLimits(DailyCommittableLimits.DailyCommittableLimitsStruct memory _dcl) external;\n\n    /// @notice Retrieve the current balance to redeem\n    /// @return The current balance to redeem\n    function getBalanceToRedeem() external view returns (uint256);\n\n    /// @notice Performs a redeem request on the redeem manager\n    /// @param _lsETHAmount The amount of LsETH to redeem\n    /// @param _recipient The address that will own the redeem request\n    /// @return redeemRequestId The ID of the newly created redeem request\n    function requestRedeem(uint256 _lsETHAmount, address _recipient) external returns (uint32 redeemRequestId);\n\n    /// @notice Claims several redeem requests\n    /// @param _redeemRequestIds The list of redeem requests to claim\n    /// @param _withdrawalEventIds The list of resolved withdrawal event ids\n    /// @return claimStatuses The operation status results\n    function claimRedeemRequests(uint32[] calldata _redeemRequestIds, uint32[] calldata _withdrawalEventIds)\n        external\n        returns (uint8[] memory claimStatuses);\n\n    /// @notice Changes the global fee parameter\n    /// @param _newFee New fee value\n    function setGlobalFee(uint256 _newFee) external;\n\n    /// @notice Changes the allowlist address\n    /// @param _newAllowlist New address for the allowlist\n    function setAllowlist(address _newAllowlist) external;\n\n    /// @notice Changes the collector address\n    /// @param _newCollector New address for the collector\n    function setCollector(address _newCollector) external;\n\n    /// @notice Changes the execution layer fee recipient\n    /// @param _newELFeeRecipient New address for the recipient\n    function setELFeeRecipient(address _newELFeeRecipient) external;\n\n    /// @notice Changes the coverage fund\n    /// @param _newCoverageFund New address for the fund\n    function setCoverageFund(address _newCoverageFund) external;\n\n    /// @notice Sets the metadata uri string value\n    /// @param _metadataURI The new metadata uri string value\n    function setMetadataURI(string memory _metadataURI) external;\n\n    /// @notice Input for execution layer fee earnings\n    function sendELFees() external payable;\n\n    /// @notice Input for consensus layer funds, containing both exit and skimming\n    function sendCLFunds() external payable;\n\n    /// @notice Input for coverage funds\n    function sendCoverageFunds() external payable;\n\n    /// @notice Input for the redeem manager funds\n    function sendRedeemManagerExceedingFunds() external payable;\n}\n"
    },
    "contracts/src/interfaces/IWithdraw.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\n/// @title Withdraw Interface (V1)\n/// @author Kiln\n/// @notice This contract is in charge of holding the exit and skimming funds and allow river to pull these funds\ninterface IWithdrawV1 {\n    /// @notice Emitted when the linked River address is changed\n    /// @param river The new River address\n    event SetRiver(address river);\n\n    /// @param _river The address of the River contract\n    function initializeWithdrawV1(address _river) external;\n\n    /// @notice Retrieve the withdrawal credentials to use\n    /// @return The withdrawal credentials\n    function getCredentials() external view returns (bytes32);\n\n    /// @notice Retrieve the linked River address\n    /// @return The River address\n    function getRiver() external view returns (address);\n\n    /// @notice Callable by River, sends the specified amount of ETH to River\n    /// @param _amount The amount to pull\n    function pullEth(uint256 _amount) external;\n}\n"
    },
    "contracts/src/interfaces/components/IConsensusLayerDepositManager.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\n/// @title Consensys Layer Deposit Manager Interface (v1)\n/// @author Kiln\n/// @notice This interface exposes methods to handle the interactions with the official deposit contract\ninterface IConsensusLayerDepositManagerV1 {\n    /// @notice The stored deposit contract address changed\n    /// @param depositContract Address of the deposit contract\n    event SetDepositContractAddress(address indexed depositContract);\n\n    /// @notice The stored withdrawal credentials changed\n    /// @param withdrawalCredentials The withdrawal credentials to use for deposits\n    event SetWithdrawalCredentials(bytes32 withdrawalCredentials);\n\n    /// @notice Emitted when the deposited validator count is updated\n    /// @param oldDepositedValidatorCount The old deposited validator count value\n    /// @param newDepositedValidatorCount The new deposited validator count value\n    event SetDepositedValidatorCount(uint256 oldDepositedValidatorCount, uint256 newDepositedValidatorCount);\n\n    /// @notice Not enough funds to deposit one validator\n    error NotEnoughFunds();\n\n    /// @notice The length of the BLS Public key is invalid during deposit\n    error InconsistentPublicKeys();\n\n    /// @notice The length of the BLS Signature is invalid during deposit\n    error InconsistentSignatures();\n\n    /// @notice The internal key retrieval returned no keys\n    error NoAvailableValidatorKeys();\n\n    /// @notice The received count of public keys to deposit is invalid\n    error InvalidPublicKeyCount();\n\n    /// @notice The received count of signatures to deposit is invalid\n    error InvalidSignatureCount();\n\n    /// @notice The withdrawal credentials value is null\n    error InvalidWithdrawalCredentials();\n\n    /// @notice An error occured during the deposit\n    error ErrorOnDeposit();\n\n    /// @notice Returns the amount of ETH not yet committed for deposit\n    /// @return The amount of ETH not yet committed for deposit\n    function getBalanceToDeposit() external view returns (uint256);\n\n    /// @notice Returns the amount of ETH committed for deposit\n    /// @return The amount of ETH committed for deposit\n    function getCommittedBalance() external view returns (uint256);\n\n    /// @notice Retrieve the withdrawal credentials\n    /// @return The withdrawal credentials\n    function getWithdrawalCredentials() external view returns (bytes32);\n\n    /// @notice Get the deposited validator count (the count of deposits made by the contract)\n    /// @return The deposited validator count\n    function getDepositedValidatorCount() external view returns (uint256);\n\n    /// @notice Deposits current balance to the Consensus Layer by batches of 32 ETH\n    /// @param _maxCount The maximum amount of validator keys to fund\n    function depositToConsensusLayer(uint256 _maxCount) external;\n}\n"
    },
    "contracts/src/interfaces/components/IOracleManager.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../state/river/CLSpec.sol\";\nimport \"../../state/river/ReportBounds.sol\";\n\n/// @title Oracle Manager (v1)\n/// @author Kiln\n/// @notice This interface exposes methods to handle the inputs provided by the oracle\ninterface IOracleManagerV1 {\n    /// @notice The stored oracle address changed\n    /// @param oracleAddress The new oracle address\n    event SetOracle(address indexed oracleAddress);\n\n    /// @notice The consensus layer data provided by the oracle has been updated\n    /// @param validatorCount The new count of validators running on the consensus layer\n    /// @param validatorTotalBalance The new total balance sum of all validators\n    /// @param roundId Round identifier\n    event ConsensusLayerDataUpdate(uint256 validatorCount, uint256 validatorTotalBalance, bytes32 roundId);\n\n    /// @notice The Consensus Layer Spec is changed\n    /// @param epochsPerFrame The number of epochs inside a frame\n    /// @param slotsPerEpoch The number of slots inside an epoch\n    /// @param secondsPerSlot The number of seconds inside a slot\n    /// @param genesisTime The genesis timestamp\n    /// @param epochsToAssumedFinality The number of epochs before an epoch is considered final\n    event SetSpec(\n        uint64 epochsPerFrame,\n        uint64 slotsPerEpoch,\n        uint64 secondsPerSlot,\n        uint64 genesisTime,\n        uint64 epochsToAssumedFinality\n    );\n\n    /// @notice The Report Bounds are changed\n    /// @param annualAprUpperBound The reporting upper bound\n    /// @param relativeLowerBound The reporting lower bound\n    event SetBounds(uint256 annualAprUpperBound, uint256 relativeLowerBound);\n\n    /// @notice The provided report has beend processed\n    /// @param report The report that was provided\n    /// @param trace The trace structure providing more insights on internals\n    event ProcessedConsensusLayerReport(\n        IOracleManagerV1.ConsensusLayerReport report, ConsensusLayerDataReportingTrace trace\n    );\n\n    /// @notice The reported validator count is invalid\n    /// @param providedValidatorCount The received validator count value\n    /// @param depositedValidatorCount The number of deposits performed by the system\n    /// @param lastReportedValidatorCount The last reported validator count\n    error InvalidValidatorCountReport(\n        uint256 providedValidatorCount, uint256 depositedValidatorCount, uint256 lastReportedValidatorCount\n    );\n\n    /// @notice Thrown when an invalid epoch was reported\n    /// @param epoch Invalid epoch\n    error InvalidEpoch(uint256 epoch);\n\n    /// @notice The balance increase is higher than the maximum allowed by the upper bound\n    /// @param prevTotalEthIncludingExited The previous total balance, including all exited balance\n    /// @param postTotalEthIncludingExited The post-report total balance, including all exited balance\n    /// @param timeElapsed The time in seconds since last report\n    /// @param annualAprUpperBound The upper bound value that was used\n    error TotalValidatorBalanceIncreaseOutOfBound(\n        uint256 prevTotalEthIncludingExited,\n        uint256 postTotalEthIncludingExited,\n        uint256 timeElapsed,\n        uint256 annualAprUpperBound\n    );\n\n    /// @notice The balance decrease is higher than the maximum allowed by the lower bound\n    /// @param prevTotalEthIncludingExited The previous total balance, including all exited balance\n    /// @param postTotalEthIncludingExited The post-report total balance, including all exited balance\n    /// @param timeElapsed The time in seconds since last report\n    /// @param relativeLowerBound The lower bound value that was used\n    error TotalValidatorBalanceDecreaseOutOfBound(\n        uint256 prevTotalEthIncludingExited,\n        uint256 postTotalEthIncludingExited,\n        uint256 timeElapsed,\n        uint256 relativeLowerBound\n    );\n\n    /// @notice The total exited balance decreased\n    /// @param currentValidatorsExitedBalance The current exited balance\n    /// @param newValidatorsExitedBalance The new exited balance\n    error InvalidDecreasingValidatorsExitedBalance(\n        uint256 currentValidatorsExitedBalance, uint256 newValidatorsExitedBalance\n    );\n\n    /// @notice The total skimmed balance decreased\n    /// @param currentValidatorsSkimmedBalance The current exited balance\n    /// @param newValidatorsSkimmedBalance The new exited balance\n    error InvalidDecreasingValidatorsSkimmedBalance(\n        uint256 currentValidatorsSkimmedBalance, uint256 newValidatorsSkimmedBalance\n    );\n\n    /// @notice Trace structure emitted via logs during reporting\n    struct ConsensusLayerDataReportingTrace {\n        uint256 rewards;\n        uint256 pulledELFees;\n        uint256 pulledRedeemManagerExceedingEthBuffer;\n        uint256 pulledCoverageFunds;\n    }\n\n    /// @notice The format of the oracle report\n    struct ConsensusLayerReport {\n        // this is the epoch at which the report was performed\n        // data should be fetched up to the state of this epoch by the oracles\n        uint256 epoch;\n        // the sum of all the validator balances on the consensus layer\n        // when a validator enters the exit queue, the validator is considered stopped, its balance is accounted in both validatorsExitingBalance and validatorsBalance\n        // when a validator leaves the exit queue and the funds are sweeped onto the execution layer, the balance is only accounted in validatorsExitedBalance and not in validatorsBalance\n        // this value can decrease between reports\n        uint256 validatorsBalance;\n        // the sum of all the skimmings performed on the validators\n        // these values can be found in the execution layer block bodies under the withdrawals field\n        // a withdrawal is considered skimming if\n        // - the epoch at which it happened is \u003c validator.withdrawableEpoch\n        // - the epoch at which it happened is \u003e= validator.withdrawableEpoch and in that case we only account for what would be above 32 eth as skimming\n        // this value cannot decrease over reports\n        uint256 validatorsSkimmedBalance;\n        // the sum of all the exits performed on the validators\n        // these values can be found in the execution layer block bodies under the withdrawals field\n        // a withdrawal is considered exit if\n        // - the epoch at which it happened is \u003e= validator.withdrawableEpoch and in that case we only account for what would be \u003c= 32 eth as exit\n        // this value cannot decrease over reports\n        uint256 validatorsExitedBalance;\n        // the sum of all the exiting balance, which is all the validators on their way to get sweeped and exited\n        // this includes voluntary exits and slashings\n        // this value can decrease between reports\n        uint256 validatorsExitingBalance;\n        // the count of activated validators\n        // even validators that are exited are still accounted\n        // this value cannot decrease over reports\n        uint32 validatorsCount;\n        // an array containing the count of stopped validators per operator\n        // the first element of the array is the sum of all stopped validators\n        // then index 1 would be operator 0\n        // these values cannot decrease over reports\n        uint32[] stoppedValidatorCountPerOperator;\n        // flag enabled by the oracles when the buffer rebalancing is activated\n        // the activation logic is written in the oracle specification and all oracle members must agree on the activation\n        // when active, the eth in the deposit buffer can be used to pay for exits in the redeem manager\n        bool rebalanceDepositToRedeemMode;\n        // flag enabled by the oracles when the slashing containment is activated\n        // the activation logic is written in the oracle specification and all oracle members must agree on the activation\n        // This flag is activated when a pre-defined threshold of slashed validators in our set of validators is reached\n        // This flag is deactivated when a bottom threshold is met, this means that when we reach the upper threshold and activate the flag, we will deactivate it when we reach the bottom threshold and not before\n        // when active, no more validator exits can be requested by the protocol\n        bool slashingContainmentMode;\n    }\n\n    /// @notice The format of the oracle report in storage\n    /// @notice These fields have the exact same function as the ones in ConsensusLayerReport, but this struct is optimized for storage\n    struct StoredConsensusLayerReport {\n        uint256 epoch;\n        uint256 validatorsBalance;\n        uint256 validatorsSkimmedBalance;\n        uint256 validatorsExitedBalance;\n        uint256 validatorsExitingBalance;\n        uint32 validatorsCount;\n        bool rebalanceDepositToRedeemMode;\n        bool slashingContainmentMode;\n    }\n\n    /// @notice Get oracle address\n    /// @return The oracle address\n    function getOracle() external view returns (address);\n\n    /// @notice Get CL validator total balance\n    /// @return The CL Validator total balance\n    function getCLValidatorTotalBalance() external view returns (uint256);\n\n    /// @notice Get CL validator count (the amount of validator reported by the oracles)\n    /// @return The CL validator count\n    function getCLValidatorCount() external view returns (uint256);\n\n    /// @notice Verifies if the provided epoch is valid\n    /// @param epoch The epoch to lookup\n    /// @return True if valid\n    function isValidEpoch(uint256 epoch) external view returns (bool);\n\n    /// @notice Retrieve the block timestamp\n    /// @return The current timestamp from the EVM context\n    function getTime() external view returns (uint256);\n\n    /// @notice Retrieve expected epoch id\n    /// @return The current expected epoch id\n    function getExpectedEpochId() external view returns (uint256);\n\n    /// @notice Retrieve the last completed epoch id\n    /// @return The last completed epoch id\n    function getLastCompletedEpochId() external view returns (uint256);\n\n    /// @notice Retrieve the current epoch id based on block timestamp\n    /// @return The current epoch id\n    function getCurrentEpochId() external view returns (uint256);\n\n    /// @notice Retrieve the current cl spec\n    /// @return The Consensus Layer Specification\n    function getCLSpec() external view returns (CLSpec.CLSpecStruct memory);\n\n    /// @notice Retrieve the current frame details\n    /// @return _startEpochId The epoch at the beginning of the frame\n    /// @return _startTime The timestamp of the beginning of the frame in seconds\n    /// @return _endTime The timestamp of the end of the frame in seconds\n    function getCurrentFrame() external view returns (uint256 _startEpochId, uint256 _startTime, uint256 _endTime);\n\n    /// @notice Retrieve the first epoch id of the frame of the provided epoch id\n    /// @param _epochId Epoch id used to get the frame\n    /// @return The first epoch id of the frame containing the given epoch id\n    function getFrameFirstEpochId(uint256 _epochId) external view returns (uint256);\n\n    /// @notice Retrieve the report bounds\n    /// @return The report bounds\n    function getReportBounds() external view returns (ReportBounds.ReportBoundsStruct memory);\n\n    /// @notice Retrieve the last consensus layer report\n    /// @return The stored consensus layer report\n    function getLastConsensusLayerReport() external view returns (IOracleManagerV1.StoredConsensusLayerReport memory);\n\n    /// @notice Set the oracle address\n    /// @param _oracleAddress Address of the oracle\n    function setOracle(address _oracleAddress) external;\n\n    /// @notice Set the consensus layer spec\n    /// @param _newValue The new consensus layer spec value\n    function setCLSpec(CLSpec.CLSpecStruct calldata _newValue) external;\n\n    /// @notice Set the report bounds\n    /// @param _newValue The new report bounds value\n    function setReportBounds(ReportBounds.ReportBoundsStruct calldata _newValue) external;\n\n    /// @notice Performs all the reporting logics\n    /// @param _report The consensus layer report structure\n    function setConsensusLayerData(ConsensusLayerReport calldata _report) external;\n}\n"
    },
    "contracts/src/interfaces/components/ISharesManager.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\n\n/// @title Shares Manager Interface (v1)\n/// @author Kiln\n/// @notice This interface exposes methods to handle the shares of the depositor and the ERC20 interface\ninterface ISharesManagerV1 is IERC20 {\n    /// @notice Emitted when the total supply is changed\n    event SetTotalSupply(uint256 totalSupply);\n\n    /// @notice Balance too low to perform operation\n    error BalanceTooLow();\n\n    /// @notice Allowance too low to perform operation\n    /// @param _from Account where funds are sent from\n    /// @param _operator Account attempting the transfer\n    /// @param _allowance Current allowance\n    /// @param _value Requested transfer value in shares\n    error AllowanceTooLow(address _from, address _operator, uint256 _allowance, uint256 _value);\n\n    /// @notice Invalid empty transfer\n    error NullTransfer();\n\n    /// @notice Invalid transfer recipients\n    /// @param _from Account sending the funds in the invalid transfer\n    /// @param _to Account receiving the funds in the invalid transfer\n    error UnauthorizedTransfer(address _from, address _to);\n\n    /// @notice Retrieve the token name\n    /// @return The token name\n    function name() external pure returns (string memory);\n\n    /// @notice Retrieve the token symbol\n    /// @return The token symbol\n    function symbol() external pure returns (string memory);\n\n    /// @notice Retrieve the decimal count\n    /// @return The decimal count\n    function decimals() external pure returns (uint8);\n\n    /// @notice Retrieve the total token supply\n    /// @return The total supply in shares\n    function totalSupply() external view returns (uint256);\n\n    /// @notice Retrieve the total underlying asset supply\n    /// @return The total underlying asset supply\n    function totalUnderlyingSupply() external view returns (uint256);\n\n    /// @notice Retrieve the balance of an account\n    /// @param _owner Address to be checked\n    /// @return The balance of the account in shares\n    function balanceOf(address _owner) external view returns (uint256);\n\n    /// @notice Retrieve the underlying asset balance of an account\n    /// @param _owner Address to be checked\n    /// @return The underlying balance of the account\n    function balanceOfUnderlying(address _owner) external view returns (uint256);\n\n    /// @notice Retrieve the underlying asset balance from an amount of shares\n    /// @param _shares Amount of shares to convert\n    /// @return The underlying asset balance represented by the shares\n    function underlyingBalanceFromShares(uint256 _shares) external view returns (uint256);\n\n    /// @notice Retrieve the shares count from an underlying asset amount\n    /// @param _underlyingAssetAmount Amount of underlying asset to convert\n    /// @return The amount of shares worth the underlying asset amopunt\n    function sharesFromUnderlyingBalance(uint256 _underlyingAssetAmount) external view returns (uint256);\n\n    /// @notice Retrieve the allowance value for a spender\n    /// @param _owner Address that issued the allowance\n    /// @param _spender Address that received the allowance\n    /// @return The allowance in shares for a given spender\n    function allowance(address _owner, address _spender) external view returns (uint256);\n\n    /// @notice Performs a transfer from the message sender to the provided account\n    /// @param _to Address receiving the tokens\n    /// @param _value Amount of shares to be sent\n    /// @return True if success\n    function transfer(address _to, uint256 _value) external returns (bool);\n\n    /// @notice Performs a transfer between two recipients\n    /// @param _from Address sending the tokens\n    /// @param _to Address receiving the tokens\n    /// @param _value Amount of shares to be sent\n    /// @return True if success\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\n\n    /// @notice Approves an account for future spendings\n    /// @dev An approved account can use transferFrom to transfer funds on behalf of the token owner\n    /// @param _spender Address that is allowed to spend the tokens\n    /// @param _value The allowed amount in shares, will override previous value\n    /// @return True if success\n    function approve(address _spender, uint256 _value) external returns (bool);\n\n    /// @notice Increase allowance to another account\n    /// @param _spender Spender that receives the allowance\n    /// @param _additionalValue Amount of shares to add\n    /// @return True if success\n    function increaseAllowance(address _spender, uint256 _additionalValue) external returns (bool);\n\n    /// @notice Decrease allowance to another account\n    /// @param _spender Spender that receives the allowance\n    /// @param _subtractableValue Amount of shares to subtract\n    /// @return True if success\n    function decreaseAllowance(address _spender, uint256 _subtractableValue) external returns (bool);\n}\n"
    },
    "contracts/src/interfaces/components/IUserDepositManager.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\n/// @title User Deposit Manager (v1)\n/// @author Kiln\n/// @notice This interface exposes methods to handle the inbound transfers cases or the explicit submissions\ninterface IUserDepositManagerV1 {\n    /// @notice User deposited ETH in the system\n    /// @param depositor Address performing the deposit\n    /// @param recipient Address receiving the minted shares\n    /// @param amount Amount in ETH deposited\n    event UserDeposit(address indexed depositor, address indexed recipient, uint256 amount);\n\n    /// @notice And empty deposit attempt was made\n    error EmptyDeposit();\n\n    /// @notice Explicit deposit method to mint on msg.sender\n    function deposit() external payable;\n\n    /// @notice Explicit deposit method to mint on msg.sender and transfer to _recipient\n    /// @param _recipient Address receiving the minted LsETH\n    function depositAndTransfer(address _recipient) external payable;\n\n    /// @notice Implicit deposit method, when the user performs a regular transfer to the contract\n    receive() external payable;\n\n    /// @notice Invalid call, when the user sends a transaction with a data payload but no method matched\n    fallback() external payable;\n}\n"
    },
    "contracts/src/libraries/LibAdministrable.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"../state/shared/AdministratorAddress.sol\";\nimport \"../state/shared/PendingAdministratorAddress.sol\";\n\n/// @title Lib Administrable\n/// @author Kiln\n/// @notice This library handles the admin and pending admin storage vars\nlibrary LibAdministrable {\n    /// @notice Retrieve the system admin\n    /// @return The address of the system admin\n    function _getAdmin() internal view returns (address) {\n        return AdministratorAddress.get();\n    }\n\n    /// @notice Retrieve the pending system admin\n    /// @return The adress of the pending system admin\n    function _getPendingAdmin() internal view returns (address) {\n        return PendingAdministratorAddress.get();\n    }\n\n    /// @notice Sets the system admin\n    /// @param _admin New system admin\n    function _setAdmin(address _admin) internal {\n        AdministratorAddress.set(_admin);\n    }\n\n    /// @notice Sets the pending system admin\n    /// @param _pendingAdmin New pending system admin\n    function _setPendingAdmin(address _pendingAdmin) internal {\n        PendingAdministratorAddress.set(_pendingAdmin);\n    }\n}\n"
    },
    "contracts/src/libraries/LibAllowlistMasks.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\n/// @title Lib Allowlist Masks\n/// @notice Holds all the mask values\nlibrary LibAllowlistMasks {\n    /// @notice Mask used for denied accounts\n    uint256 internal constant DENY_MASK = 0x1 \u003c\u003c 255;\n    /// @notice The mask for the deposit right\n    uint256 internal constant DEPOSIT_MASK = 0x1;\n    /// @notice The mask for the donation right\n    uint256 internal constant DONATE_MASK = 0x1 \u003c\u003c 1;\n    /// @notice The mask for the redeem right\n    uint256 internal constant REDEEM_MASK = 0x1 \u003c\u003c 2;\n}\n"
    },
    "contracts/src/libraries/LibBasisPoints.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\n/// @title Lib Basis Points\n/// @notice Holds the basis points max value\nlibrary LibBasisPoints {\n    /// @notice The max value for basis points (represents 100%)\n    uint256 internal constant BASIS_POINTS_MAX = 10_000;\n}\n"
    },
    "contracts/src/libraries/LibBytes.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\n/// @title Lib Bytes\n/// @notice This library helps manipulating bytes\nlibrary LibBytes {\n    /// @notice The length overflows an uint\n    error SliceOverflow();\n\n    /// @notice The slice is outside of the initial bytes bounds\n    error SliceOutOfBounds();\n\n    /// @notice Slices the provided bytes\n    /// @param _bytes Bytes to slice\n    /// @param _start The starting index of the slice\n    /// @param _length The length of the slice\n    /// @return The slice of _bytes starting at _start of length _length\n    function slice(bytes memory _bytes, uint256 _start, uint256 _length) internal pure returns (bytes memory) {\n        unchecked {\n            if (_length + 31 \u003c _length) {\n                revert SliceOverflow();\n            }\n        }\n        if (_bytes.length \u003c _start + _length) {\n            revert SliceOutOfBounds();\n        }\n\n        bytes memory tempBytes;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } { mstore(mc, mload(cc)) }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n}\n"
    },
    "contracts/src/libraries/LibErrors.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\n/// @title Lib Errors\n/// @notice Library of common errors\nlibrary LibErrors {\n    /// @notice The operator is unauthorized for the caller\n    /// @param caller Address performing the call\n    error Unauthorized(address caller);\n\n    /// @notice The call was invalid\n    error InvalidCall();\n\n    /// @notice The argument was invalid\n    error InvalidArgument();\n\n    /// @notice The address is zero\n    error InvalidZeroAddress();\n\n    /// @notice The string is empty\n    error InvalidEmptyString();\n\n    /// @notice The fee is invalid\n    error InvalidFee();\n}\n"
    },
    "contracts/src/libraries/LibSanitize.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"./LibErrors.sol\";\nimport \"./LibBasisPoints.sol\";\n\n/// @title Lib Sanitize\n/// @notice Utilities to sanitize input values\nlibrary LibSanitize {\n    /// @notice Reverts if address is 0\n    /// @param _address Address to check\n    function _notZeroAddress(address _address) internal pure {\n        if (_address == address(0)) {\n            revert LibErrors.InvalidZeroAddress();\n        }\n    }\n\n    /// @notice Reverts if string is empty\n    /// @param _string String to check\n    function _notEmptyString(string memory _string) internal pure {\n        if (bytes(_string).length == 0) {\n            revert LibErrors.InvalidEmptyString();\n        }\n    }\n\n    /// @notice Reverts if fee is invalid\n    /// @param _fee Fee to check\n    function _validFee(uint256 _fee) internal pure {\n        if (_fee \u003e LibBasisPoints.BASIS_POINTS_MAX) {\n            revert LibErrors.InvalidFee();\n        }\n    }\n}\n"
    },
    "contracts/src/libraries/LibUint256.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\n/// @title Lib Uint256\n/// @notice Utilities to perform uint operations\nlibrary LibUint256 {\n    /// @notice Converts a value to little endian (64 bits)\n    /// @param _value The value to convert\n    /// @return result The converted value\n    function toLittleEndian64(uint256 _value) internal pure returns (uint256 result) {\n        result = 0;\n        uint256 tempValue = _value;\n        result = tempValue \u0026 0xFF;\n        tempValue \u003e\u003e= 8;\n\n        result = (result \u003c\u003c 8) | (tempValue \u0026 0xFF);\n        tempValue \u003e\u003e= 8;\n\n        result = (result \u003c\u003c 8) | (tempValue \u0026 0xFF);\n        tempValue \u003e\u003e= 8;\n\n        result = (result \u003c\u003c 8) | (tempValue \u0026 0xFF);\n        tempValue \u003e\u003e= 8;\n\n        result = (result \u003c\u003c 8) | (tempValue \u0026 0xFF);\n        tempValue \u003e\u003e= 8;\n\n        result = (result \u003c\u003c 8) | (tempValue \u0026 0xFF);\n        tempValue \u003e\u003e= 8;\n\n        result = (result \u003c\u003c 8) | (tempValue \u0026 0xFF);\n        tempValue \u003e\u003e= 8;\n\n        result = (result \u003c\u003c 8) | (tempValue \u0026 0xFF);\n        tempValue \u003e\u003e= 8;\n\n        assert(0 == tempValue); // fully converted\n        result \u003c\u003c= (24 * 8);\n    }\n\n    /// @notice Returns the minimum value\n    /// @param _a First value\n    /// @param _b Second value\n    /// @return Smallest value between _a and _b\n    function min(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        return (_a \u003e _b ? _b : _a);\n    }\n\n    /// @notice Returns the max value\n    /// @param _a First value\n    /// @param _b Second value\n    /// @return Highest value between _a and _b\n    function max(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        return (_a \u003c _b ? _b : _a);\n    }\n\n    /// @notice Performs a ceiled division\n    /// @param _a Numerator\n    /// @param _b Denominator\n    /// @return ceil(_a / _b)\n    function ceil(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        return (_a / _b) + (_a % _b \u003e 0 ? 1 : 0);\n    }\n}\n"
    },
    "contracts/src/libraries/LibUnstructuredStorage.sol": {
      "content": "// SPDX-License-Identifier:    MIT\n\npragma solidity 0.8.10;\n\n/// @title Lib Unstructured Storage\n/// @notice Utilities to work with unstructured storage\nlibrary LibUnstructuredStorage {\n    /// @notice Retrieve a bool value at a storage slot\n    /// @param _position The storage slot to retrieve\n    /// @return data The bool value\n    function getStorageBool(bytes32 _position) internal view returns (bool data) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            data := sload(_position)\n        }\n    }\n\n    /// @notice Retrieve an address value at a storage slot\n    /// @param _position The storage slot to retrieve\n    /// @return data The address value\n    function getStorageAddress(bytes32 _position) internal view returns (address data) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            data := sload(_position)\n        }\n    }\n\n    /// @notice Retrieve a bytes32 value at a storage slot\n    /// @param _position The storage slot to retrieve\n    /// @return data The bytes32 value\n    function getStorageBytes32(bytes32 _position) internal view returns (bytes32 data) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            data := sload(_position)\n        }\n    }\n\n    /// @notice Retrieve an uint256 value at a storage slot\n    /// @param _position The storage slot to retrieve\n    /// @return data The uint256 value\n    function getStorageUint256(bytes32 _position) internal view returns (uint256 data) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            data := sload(_position)\n        }\n    }\n\n    /// @notice Sets a bool value at a storage slot\n    /// @param _position The storage slot to set\n    /// @param _data The bool value to set\n    function setStorageBool(bytes32 _position, bool _data) internal {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(_position, _data)\n        }\n    }\n\n    /// @notice Sets an address value at a storage slot\n    /// @param _position The storage slot to set\n    /// @param _data The address value to set\n    function setStorageAddress(bytes32 _position, address _data) internal {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(_position, _data)\n        }\n    }\n\n    /// @notice Sets a bytes32 value at a storage slot\n    /// @param _position The storage slot to set\n    /// @param _data The bytes32 value to set\n    function setStorageBytes32(bytes32 _position, bytes32 _data) internal {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(_position, _data)\n        }\n    }\n\n    /// @notice Sets an uint256 value at a storage slot\n    /// @param _position The storage slot to set\n    /// @param _data The uint256 value to set\n    function setStorageUint256(bytes32 _position, uint256 _data) internal {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(_position, _data)\n        }\n    }\n}\n"
    },
    "contracts/src/state/operatorsRegistry/Operators.2.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibSanitize.sol\";\n\n/// @title Operators Storage\n/// @notice Utility to manage the Operators in storage\nlibrary OperatorsV2 {\n    /// @notice Storage slot of the Operators\n    bytes32 internal constant OPERATORS_SLOT = bytes32(uint256(keccak256(\"river.state.v2.operators\")) - 1);\n\n    /// @notice The Operator structure in storage\n    struct Operator {\n        /// @dev The following values respect this invariant:\n        /// @dev     keys \u003e= limit \u003e= funded \u003e= RequestedExits\n\n        /// @custom:attribute Staking limit of the operator\n        uint32 limit;\n        /// @custom:attribute The count of funded validators\n        uint32 funded;\n        /// @custom:attribute The count of exit requests made to this operator\n        uint32 requestedExits;\n        /// @custom:attribute The total count of keys of the operator\n        uint32 keys;\n        /// @custom attribute The block at which the last edit happened in the operator details\n        uint64 latestKeysEditBlockNumber;\n        /// @custom:attribute True if the operator is active and allowed to operate on River\n        bool active;\n        /// @custom:attribute Display name of the operator\n        string name;\n        /// @custom:attribute Address of the operator\n        address operator;\n    }\n\n    /// @notice The Operator structure when loaded in memory\n    struct CachedOperator {\n        /// @custom:attribute Staking limit of the operator\n        uint32 limit;\n        /// @custom:attribute The count of funded validators\n        uint32 funded;\n        /// @custom:attribute The count of exit requests made to this operator\n        uint32 requestedExits;\n        /// @custom:attribute The original index of the operator\n        uint32 index;\n        /// @custom:attribute The amount of picked keys, buffer used before changing funded in storage\n        uint32 picked;\n    }\n\n    /// @notice The Operator structure when loaded in memory for the exit selection\n    struct CachedExitableOperator {\n        /// @custom:attribute The count of funded validators\n        uint32 funded;\n        /// @custom:attribute The count of exit requests made to this operator\n        uint32 requestedExits;\n        /// @custom:attribute The original index of the operator\n        uint32 index;\n        /// @custom:attribute The amount of picked keys, buffer used before changing funded in storage\n        uint32 picked;\n    }\n\n    /// @notice The structure at the storage slot\n    struct SlotOperator {\n        /// @custom:attribute Array containing all the operators\n        Operator[] value;\n    }\n\n    /// @notice The operator was not found\n    /// @param index The provided index\n    error OperatorNotFound(uint256 index);\n\n    /// @notice Retrieve the operator in storage\n    /// @param _index The index of the operator\n    /// @return The Operator structure\n    function get(uint256 _index) internal view returns (Operator storage) {\n        bytes32 slot = OPERATORS_SLOT;\n\n        SlotOperator storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        if (r.value.length \u003c= _index) {\n            revert OperatorNotFound(_index);\n        }\n\n        return r.value[_index];\n    }\n\n    /// @notice Retrieve the operators in storage\n    /// @return The Operator structure array\n    function getAll() internal view returns (Operator[] storage) {\n        bytes32 slot = OPERATORS_SLOT;\n\n        SlotOperator storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value;\n    }\n\n    /// @notice Retrieve the operator count in storage\n    /// @return The count of operators in storage\n    function getCount() internal view returns (uint256) {\n        bytes32 slot = OPERATORS_SLOT;\n\n        SlotOperator storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value.length;\n    }\n\n    /// @notice Retrieve all the active operators\n    /// @return The list of active operator structures\n    function getAllActive() internal view returns (Operator[] memory) {\n        bytes32 slot = OPERATORS_SLOT;\n\n        SlotOperator storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        uint256 activeCount = 0;\n        uint256 operatorCount = r.value.length;\n\n        for (uint256 idx = 0; idx \u003c operatorCount;) {\n            if (r.value[idx].active) {\n                unchecked {\n                    ++activeCount;\n                }\n            }\n            unchecked {\n                ++idx;\n            }\n        }\n\n        Operator[] memory activeOperators = new Operator[](activeCount);\n\n        uint256 activeIdx = 0;\n        for (uint256 idx = 0; idx \u003c operatorCount;) {\n            if (r.value[idx].active) {\n                activeOperators[activeIdx] = r.value[idx];\n                unchecked {\n                    ++activeIdx;\n                }\n            }\n            unchecked {\n                ++idx;\n            }\n        }\n\n        return activeOperators;\n    }\n\n    /// @notice Retrieve the stopped validator count for an operator by its index\n    /// @param stoppedValidatorCounts The storage pointer to the raw array containing the stopped validator counts\n    /// @param index The index of the operator to lookup\n    /// @return The amount of stopped validators for the given operator index\n    function _getStoppedValidatorCountAtIndex(uint32[] storage stoppedValidatorCounts, uint256 index)\n        internal\n        view\n        returns (uint32)\n    {\n        if (index + 1 \u003e= stoppedValidatorCounts.length) {\n            return 0;\n        }\n        return stoppedValidatorCounts[index + 1];\n    }\n\n    /// @notice Retrieve all the active and fundable operators\n    /// @dev This method will return a memory array of length equal to the number of operator, but only\n    /// @dev populated up to the fundable operator count, also returned by the method\n    /// @return The list of active and fundable operators\n    /// @return The count of active and fundable operators\n    function getAllFundable() internal view returns (CachedOperator[] memory, uint256) {\n        bytes32 slot = OPERATORS_SLOT;\n\n        SlotOperator storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        uint256 fundableCount = 0;\n        uint256 operatorCount = r.value.length;\n        CachedOperator[] memory fundableOperators = new CachedOperator[](operatorCount);\n\n        uint32[] storage stoppedValidatorCounts = getStoppedValidators();\n\n        for (uint256 idx = 0; idx \u003c operatorCount;) {\n            if (\n                _hasFundableKeys(r.value[idx])\n                    \u0026\u0026 _getStoppedValidatorCountAtIndex(stoppedValidatorCounts, idx) \u003e= r.value[idx].requestedExits\n            ) {\n                Operator storage op = r.value[idx];\n                fundableOperators[fundableCount] = CachedOperator({\n                    limit: op.limit,\n                    funded: op.funded,\n                    requestedExits: op.requestedExits,\n                    index: uint32(idx),\n                    picked: 0\n                });\n                unchecked {\n                    ++fundableCount;\n                }\n            }\n            unchecked {\n                ++idx;\n            }\n        }\n\n        return (fundableOperators, fundableCount);\n    }\n\n    /// @notice Retrieve all the active and exitable operators\n    /// @dev This method will return a memory array of length equal to the number of operator, but only\n    /// @dev populated up to the exitable operator count, also returned by the method\n    /// @return The list of active and exitable operators\n    /// @return The count of active and exitable operators\n    function getAllExitable() internal view returns (CachedExitableOperator[] memory, uint256) {\n        bytes32 slot = OPERATORS_SLOT;\n\n        SlotOperator storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        uint256 exitableCount = 0;\n        uint256 operatorCount = r.value.length;\n\n        CachedExitableOperator[] memory exitableOperators = new CachedExitableOperator[](operatorCount);\n\n        for (uint256 idx = 0; idx \u003c operatorCount;) {\n            if (_hasExitableKeys(r.value[idx])) {\n                Operator storage op = r.value[idx];\n                exitableOperators[exitableCount] = CachedExitableOperator({\n                    funded: op.funded,\n                    requestedExits: op.requestedExits,\n                    index: uint32(idx),\n                    picked: 0\n                });\n                unchecked {\n                    ++exitableCount;\n                }\n            }\n            unchecked {\n                ++idx;\n            }\n        }\n\n        return (exitableOperators, exitableCount);\n    }\n\n    /// @notice Add a new operator in storage\n    /// @param _newOperator Value of the new operator\n    /// @return The size of the operator array after the operation\n    function push(Operator memory _newOperator) internal returns (uint256) {\n        LibSanitize._notZeroAddress(_newOperator.operator);\n        LibSanitize._notEmptyString(_newOperator.name);\n        bytes32 slot = OPERATORS_SLOT;\n\n        SlotOperator storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        r.value.push(_newOperator);\n\n        return r.value.length;\n    }\n\n    /// @notice Atomic operation to set the key count and update the latestKeysEditBlockNumber field at the same time\n    /// @param _index The operator index\n    /// @param _newKeys The new value for the key count\n    function setKeys(uint256 _index, uint32 _newKeys) internal {\n        Operator storage op = get(_index);\n\n        op.keys = _newKeys;\n        op.latestKeysEditBlockNumber = uint64(block.number);\n    }\n\n    /// @notice Checks if an operator is active and has fundable keys\n    /// @param _operator The operator details\n    /// @return True if active and fundable\n    function _hasFundableKeys(OperatorsV2.Operator memory _operator) internal pure returns (bool) {\n        return (_operator.active \u0026\u0026 _operator.limit \u003e _operator.funded);\n    }\n\n    /// @notice Checks if an operator is active and has exitable keys\n    /// @param _operator The operator details\n    /// @return True if active and exitable\n    function _hasExitableKeys(OperatorsV2.Operator memory _operator) internal pure returns (bool) {\n        return (_operator.active \u0026\u0026 _operator.funded \u003e _operator.requestedExits);\n    }\n\n    /// @notice Storage slot of the Stopped Validators\n    bytes32 internal constant STOPPED_VALIDATORS_SLOT = bytes32(uint256(keccak256(\"river.state.stoppedValidators\")) - 1);\n\n    struct SlotStoppedValidators {\n        uint32[] value;\n    }\n\n    /// @notice Retrieve the storage pointer of the Stopped Validators array\n    /// @return The Stopped Validators storage pointer\n    function getStoppedValidators() internal view returns (uint32[] storage) {\n        bytes32 slot = STOPPED_VALIDATORS_SLOT;\n\n        SlotStoppedValidators storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value;\n    }\n\n    /// @notice Sets the entire stopped validators array\n    /// @param value The new stopped validators array\n    function setRawStoppedValidators(uint32[] memory value) internal {\n        bytes32 slot = STOPPED_VALIDATORS_SLOT;\n\n        SlotStoppedValidators storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        r.value = value;\n    }\n}\n"
    },
    "contracts/src/state/redeemManager/RedeemQueue.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\n/// @title Redeem Manager Redeem Queue storage\n/// @notice Utility to manage the Redeem Queue in the Redeem Manager\nlibrary RedeemQueue {\n    /// @notice Storage slot of the Redeem Queue\n    bytes32 internal constant REDEEM_QUEUE_ID_SLOT = bytes32(uint256(keccak256(\"river.state.redeemQueue\")) - 1);\n\n    /// @notice The Redeemer structure represents the redeem request made by a user\n    struct RedeemRequest {\n        /// @custom:attribute The amount of the redeem request in LsETH\n        uint256 amount;\n        /// @custom:attribute The maximum amount of ETH redeemable by this request\n        uint256 maxRedeemableEth;\n        /// @custom:attribute The owner of the redeem request\n        address owner;\n        /// @custom:attribute The height is the cumulative sum of all the sizes of preceding redeem requests\n        uint256 height;\n    }\n\n    /// @notice Retrieve the Redeem Queue array storage pointer\n    /// @return data The Redeem Queue array storage pointer\n    function get() internal pure returns (RedeemRequest[] storage data) {\n        bytes32 position = REDEEM_QUEUE_ID_SLOT;\n        assembly {\n            data.slot := position\n        }\n    }\n}\n"
    },
    "contracts/src/state/redeemManager/WithdrawalStack.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\n/// @title Redeem Manager Withdrawal Stack storage\n/// @notice Utility to manage the Withdrawal Stack in the Redeem Manager\nlibrary WithdrawalStack {\n    /// @notice Storage slot of the Withdrawal Stack\n    bytes32 internal constant WITHDRAWAL_STACK_ID_SLOT = bytes32(uint256(keccak256(\"river.state.withdrawalStack\")) - 1);\n\n    /// @notice The Redeemer structure represents the withdrawal events made by River\n    struct WithdrawalEvent {\n        /// @custom:attribute The amount of the withdrawal event in LsETH\n        uint256 amount;\n        /// @custom:attribute The amount of the withdrawal event in ETH\n        uint256 withdrawnEth;\n        /// @custom:attribute The height is the cumulative sum of all the sizes of preceding withdrawal events\n        uint256 height;\n    }\n\n    /// @notice Retrieve the Withdrawal Stack array storage pointer\n    /// @return data The Withdrawal Stack array storage pointer\n    function get() internal pure returns (WithdrawalEvent[] storage data) {\n        bytes32 position = WITHDRAWAL_STACK_ID_SLOT;\n        assembly {\n            data.slot := position\n        }\n    }\n}\n"
    },
    "contracts/src/state/river/AllowlistAddress.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\nimport \"../../libraries/LibSanitize.sol\";\n\n/// @title Allowlist Address Storage\n/// @notice Utility to manage the Allowlist Address in storage\nlibrary AllowlistAddress {\n    /// @notice Storage slot of the Allowlist Address\n    bytes32 internal constant ALLOWLIST_ADDRESS_SLOT = bytes32(uint256(keccak256(\"river.state.allowlistAddress\")) - 1);\n\n    /// @notice Retrieve the Allowlist Address\n    /// @return The Allowlist Address\n    function get() internal view returns (address) {\n        return LibUnstructuredStorage.getStorageAddress(ALLOWLIST_ADDRESS_SLOT);\n    }\n\n    /// @notice Sets the Allowlist Address\n    /// @param _newValue New Allowlist Address\n    function set(address _newValue) internal {\n        LibSanitize._notZeroAddress(_newValue);\n        LibUnstructuredStorage.setStorageAddress(ALLOWLIST_ADDRESS_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/river/BalanceToDeposit.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\n\nlibrary BalanceToDeposit {\n    bytes32 internal constant BALANCE_TO_DEPOSIT_SLOT = bytes32(uint256(keccak256(\"river.state.balanceToDeposit\")) - 1);\n\n    function get() internal view returns (uint256) {\n        return LibUnstructuredStorage.getStorageUint256(BALANCE_TO_DEPOSIT_SLOT);\n    }\n\n    function set(uint256 newValue) internal {\n        LibUnstructuredStorage.setStorageUint256(BALANCE_TO_DEPOSIT_SLOT, newValue);\n    }\n}\n"
    },
    "contracts/src/state/river/BalanceToRedeem.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\n\nlibrary BalanceToRedeem {\n    bytes32 internal constant BALANCE_TO_REDEEM_SLOT = bytes32(uint256(keccak256(\"river.state.balanceToRedeem\")) - 1);\n\n    function get() internal view returns (uint256) {\n        return LibUnstructuredStorage.getStorageUint256(BALANCE_TO_REDEEM_SLOT);\n    }\n\n    function set(uint256 newValue) internal {\n        LibUnstructuredStorage.setStorageUint256(BALANCE_TO_REDEEM_SLOT, newValue);\n    }\n}\n"
    },
    "contracts/src/state/river/CLSpec.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\n/// @title Consensus Layer Spec Storage\n/// @notice Utility to manage the Consensus Layer Spec in storage\nlibrary CLSpec {\n    /// @notice Storage slot of the Consensus Layer Spec\n    bytes32 internal constant CL_SPEC_SLOT = bytes32(uint256(keccak256(\"river.state.clSpec\")) - 1);\n\n    /// @notice The Consensus Layer Spec structure\n    struct CLSpecStruct {\n        /// @custom:attribute The count of epochs per frame, 225 means 24h\n        uint64 epochsPerFrame;\n        /// @custom:attribute The count of slots in an epoch (32 on mainnet)\n        uint64 slotsPerEpoch;\n        /// @custom:attribute The seconds in a slot (12 on mainnet)\n        uint64 secondsPerSlot;\n        /// @custom:attribute The block timestamp of the first consensus layer block\n        uint64 genesisTime;\n        /// @custom:attribute The count of epochs before considering an epoch final on-chain\n        uint64 epochsToAssumedFinality;\n    }\n\n    /// @notice The structure in storage\n    struct Slot {\n        /// @custom:attribute The structure in storage\n        CLSpecStruct value;\n    }\n\n    /// @notice Retrieve the Consensus Layer Spec from storage\n    /// @return The Consensus Layer Spec\n    function get() internal view returns (CLSpecStruct memory) {\n        bytes32 slot = CL_SPEC_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value;\n    }\n\n    /// @notice Set the Consensus Layer Spec value in storage\n    /// @param _newCLSpec The new value to set in storage\n    function set(CLSpecStruct memory _newCLSpec) internal {\n        bytes32 slot = CL_SPEC_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        r.value = _newCLSpec;\n    }\n}\n"
    },
    "contracts/src/state/river/CLValidatorCount.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\n\n/// @title Consensus Layer Validator Count Storage\n/// @notice Utility to manage the Consensus Layer Validator Count in storage\n/// @notice This state variable is deprecated and was kept due to migration logic needs\nlibrary CLValidatorCount {\n    /// @notice Storage slot of the Consensus Layer Validator Count\n    bytes32 internal constant CL_VALIDATOR_COUNT_SLOT = bytes32(uint256(keccak256(\"river.state.clValidatorCount\")) - 1);\n\n    /// @notice Retrieve the Consensus Layer Validator Count\n    /// @return The Consensus Layer Validator Count\n    function get() internal view returns (uint256) {\n        return LibUnstructuredStorage.getStorageUint256(CL_VALIDATOR_COUNT_SLOT);\n    }\n\n    /// @notice Sets the Consensus Layer Validator Count\n    /// @param _newValue New Consensus Layer Validator Count\n    function set(uint256 _newValue) internal {\n        LibUnstructuredStorage.setStorageUint256(CL_VALIDATOR_COUNT_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/river/CLValidatorTotalBalance.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\n\n/// @title Consensus Layer Validator Total Balance Storage\n/// @notice Utility to manage the Consensus Layer Validator Total Balance in storage\n/// @notice This state variable is deprecated and was kept due to migration logic needs\nlibrary CLValidatorTotalBalance {\n    /// @notice Storage slot of the Consensus Layer Validator Total Balance\n    bytes32 internal constant CL_VALIDATOR_TOTAL_BALANCE_SLOT =\n        bytes32(uint256(keccak256(\"river.state.clValidatorTotalBalance\")) - 1);\n\n    /// @notice Retrieve the Consensus Layer Validator Total Balance\n    /// @return The Consensus Layer Validator Total Balance\n    function get() internal view returns (uint256) {\n        return LibUnstructuredStorage.getStorageUint256(CL_VALIDATOR_TOTAL_BALANCE_SLOT);\n    }\n\n    /// @notice Sets the Consensus Layer Validator Total Balance\n    /// @param _newValue New Consensus Layer Validator Total Balance\n    function set(uint256 _newValue) internal {\n        LibUnstructuredStorage.setStorageUint256(CL_VALIDATOR_TOTAL_BALANCE_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/river/CollectorAddress.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\nimport \"../../libraries/LibSanitize.sol\";\n\n/// @title Collector Address Storage\n/// @notice Utility to manage the Collector Address in storage\nlibrary CollectorAddress {\n    /// @notice Storage slot of the Collector Address\n    bytes32 internal constant COLLECTOR_ADDRESS_SLOT = bytes32(uint256(keccak256(\"river.state.collectorAddress\")) - 1);\n\n    /// @notice Retrieve the Collector Address\n    /// @return The Collector Address\n    function get() internal view returns (address) {\n        return LibUnstructuredStorage.getStorageAddress(COLLECTOR_ADDRESS_SLOT);\n    }\n\n    /// @notice Sets the Collector Address\n    /// @param _newValue New Collector Address\n    function set(address _newValue) internal {\n        LibSanitize._notZeroAddress(_newValue);\n        LibUnstructuredStorage.setStorageAddress(COLLECTOR_ADDRESS_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/river/CommittedBalance.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\n\nlibrary CommittedBalance {\n    bytes32 internal constant COMMITTED_BALANCE_SLOT = bytes32(uint256(keccak256(\"river.state.committedBalance\")) - 1);\n\n    function get() internal view returns (uint256) {\n        return LibUnstructuredStorage.getStorageUint256(COMMITTED_BALANCE_SLOT);\n    }\n\n    function set(uint256 newValue) internal {\n        LibUnstructuredStorage.setStorageUint256(COMMITTED_BALANCE_SLOT, newValue);\n    }\n}\n"
    },
    "contracts/src/state/river/CoverageFundAddress.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\nimport \"../../libraries/LibSanitize.sol\";\n\n/// @title Coverage Fund Address Storage\n/// @notice Utility to manage the Coverage Fund Address in storage\nlibrary CoverageFundAddress {\n    /// @notice Storage slot of the Coverage Fund Address\n    bytes32 internal constant COVERAGE_FUND_ADDRESS_SLOT =\n        bytes32(uint256(keccak256(\"river.state.coverageFundAddress\")) - 1);\n\n    /// @notice Retrieve the Coverage Fund Address\n    /// @return The Coverage Fund Address\n    function get() internal view returns (address) {\n        return LibUnstructuredStorage.getStorageAddress(COVERAGE_FUND_ADDRESS_SLOT);\n    }\n\n    /// @notice Sets the Coverage Fund Address\n    /// @param _newValue New Coverage Fund Address\n    function set(address _newValue) internal {\n        LibSanitize._notZeroAddress(_newValue);\n        LibUnstructuredStorage.setStorageAddress(COVERAGE_FUND_ADDRESS_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/river/DailyCommittableLimits.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibSanitize.sol\";\n\n/// @title Daily Committable Limits storage\n/// @notice Utility to manage the Daily Committable Limits in storage\nlibrary DailyCommittableLimits {\n    /// @notice Storage slot of the Daily Committable Limits storage\n    bytes32 internal constant DAILY_COMMITTABLE_LIMITS_SLOT =\n        bytes32(uint256(keccak256(\"river.state.dailyCommittableLimits\")) - 1);\n\n    /// @notice The daily committable limits structure\n    struct DailyCommittableLimitsStruct {\n        uint128 minDailyNetCommittableAmount;\n        uint128 maxDailyRelativeCommittableAmount;\n    }\n\n    /// @notice The structure in storage\n    struct Slot {\n        /// @custom:attribute The structure in storage\n        DailyCommittableLimitsStruct value;\n    }\n\n    /// @notice Retrieve the Daily Committable Limits from storage\n    /// @return The Daily Committable Limits\n    function get() internal view returns (DailyCommittableLimitsStruct memory) {\n        bytes32 slot = DAILY_COMMITTABLE_LIMITS_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value;\n    }\n\n    /// @notice Set the Daily Committable Limits value in storage\n    /// @param _newValue The new value to set in storage\n    function set(DailyCommittableLimitsStruct memory _newValue) internal {\n        bytes32 slot = DAILY_COMMITTABLE_LIMITS_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        r.value = _newValue;\n    }\n}\n"
    },
    "contracts/src/state/river/DepositContractAddress.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibSanitize.sol\";\nimport \"../../libraries/LibUnstructuredStorage.sol\";\n\n/// @title Deposit Contract Address Storage\n/// @notice Utility to manage the Deposit Contract Address in storage\nlibrary DepositContractAddress {\n    /// @notice Storage slot of the Deposit Contract Address\n    bytes32 internal constant DEPOSIT_CONTRACT_ADDRESS_SLOT =\n        bytes32(uint256(keccak256(\"river.state.depositContractAddress\")) - 1);\n\n    /// @notice Retrieve the Deposit Contract Address\n    /// @return The Deposit Contract Address\n    function get() internal view returns (address) {\n        return LibUnstructuredStorage.getStorageAddress(DEPOSIT_CONTRACT_ADDRESS_SLOT);\n    }\n\n    /// @notice Sets the Deposit Contract Address\n    /// @param _newValue New Deposit Contract Address\n    function set(address _newValue) internal {\n        LibSanitize._notZeroAddress(_newValue);\n        LibUnstructuredStorage.setStorageAddress(DEPOSIT_CONTRACT_ADDRESS_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/river/DepositedValidatorCount.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\n\n/// @title Deposited Validator Count Storage\n/// @notice Utility to manage the Deposited Validator Count in storage\nlibrary DepositedValidatorCount {\n    /// @notice Storage slot of the Deposited Validator Count\n    bytes32 internal constant DEPOSITED_VALIDATOR_COUNT_SLOT =\n        bytes32(uint256(keccak256(\"river.state.depositedValidatorCount\")) - 1);\n\n    /// @notice Retrieve the Deposited Validator Count\n    /// @return The Deposited Validator Count\n    function get() internal view returns (uint256) {\n        return LibUnstructuredStorage.getStorageUint256(DEPOSITED_VALIDATOR_COUNT_SLOT);\n    }\n\n    /// @notice Sets the Deposited Validator Count\n    /// @param _newValue New Deposited Validator Count\n    function set(uint256 _newValue) internal {\n        LibUnstructuredStorage.setStorageUint256(DEPOSITED_VALIDATOR_COUNT_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/river/ELFeeRecipientAddress.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\nimport \"../../libraries/LibSanitize.sol\";\n\n/// @title Execution Layer Fee Recipient Address Storage\n/// @notice Utility to manage the Execution Layer Fee Recipient Address in storage\nlibrary ELFeeRecipientAddress {\n    /// @notice Storage slot of the Execution Layer Fee Recipient Address\n    bytes32 internal constant EL_FEE_RECIPIENT_ADDRESS =\n        bytes32(uint256(keccak256(\"river.state.elFeeRecipientAddress\")) - 1);\n\n    /// @notice Retrieve the Execution Layer Fee Recipient Address\n    /// @return The Execution Layer Fee Recipient Address\n    function get() internal view returns (address) {\n        return LibUnstructuredStorage.getStorageAddress(EL_FEE_RECIPIENT_ADDRESS);\n    }\n\n    /// @notice Sets the Execution Layer Fee Recipient Address\n    /// @param _newValue New Execution Layer Fee Recipient Address\n    function set(address _newValue) internal {\n        LibSanitize._notZeroAddress(_newValue);\n        LibUnstructuredStorage.setStorageAddress(EL_FEE_RECIPIENT_ADDRESS, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/river/GlobalFee.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibSanitize.sol\";\nimport \"../../libraries/LibUnstructuredStorage.sol\";\n\n/// @title Global Fee Storage\n/// @notice Utility to manage the Global Fee in storage\nlibrary GlobalFee {\n    /// @notice Storage slot of the Global Fee\n    bytes32 internal constant GLOBAL_FEE_SLOT = bytes32(uint256(keccak256(\"river.state.globalFee\")) - 1);\n\n    /// @notice Retrieve the Global Fee\n    /// @return The Global Fee\n    function get() internal view returns (uint256) {\n        return LibUnstructuredStorage.getStorageUint256(GLOBAL_FEE_SLOT);\n    }\n\n    /// @notice Sets the Global Fee\n    /// @param _newValue New Global Fee\n    function set(uint256 _newValue) internal {\n        LibSanitize._validFee(_newValue);\n        LibUnstructuredStorage.setStorageUint256(GLOBAL_FEE_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/river/LastConsensusLayerReport.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../interfaces/components/IOracleManager.1.sol\";\n\n/// @title Last Consensus Layer Report Storage\n/// @notice Utility to manage the Last Consensus Layer Report in storage\nlibrary LastConsensusLayerReport {\n    /// @notice Storage slot of the Last Consensus Layer Report\n    bytes32 internal constant LAST_CONSENSUS_LAYER_REPORT_SLOT =\n        bytes32(uint256(keccak256(\"river.state.lastConsensusLayerReport\")) - 1);\n\n    /// @notice The structure in storage\n    struct Slot {\n        /// @custom:attribute The structure in storage\n        IOracleManagerV1.StoredConsensusLayerReport value;\n    }\n\n    /// @notice Retrieve the Last Consensus Layer Report from storage\n    /// @return The Last Consensus Layer Report\n    function get() internal view returns (IOracleManagerV1.StoredConsensusLayerReport storage) {\n        bytes32 slot = LAST_CONSENSUS_LAYER_REPORT_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value;\n    }\n\n    /// @notice Set the Last Consensus Layer Report value in storage\n    /// @param _newValue The new value to set in storage\n    function set(IOracleManagerV1.StoredConsensusLayerReport memory _newValue) internal {\n        bytes32 slot = LAST_CONSENSUS_LAYER_REPORT_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        r.value = _newValue;\n    }\n}\n"
    },
    "contracts/src/state/river/LastOracleRoundId.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\n\n/// @title Last Oracle Round Id Storage\n/// @notice Utility to manage the Last Oracle Round Id in storage\n/// @notice This state variable is deprecated and was kept due to migration logic needs\nlibrary LastOracleRoundId {\n    /// @notice Storage slot of the Last Oracle Round Id\n    bytes32 internal constant LAST_ORACLE_ROUND_ID_SLOT =\n        bytes32(uint256(keccak256(\"river.state.lastOracleRoundId\")) - 1);\n\n    /// @notice Retrieve the Last Oracle Round Id\n    /// @return The Last Oracle Round Id\n    function get() internal view returns (bytes32) {\n        return LibUnstructuredStorage.getStorageBytes32(LAST_ORACLE_ROUND_ID_SLOT);\n    }\n\n    /// @notice Sets the Last Oracle Round Id\n    /// @param _newValue New Last Oracle Round Id\n    function set(bytes32 _newValue) internal {\n        LibUnstructuredStorage.setStorageBytes32(LAST_ORACLE_ROUND_ID_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/river/MetadataURI.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\n/// @title Metadata URI Storage\n/// @notice Utility to manage the Metadata in storage\nlibrary MetadataURI {\n    /// @notice Storage slot of the Metadata URI\n    bytes32 internal constant METADATA_URI_SLOT = bytes32(uint256(keccak256(\"river.state.metadataUri\")) - 1);\n\n    /// @notice Structure in storage\n    struct Slot {\n        /// @custom:attribute The metadata value\n        string value;\n    }\n\n    /// @notice Retrieve the metadata URI\n    /// @return The metadata URI string\n    function get() internal view returns (string memory) {\n        bytes32 slot = METADATA_URI_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value;\n    }\n\n    /// @notice Set the metadata URI value\n    /// @param _newValue The new metadata URI value\n    function set(string memory _newValue) internal {\n        bytes32 slot = METADATA_URI_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        r.value = _newValue;\n    }\n}\n"
    },
    "contracts/src/state/river/OperatorsRegistryAddress.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\nimport \"../../libraries/LibSanitize.sol\";\n\n/// @title Operators Registry Address Storage\n/// @notice Utility to manage the Operators Registry Address in storage\nlibrary OperatorsRegistryAddress {\n    /// @notice Storage slot of the Operators Registry Address\n    bytes32 internal constant OPERATORS_REGISTRY_ADDRESS_SLOT =\n        bytes32(uint256(keccak256(\"river.state.operatorsRegistryAddress\")) - 1);\n\n    /// @notice Retrieve the Operators Registry Address\n    /// @return The Operators Registry Address\n    function get() internal view returns (address) {\n        return LibUnstructuredStorage.getStorageAddress(OPERATORS_REGISTRY_ADDRESS_SLOT);\n    }\n\n    /// @notice Sets the Operators Registry Address\n    /// @param _newValue New Operators Registry Address\n    function set(address _newValue) internal {\n        LibSanitize._notZeroAddress(_newValue);\n        LibUnstructuredStorage.setStorageAddress(OPERATORS_REGISTRY_ADDRESS_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/river/OracleAddress.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\nimport \"../../libraries/LibSanitize.sol\";\n\n/// @title Oracle Address Storage\n/// @notice Utility to manage the Oracle Address in storage\nlibrary OracleAddress {\n    /// @notice Storage slot of the Oracle Address\n    bytes32 internal constant ORACLE_ADDRESS_SLOT = bytes32(uint256(keccak256(\"river.state.oracleAddress\")) - 1);\n\n    /// @notice Retrieve the Oracle Address\n    /// @return The Oracle Address\n    function get() internal view returns (address) {\n        return LibUnstructuredStorage.getStorageAddress(ORACLE_ADDRESS_SLOT);\n    }\n\n    /// @notice Sets the Oracle Address\n    /// @param _newValue New Oracle Address\n    function set(address _newValue) internal {\n        LibSanitize._notZeroAddress(_newValue);\n        LibUnstructuredStorage.setStorageAddress(ORACLE_ADDRESS_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/river/RedeemManagerAddress.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\nimport \"../../libraries/LibSanitize.sol\";\n\n/// @title Redeem Manager Address Storage\n/// @notice Utility to manage the Redeem Manager Address in storage\nlibrary RedeemManagerAddress {\n    /// @notice Storage slot of the Redeem Manager Address\n    bytes32 internal constant REDEEM_MANAGER_ADDRESS_SLOT =\n        bytes32(uint256(keccak256(\"river.state.redeemManagerAddress\")) - 1);\n\n    /// @notice Retrieve the Redeem Manager Address\n    /// @return The Redeem Manager Address\n    function get() internal view returns (address) {\n        return LibUnstructuredStorage.getStorageAddress(REDEEM_MANAGER_ADDRESS_SLOT);\n    }\n\n    /// @notice Sets the Redeem Manager Address\n    /// @param _newValue New Redeem Manager Address\n    function set(address _newValue) internal {\n        LibSanitize._notZeroAddress(_newValue);\n        LibUnstructuredStorage.setStorageAddress(REDEEM_MANAGER_ADDRESS_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/river/ReportBounds.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\n/// @title Report Bounds Storage\n/// @notice Utility to manage the Report Bounds in storage\nlibrary ReportBounds {\n    /// @notice Storage slot of the Report Bounds\n    bytes32 internal constant REPORT_BOUNDS_SLOT = bytes32(uint256(keccak256(\"river.state.reportBounds\")) - 1);\n\n    /// @notice The Report Bounds structure\n    struct ReportBoundsStruct {\n        /// @custom:attribute The maximum allowed annual apr, checked before submitting a report to River\n        uint256 annualAprUpperBound;\n        /// @custom:attribute The maximum allowed balance decrease, also checked before submitting a report to River\n        uint256 relativeLowerBound;\n    }\n\n    /// @notice The structure in storage\n    struct Slot {\n        /// @custom:attribute The structure in storage\n        ReportBoundsStruct value;\n    }\n\n    /// @notice Retrieve the Report Bounds from storage\n    /// @return The Report Bounds\n    function get() internal view returns (ReportBoundsStruct memory) {\n        bytes32 slot = REPORT_BOUNDS_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value;\n    }\n\n    /// @notice Set the Report Bounds in storage\n    /// @param _newReportBounds The new Report Bounds value\n    function set(ReportBoundsStruct memory _newReportBounds) internal {\n        bytes32 slot = REPORT_BOUNDS_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        r.value = _newReportBounds;\n    }\n}\n"
    },
    "contracts/src/state/river/Shares.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\n\n/// @title Shares Count Storage\n/// @notice Utility to manage the Shares Count in storage\nlibrary Shares {\n    /// @notice Storage slot of the Shares Count\n    bytes32 internal constant SHARES_SLOT = bytes32(uint256(keccak256(\"river.state.shares\")) - 1);\n\n    /// @notice Retrieve the Shares Count\n    /// @return The Shares Count\n    function get() internal view returns (uint256) {\n        return LibUnstructuredStorage.getStorageUint256(SHARES_SLOT);\n    }\n\n    /// @notice Sets the Shares Count\n    /// @param _newValue New Shares Count\n    function set(uint256 _newValue) internal {\n        LibUnstructuredStorage.setStorageUint256(SHARES_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/river/SharesPerOwner.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\n/// @title Shares Per Owner Storage\n/// @notice Utility to manage the Shares Per Owner in storage\nlibrary SharesPerOwner {\n    /// @notice Storage slot of the Shares Per Owner\n    bytes32 internal constant SHARES_PER_OWNER_SLOT = bytes32(uint256(keccak256(\"river.state.sharesPerOwner\")) - 1);\n\n    /// @notice Structure in storage\n    struct Slot {\n        /// @custom:attribute The mapping from an owner to its share count\n        mapping(address =\u003e uint256) value;\n    }\n\n    /// @notice Retrieve the share count for given owner\n    /// @param _owner The address to get the balance of\n    /// @return The amount of shares\n    function get(address _owner) internal view returns (uint256) {\n        bytes32 slot = SHARES_PER_OWNER_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value[_owner];\n    }\n\n    /// @notice Set the amount of shares for an owner\n    /// @param _owner The owner of the shares to edit\n    /// @param _newValue The new shares value for the owner\n    function set(address _owner, uint256 _newValue) internal {\n        bytes32 slot = SHARES_PER_OWNER_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        r.value[_owner] = _newValue;\n    }\n}\n"
    },
    "contracts/src/state/river/WithdrawalCredentials.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibErrors.sol\";\nimport \"../../libraries/LibUnstructuredStorage.sol\";\n\n/// @title Withdrawal Credentials Storage\n/// @notice Utility to manage the Withdrawal Credentials in storage\nlibrary WithdrawalCredentials {\n    /// @notice Storage slot of the Withdrawal Credentials\n    bytes32 internal constant WITHDRAWAL_CREDENTIALS_SLOT =\n        bytes32(uint256(keccak256(\"river.state.withdrawalCredentials\")) - 1);\n\n    /// @notice Retrieve the Withdrawal Credentials\n    /// @return The Withdrawal Credentials\n    function get() internal view returns (bytes32) {\n        return LibUnstructuredStorage.getStorageBytes32(WITHDRAWAL_CREDENTIALS_SLOT);\n    }\n\n    /// @notice Retrieve the Withdrawal Credential under its address format\n    /// @return The Withdrawal Credentials in its address format\n    function getAddress() internal view returns (address) {\n        return LibUnstructuredStorage.getStorageAddress(WITHDRAWAL_CREDENTIALS_SLOT);\n    }\n\n    /// @notice Sets the Withdrawal Credentials\n    /// @param _newValue New Withdrawal Credentials\n    function set(bytes32 _newValue) internal {\n        if (_newValue == bytes32(0)) {\n            revert LibErrors.InvalidArgument();\n        }\n        LibUnstructuredStorage.setStorageBytes32(WITHDRAWAL_CREDENTIALS_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/shared/AdministratorAddress.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\nimport \"../../libraries/LibSanitize.sol\";\n\n/// @title Administrator Address Storage\n/// @notice Utility to manage the Administrator Address in storage\nlibrary AdministratorAddress {\n    /// @notice Storage slot of the Administrator Address\n    bytes32 public constant ADMINISTRATOR_ADDRESS_SLOT =\n        bytes32(uint256(keccak256(\"river.state.administratorAddress\")) - 1);\n\n    /// @notice Retrieve the Administrator Address\n    /// @return The Administrator Address\n    function get() internal view returns (address) {\n        return LibUnstructuredStorage.getStorageAddress(ADMINISTRATOR_ADDRESS_SLOT);\n    }\n\n    /// @notice Sets the Administrator Address\n    /// @param _newValue New Administrator Address\n    function set(address _newValue) internal {\n        LibSanitize._notZeroAddress(_newValue);\n        LibUnstructuredStorage.setStorageAddress(ADMINISTRATOR_ADDRESS_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/shared/ApprovalsPerOwner.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\n/// @title Approvals Per Owner Storage\n/// @notice Utility to manage the Approvals Per Owner in storage\nlibrary ApprovalsPerOwner {\n    /// @notice Storage slot of the Approvals Per Owner\n    bytes32 internal constant APPROVALS_PER_OWNER_SLOT =\n        bytes32(uint256(keccak256(\"river.state.approvalsPerOwner\")) - 1);\n\n    /// @notice The structure in storage\n    struct Slot {\n        /// @custom:attribute The mapping from an owner to an operator to the approval amount\n        mapping(address =\u003e mapping(address =\u003e uint256)) value;\n    }\n\n    /// @notice Retrieve the approval for an owner to an operator\n    /// @param _owner The account that gave the approval\n    /// @param _operator The account receiving the approval\n    /// @return The value of the approval\n    function get(address _owner, address _operator) internal view returns (uint256) {\n        bytes32 slot = APPROVALS_PER_OWNER_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value[_owner][_operator];\n    }\n\n    /// @notice Set the approval value for an owner to an operator\n    /// @param _owner The account that gives the approval\n    /// @param _operator The account receiving the approval\n    /// @param _newValue The value of the approval\n    function set(address _owner, address _operator, uint256 _newValue) internal {\n        bytes32 slot = APPROVALS_PER_OWNER_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        r.value[_owner][_operator] = _newValue;\n    }\n}\n"
    },
    "contracts/src/state/shared/PendingAdministratorAddress.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\n\n/// @title Pending Administrator Address Storage\n/// @notice Utility to manage the Pending Administrator Address in storage\nlibrary PendingAdministratorAddress {\n    /// @notice Storage slot of the Pending Administrator Address\n    bytes32 public constant PENDING_ADMINISTRATOR_ADDRESS_SLOT =\n        bytes32(uint256(keccak256(\"river.state.pendingAdministratorAddress\")) - 1);\n\n    /// @notice Retrieve the Pending Administrator Address\n    /// @return The Pending Administrator Address\n    function get() internal view returns (address) {\n        return LibUnstructuredStorage.getStorageAddress(PENDING_ADMINISTRATOR_ADDRESS_SLOT);\n    }\n\n    /// @notice Sets the Pending Administrator Address\n    /// @param _newValue New Pending Administrator Address\n    function set(address _newValue) internal {\n        LibUnstructuredStorage.setStorageAddress(PENDING_ADMINISTRATOR_ADDRESS_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/shared/Version.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\n\n/// @title Version Storage\n/// @notice Utility to manage the Version in storage\nlibrary Version {\n    /// @notice Storage slot of the Version\n    bytes32 public constant VERSION_SLOT = bytes32(uint256(keccak256(\"river.state.version\")) - 1);\n\n    /// @notice Retrieve the Version\n    /// @return The Version\n    function get() internal view returns (uint256) {\n        return LibUnstructuredStorage.getStorageUint256(VERSION_SLOT);\n    }\n\n    /// @notice Sets the Version\n    /// @param _newValue New Version\n    function set(uint256 _newValue) internal {\n        LibUnstructuredStorage.setStorageUint256(VERSION_SLOT, _newValue);\n    }\n}\n"
    },
    "openzeppelin-contracts/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    }
  }
}