{
  "language": "Solidity",
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 100
    }
  },
  "sources": {
    "contracts/src/Administrable.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"./interfaces/IAdministrable.sol\";\n\nimport \"./libraries/LibAdministrable.sol\";\nimport \"./libraries/LibSanitize.sol\";\n\n/// @title Administrable\n/// @author Kiln\n/// @notice This contract handles the administration of the contracts\nabstract contract Administrable is IAdministrable {\n    /// @notice Prevents unauthorized calls\n    modifier onlyAdmin() {\n        if (msg.sender != LibAdministrable._getAdmin()) {\n            revert LibErrors.Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    /// @notice Prevents unauthorized calls\n    modifier onlyPendingAdmin() {\n        if (msg.sender != LibAdministrable._getPendingAdmin()) {\n            revert LibErrors.Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    /// @inheritdoc IAdministrable\n    function getAdmin() external view returns (address) {\n        return LibAdministrable._getAdmin();\n    }\n\n    /// @inheritdoc IAdministrable\n    function getPendingAdmin() external view returns (address) {\n        return LibAdministrable._getPendingAdmin();\n    }\n\n    /// @inheritdoc IAdministrable\n    function proposeAdmin(address _newAdmin) external onlyAdmin {\n        _setPendingAdmin(_newAdmin);\n    }\n\n    /// @inheritdoc IAdministrable\n    function acceptAdmin() external onlyPendingAdmin {\n        _setAdmin(LibAdministrable._getPendingAdmin());\n        _setPendingAdmin(address(0));\n    }\n\n    /// @notice Internal utility to set the admin address\n    /// @param _admin Address to set as admin\n    function _setAdmin(address _admin) internal {\n        LibSanitize._notZeroAddress(_admin);\n        LibAdministrable._setAdmin(_admin);\n        emit SetAdmin(_admin);\n    }\n\n    /// @notice Internal utility to set the pending admin address\n    /// @param _pendingAdmin Address to set as pending admin\n    function _setPendingAdmin(address _pendingAdmin) internal {\n        LibAdministrable._setPendingAdmin(_pendingAdmin);\n        emit SetPendingAdmin(_pendingAdmin);\n    }\n\n    /// @notice Internal utility to retrieve the address of the current admin\n    /// @return The address of admin\n    function _getAdmin() internal view returns (address) {\n        return LibAdministrable._getAdmin();\n    }\n}\n"
    },
    "contracts/src/Initializable.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"./state/shared/Version.sol\";\n\n/// @title Initializable\n/// @author Kiln\n/// @notice This contract ensures that initializers are called only once per version\ncontract Initializable {\n    /// @notice An error occured during the initialization\n    /// @param version The version that was attempting to be initialized\n    /// @param expectedVersion The version that was expected\n    error InvalidInitialization(uint256 version, uint256 expectedVersion);\n\n    /// @notice Emitted when the contract is properly initialized\n    /// @param version New version of the contracts\n    /// @param cdata Complete calldata that was used during the initialization\n    event Initialize(uint256 version, bytes cdata);\n\n    /// @notice Use this modifier on initializers along with a hard-coded version number\n    /// @param _version Version to initialize\n    modifier init(uint256 _version) {\n        if (_version != Version.get()) {\n            revert InvalidInitialization(_version, Version.get());\n        }\n        Version.set(_version + 1); // prevents reentrency on the called method\n        _;\n        emit Initialize(_version, msg.data);\n    }\n}\n"
    },
    "contracts/src/Oracle.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"./interfaces/IRiver.1.sol\";\nimport \"./interfaces/IOracle.1.sol\";\n\nimport \"./Administrable.sol\";\nimport \"./Initializable.sol\";\n\nimport \"./state/shared/RiverAddress.sol\";\nimport \"./state/oracle/OracleMembers.sol\";\nimport \"./state/oracle/Quorum.sol\";\nimport \"./state/oracle/ExpectedEpochId.sol\";\nimport \"./state/oracle/LastEpochId.sol\";\nimport \"./state/oracle/ReportsPositions.sol\";\nimport \"./state/oracle/ReportsVariants.sol\";\n\n/// @title Oracle (v1)\n/// @author Kiln\n/// @notice This contract handles the input from the allowed oracle members. Highly inspired by Lido's implementation.\ncontract OracleV1 is IOracleV1, Initializable, Administrable {\n    /// @notice One Year value\n    uint256 internal constant ONE_YEAR = 365 days;\n\n    /// @notice Received ETH input has only 9 decimals\n    uint128 internal constant DENOMINATION_OFFSET = 1e9;\n\n    /// @inheritdoc IOracleV1\n    function initOracleV1(\n        address _river,\n        address _administratorAddress,\n        uint64 _epochsPerFrame,\n        uint64 _slotsPerEpoch,\n        uint64 _secondsPerSlot,\n        uint64 _genesisTime,\n        uint256 _annualAprUpperBound,\n        uint256 _relativeLowerBound\n    ) external init(0) {\n        _setAdmin(_administratorAddress);\n        RiverAddress.set(_river);\n        emit SetRiver(_river);\n        CLSpec.set(\n            CLSpec.CLSpecStruct({\n                epochsPerFrame: _epochsPerFrame,\n                slotsPerEpoch: _slotsPerEpoch,\n                secondsPerSlot: _secondsPerSlot,\n                genesisTime: _genesisTime\n            })\n        );\n        emit SetSpec(_epochsPerFrame, _slotsPerEpoch, _secondsPerSlot, _genesisTime);\n        ReportBounds.set(\n            ReportBounds.ReportBoundsStruct({\n                annualAprUpperBound: _annualAprUpperBound,\n                relativeLowerBound: _relativeLowerBound\n            })\n        );\n        emit SetBounds(_annualAprUpperBound, _relativeLowerBound);\n        Quorum.set(0);\n        emit SetQuorum(0);\n    }\n\n    /// @inheritdoc IOracleV1\n    function getRiver() external view returns (address) {\n        return RiverAddress.get();\n    }\n\n    /// @inheritdoc IOracleV1\n    function getTime() external view returns (uint256) {\n        return _getTime();\n    }\n\n    /// @inheritdoc IOracleV1\n    function getExpectedEpochId() external view returns (uint256) {\n        return ExpectedEpochId.get();\n    }\n\n    /// @inheritdoc IOracleV1\n    function getMemberReportStatus(address _oracleMember) external view returns (bool) {\n        int256 memberIndex = OracleMembers.indexOf(_oracleMember);\n        return memberIndex != -1 \u0026\u0026 ReportsPositions.get(uint256(memberIndex));\n    }\n\n    /// @inheritdoc IOracleV1\n    function getGlobalReportStatus() external view returns (uint256) {\n        return ReportsPositions.getRaw();\n    }\n\n    /// @inheritdoc IOracleV1\n    function getReportVariantsCount() external view returns (uint256) {\n        return ReportsVariants.get().length;\n    }\n\n    /// @inheritdoc IOracleV1\n    function getReportVariant(uint256 _idx)\n        external\n        view\n        returns (uint64 _clBalance, uint32 _clValidators, uint16 _reportCount)\n    {\n        uint256 report = ReportsVariants.get()[_idx];\n        (_clBalance, _clValidators) = _decodeReport(report);\n        _reportCount = _getReportCount(report);\n    }\n\n    /// @inheritdoc IOracleV1\n    function getLastCompletedEpochId() external view returns (uint256) {\n        return LastEpochId.get();\n    }\n\n    /// @inheritdoc IOracleV1\n    function getCurrentEpochId() external view returns (uint256) {\n        CLSpec.CLSpecStruct memory clSpec = CLSpec.get();\n        return _getCurrentEpochId(clSpec);\n    }\n\n    /// @inheritdoc IOracleV1\n    function getQuorum() external view returns (uint256) {\n        return Quorum.get();\n    }\n\n    /// @inheritdoc IOracleV1\n    function getCLSpec() external view returns (CLSpec.CLSpecStruct memory) {\n        return CLSpec.get();\n    }\n\n    /// @inheritdoc IOracleV1\n    function getCurrentFrame() external view returns (uint256 _startEpochId, uint256 _startTime, uint256 _endTime) {\n        CLSpec.CLSpecStruct memory clSpec = CLSpec.get();\n        _startEpochId = _getFrameFirstEpochId(_getCurrentEpochId(clSpec), clSpec);\n        uint256 secondsPerEpoch = clSpec.secondsPerSlot * clSpec.slotsPerEpoch;\n        _startTime = clSpec.genesisTime + _startEpochId * secondsPerEpoch;\n        _endTime = _startTime + secondsPerEpoch * clSpec.epochsPerFrame - 1;\n    }\n\n    /// @inheritdoc IOracleV1\n    function getFrameFirstEpochId(uint256 _epochId) external view returns (uint256) {\n        CLSpec.CLSpecStruct memory clSpec = CLSpec.get();\n        return _getFrameFirstEpochId(_epochId, clSpec);\n    }\n\n    /// @inheritdoc IOracleV1\n    function getReportBounds() external view returns (ReportBounds.ReportBoundsStruct memory) {\n        return ReportBounds.get();\n    }\n\n    /// @inheritdoc IOracleV1\n    function getOracleMembers() external view returns (address[] memory) {\n        return OracleMembers.get();\n    }\n\n    /// @inheritdoc IOracleV1\n    function isMember(address _memberAddress) external view returns (bool) {\n        return OracleMembers.indexOf(_memberAddress) \u003e= 0;\n    }\n\n    /// @inheritdoc IOracleV1\n    function addMember(address _newOracleMember, uint256 _newQuorum) external onlyAdmin {\n        int256 memberIdx = OracleMembers.indexOf(_newOracleMember);\n        if (memberIdx \u003e= 0) {\n            revert AddressAlreadyInUse(_newOracleMember);\n        }\n        OracleMembers.push(_newOracleMember);\n        uint256 previousQuorum = Quorum.get();\n        _clearReportsAndSetQuorum(_newQuorum, previousQuorum);\n        emit AddMember(_newOracleMember);\n    }\n\n    /// @inheritdoc IOracleV1\n    function removeMember(address _oracleMember, uint256 _newQuorum) external onlyAdmin {\n        int256 memberIdx = OracleMembers.indexOf(_oracleMember);\n        if (memberIdx \u003c 0) {\n            revert LibErrors.InvalidCall();\n        }\n        OracleMembers.deleteItem(uint256(memberIdx));\n        uint256 previousQuorum = Quorum.get();\n        _clearReportsAndSetQuorum(_newQuorum, previousQuorum);\n        emit RemoveMember(_oracleMember);\n    }\n\n    /// @inheritdoc IOracleV1\n    function setMember(address _oracleMember, address _newAddress) external onlyAdmin {\n        LibSanitize._notZeroAddress(_newAddress);\n        if (OracleMembers.indexOf(_newAddress) \u003e= 0) {\n            revert AddressAlreadyInUse(_newAddress);\n        }\n        int256 memberIdx = OracleMembers.indexOf(_oracleMember);\n        if (memberIdx \u003c 0) {\n            revert LibErrors.InvalidCall();\n        }\n        OracleMembers.set(uint256(memberIdx), _newAddress);\n        emit SetMember(_oracleMember, _newAddress);\n        _clearReports();\n    }\n\n    /// @inheritdoc IOracleV1\n    function setCLSpec(uint64 _epochsPerFrame, uint64 _slotsPerEpoch, uint64 _secondsPerSlot, uint64 _genesisTime)\n        external\n        onlyAdmin\n    {\n        CLSpec.set(\n            CLSpec.CLSpecStruct({\n                epochsPerFrame: _epochsPerFrame,\n                slotsPerEpoch: _slotsPerEpoch,\n                secondsPerSlot: _secondsPerSlot,\n                genesisTime: _genesisTime\n            })\n        );\n        emit SetSpec(_epochsPerFrame, _slotsPerEpoch, _secondsPerSlot, _genesisTime);\n    }\n\n    /// @inheritdoc IOracleV1\n    function setReportBounds(uint256 _annualAprUpperBound, uint256 _relativeLowerBound) external onlyAdmin {\n        ReportBounds.set(\n            ReportBounds.ReportBoundsStruct({\n                annualAprUpperBound: _annualAprUpperBound,\n                relativeLowerBound: _relativeLowerBound\n            })\n        );\n        emit SetBounds(_annualAprUpperBound, _relativeLowerBound);\n    }\n\n    /// @inheritdoc IOracleV1\n    function setQuorum(uint256 _newQuorum) external onlyAdmin {\n        uint256 previousQuorum = Quorum.get();\n        if (previousQuorum == _newQuorum) {\n            revert LibErrors.InvalidArgument();\n        }\n        _clearReportsAndSetQuorum(_newQuorum, previousQuorum);\n    }\n\n    /// @inheritdoc IOracleV1\n    function reportConsensusLayerData(uint256 _epochId, uint64 _clValidatorsBalance, uint32 _clValidatorCount)\n        external\n    {\n        int256 memberIndex = OracleMembers.indexOf(msg.sender);\n        if (memberIndex == -1) {\n            revert LibErrors.Unauthorized(msg.sender);\n        }\n\n        CLSpec.CLSpecStruct memory clSpec = CLSpec.get();\n        uint256 expectedEpochId = ExpectedEpochId.get();\n        if (_epochId \u003c expectedEpochId) {\n            revert EpochTooOld(_epochId, expectedEpochId);\n        }\n\n        if (_epochId \u003e expectedEpochId) {\n            uint256 frameFirstEpochId = _getFrameFirstEpochId(_getCurrentEpochId(clSpec), clSpec);\n            if (_epochId != frameFirstEpochId) {\n                revert NotFrameFirstEpochId(_epochId, frameFirstEpochId);\n            }\n            _clearReportsAndUpdateExpectedEpochId(_epochId);\n        }\n\n        if (ReportsPositions.get(uint256(memberIndex))) {\n            revert AlreadyReported(_epochId, msg.sender);\n        }\n        ReportsPositions.register(uint256(memberIndex));\n\n        uint128 clBalanceEth1 = DENOMINATION_OFFSET * uint128(_clValidatorsBalance);\n        emit CLReported(_epochId, clBalanceEth1, _clValidatorCount, msg.sender);\n\n        uint256 report = _encodeReport(_clValidatorsBalance, _clValidatorCount);\n        int256 reportIndex = ReportsVariants.indexOfReport(report);\n        uint256 quorum = Quorum.get();\n\n        if (reportIndex \u003e= 0) {\n            uint256 registeredReport = ReportsVariants.get()[uint256(reportIndex)];\n            if (_getReportCount(registeredReport) + 1 \u003e= quorum) {\n                _pushToRiver(_epochId, clBalanceEth1, _clValidatorCount, clSpec);\n            } else {\n                ReportsVariants.set(uint256(reportIndex), registeredReport + 1);\n            }\n        } else {\n            if (quorum == 1) {\n                _pushToRiver(_epochId, clBalanceEth1, _clValidatorCount, clSpec);\n            } else {\n                ReportsVariants.push(report + 1);\n            }\n        }\n    }\n\n    /// @notice Internal utility to clear all the reports and edit the quorum if a new value is provided\n    /// @dev Ensures that the quorum respects invariants\n    /// @dev The admin is in charge of providing a proper quorum based on the oracle member count\n    /// @dev The quorum value Q should respect the following invariant, where O is oracle member count\n    /// @dev (O / 2) + 1 \u003c= Q \u003c= O\n    /// @param _newQuorum New quorum value\n    /// @param _previousQuorum The old quorum value\n    function _clearReportsAndSetQuorum(uint256 _newQuorum, uint256 _previousQuorum) internal {\n        uint256 memberCount = OracleMembers.get().length;\n        if ((_newQuorum == 0 \u0026\u0026 memberCount \u003e 0) || _newQuorum \u003e memberCount) {\n            revert LibErrors.InvalidArgument();\n        }\n        _clearReports();\n        if (_newQuorum != _previousQuorum) {\n            Quorum.set(_newQuorum);\n            emit SetQuorum(_newQuorum);\n        }\n    }\n\n    /// @notice Retrieve the block timestamp\n    /// @return The block timestamp\n    function _getTime() internal view returns (uint256) {\n        return block.timestamp; // solhint-disable-line not-rely-on-time\n    }\n\n    /// @notice Retrieve the current epoch id based on block timestamp\n    /// @param _clSpec CL spec parameters\n    /// @return The current epoch id\n    function _getCurrentEpochId(CLSpec.CLSpecStruct memory _clSpec) internal view returns (uint256) {\n        return (_getTime() - _clSpec.genesisTime) / (_clSpec.slotsPerEpoch * _clSpec.secondsPerSlot);\n    }\n\n    /// @notice Retrieve the first epoch id of the frame of the provided epoch id\n    /// @param _epochId Epoch id used to get the frame\n    /// @param _clSpec CL spec parameters\n    /// @return The epoch id at the beginning of the frame\n    function _getFrameFirstEpochId(uint256 _epochId, CLSpec.CLSpecStruct memory _clSpec)\n        internal\n        pure\n        returns (uint256)\n    {\n        return (_epochId / _clSpec.epochsPerFrame) * _clSpec.epochsPerFrame;\n    }\n\n    /// @notice Clear reporting data\n    /// @param _epochId Next expected epoch id (first epoch of the next frame)\n    function _clearReportsAndUpdateExpectedEpochId(uint256 _epochId) internal {\n        _clearReports();\n        ExpectedEpochId.set(_epochId);\n        emit ExpectedEpochIdUpdated(_epochId);\n    }\n\n    /// @notice Internal utility to clear the reporting data\n    function _clearReports() internal {\n        ReportsPositions.clear();\n        ReportsVariants.clear();\n    }\n\n    /// @notice Encode report into one slot. Last 16 bits are free to use for vote counting.\n    /// @param _clBalance Total validator balance\n    /// @param _clValidators Total validator count\n    /// @return The encoded report value\n    function _encodeReport(uint64 _clBalance, uint32 _clValidators) internal pure returns (uint256) {\n        return (uint256(_clBalance) \u003c\u003c 48) | (uint256(_clValidators) \u003c\u003c 16);\n    }\n\n    /// @notice Decode report from one slot to two variables, ignoring the last 16 bits\n    /// @param _value Encoded report\n    function _decodeReport(uint256 _value) internal pure returns (uint64 _clBalance, uint32 _clValidators) {\n        _clBalance = uint64(_value \u003e\u003e 48);\n        _clValidators = uint32(_value \u003e\u003e 16);\n    }\n\n    /// @notice Retrieve the vote count from the encoded report (last 16 bits)\n    /// @param _report Encoded report\n    /// @return The report count\n    function _getReportCount(uint256 _report) internal pure returns (uint16) {\n        return uint16(_report);\n    }\n\n    /// @notice Compute the max allowed increase based on the previous total balance and the time elapsed\n    /// @param _prevTotalEth The previous total balance\n    /// @param _timeElapsed The time since last report\n    /// @return The maximum increase in balance allowed\n    function _maxIncrease(uint256 _prevTotalEth, uint256 _timeElapsed) internal view returns (uint256) {\n        uint256 annualAprUpperBound = ReportBounds.get().annualAprUpperBound;\n        return (_prevTotalEth * annualAprUpperBound * _timeElapsed) / (LibBasisPoints.BASIS_POINTS_MAX * ONE_YEAR);\n    }\n\n    /// @notice Performs sanity checks to prevent an erroneous update to the River system\n    /// @param _postTotalEth Total validator balance after update\n    /// @param _prevTotalEth Total validator balance before update\n    /// @param _timeElapsed Time since last update\n    function _sanityChecks(uint256 _postTotalEth, uint256 _prevTotalEth, uint256 _timeElapsed) internal view {\n        if (_postTotalEth \u003e= _prevTotalEth) {\n            // increase                 = _postTotalPooledEther - _preTotalPooledEther,\n            // relativeIncrease         = increase / _preTotalPooledEther,\n            // annualRelativeIncrease   = relativeIncrease / (timeElapsed / 365 days),\n            // annualRelativeIncreaseBp = annualRelativeIncrease * 10000, in basis points 0.01% (1e-4)\n            uint256 annualAprUpperBound = ReportBounds.get().annualAprUpperBound;\n            // check that annualRelativeIncreaseBp \u003c= allowedAnnualRelativeIncreaseBp\n            if (\n                LibBasisPoints.BASIS_POINTS_MAX * ONE_YEAR * (_postTotalEth - _prevTotalEth)\n                    \u003e annualAprUpperBound * _prevTotalEth * _timeElapsed\n            ) {\n                revert TotalValidatorBalanceIncreaseOutOfBound(\n                    _prevTotalEth, _postTotalEth, _timeElapsed, annualAprUpperBound\n                );\n            }\n        } else {\n            // decrease           = _preTotalPooledEther - _postTotalPooledEther\n            // relativeDecrease   = decrease / _preTotalPooledEther\n            // relativeDecreaseBp = relativeDecrease * 10000, in basis points 0.01% (1e-4)\n            uint256 relativeLowerBound = ReportBounds.get().relativeLowerBound;\n            // check that relativeDecreaseBp \u003c= allowedRelativeDecreaseBp\n            if (LibBasisPoints.BASIS_POINTS_MAX * (_prevTotalEth - _postTotalEth) \u003e relativeLowerBound * _prevTotalEth)\n            {\n                revert TotalValidatorBalanceDecreaseOutOfBound(\n                    _prevTotalEth, _postTotalEth, _timeElapsed, relativeLowerBound\n                );\n            }\n        }\n    }\n\n    /// @notice Push the new cl data to the river system and performs sanity checks\n    /// @dev At this point, the maximum increase allowed to the previous total asset balance is computed and\n    /// @dev provided to River. It's then up to River to manage how extra funds are injected in the system\n    /// @dev and make sure the limit is not crossed. If the _totalBalance is already crossing this limit,\n    /// @dev then there is nothing River can do to prevent it.\n    /// @dev These extra funds are:\n    /// @dev - the execution layer fees\n    /// @param _epochId Id of the epoch\n    /// @param _totalBalance Total validator balance\n    /// @param _validatorCount Total validator count\n    /// @param _clSpec CL spec parameters\n    function _pushToRiver(\n        uint256 _epochId,\n        uint128 _totalBalance,\n        uint32 _validatorCount,\n        CLSpec.CLSpecStruct memory _clSpec\n    ) internal {\n        _clearReportsAndUpdateExpectedEpochId(_epochId + _clSpec.epochsPerFrame);\n\n        IRiverV1 river = IRiverV1(payable(RiverAddress.get()));\n        uint256 prevTotalEth = river.totalUnderlyingSupply();\n        uint256 timeElapsed = (_epochId - LastEpochId.get()) * _clSpec.slotsPerEpoch * _clSpec.secondsPerSlot;\n        uint256 maxIncrease = _maxIncrease(prevTotalEth, timeElapsed);\n        river.setConsensusLayerData(_validatorCount, _totalBalance, bytes32(_epochId), maxIncrease);\n        uint256 postTotalEth = river.totalUnderlyingSupply();\n\n        _sanityChecks(postTotalEth, prevTotalEth, timeElapsed);\n        LastEpochId.set(_epochId);\n\n        emit PostTotalShares(postTotalEth, prevTotalEth, timeElapsed, river.totalSupply());\n    }\n}\n"
    },
    "contracts/src/interfaces/IAdministrable.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\n/// @title Administrable Interface\n/// @author Kiln\n/// @notice This interface exposes methods to handle the ownership of the contracts\ninterface IAdministrable {\n    /// @notice The pending admin address changed\n    /// @param pendingAdmin New pending admin address\n    event SetPendingAdmin(address indexed pendingAdmin);\n\n    /// @notice The admin address changed\n    /// @param admin New admin address\n    event SetAdmin(address indexed admin);\n\n    /// @notice Retrieves the current admin address\n    /// @return The admin address\n    function getAdmin() external view returns (address);\n\n    /// @notice Retrieve the current pending admin address\n    /// @return The pending admin address\n    function getPendingAdmin() external view returns (address);\n\n    /// @notice Proposes a new address as admin\n    /// @dev This security prevents setting an invalid address as an admin. The pending\n    /// @dev admin has to claim its ownership of the contract, and prove that the new\n    /// @dev address is able to perform regular transactions.\n    /// @param _newAdmin New admin address\n    function proposeAdmin(address _newAdmin) external;\n\n    /// @notice Accept the transfer of ownership\n    /// @dev Only callable by the pending admin. Resets the pending admin if succesful.\n    function acceptAdmin() external;\n}\n"
    },
    "contracts/src/interfaces/IOracle.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../state/oracle/CLSpec.sol\";\nimport \"../state/oracle/ReportBounds.sol\";\n\n/// @title Oracle Interface (v1)\n/// @author Kiln\n/// @notice This interface exposes methods to handle the input from the allowed oracle members.\n/// @notice Highly inspired by Lido's implementation.\ninterface IOracleV1 {\n    /// @notice Consensus Layer data has been reported by an oracle member\n    /// @param epochId The epoch of the report\n    /// @param newCLBalance The new consensus layer balance\n    /// @param newCLValidatorCount The new consensus layer validator count\n    /// @param oracleMember The oracle member that reported\n    event CLReported(uint256 epochId, uint128 newCLBalance, uint32 newCLValidatorCount, address oracleMember);\n\n    /// @notice The storage quorum value has been changed\n    /// @param newQuorum The new quorum value\n    event SetQuorum(uint256 newQuorum);\n\n    /// @notice The expected epoch id has been changed\n    /// @param epochId The new expected epoch id\n    event ExpectedEpochIdUpdated(uint256 epochId);\n\n    /// @notice The report has been submitted to river\n    /// @param postTotalEth The new total ETH balance\n    /// @param prevTotalEth The previous total ETH balance\n    /// @param timeElapsed Time since last report\n    /// @param totalShares The new total amount of shares\n    event PostTotalShares(uint256 postTotalEth, uint256 prevTotalEth, uint256 timeElapsed, uint256 totalShares);\n\n    /// @notice A member has been added to the oracle member list\n    /// @param member The address of the member\n    event AddMember(address indexed member);\n\n    /// @notice A member has been removed from the oracle member list\n    /// @param member The address of the member\n    event RemoveMember(address indexed member);\n\n    /// @notice A member address has been edited\n    /// @param oldAddress The previous member address\n    /// @param newAddress The new member address\n    event SetMember(address indexed oldAddress, address indexed newAddress);\n\n    /// @notice The storage river address value has been changed\n    /// @param _river The new river address\n    event SetRiver(address _river);\n\n    /// @notice The consensus layer spec has been changed\n    /// @param epochsPerFrame The number of epochs inside a frame (225 = 24 hours)\n    /// @param slotsPerEpoch The number of slots inside an epoch (32 on ethereum mainnet)\n    /// @param secondsPerSlot The time between two slots (12 seconds on ethereum mainnet)\n    /// @param genesisTime The timestamp of block #0\n    event SetSpec(uint64 epochsPerFrame, uint64 slotsPerEpoch, uint64 secondsPerSlot, uint64 genesisTime);\n\n    /// @notice The report bounds have been changed\n    /// @param annualAprUpperBound The maximum allowed apr. 10% means increases in balance extrapolated to a year should not exceed 10%.\n    /// @param relativeLowerBound The maximum allowed balance decrease as a relative % of the total balance\n    event SetBounds(uint256 annualAprUpperBound, uint256 relativeLowerBound);\n\n    /// @notice The provided epoch is too old compared to the expected epoch id\n    /// @param providedEpochId The epoch id provided as input\n    /// @param minExpectedEpochId The minimum epoch id expected\n    error EpochTooOld(uint256 providedEpochId, uint256 minExpectedEpochId);\n\n    /// @notice The provided epoch is not at the beginning of its frame\n    /// @param providedEpochId The epoch id provided as input\n    /// @param expectedFrameFirstEpochId The frame first epoch id that was expected\n    error NotFrameFirstEpochId(uint256 providedEpochId, uint256 expectedFrameFirstEpochId);\n\n    /// @notice The member already reported on the given epoch id\n    /// @param epochId The epoch id provided as input\n    /// @param member The oracle member\n    error AlreadyReported(uint256 epochId, address member);\n\n    /// @notice The delta in balance is above the allowed upper bound\n    /// @param prevTotalEth The previous total balance\n    /// @param postTotalEth The new total balance\n    /// @param timeElapsed The time since last report\n    /// @param annualAprUpperBound The maximum apr allowed\n    error TotalValidatorBalanceIncreaseOutOfBound(\n        uint256 prevTotalEth, uint256 postTotalEth, uint256 timeElapsed, uint256 annualAprUpperBound\n    );\n\n    /// @notice The negative delta in balance is above the allowed lower bound\n    /// @param prevTotalEth The previous total balance\n    /// @param postTotalEth The new total balance\n    /// @param timeElapsed The time since last report\n    /// @param relativeLowerBound The maximum relative decrease allowed\n    error TotalValidatorBalanceDecreaseOutOfBound(\n        uint256 prevTotalEth, uint256 postTotalEth, uint256 timeElapsed, uint256 relativeLowerBound\n    );\n\n    /// @notice The address is already in use by an oracle member\n    /// @param newAddress The address already in use\n    error AddressAlreadyInUse(address newAddress);\n\n    /// @notice Initializes the oracle\n    /// @param _river Address of the River contract, able to receive oracle input data after quorum is met\n    /// @param _administratorAddress Address able to call administrative methods\n    /// @param _epochsPerFrame CL spec parameter. Number of epochs in a frame.\n    /// @param _slotsPerEpoch CL spec parameter. Number of slots in one epoch.\n    /// @param _secondsPerSlot CL spec parameter. Number of seconds between slots.\n    /// @param _genesisTime CL spec parameter. Timestamp of the genesis slot.\n    /// @param _annualAprUpperBound CL bound parameter. Maximum apr allowed for balance increase. Delta between updates is extrapolated on a year time frame.\n    /// @param _relativeLowerBound CL bound parameter. Maximum relative balance decrease.\n    function initOracleV1(\n        address _river,\n        address _administratorAddress,\n        uint64 _epochsPerFrame,\n        uint64 _slotsPerEpoch,\n        uint64 _secondsPerSlot,\n        uint64 _genesisTime,\n        uint256 _annualAprUpperBound,\n        uint256 _relativeLowerBound\n    ) external;\n\n    /// @notice Retrieve River address\n    /// @return The address of River\n    function getRiver() external view returns (address);\n\n    /// @notice Retrieve the block timestamp\n    /// @return The current timestamp from the EVM context\n    function getTime() external view returns (uint256);\n\n    /// @notice Retrieve expected epoch id\n    /// @return The current expected epoch id\n    function getExpectedEpochId() external view returns (uint256);\n\n    /// @notice Retrieve member report status\n    /// @param _oracleMember Address of member to check\n    /// @return True if member has reported\n    function getMemberReportStatus(address _oracleMember) external view returns (bool);\n\n    /// @notice Retrieve member report status\n    /// @return The raw report status value\n    function getGlobalReportStatus() external view returns (uint256);\n\n    /// @notice Retrieve report variants count\n    /// @return The count of report variants\n    function getReportVariantsCount() external view returns (uint256);\n\n    /// @notice Retrieve decoded report at provided index\n    /// @param _idx Index of report\n    /// @return _clBalance The reported consensus layer balance sum of River's validators\n    /// @return _clValidators The reported validator count\n    /// @return _reportCount The number of similar reports\n    function getReportVariant(uint256 _idx)\n        external\n        view\n        returns (uint64 _clBalance, uint32 _clValidators, uint16 _reportCount);\n\n    /// @notice Retrieve the last completed epoch id\n    /// @return The last completed epoch id\n    function getLastCompletedEpochId() external view returns (uint256);\n\n    /// @notice Retrieve the current epoch id based on block timestamp\n    /// @return The current epoch id\n    function getCurrentEpochId() external view returns (uint256);\n\n    /// @notice Retrieve the current quorum\n    /// @return The current quorum\n    function getQuorum() external view returns (uint256);\n\n    /// @notice Retrieve the current cl spec\n    /// @return The Consensus Layer Specification\n    function getCLSpec() external view returns (CLSpec.CLSpecStruct memory);\n\n    /// @notice Retrieve the current frame details\n    /// @return _startEpochId The epoch at the beginning of the frame\n    /// @return _startTime The timestamp of the beginning of the frame in seconds\n    /// @return _endTime The timestamp of the end of the frame in seconds\n    function getCurrentFrame() external view returns (uint256 _startEpochId, uint256 _startTime, uint256 _endTime);\n\n    /// @notice Retrieve the first epoch id of the frame of the provided epoch id\n    /// @param _epochId Epoch id used to get the frame\n    /// @return The first epoch id of the frame containing the given epoch id\n    function getFrameFirstEpochId(uint256 _epochId) external view returns (uint256);\n\n    /// @notice Retrieve the report bounds\n    /// @return The report bounds\n    function getReportBounds() external view returns (ReportBounds.ReportBoundsStruct memory);\n\n    /// @notice Retrieve the list of oracle members\n    /// @return The oracle members\n    function getOracleMembers() external view returns (address[] memory);\n\n    /// @notice Returns true if address is member\n    /// @dev Performs a naive search, do not call this on-chain, used as an off-chain helper\n    /// @param _memberAddress Address of the member\n    /// @return True if address is a member\n    function isMember(address _memberAddress) external view returns (bool);\n\n    /// @notice Adds new address as oracle member, giving the ability to push cl reports.\n    /// @dev Only callable by the adminstrator\n    /// @dev Modifying the quorum clears all the reporting data\n    /// @param _newOracleMember Address of the new member\n    /// @param _newQuorum New quorum value\n    function addMember(address _newOracleMember, uint256 _newQuorum) external;\n\n    /// @notice Removes an address from the oracle members.\n    /// @dev Only callable by the adminstrator\n    /// @dev Modifying the quorum clears all the reporting data\n    /// @dev Remaining members that have already voted should vote again for the same frame.\n    /// @param _oracleMember Address to remove\n    /// @param _newQuorum New quorum value\n    function removeMember(address _oracleMember, uint256 _newQuorum) external;\n\n    /// @notice Changes the address of an oracle member\n    /// @dev Only callable by the adminitrator\n    /// @dev Cannot use an address already in use\n    /// @dev This call will clear all the reporting data\n    /// @param _oracleMember Address to change\n    /// @param _newAddress New address for the member\n    function setMember(address _oracleMember, address _newAddress) external;\n\n    /// @notice Edits the cl spec parameters\n    /// @dev Only callable by the adminstrator\n    /// @param _epochsPerFrame Number of epochs in a frame.\n    /// @param _slotsPerEpoch Number of slots in one epoch.\n    /// @param _secondsPerSlot Number of seconds between slots.\n    /// @param _genesisTime Timestamp of the genesis slot.\n    function setCLSpec(uint64 _epochsPerFrame, uint64 _slotsPerEpoch, uint64 _secondsPerSlot, uint64 _genesisTime)\n        external;\n\n    /// @notice Edits the cl bounds parameters\n    /// @dev Only callable by the adminstrator\n    /// @param _annualAprUpperBound Maximum apr allowed for balance increase. Delta between updates is extrapolated on a year time frame.\n    /// @param _relativeLowerBound Maximum relative balance decrease.\n    function setReportBounds(uint256 _annualAprUpperBound, uint256 _relativeLowerBound) external;\n\n    /// @notice Edits the quorum required to forward cl data to River\n    /// @dev Modifying the quorum clears all the reporting data\n    /// @param _newQuorum New quorum parameter\n    function setQuorum(uint256 _newQuorum) external;\n\n    /// @notice Report cl chain data\n    /// @dev Only callable by an oracle member\n    /// @dev The epoch id is expected to be \u003e= to the expected epoch id stored in the contract\n    /// @dev The epoch id is expected to be the first epoch of its frame\n    /// @dev The Consensus Layer Validator count is the amount of running validators managed by River.\n    /// @dev Until withdrawals are enabled, this count also takes into account any exited and slashed validator\n    /// @dev as funds are still locked on the consensus layer.\n    /// @param _epochId Epoch where the balance and validator count has been computed\n    /// @param _clValidatorsBalance Total balance of River validators\n    /// @param _clValidatorCount Total River validator count\n    function reportConsensusLayerData(uint256 _epochId, uint64 _clValidatorsBalance, uint32 _clValidatorCount)\n        external;\n}\n"
    },
    "contracts/src/interfaces/IRiver.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"./components/IConsensusLayerDepositManager.1.sol\";\nimport \"./components/IOracleManager.1.sol\";\nimport \"./components/ISharesManager.1.sol\";\nimport \"./components/IUserDepositManager.1.sol\";\n\n/// @title River Interface (v1)\n/// @author Kiln\n/// @notice The main system interface\ninterface IRiverV1 is IConsensusLayerDepositManagerV1, IUserDepositManagerV1, ISharesManagerV1, IOracleManagerV1 {\n    /// @notice Funds have been pulled from the Execution Layer Fee Recipient\n    /// @param amount The amount pulled\n    event PulledELFees(uint256 amount);\n\n    /// @notice The stored Execution Layer Fee Recipient has been changed\n    /// @param elFeeRecipient The new Execution Layer Fee Recipient\n    event SetELFeeRecipient(address indexed elFeeRecipient);\n\n    /// @notice The stored Collector has been changed\n    /// @param collector The new Collector\n    event SetCollector(address indexed collector);\n\n    /// @notice The stored Allowlist has been changed\n    /// @param allowlist The new Allowlist\n    event SetAllowlist(address indexed allowlist);\n\n    /// @notice The stored Global Fee has been changed\n    /// @param fee The new Global Fee\n    event SetGlobalFee(uint256 fee);\n\n    /// @notice The stored Operators Registry has been changed\n    /// @param operatorRegistry The new Operators Registry\n    event SetOperatorsRegistry(address indexed operatorRegistry);\n\n    /// @notice The system underlying supply increased. This is a snapshot of the balances for accounting purposes\n    /// @param _collector The address of the collector during this event\n    /// @param _oldTotalUnderlyingBalance Old total ETH balance under management by River\n    /// @param _oldTotalSupply Old total supply in shares\n    /// @param _newTotalUnderlyingBalance New total ETH balance under management by River\n    /// @param _newTotalSupply New total supply in shares\n    event RewardsEarned(\n        address indexed _collector,\n        uint256 _oldTotalUnderlyingBalance,\n        uint256 _oldTotalSupply,\n        uint256 _newTotalUnderlyingBalance,\n        uint256 _newTotalSupply\n    );\n\n    /// @notice The computed amount of shares to mint is 0\n    error ZeroMintedShares();\n\n    /// @notice The access was denied\n    /// @param account The account that was denied\n    error Denied(address account);\n\n    /// @notice Initializes the River system\n    /// @param _depositContractAddress Address to make Consensus Layer deposits\n    /// @param _elFeeRecipientAddress Address that receives the execution layer fees\n    /// @param _withdrawalCredentials Credentials to use for every validator deposit\n    /// @param _oracleAddress The address of the Oracle contract\n    /// @param _systemAdministratorAddress Administrator address\n    /// @param _allowlistAddress Address of the allowlist contract\n    /// @param _operatorRegistryAddress Address of the operator registry\n    /// @param _collectorAddress Address receiving the the global fee on revenue\n    /// @param _globalFee Amount retained when the ETH balance increases and sent to the collector\n    function initRiverV1(\n        address _depositContractAddress,\n        address _elFeeRecipientAddress,\n        bytes32 _withdrawalCredentials,\n        address _oracleAddress,\n        address _systemAdministratorAddress,\n        address _allowlistAddress,\n        address _operatorRegistryAddress,\n        address _collectorAddress,\n        uint256 _globalFee\n    ) external;\n\n    /// @notice Get the current global fee\n    /// @return The global fee\n    function getGlobalFee() external view returns (uint256);\n\n    /// @notice Retrieve the allowlist address\n    /// @return The allowlist address\n    function getAllowlist() external view returns (address);\n\n    /// @notice Retrieve the collector address\n    /// @return The collector address\n    function getCollector() external view returns (address);\n\n    /// @notice Retrieve the execution layer fee recipient\n    /// @return The execution layer fee recipient address\n    function getELFeeRecipient() external view returns (address);\n\n    /// @notice Retrieve the operators registry\n    /// @return The operators registry address\n    function getOperatorsRegistry() external view returns (address);\n\n    /// @notice Changes the global fee parameter\n    /// @param newFee New fee value\n    function setGlobalFee(uint256 newFee) external;\n\n    /// @notice Changes the allowlist address\n    /// @param _newAllowlist New address for the allowlist\n    function setAllowlist(address _newAllowlist) external;\n\n    /// @notice Changes the collector address\n    /// @param _newCollector New address for the collector\n    function setCollector(address _newCollector) external;\n\n    /// @notice Changes the execution layer fee recipient\n    /// @param _newELFeeRecipient New address for the recipient\n    function setELFeeRecipient(address _newELFeeRecipient) external;\n\n    /// @notice Input for execution layer fee earnings\n    function sendELFees() external payable;\n}\n"
    },
    "contracts/src/interfaces/components/IConsensusLayerDepositManager.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\n/// @title Consensys Layer Deposit Manager Interface (v1)\n/// @author Kiln\n/// @notice This interface exposes methods to handle the interactions with the official deposit contract\ninterface IConsensusLayerDepositManagerV1 {\n    /// @notice A validator key got funded on the deposit contract\n    /// @param publicKey BLS Public key that got funded\n    event FundedValidatorKey(bytes publicKey);\n\n    /// @notice The stored deposit contract address changed\n    /// @param depositContract Address of the deposit contract\n    event SetDepositContractAddress(address indexed depositContract);\n\n    /// @notice The stored withdrawal credentials changed\n    /// @param withdrawalCredentials The withdrawal credentials to use for deposits\n    event SetWithdrawalCredentials(bytes32 withdrawalCredentials);\n\n    /// @notice Not enough funds to deposit one validator\n    error NotEnoughFunds();\n\n    /// @notice The length of the BLS Public key is invalid during deposit\n    error InconsistentPublicKeys();\n\n    /// @notice The length of the BLS Signature is invalid during deposit\n    error InconsistentSignatures();\n\n    /// @notice The internal key retrieval returned no keys\n    error NoAvailableValidatorKeys();\n\n    /// @notice The received count of public keys to deposit is invalid\n    error InvalidPublicKeyCount();\n\n    /// @notice The received count of signatures to deposit is invalid\n    error InvalidSignatureCount();\n\n    /// @notice The withdrawal credentials value is null\n    error InvalidWithdrawalCredentials();\n\n    /// @notice An error occured during the deposit\n    error ErrorOnDeposit();\n\n    /// @notice Returns the amount of pending ETH\n    /// @return The amount of pending ETH\n    function getBalanceToDeposit() external view returns (uint256);\n\n    /// @notice Retrieve the withdrawal credentials\n    /// @return The withdrawal credentials\n    function getWithdrawalCredentials() external view returns (bytes32);\n\n    /// @notice Get the deposited validator count (the count of deposits made by the contract)\n    /// @return The deposited validator count\n    function getDepositedValidatorCount() external view returns (uint256);\n\n    /// @notice Deposits current balance to the Consensus Layer by batches of 32 ETH\n    /// @param _maxCount The maximum amount of validator keys to fund\n    function depositToConsensusLayer(uint256 _maxCount) external;\n}\n"
    },
    "contracts/src/interfaces/components/IOracleManager.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\n/// @title Oracle Manager (v1)\n/// @author Kiln\n/// @notice This interface exposes methods to handle the inputs provided by the oracle\ninterface IOracleManagerV1 {\n    /// @notice The stored oracle address changed\n    /// @param oracleAddress The new oracle address\n    event SetOracle(address indexed oracleAddress);\n\n    /// @notice The consensus layer data provided by the oracle has been updated\n    /// @param validatorCount The new count of validators running on the consensus layer\n    /// @param validatorTotalBalance The new total balance sum of all validators\n    /// @param roundId Round identifier\n    event ConsensusLayerDataUpdate(uint256 validatorCount, uint256 validatorTotalBalance, bytes32 roundId);\n\n    /// @notice The reported validator count is invalid\n    /// @param providedValidatorCount The received validator count value\n    /// @param depositedValidatorCount The number of deposits performed by the system\n    error InvalidValidatorCountReport(uint256 providedValidatorCount, uint256 depositedValidatorCount);\n\n    /// @notice Get oracle address\n    /// @return The oracle address\n    function getOracle() external view returns (address);\n\n    /// @notice Get CL validator total balance\n    /// @return The CL Validator total balance\n    function getCLValidatorTotalBalance() external view returns (uint256);\n\n    /// @notice Get CL validator count (the amount of validator reported by the oracles)\n    /// @return The CL validator count\n    function getCLValidatorCount() external view returns (uint256);\n\n    /// @notice Set the oracle address\n    /// @param _oracleAddress Address of the oracle\n    function setOracle(address _oracleAddress) external;\n\n    /// @notice Sets the validator count and validator total balance sum reported by the oracle\n    /// @dev Can only be called by the oracle address\n    /// @dev The round id is a blackbox value that should only be used to identify unique reports\n    /// @dev When a report is performed, River computes the amount of fees that can be pulled\n    /// @dev from the execution layer fee recipient. This amount is capped by the max allowed\n    /// @dev increase provided during the report.\n    /// @dev If the total asset balance increases (from the reported total balance and the pulled funds)\n    /// @dev we then compute the share that must be taken for the collector on the positive delta.\n    /// @dev The execution layer fees are taken into account here because they are the product of\n    /// @dev node operator's work, just like consensus layer fees, and both should be handled in the\n    /// @dev same manner, as a single revenue stream for the users and the collector.\n    /// @param _validatorCount The number of active validators on the consensus layer\n    /// @param _validatorTotalBalance The balance sum of the active validators on the consensus layer\n    /// @param _roundId An identifier for this update\n    /// @param _maxIncrease The maximum allowed increase in the total balance\n    function setConsensusLayerData(\n        uint256 _validatorCount,\n        uint256 _validatorTotalBalance,\n        bytes32 _roundId,\n        uint256 _maxIncrease\n    ) external;\n}\n"
    },
    "contracts/src/interfaces/components/ISharesManager.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\n\n/// @title Shares Manager Interface (v1)\n/// @author Kiln\n/// @notice This interface exposes methods to handle the shares of the depositor and the ERC20 interface\ninterface ISharesManagerV1 is IERC20 {\n    /// @notice Balance too low to perform operation\n    error BalanceTooLow();\n\n    /// @notice Allowance too low to perform operation\n    /// @param _from Account where funds are sent from\n    /// @param _operator Account attempting the transfer\n    /// @param _allowance Current allowance\n    /// @param _value Requested transfer value in shares\n    error AllowanceTooLow(address _from, address _operator, uint256 _allowance, uint256 _value);\n\n    /// @notice Invalid empty transfer\n    error NullTransfer();\n\n    /// @notice Invalid transfer recipients\n    /// @param _from Account sending the funds in the invalid transfer\n    /// @param _to Account receiving the funds in the invalid transfer\n    error UnauthorizedTransfer(address _from, address _to);\n\n    /// @notice Retrieve the token name\n    /// @return The token name\n    function name() external pure returns (string memory);\n\n    /// @notice Retrieve the token symbol\n    /// @return The token symbol\n    function symbol() external pure returns (string memory);\n\n    /// @notice Retrieve the decimal count\n    /// @return The decimal count\n    function decimals() external pure returns (uint8);\n\n    /// @notice Retrieve the total token supply\n    /// @return The total supply in shares\n    function totalSupply() external view returns (uint256);\n\n    /// @notice Retrieve the total underlying asset supply\n    /// @return The total underlying asset supply\n    function totalUnderlyingSupply() external view returns (uint256);\n\n    /// @notice Retrieve the balance of an account\n    /// @param _owner Address to be checked\n    /// @return The balance of the account in shares\n    function balanceOf(address _owner) external view returns (uint256);\n\n    /// @notice Retrieve the underlying asset balance of an account\n    /// @param _owner Address to be checked\n    /// @return The underlying balance of the account\n    function balanceOfUnderlying(address _owner) external view returns (uint256);\n\n    /// @notice Retrieve the underlying asset balance from an amount of shares\n    /// @param _shares Amount of shares to convert\n    /// @return The underlying asset balance represented by the shares\n    function underlyingBalanceFromShares(uint256 _shares) external view returns (uint256);\n\n    /// @notice Retrieve the shares count from an underlying asset amount\n    /// @param _underlyingAssetAmount Amount of underlying asset to convert\n    /// @return The amount of shares worth the underlying asset amopunt\n    function sharesFromUnderlyingBalance(uint256 _underlyingAssetAmount) external view returns (uint256);\n\n    /// @notice Retrieve the allowance value for a spender\n    /// @param _owner Address that issued the allowance\n    /// @param _spender Address that received the allowance\n    /// @return The allowance in shares for a given spender\n    function allowance(address _owner, address _spender) external view returns (uint256);\n\n    /// @notice Performs a transfer from the message sender to the provided account\n    /// @param _to Address receiving the tokens\n    /// @param _value Amount of shares to be sent\n    /// @return True if success\n    function transfer(address _to, uint256 _value) external returns (bool);\n\n    /// @notice Performs a transfer between two recipients\n    /// @param _from Address sending the tokens\n    /// @param _to Address receiving the tokens\n    /// @param _value Amount of shares to be sent\n    /// @return True if success\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\n\n    /// @notice Approves an account for future spendings\n    /// @dev An approved account can use transferFrom to transfer funds on behalf of the token owner\n    /// @param _spender Address that is allowed to spend the tokens\n    /// @param _value The allowed amount in shares, will override previous value\n    /// @return True if success\n    function approve(address _spender, uint256 _value) external returns (bool);\n\n    /// @notice Increase allowance to another account\n    /// @param _spender Spender that receives the allowance\n    /// @param _additionalValue Amount of shares to add\n    /// @return True if success\n    function increaseAllowance(address _spender, uint256 _additionalValue) external returns (bool);\n\n    /// @notice Decrease allowance to another account\n    /// @param _spender Spender that receives the allowance\n    /// @param _subtractableValue Amount of shares to subtract\n    /// @return True if success\n    function decreaseAllowance(address _spender, uint256 _subtractableValue) external returns (bool);\n}\n"
    },
    "contracts/src/interfaces/components/IUserDepositManager.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\n/// @title User Deposit Manager (v1)\n/// @author Kiln\n/// @notice This interface exposes methods to handle the inbound transfers cases or the explicit submissions\ninterface IUserDepositManagerV1 {\n    /// @notice User deposited ETH in the system\n    /// @param depositor Address performing the deposit\n    /// @param recipient Address receiving the minted shares\n    /// @param amount Amount in ETH deposited\n    event UserDeposit(address indexed depositor, address indexed recipient, uint256 amount);\n\n    /// @notice And empty deposit attempt was made\n    error EmptyDeposit();\n\n    /// @notice Explicit deposit method to mint on msg.sender\n    function deposit() external payable;\n\n    /// @notice Explicit deposit method to mint on msg.sender and transfer to _recipient\n    /// @param _recipient Address receiving the minted LsETH\n    function depositAndTransfer(address _recipient) external payable;\n\n    /// @notice Implicit deposit method, when the user performs a regular transfer to the contract\n    receive() external payable;\n\n    /// @notice Invalid call, when the user sends a transaction with a data payload but no method matched\n    fallback() external payable;\n}\n"
    },
    "contracts/src/libraries/LibAdministrable.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"../state/shared/AdministratorAddress.sol\";\nimport \"../state/shared/PendingAdministratorAddress.sol\";\n\n/// @title Lib Administrable\n/// @author Kiln\n/// @notice This library handles the admin and pending admin storage vars\nlibrary LibAdministrable {\n    /// @notice Retrieve the system admin\n    /// @return The address of the system admin\n    function _getAdmin() internal view returns (address) {\n        return AdministratorAddress.get();\n    }\n\n    /// @notice Retrieve the pending system admin\n    /// @return The adress of the pending system admin\n    function _getPendingAdmin() internal view returns (address) {\n        return PendingAdministratorAddress.get();\n    }\n\n    /// @notice Sets the system admin\n    /// @param _admin New system admin\n    function _setAdmin(address _admin) internal {\n        AdministratorAddress.set(_admin);\n    }\n\n    /// @notice Sets the pending system admin\n    /// @param _pendingAdmin New pending system admin\n    function _setPendingAdmin(address _pendingAdmin) internal {\n        PendingAdministratorAddress.set(_pendingAdmin);\n    }\n}\n"
    },
    "contracts/src/libraries/LibBasisPoints.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\n/// @title Lib Basis Points\n/// @notice Holds the basis points max value\nlibrary LibBasisPoints {\n    /// @notice The max value for basis points (represents 100%)\n    uint256 internal constant BASIS_POINTS_MAX = 10_000;\n}\n"
    },
    "contracts/src/libraries/LibErrors.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\n/// @title Lib Errors\n/// @notice Library of common errors\nlibrary LibErrors {\n    /// @notice The operator is unauthorized for the caller\n    /// @param caller Address performing the call\n    error Unauthorized(address caller);\n\n    /// @notice The call was invalid\n    error InvalidCall();\n\n    /// @notice The argument was invalid\n    error InvalidArgument();\n\n    /// @notice The address is zero\n    error InvalidZeroAddress();\n\n    /// @notice The string is empty\n    error InvalidEmptyString();\n\n    /// @notice The fee is invalid\n    error InvalidFee();\n}\n"
    },
    "contracts/src/libraries/LibSanitize.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"./LibErrors.sol\";\nimport \"./LibBasisPoints.sol\";\n\n/// @title Lib Sanitize\n/// @notice Utilities to sanitize input values\nlibrary LibSanitize {\n    /// @notice Reverts if address is 0\n    /// @param _address Address to check\n    function _notZeroAddress(address _address) internal pure {\n        if (_address == address(0)) {\n            revert LibErrors.InvalidZeroAddress();\n        }\n    }\n\n    /// @notice Reverts if string is empty\n    /// @param _string String to check\n    function _notEmptyString(string memory _string) internal pure {\n        if (bytes(_string).length == 0) {\n            revert LibErrors.InvalidEmptyString();\n        }\n    }\n\n    /// @notice Reverts if fee is invalid\n    /// @param _fee Fee to check\n    function _validFee(uint256 _fee) internal pure {\n        if (_fee \u003e LibBasisPoints.BASIS_POINTS_MAX) {\n            revert LibErrors.InvalidFee();\n        }\n    }\n}\n"
    },
    "contracts/src/libraries/LibUnstructuredStorage.sol": {
      "content": "// SPDX-License-Identifier:    MIT\n\npragma solidity 0.8.10;\n\n/// @title Lib Unstructured Storage\n/// @notice Utilities to work with unstructured storage\nlibrary LibUnstructuredStorage {\n    /// @notice Retrieve a bool value at a storage slot\n    /// @param _position The storage slot to retrieve\n    /// @return data The bool value\n    function getStorageBool(bytes32 _position) internal view returns (bool data) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            data := sload(_position)\n        }\n    }\n\n    /// @notice Retrieve an address value at a storage slot\n    /// @param _position The storage slot to retrieve\n    /// @return data The address value\n    function getStorageAddress(bytes32 _position) internal view returns (address data) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            data := sload(_position)\n        }\n    }\n\n    /// @notice Retrieve a bytes32 value at a storage slot\n    /// @param _position The storage slot to retrieve\n    /// @return data The bytes32 value\n    function getStorageBytes32(bytes32 _position) internal view returns (bytes32 data) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            data := sload(_position)\n        }\n    }\n\n    /// @notice Retrieve an uint256 value at a storage slot\n    /// @param _position The storage slot to retrieve\n    /// @return data The uint256 value\n    function getStorageUint256(bytes32 _position) internal view returns (uint256 data) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            data := sload(_position)\n        }\n    }\n\n    /// @notice Sets a bool value at a storage slot\n    /// @param _position The storage slot to set\n    /// @param _data The bool value to set\n    function setStorageBool(bytes32 _position, bool _data) internal {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(_position, _data)\n        }\n    }\n\n    /// @notice Sets an address value at a storage slot\n    /// @param _position The storage slot to set\n    /// @param _data The address value to set\n    function setStorageAddress(bytes32 _position, address _data) internal {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(_position, _data)\n        }\n    }\n\n    /// @notice Sets a bytes32 value at a storage slot\n    /// @param _position The storage slot to set\n    /// @param _data The bytes32 value to set\n    function setStorageBytes32(bytes32 _position, bytes32 _data) internal {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(_position, _data)\n        }\n    }\n\n    /// @notice Sets an uint256 value at a storage slot\n    /// @param _position The storage slot to set\n    /// @param _data The uint256 value to set\n    function setStorageUint256(bytes32 _position, uint256 _data) internal {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(_position, _data)\n        }\n    }\n}\n"
    },
    "contracts/src/state/oracle/CLSpec.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\n/// @title Consensus Layer Spec Storage\n/// @notice Utility to manage the Consensus Layer Spec in storage\nlibrary CLSpec {\n    /// @notice Storage slot of the Consensus Layer Spec\n    bytes32 internal constant CL_SPEC_SLOT = bytes32(uint256(keccak256(\"river.state.clSpec\")) - 1);\n\n    /// @notice The Consensus Layer Spec structure\n    struct CLSpecStruct {\n        /// @custom:attribute The count of epochs per frame, 225 means 24h\n        uint64 epochsPerFrame;\n        /// @custom:attribute The count of slots in an epoch (32 on mainnet)\n        uint64 slotsPerEpoch;\n        /// @custom:attribute The seconds in a slot (12 on mainnet)\n        uint64 secondsPerSlot;\n        /// @custom:attribute The block timestamp of the first consensus layer block\n        uint64 genesisTime;\n    }\n\n    /// @notice The structure in storage\n    struct Slot {\n        /// @custom:attribute The structure in storage\n        CLSpecStruct value;\n    }\n\n    /// @notice Retrieve the Consensus Layer Spec from storage\n    /// @return The Consensus Layer Spec\n    function get() internal view returns (CLSpecStruct memory) {\n        bytes32 slot = CL_SPEC_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value;\n    }\n\n    /// @notice Set the Consensus Layer Spec value in storage\n    /// @param _newCLSpec The new value to set in storage\n    function set(CLSpecStruct memory _newCLSpec) internal {\n        bytes32 slot = CL_SPEC_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        r.value = _newCLSpec;\n    }\n}\n"
    },
    "contracts/src/state/oracle/ExpectedEpochId.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\n\n/// @title Expected Epoch Id Storage\n/// @notice Utility to manage the Expected Epoch Id in storage\nlibrary ExpectedEpochId {\n    /// @notice Storage slot of the Expected Epoch Id\n    bytes32 internal constant EXPECTED_EPOCH_ID_SLOT = bytes32(uint256(keccak256(\"river.state.expectedEpochId\")) - 1);\n\n    /// @notice Retrieve the Expected Epoch Id\n    /// @return The Expected Epoch Id\n    function get() internal view returns (uint256) {\n        return LibUnstructuredStorage.getStorageUint256(EXPECTED_EPOCH_ID_SLOT);\n    }\n\n    /// @notice Sets the Expected Epoch Id\n    /// @param _newValue New Expected Epoch Id\n    function set(uint256 _newValue) internal {\n        LibUnstructuredStorage.setStorageUint256(EXPECTED_EPOCH_ID_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/oracle/LastEpochId.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\n\n/// @title Last Epoch Id Storage\n/// @notice Utility to manage the Last Epoch Id in storage\nlibrary LastEpochId {\n    /// @notice Storage slot of the Last Epoch Id\n    bytes32 internal constant LAST_EPOCH_ID_SLOT = bytes32(uint256(keccak256(\"river.state.lastEpochId\")) - 1);\n\n    /// @notice Retrieve the Last Epoch Id\n    /// @return The Last Epoch Id\n    function get() internal view returns (uint256) {\n        return LibUnstructuredStorage.getStorageUint256(LAST_EPOCH_ID_SLOT);\n    }\n\n    /// @notice Sets the Last Epoch Id\n    /// @param _newValue New Last Epoch Id\n    function set(uint256 _newValue) internal {\n        LibUnstructuredStorage.setStorageUint256(LAST_EPOCH_ID_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/oracle/OracleMembers.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibSanitize.sol\";\n\n/// @title Oracle Members Storage\n/// @notice Utility to manage the Oracle Members in storage\n/// @dev There can only be up to 256 oracle members. This is due to how report statuses are stored in Reports Positions\nlibrary OracleMembers {\n    /// @notice Storage slot of the Oracle Members\n    bytes32 internal constant ORACLE_MEMBERS_SLOT = bytes32(uint256(keccak256(\"river.state.oracleMembers\")) - 1);\n\n    /// @notice The structure in storage\n    struct Slot {\n        /// @custom:attribute The array of oracle members\n        address[] value;\n    }\n\n    /// @notice Retrieve the list of oracle members\n    /// @return List of oracle members\n    function get() internal view returns (address[] memory) {\n        bytes32 slot = ORACLE_MEMBERS_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value;\n    }\n\n    /// @notice Add a new oracle member to the list\n    /// @param _newOracleMember Address of the new oracle member\n    function push(address _newOracleMember) internal {\n        LibSanitize._notZeroAddress(_newOracleMember);\n\n        bytes32 slot = ORACLE_MEMBERS_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        r.value.push(_newOracleMember);\n    }\n\n    /// @notice Set an address in the oracle member list\n    /// @param _index The index to edit\n    /// @param _newOracleAddress The new value of the oracle member\n    function set(uint256 _index, address _newOracleAddress) internal {\n        bytes32 slot = ORACLE_MEMBERS_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        r.value[_index] = _newOracleAddress;\n    }\n\n    /// @notice Retrieve the index of the oracle member\n    /// @param _memberAddress The address to lookup\n    /// @return The index of the member, -1 if not found\n    function indexOf(address _memberAddress) internal view returns (int256) {\n        bytes32 slot = ORACLE_MEMBERS_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        for (uint256 idx = 0; idx \u003c r.value.length;) {\n            if (r.value[idx] == _memberAddress) {\n                return int256(idx);\n            }\n            unchecked {\n                ++idx;\n            }\n        }\n\n        return int256(-1);\n    }\n\n    /// @notice Delete the oracle member at the given index\n    /// @param _idx The index of the member to remove\n    function deleteItem(uint256 _idx) internal {\n        bytes32 slot = ORACLE_MEMBERS_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        uint256 lastIdx = r.value.length - 1;\n        if (lastIdx != _idx) {\n            r.value[_idx] = r.value[lastIdx];\n        }\n\n        r.value.pop();\n    }\n}\n"
    },
    "contracts/src/state/oracle/Quorum.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\n\n/// @title Quorum Storage\n/// @notice Utility to manage the Quorum in storage\nlibrary Quorum {\n    /// @notice Storage slot of the Quorum\n    bytes32 internal constant QUORUM_SLOT = bytes32(uint256(keccak256(\"river.state.quorum\")) - 1);\n\n    /// @notice Retrieve the Quorum\n    /// @return The Quorum\n    function get() internal view returns (uint256) {\n        return LibUnstructuredStorage.getStorageUint256(QUORUM_SLOT);\n    }\n\n    /// @notice Sets the Quorum\n    /// @param _newValue New Quorum\n    function set(uint256 _newValue) internal {\n        return LibUnstructuredStorage.setStorageUint256(QUORUM_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/oracle/ReportBounds.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\n/// @title Report Bounds Storage\n/// @notice Utility to manage the Report Bounds in storage\nlibrary ReportBounds {\n    /// @notice Storage slot of the Report Bounds\n    bytes32 internal constant REPORT_BOUNDS_SLOT = bytes32(uint256(keccak256(\"river.state.reportBounds\")) - 1);\n\n    /// @notice The Report Bounds structure\n    struct ReportBoundsStruct {\n        /// @custom:attribute The maximum allowed annual apr, checked before submitting a report to River\n        uint256 annualAprUpperBound;\n        /// @custom:attribute The maximum allowed balance decrease, also checked before submitting a report to River\n        uint256 relativeLowerBound;\n    }\n\n    /// @notice The structure in storage\n    struct Slot {\n        /// @custom:attribute The structure in storage\n        ReportBoundsStruct value;\n    }\n\n    /// @notice Retrieve the Report Bounds from storage\n    /// @return The Report Bounds\n    function get() internal view returns (ReportBoundsStruct memory) {\n        bytes32 slot = REPORT_BOUNDS_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value;\n    }\n\n    /// @notice Set the Report Bounds in storage\n    /// @param _newReportBounds The new Report Bounds value\n    function set(ReportBoundsStruct memory _newReportBounds) internal {\n        bytes32 slot = REPORT_BOUNDS_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        r.value = _newReportBounds;\n    }\n}\n"
    },
    "contracts/src/state/oracle/ReportsPositions.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\n\n/// @title Reports Positions Storage\n/// @notice Utility to manage the Reports Positions in storage\n/// @dev Each bit in the stored uint256 value tells if the member at a given index has reported\nlibrary ReportsPositions {\n    /// @notice Storage slot of the Reports Positions\n    bytes32 internal constant REPORTS_POSITIONS_SLOT = bytes32(uint256(keccak256(\"river.state.reportsPositions\")) - 1);\n\n    /// @notice Retrieve the Reports Positions at index\n    /// @param _idx The index to retrieve\n    /// @return True if already reported\n    function get(uint256 _idx) internal view returns (bool) {\n        uint256 mask = 1 \u003c\u003c _idx;\n        return LibUnstructuredStorage.getStorageUint256(REPORTS_POSITIONS_SLOT) \u0026 mask == mask;\n    }\n\n    /// @notice Retrieve the raw Reports Positions from storage\n    /// @return Raw Reports Positions\n    function getRaw() internal view returns (uint256) {\n        return LibUnstructuredStorage.getStorageUint256(REPORTS_POSITIONS_SLOT);\n    }\n\n    /// @notice Register an index as reported\n    /// @param _idx The index to register\n    function register(uint256 _idx) internal {\n        uint256 mask = 1 \u003c\u003c _idx;\n        return LibUnstructuredStorage.setStorageUint256(\n            REPORTS_POSITIONS_SLOT, LibUnstructuredStorage.getStorageUint256(REPORTS_POSITIONS_SLOT) | mask\n        );\n    }\n\n    /// @notice Clears all the report positions in storage\n    function clear() internal {\n        return LibUnstructuredStorage.setStorageUint256(REPORTS_POSITIONS_SLOT, 0);\n    }\n}\n"
    },
    "contracts/src/state/oracle/ReportsVariants.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\n/// @title Reports Variants Storage\n/// @notice Utility to manage the Reports Variants in storage\nlibrary ReportsVariants {\n    /// @notice Storage slot of the Reports Variants\n    bytes32 internal constant REPORTS_VARIANTS_SLOT = bytes32(uint256(keccak256(\"river.state.reportsVariants\")) - 1);\n\n    /// @notice Mask used to extra the report values from the variant\n    /// @notice This is the packing done inside the variant in storage\n    /// @notice\n    /// @notice [ 0,  16) : \u003cvoteCount\u003e           oracle member's total vote count for the numbers below (uint16, 2 bytes)\n    /// @notice [16,  48) : \u003cbeaconValidators\u003e    total number of beacon validators (uint32, 4 bytes)\n    /// @notice [48, 112) : \u003cbeaconBalance\u003e       total balance of all the beacon validators (uint64, 6 bytes)\n    /// @notice\n    /// @notice So applying this mask, we can extra the voteCount out to perform comparisons on the report values\n    /// @notice\n    /// @notice xx...xx \u003cbeaconBalance\u003e \u003cbeaconValidators\u003e xxxx \u0026 COUNT_OUTMASK  ==\n    /// @notice 00...00 \u003cbeaconBalance\u003e \u003cbeaconValidators\u003e 0000\n    uint256 internal constant COUNT_OUTMASK = 0xFFFFFFFFFFFFFFFFFFFFFFFF0000;\n\n    /// @notice Structure in storage\n    struct Slot {\n        /// @custom:attribute The list of variants\n        uint256[] value;\n    }\n\n    /// @notice Retrieve the Reports Variants from storage\n    /// @return The Reports Variants\n    function get() internal view returns (uint256[] memory) {\n        bytes32 slot = REPORTS_VARIANTS_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value;\n    }\n\n    /// @notice Set the Reports Variants value at index\n    /// @param _idx The index to set\n    /// @param _val The value to set\n    function set(uint256 _idx, uint256 _val) internal {\n        bytes32 slot = REPORTS_VARIANTS_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        r.value[_idx] = _val;\n    }\n\n    /// @notice Add a new variant in the list\n    /// @param _variant The new variant to add\n    function push(uint256 _variant) internal {\n        bytes32 slot = REPORTS_VARIANTS_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        r.value.push(_variant);\n    }\n\n    /// @notice Retrieve the index of a specific variant, ignoring the count field\n    /// @param _variant Variant value to lookup\n    /// @return The index of the variant, -1 if not found\n    function indexOfReport(uint256 _variant) internal view returns (int256) {\n        bytes32 slot = REPORTS_VARIANTS_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        for (uint256 idx = 0; idx \u003c r.value.length;) {\n            if (r.value[idx] \u0026 COUNT_OUTMASK == _variant) {\n                return int256(idx);\n            }\n            unchecked {\n                ++idx;\n            }\n        }\n\n        return int256(-1);\n    }\n\n    /// @notice Clear all variants from storage\n    function clear() internal {\n        bytes32 slot = REPORTS_VARIANTS_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        delete r.value;\n    }\n}\n"
    },
    "contracts/src/state/shared/AdministratorAddress.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\nimport \"../../libraries/LibSanitize.sol\";\n\n/// @title Administrator Address Storage\n/// @notice Utility to manage the Administrator Address in storage\nlibrary AdministratorAddress {\n    /// @notice Storage slot of the Administrator Address\n    bytes32 public constant ADMINISTRATOR_ADDRESS_SLOT =\n        bytes32(uint256(keccak256(\"river.state.administratorAddress\")) - 1);\n\n    /// @notice Retrieve the Administrator Address\n    /// @return The Administrator Address\n    function get() internal view returns (address) {\n        return LibUnstructuredStorage.getStorageAddress(ADMINISTRATOR_ADDRESS_SLOT);\n    }\n\n    /// @notice Sets the Administrator Address\n    /// @param _newValue New Administrator Address\n    function set(address _newValue) internal {\n        LibSanitize._notZeroAddress(_newValue);\n        LibUnstructuredStorage.setStorageAddress(ADMINISTRATOR_ADDRESS_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/shared/PendingAdministratorAddress.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\n\n/// @title Pending Administrator Address Storage\n/// @notice Utility to manage the Pending Administrator Address in storage\nlibrary PendingAdministratorAddress {\n    /// @notice Storage slot of the Pending Administrator Address\n    bytes32 public constant PENDING_ADMINISTRATOR_ADDRESS_SLOT =\n        bytes32(uint256(keccak256(\"river.state.pendingAdministratorAddress\")) - 1);\n\n    /// @notice Retrieve the Pending Administrator Address\n    /// @return The Pending Administrator Address\n    function get() internal view returns (address) {\n        return LibUnstructuredStorage.getStorageAddress(PENDING_ADMINISTRATOR_ADDRESS_SLOT);\n    }\n\n    /// @notice Sets the Pending Administrator Address\n    /// @param _newValue New Pending Administrator Address\n    function set(address _newValue) internal {\n        LibUnstructuredStorage.setStorageAddress(PENDING_ADMINISTRATOR_ADDRESS_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/shared/RiverAddress.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibSanitize.sol\";\nimport \"../../libraries/LibUnstructuredStorage.sol\";\n\n/// @title River Address Storage\n/// @notice Utility to manage the River Address in storage\nlibrary RiverAddress {\n    /// @notice Storage slot of the River Address\n    bytes32 internal constant RIVER_ADDRESS_SLOT = bytes32(uint256(keccak256(\"river.state.riverAddress\")) - 1);\n\n    /// @notice Retrieve the River Address\n    /// @return The River Address\n    function get() internal view returns (address) {\n        return LibUnstructuredStorage.getStorageAddress(RIVER_ADDRESS_SLOT);\n    }\n\n    /// @notice Sets the River Address\n    /// @param _newValue New River Address\n    function set(address _newValue) internal {\n        LibSanitize._notZeroAddress(_newValue);\n        LibUnstructuredStorage.setStorageAddress(RIVER_ADDRESS_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/shared/Version.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\n\n/// @title Version Storage\n/// @notice Utility to manage the Version in storage\nlibrary Version {\n    /// @notice Storage slot of the Version\n    bytes32 public constant VERSION_SLOT = bytes32(uint256(keccak256(\"river.state.version\")) - 1);\n\n    /// @notice Retrieve the Version\n    /// @return The Version\n    function get() internal view returns (uint256) {\n        return LibUnstructuredStorage.getStorageUint256(VERSION_SLOT);\n    }\n\n    /// @notice Sets the Version\n    /// @param _newValue New Version\n    function set(uint256 _newValue) internal {\n        LibUnstructuredStorage.setStorageUint256(VERSION_SLOT, _newValue);\n    }\n}\n"
    },
    "openzeppelin-contracts/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    }
  }
}