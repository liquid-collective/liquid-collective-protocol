{
  "language": "Solidity",
  "sources": {
    "contracts/src/Administrable.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"./interfaces/IAdministrable.sol\";\n\nimport \"./libraries/LibAdministrable.sol\";\nimport \"./libraries/LibSanitize.sol\";\n\n/// @title Administrable\n/// @author Kiln\n/// @notice This contract handles the administration of the contracts\nabstract contract Administrable is IAdministrable {\n    /// @notice Prevents unauthorized calls\n    modifier onlyAdmin() {\n        if (msg.sender != LibAdministrable._getAdmin()) {\n            revert LibErrors.Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    /// @notice Prevents unauthorized calls\n    modifier onlyPendingAdmin() {\n        if (msg.sender != LibAdministrable._getPendingAdmin()) {\n            revert LibErrors.Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    /// @inheritdoc IAdministrable\n    function getAdmin() external view returns (address) {\n        return LibAdministrable._getAdmin();\n    }\n\n    /// @inheritdoc IAdministrable\n    function getPendingAdmin() external view returns (address) {\n        return LibAdministrable._getPendingAdmin();\n    }\n\n    /// @inheritdoc IAdministrable\n    function proposeAdmin(address _newAdmin) external onlyAdmin {\n        _setPendingAdmin(_newAdmin);\n    }\n\n    /// @inheritdoc IAdministrable\n    function acceptAdmin() external onlyPendingAdmin {\n        _setAdmin(LibAdministrable._getPendingAdmin());\n        _setPendingAdmin(address(0));\n    }\n\n    /// @notice Internal utility to set the admin address\n    /// @param _admin Address to set as admin\n    function _setAdmin(address _admin) internal {\n        LibSanitize._notZeroAddress(_admin);\n        LibAdministrable._setAdmin(_admin);\n        emit SetAdmin(_admin);\n    }\n\n    /// @notice Internal utility to set the pending admin address\n    /// @param _pendingAdmin Address to set as pending admin\n    function _setPendingAdmin(address _pendingAdmin) internal {\n        LibAdministrable._setPendingAdmin(_pendingAdmin);\n        emit SetPendingAdmin(_pendingAdmin);\n    }\n\n    /// @notice Internal utility to retrieve the address of the current admin\n    /// @return The address of admin\n    function _getAdmin() internal view returns (address) {\n        return LibAdministrable._getAdmin();\n    }\n}\n"
    },
    "contracts/src/interfaces/IAdministrable.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\n/// @title Administrable Interface\n/// @author Kiln\n/// @notice This interface exposes methods to handle the ownership of the contracts\ninterface IAdministrable {\n    /// @notice The pending admin address changed\n    /// @param pendingAdmin New pending admin address\n    event SetPendingAdmin(address indexed pendingAdmin);\n\n    /// @notice The admin address changed\n    /// @param admin New admin address\n    event SetAdmin(address indexed admin);\n\n    /// @notice Retrieves the current admin address\n    /// @return The admin address\n    function getAdmin() external view returns (address);\n\n    /// @notice Retrieve the current pending admin address\n    /// @return The pending admin address\n    function getPendingAdmin() external view returns (address);\n\n    /// @notice Proposes a new address as admin\n    /// @dev This security prevents setting an invalid address as an admin. The pending\n    /// @dev admin has to claim its ownership of the contract, and prove that the new\n    /// @dev address is able to perform regular transactions.\n    /// @param _newAdmin New admin address\n    function proposeAdmin(address _newAdmin) external;\n\n    /// @notice Accept the transfer of ownership\n    /// @dev Only callable by the pending admin. Resets the pending admin if succesful.\n    function acceptAdmin() external;\n}\n"
    },
    "contracts/src/libraries/LibAdministrable.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"../state/shared/AdministratorAddress.sol\";\nimport \"../state/shared/PendingAdministratorAddress.sol\";\n\n/// @title Lib Administrable\n/// @author Kiln\n/// @notice This library handles the admin and pending admin storage vars\nlibrary LibAdministrable {\n    /// @notice Retrieve the system admin\n    /// @return The address of the system admin\n    function _getAdmin() internal view returns (address) {\n        return AdministratorAddress.get();\n    }\n\n    /// @notice Retrieve the pending system admin\n    /// @return The adress of the pending system admin\n    function _getPendingAdmin() internal view returns (address) {\n        return PendingAdministratorAddress.get();\n    }\n\n    /// @notice Sets the system admin\n    /// @param _admin New system admin\n    function _setAdmin(address _admin) internal {\n        AdministratorAddress.set(_admin);\n    }\n\n    /// @notice Sets the pending system admin\n    /// @param _pendingAdmin New pending system admin\n    function _setPendingAdmin(address _pendingAdmin) internal {\n        PendingAdministratorAddress.set(_pendingAdmin);\n    }\n}\n"
    },
    "contracts/src/libraries/LibSanitize.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"./LibErrors.sol\";\nimport \"./LibBasisPoints.sol\";\n\n/// @title Lib Sanitize\n/// @notice Utilities to sanitize input values\nlibrary LibSanitize {\n    /// @notice Reverts if address is 0\n    /// @param _address Address to check\n    function _notZeroAddress(address _address) internal pure {\n        if (_address == address(0)) {\n            revert LibErrors.InvalidZeroAddress();\n        }\n    }\n\n    /// @notice Reverts if string is empty\n    /// @param _string String to check\n    function _notEmptyString(string memory _string) internal pure {\n        if (bytes(_string).length == 0) {\n            revert LibErrors.InvalidEmptyString();\n        }\n    }\n\n    /// @notice Reverts if fee is invalid\n    /// @param _fee Fee to check\n    function _validFee(uint256 _fee) internal pure {\n        if (_fee > LibBasisPoints.BASIS_POINTS_MAX) {\n            revert LibErrors.InvalidFee();\n        }\n    }\n}\n"
    },
    "contracts/src/state/shared/AdministratorAddress.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\nimport \"../../libraries/LibSanitize.sol\";\n\n/// @title Administrator Address Storage\n/// @notice Utility to manage the Administrator Address in storage\nlibrary AdministratorAddress {\n    /// @notice Storage slot of the Administrator Address\n    bytes32 public constant ADMINISTRATOR_ADDRESS_SLOT =\n        bytes32(uint256(keccak256(\"river.state.administratorAddress\")) - 1);\n\n    /// @notice Retrieve the Administrator Address\n    /// @return The Administrator Address\n    function get() internal view returns (address) {\n        return LibUnstructuredStorage.getStorageAddress(ADMINISTRATOR_ADDRESS_SLOT);\n    }\n\n    /// @notice Sets the Administrator Address\n    /// @param _newValue New Administrator Address\n    function set(address _newValue) internal {\n        LibSanitize._notZeroAddress(_newValue);\n        LibUnstructuredStorage.setStorageAddress(ADMINISTRATOR_ADDRESS_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/shared/PendingAdministratorAddress.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\n\n/// @title Pending Administrator Address Storage\n/// @notice Utility to manage the Pending Administrator Address in storage\nlibrary PendingAdministratorAddress {\n    /// @notice Storage slot of the Pending Administrator Address\n    bytes32 public constant PENDING_ADMINISTRATOR_ADDRESS_SLOT =\n        bytes32(uint256(keccak256(\"river.state.pendingAdministratorAddress\")) - 1);\n\n    /// @notice Retrieve the Pending Administrator Address\n    /// @return The Pending Administrator Address\n    function get() internal view returns (address) {\n        return LibUnstructuredStorage.getStorageAddress(PENDING_ADMINISTRATOR_ADDRESS_SLOT);\n    }\n\n    /// @notice Sets the Pending Administrator Address\n    /// @param _newValue New Pending Administrator Address\n    function set(address _newValue) internal {\n        LibUnstructuredStorage.setStorageAddress(PENDING_ADMINISTRATOR_ADDRESS_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/libraries/LibUnstructuredStorage.sol": {
      "content": "// SPDX-License-Identifier:    MIT\n\npragma solidity 0.8.10;\n\n/// @title Lib Unstructured Storage\n/// @notice Utilities to work with unstructured storage\nlibrary LibUnstructuredStorage {\n    /// @notice Retrieve a bool value at a storage slot\n    /// @param _position The storage slot to retrieve\n    /// @return data The bool value\n    function getStorageBool(bytes32 _position) internal view returns (bool data) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            data := sload(_position)\n        }\n    }\n\n    /// @notice Retrieve an address value at a storage slot\n    /// @param _position The storage slot to retrieve\n    /// @return data The address value\n    function getStorageAddress(bytes32 _position) internal view returns (address data) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            data := sload(_position)\n        }\n    }\n\n    /// @notice Retrieve a bytes32 value at a storage slot\n    /// @param _position The storage slot to retrieve\n    /// @return data The bytes32 value\n    function getStorageBytes32(bytes32 _position) internal view returns (bytes32 data) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            data := sload(_position)\n        }\n    }\n\n    /// @notice Retrieve an uint256 value at a storage slot\n    /// @param _position The storage slot to retrieve\n    /// @return data The uint256 value\n    function getStorageUint256(bytes32 _position) internal view returns (uint256 data) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            data := sload(_position)\n        }\n    }\n\n    /// @notice Sets a bool value at a storage slot\n    /// @param _position The storage slot to set\n    /// @param _data The bool value to set\n    function setStorageBool(bytes32 _position, bool _data) internal {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(_position, _data)\n        }\n    }\n\n    /// @notice Sets an address value at a storage slot\n    /// @param _position The storage slot to set\n    /// @param _data The address value to set\n    function setStorageAddress(bytes32 _position, address _data) internal {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(_position, _data)\n        }\n    }\n\n    /// @notice Sets a bytes32 value at a storage slot\n    /// @param _position The storage slot to set\n    /// @param _data The bytes32 value to set\n    function setStorageBytes32(bytes32 _position, bytes32 _data) internal {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(_position, _data)\n        }\n    }\n\n    /// @notice Sets an uint256 value at a storage slot\n    /// @param _position The storage slot to set\n    /// @param _data The uint256 value to set\n    function setStorageUint256(bytes32 _position, uint256 _data) internal {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(_position, _data)\n        }\n    }\n}\n"
    },
    "contracts/src/libraries/LibErrors.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\n/// @title Lib Errors\n/// @notice Library of common errors\nlibrary LibErrors {\n    /// @notice The operator is unauthorized for the caller\n    /// @param caller Address performing the call\n    error Unauthorized(address caller);\n\n    /// @notice The call was invalid\n    error InvalidCall();\n\n    /// @notice The argument was invalid\n    error InvalidArgument();\n\n    /// @notice The address is zero\n    error InvalidZeroAddress();\n\n    /// @notice The string is empty\n    error InvalidEmptyString();\n\n    /// @notice The fee is invalid\n    error InvalidFee();\n}\n"
    },
    "contracts/src/libraries/LibBasisPoints.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\n/// @title Lib Basis Points\n/// @notice Holds the basis points max value\nlibrary LibBasisPoints {\n    /// @notice The max value for basis points (represents 100%)\n    uint256 internal constant BASIS_POINTS_MAX = 10_000;\n}\n"
    },
    "contracts/src/River.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"./interfaces/IAllowlist.1.sol\";\nimport \"./interfaces/IOperatorRegistry.1.sol\";\nimport \"./interfaces/IRiver.1.sol\";\nimport \"./interfaces/IELFeeRecipient.1.sol\";\n\nimport \"./components/ConsensusLayerDepositManager.1.sol\";\nimport \"./components/UserDepositManager.1.sol\";\nimport \"./components/SharesManager.1.sol\";\nimport \"./components/OracleManager.1.sol\";\nimport \"./Initializable.sol\";\nimport \"./Administrable.sol\";\n\nimport \"./state/river/AllowlistAddress.sol\";\nimport \"./state/river/OperatorsRegistryAddress.sol\";\nimport \"./state/river/CollectorAddress.sol\";\nimport \"./state/river/GlobalFee.sol\";\nimport \"./state/river/ELFeeRecipientAddress.sol\";\n\n/// @title River (v1)\n/// @author Kiln\n/// @notice This contract merges all the manager contracts and implements all the virtual methods stitching all components together\n/// @notice\n/// @notice    +---------------------------------------------------------------------+\n/// @notice    |                                                                     |\n/// @notice    |                           Consensus Layer                           |\n/// @notice    |                                                                     |\n/// @notice    | +-------------------+  +-------------------+  +-------------------+ |\n/// @notice    | |                   |  |                   |  |                   | |\n/// @notice    | |  EL Fee Recipient |  |      Oracle       |  |  Deposit Contract | |\n/// @notice    | |                   |  |                   |  |                   | |\n/// @notice    | +---------|---------+  +---------|---------+  +---------|---------+ |\n/// @notice    +---------------------------------------------------------------------+\n/// @notice                |         7            |            5         |\n/// @notice                +-----------------|    |    |-----------------+\n/// @notice                                  |    |6   |\n/// @notice                                  |    |    |\n/// @notice        +---------+          +----|----|----|----+            +---------+\n/// @notice        |         |          |                   |     2      |         |\n/// @notice        |Operator |          |       River       --------------  User   |\n/// @notice        |         |          |                   |            |         |\n/// @notice        +----|----+          +----|---------|----+            +---------+\n/// @notice             |                    |         |\n/// @notice             |             4      |         |       3\n/// @notice             |1     +-------------|         |--------------+\n/// @notice             |      |                                      |\n/// @notice             |      |                                      |\n/// @notice      +------|------|------------+           +-------------|------------+\n/// @notice      |                          |           |                          |\n/// @notice      |    Operators Registry    |           |         Allowlist        |\n/// @notice      |                          |           |                          |\n/// @notice      +--------------------------+           +--------------------------+\n/// @notice\n/// @notice      1. Operators are adding BLS Public Keys of validators running in their\n/// @notice         infrastructure.\n/// @notice      2. User deposit ETH to the system and get shares minted in exchange\n/// @notice      3. Upon deposit, the system verifies if the User is allowed to deposit\n/// @notice         by querying the Allowlist\n/// @notice      4. When the system has enough funds to deposit validators, keys are pulled\n/// @notice         from the Operators Registry\n/// @notice      5. The deposit data is computed and the validators are funded via the official\n/// @notice         deposit contract\n/// @notice      6. Oracles report the total balance of the running validators and the total count\n/// @notice         of running validators\n/// @notice      7. The running validators propose blocks that reward the EL Fee Recipient. The funds\n/// @notice         are pulled back in the system.\n/// @notice\ncontract RiverV1 is\n    ConsensusLayerDepositManagerV1,\n    UserDepositManagerV1,\n    SharesManagerV1,\n    OracleManagerV1,\n    Initializable,\n    Administrable,\n    IRiverV1\n{\n    /// @notice The mask for the deposit right\n    uint256 internal constant DEPOSIT_MASK = 0x1;\n\n    /// @inheritdoc IRiverV1\n    function initRiverV1(\n        address _depositContractAddress,\n        address _elFeeRecipientAddress,\n        bytes32 _withdrawalCredentials,\n        address _oracleAddress,\n        address _systemAdministratorAddress,\n        address _allowlistAddress,\n        address _operatorRegistryAddress,\n        address _collectorAddress,\n        uint256 _globalFee\n    ) external init(0) {\n        _setAdmin(_systemAdministratorAddress);\n\n        CollectorAddress.set(_collectorAddress);\n        emit SetCollector(_collectorAddress);\n\n        GlobalFee.set(_globalFee);\n        emit SetGlobalFee(_globalFee);\n\n        ELFeeRecipientAddress.set(_elFeeRecipientAddress);\n        emit SetELFeeRecipient(_elFeeRecipientAddress);\n\n        AllowlistAddress.set(_allowlistAddress);\n        emit SetAllowlist(_allowlistAddress);\n\n        OperatorsRegistryAddress.set(_operatorRegistryAddress);\n        emit SetOperatorsRegistry(_operatorRegistryAddress);\n\n        ConsensusLayerDepositManagerV1.initConsensusLayerDepositManagerV1(\n            _depositContractAddress, _withdrawalCredentials\n        );\n\n        OracleManagerV1.initOracleManagerV1(_oracleAddress);\n    }\n\n    /// @inheritdoc IRiverV1\n    function getGlobalFee() external view returns (uint256) {\n        return GlobalFee.get();\n    }\n\n    /// @inheritdoc IRiverV1\n    function getAllowlist() external view returns (address) {\n        return AllowlistAddress.get();\n    }\n\n    /// @inheritdoc IRiverV1\n    function getCollector() external view returns (address) {\n        return CollectorAddress.get();\n    }\n\n    /// @inheritdoc IRiverV1\n    function getELFeeRecipient() external view returns (address) {\n        return ELFeeRecipientAddress.get();\n    }\n\n    /// @inheritdoc IRiverV1\n    function setGlobalFee(uint256 newFee) external onlyAdmin {\n        GlobalFee.set(newFee);\n        emit SetGlobalFee(newFee);\n    }\n\n    /// @inheritdoc IRiverV1\n    function setAllowlist(address _newAllowlist) external onlyAdmin {\n        AllowlistAddress.set(_newAllowlist);\n        emit SetAllowlist(_newAllowlist);\n    }\n\n    /// @inheritdoc IRiverV1\n    function setCollector(address _newCollector) external onlyAdmin {\n        CollectorAddress.set(_newCollector);\n        emit SetCollector(_newCollector);\n    }\n\n    /// @inheritdoc IRiverV1\n    function setELFeeRecipient(address _newELFeeRecipient) external onlyAdmin {\n        ELFeeRecipientAddress.set(_newELFeeRecipient);\n        emit SetELFeeRecipient(_newELFeeRecipient);\n    }\n\n    /// @inheritdoc IRiverV1\n    function getOperatorsRegistry() external view returns (address) {\n        return OperatorsRegistryAddress.get();\n    }\n\n    /// @inheritdoc IRiverV1\n    function sendELFees() external payable {\n        if (msg.sender != ELFeeRecipientAddress.get()) {\n            revert LibErrors.Unauthorized(msg.sender);\n        }\n    }\n\n    /// @notice Overriden handler to pass the system admin inside components\n    /// @return The address of the admin\n    function _getRiverAdmin()\n        internal\n        view\n        override (OracleManagerV1, ConsensusLayerDepositManagerV1)\n        returns (address)\n    {\n        return Administrable._getAdmin();\n    }\n\n    /// @notice Overriden handler called whenever a token transfer is triggered\n    /// @param _from Token sender\n    /// @param _to Token receiver\n    function _onTransfer(address _from, address _to) internal view override {\n        IAllowlistV1 allowlist = IAllowlistV1(AllowlistAddress.get());\n        if (allowlist.isDenied(_from)) {\n            revert Denied(_from);\n        }\n        if (allowlist.isDenied(_to)) {\n            revert Denied(_to);\n        }\n    }\n\n    /// @notice Overriden handler called whenever a user deposits ETH to the system. Mints the adequate amount of shares.\n    /// @param _depositor User address that made the deposit\n    /// @param _amount Amount of ETH deposited\n    function _onDeposit(address _depositor, address _recipient, uint256 _amount) internal override {\n        uint256 mintedShares = SharesManagerV1._mintShares(_depositor, _amount);\n        IAllowlistV1 allowlist = IAllowlistV1(AllowlistAddress.get());\n        if (_depositor == _recipient) {\n            allowlist.onlyAllowed(_depositor, DEPOSIT_MASK); // this call reverts if unauthorized or denied\n        } else {\n            allowlist.onlyAllowed(_depositor, DEPOSIT_MASK); // this call reverts if unauthorized or denied\n            if (allowlist.isDenied(_recipient)) {\n                revert Denied(_recipient);\n            }\n            _transfer(_depositor, _recipient, mintedShares);\n        }\n    }\n\n    /// @notice Overriden handler called whenever a deposit to the consensus layer is made. Should retrieve _requestedAmount or lower keys\n    /// @param _requestedAmount Amount of keys required. Contract is expected to send _requestedAmount or lower.\n    /// @return publicKeys Array of fundable public keys\n    /// @return signatures Array of signatures linked to the public keys\n    function _getNextValidators(uint256 _requestedAmount)\n        internal\n        override\n        returns (bytes[] memory publicKeys, bytes[] memory signatures)\n    {\n        return IOperatorsRegistryV1(OperatorsRegistryAddress.get()).pickNextValidators(_requestedAmount);\n    }\n\n    /// @notice Overriden handler to pull funds from the execution layer fee recipient to River and return the delta in the balance\n    /// @param _max The maximum amount to pull from the execution layer fee recipient\n    /// @return The amount pulled from the execution layer fee recipient\n    function _pullELFees(uint256 _max) internal override returns (uint256) {\n        address elFeeRecipient = ELFeeRecipientAddress.get();\n        if (elFeeRecipient == address(0)) {\n            return 0;\n        }\n        uint256 initialBalance = address(this).balance;\n        IELFeeRecipientV1(payable(elFeeRecipient)).pullELFees(_max);\n        uint256 collectedELFees = address(this).balance - initialBalance;\n        BalanceToDeposit.set(BalanceToDeposit.get() + collectedELFees);\n        emit PulledELFees(collectedELFees);\n        return collectedELFees;\n    }\n\n    /// @notice Overriden handler called whenever the balance of ETH handled by the system increases. Computes the fees paid to the collector\n    /// @param _amount Additional ETH received\n    function _onEarnings(uint256 _amount) internal override {\n        uint256 oldTotalSupply = _totalSupply();\n        if (oldTotalSupply == 0) {\n            revert ZeroMintedShares();\n        }\n        uint256 newTotalBalance = _assetBalance();\n        uint256 globalFee = GlobalFee.get();\n        uint256 numerator = _amount * oldTotalSupply * globalFee;\n        uint256 denominator = (newTotalBalance * LibBasisPoints.BASIS_POINTS_MAX) - (_amount * globalFee);\n        uint256 sharesToMint = denominator == 0 ? 0 : (numerator / denominator);\n\n        if (sharesToMint > 0) {\n            address collector = CollectorAddress.get();\n            _mintRawShares(collector, sharesToMint);\n            uint256 newTotalSupply = _totalSupply();\n            uint256 oldTotalBalance = newTotalBalance - _amount;\n            emit RewardsEarned(collector, oldTotalBalance, oldTotalSupply, newTotalBalance, newTotalSupply);\n        }\n    }\n\n    /// @notice Overriden handler called whenever the total balance of ETH is requested\n    /// @return The current total asset balance managed by River\n    function _assetBalance() internal view override returns (uint256) {\n        uint256 clValidatorCount = CLValidatorCount.get();\n        uint256 depositedValidatorCount = DepositedValidatorCount.get();\n        if (clValidatorCount < depositedValidatorCount) {\n            return CLValidatorTotalBalance.get() + BalanceToDeposit.get()\n                + (depositedValidatorCount - clValidatorCount) * ConsensusLayerDepositManagerV1.DEPOSIT_SIZE;\n        } else {\n            return CLValidatorTotalBalance.get() + BalanceToDeposit.get();\n        }\n    }\n}\n"
    },
    "contracts/src/interfaces/IAllowlist.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\n/// @title Allowlist Interface (v1)\n/// @author Kiln\n/// @notice This interface exposes methods to handle the list of allowed recipients.\ninterface IAllowlistV1 {\n    /// @notice The permissions of several accounts have changed\n    /// @param accounts List of accounts\n    /// @param permissions New permissions for each account at the same index\n    event SetAllowlistPermissions(address[] indexed accounts, uint256[] permissions);\n\n    /// @notice The stored allower address has been changed\n    /// @param allower The new allower address\n    event SetAllower(address indexed allower);\n\n    /// @notice The provided accounts list is empty\n    error InvalidAlloweeCount();\n\n    /// @notice The account is denied access\n    /// @param _account The denied account\n    error Denied(address _account);\n\n    /// @notice The provided accounts and permissions list have different lengths\n    error MismatchedAlloweeAndStatusCount();\n\n    /// @notice Initializes the allowlist\n    /// @param _admin Address of the Allowlist administrator\n    /// @param _allower Address of the allower\n    function initAllowlistV1(address _admin, address _allower) external;\n\n    /// @notice Retrieves the allower address\n    /// @return The address of the allower\n    function getAllower() external view returns (address);\n\n    /// @notice This method returns true if the user has the expected permission and\n    ///         is not in the deny list\n    /// @param _account Recipient to verify\n    /// @param _mask Combination of permissions to verify\n    /// @return True if mask is respected and user is allowed\n    function isAllowed(address _account, uint256 _mask) external view returns (bool);\n\n    /// @notice This method returns true if the user is in the deny list\n    /// @param _account Recipient to verify\n    /// @return True if user is denied access\n    function isDenied(address _account) external view returns (bool);\n\n    /// @notice This method returns true if the user has the expected permission\n    ///         ignoring any deny list membership\n    /// @param _account Recipient to verify\n    /// @param _mask Combination of permissions to verify\n    /// @return True if mask is respected\n    function hasPermission(address _account, uint256 _mask) external view returns (bool);\n\n    /// @notice This method retrieves the raw permission value\n    /// @param _account Recipient to verify\n    /// @return The raw permissions value of the account\n    function getPermissions(address _account) external view returns (uint256);\n\n    /// @notice This method should be used as a modifier and is expected to revert\n    ///         if the user hasn't got the required permission or if the user is\n    ///         in the deny list.\n    /// @param _account Recipient to verify\n    /// @param _mask Combination of permissions to verify\n    function onlyAllowed(address _account, uint256 _mask) external view;\n\n    /// @notice Changes the allower address\n    /// @param _newAllowerAddress New address allowed to edit the allowlist\n    function setAllower(address _newAllowerAddress) external;\n\n    /// @notice Sets the allowlisting status for one or more accounts\n    /// @dev The permission value is overridden and not updated\n    /// @param _accounts Accounts with statuses to edit\n    /// @param _permissions Allowlist permissions for each account, in the same order as _accounts\n    function allow(address[] calldata _accounts, uint256[] calldata _permissions) external;\n}\n"
    },
    "contracts/src/interfaces/IOperatorRegistry.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../state/operatorsRegistry/Operators.sol\";\n\n/// @title Operators Registry Interface (v1)\n/// @author Kiln\n/// @notice This interface exposes methods to handle the list of operators and their keys\ninterface IOperatorsRegistryV1 {\n    /// @notice A new operator has been added to the registry\n    /// @param index The operator index\n    /// @param name The operator display name\n    /// @param operatorAddress The operator address\n    event AddedOperator(uint256 indexed index, string name, address indexed operatorAddress);\n\n    /// @notice The operator status has been changed\n    /// @param index The operator index\n    /// @param active True if the operator is active\n    event SetOperatorStatus(uint256 indexed index, bool active);\n\n    /// @notice The operator limit has been changed\n    /// @param index The operator index\n    /// @param newLimit The new operator staking limit\n    event SetOperatorLimit(uint256 indexed index, uint256 newLimit);\n\n    /// @notice The operator stopped validator count has been changed\n    /// @param index The operator index\n    /// @param newStoppedValidatorCount The new stopped validator count\n    event SetOperatorStoppedValidatorCount(uint256 indexed index, uint256 newStoppedValidatorCount);\n\n    /// @notice The operator address has been changed\n    /// @param index The operator index\n    /// @param newOperatorAddress The new operator address\n    event SetOperatorAddress(uint256 indexed index, address indexed newOperatorAddress);\n\n    /// @notice The operator display name has been changed\n    /// @param index The operator index\n    /// @param newName The new display name\n    event SetOperatorName(uint256 indexed index, string newName);\n\n    /// @notice The operator or the admin added new validator keys and signatures\n    /// @dev The public keys and signatures are concatenated\n    /// @dev A public key is 48 bytes long\n    /// @dev A signature is 96 bytes long\n    /// @dev [P1, S1, P2, S2, ..., PN, SN] where N is the bytes length divided by (96 + 48)\n    /// @param index The operator index\n    /// @param publicKeysAndSignatures The concatenated public keys and signatures\n    event AddedValidatorKeys(uint256 indexed index, bytes publicKeysAndSignatures);\n\n    /// @notice The operator or the admin removed a public key and its signature from the registry\n    /// @param index The operator index\n    /// @param publicKey The BLS public key that has been removed\n    event RemovedValidatorKey(uint256 indexed index, bytes publicKey);\n\n    /// @notice The stored river address has been changed\n    /// @param river The new river address\n    event SetRiver(address indexed river);\n\n    /// @notice The operator edited its keys after the snapshot block\n    /// @dev This means that we cannot assume that its key set is checked by the snapshot\n    /// @dev This happens only if the limit was meant to be increased\n    /// @param index The operator index\n    /// @param currentLimit The current operator limit\n    /// @param newLimit The new operator limit that was attempted to be set\n    /// @param latestKeysEditBlockNumber The last block number at which the operator changed its keys\n    /// @param snapshotBlock The block number of the snapshot\n    event OperatorEditsAfterSnapshot(\n        uint256 indexed index,\n        uint256 currentLimit,\n        uint256 newLimit,\n        uint256 indexed latestKeysEditBlockNumber,\n        uint256 indexed snapshotBlock\n    );\n\n    /// @notice The call didn't alter the limit of the operator\n    /// @param index The operator index\n    /// @param limit The limit of the operator\n    event OperatorLimitUnchanged(uint256 indexed index, uint256 limit);\n\n    /// @notice The calling operator is inactive\n    /// @param index The operator index\n    error InactiveOperator(uint256 index);\n\n    /// @notice A funded key deletion has been attempted\n    error InvalidFundedKeyDeletionAttempt();\n\n    /// @notice The index provided are not sorted properly (descending order)\n    error InvalidUnsortedIndexes();\n\n    /// @notice The provided operator and limits array have different lengths\n    error InvalidArrayLengths();\n\n    /// @notice The provided operator and limits array are empty\n    error InvalidEmptyArray();\n\n    /// @notice The provided key count is 0\n    error InvalidKeyCount();\n\n    /// @notice The provided concatenated keys do not have the expected length\n    error InvalidKeysLength();\n\n    /// @notice The index that is removed is out of bounds\n    error InvalidIndexOutOfBounds();\n\n    /// @notice The value for the operator limit is too high\n    /// @param index The operator index\n    /// @param limit The new limit provided\n    /// @param keyCount The operator key count\n    error OperatorLimitTooHigh(uint256 index, uint256 limit, uint256 keyCount);\n\n    /// @notice The value for the limit is too low\n    /// @param index The operator index\n    /// @param limit The new limit provided\n    /// @param fundedKeyCount The operator funded key count\n    error OperatorLimitTooLow(uint256 index, uint256 limit, uint256 fundedKeyCount);\n\n    /// @notice The provided list of operators is not in increasing order\n    error UnorderedOperatorList();\n\n    /// @notice Initializes the operators registry\n    /// @param _admin Admin in charge of managing operators\n    /// @param _river Address of River system\n    function initOperatorsRegistryV1(address _admin, address _river) external;\n\n    /// @notice Retrieve the River address\n    /// @return The address of River\n    function getRiver() external view returns (address);\n\n    /// @notice Get operator details\n    /// @param _index The index of the operator\n    /// @return The details of the operator\n    function getOperator(uint256 _index) external view returns (Operators.Operator memory);\n\n    /// @notice Get operator count\n    /// @return The operator count\n    function getOperatorCount() external view returns (uint256);\n\n    /// @notice Get the details of a validator\n    /// @param _operatorIndex The index of the operator\n    /// @param _validatorIndex The index of the validator\n    /// @return publicKey The public key of the validator\n    /// @return signature The signature used during deposit\n    /// @return funded True if validator has been funded\n    function getValidator(uint256 _operatorIndex, uint256 _validatorIndex)\n        external\n        view\n        returns (bytes memory publicKey, bytes memory signature, bool funded);\n\n    /// @notice Retrieve the active operator set\n    /// @return The list of active operators and their details\n    function listActiveOperators() external view returns (Operators.Operator[] memory);\n\n    /// @notice Adds an operator to the registry\n    /// @dev Only callable by the administrator\n    /// @param _name The name identifying the operator\n    /// @param _operator The address representing the operator, receiving the rewards\n    /// @return The index of the new operator\n    function addOperator(string calldata _name, address _operator) external returns (uint256);\n\n    /// @notice Changes the operator address of an operator\n    /// @dev Only callable by the administrator or the previous operator address\n    /// @param _index The operator index\n    /// @param _newOperatorAddress The new address of the operator\n    function setOperatorAddress(uint256 _index, address _newOperatorAddress) external;\n\n    /// @notice Changes the operator name\n    /// @dev Only callable by the administrator or the operator\n    /// @param _index The operator index\n    /// @param _newName The new operator name\n    function setOperatorName(uint256 _index, string calldata _newName) external;\n\n    /// @notice Changes the operator status\n    /// @dev Only callable by the administrator\n    /// @param _index The operator index\n    /// @param _newStatus The new status of the operator\n    function setOperatorStatus(uint256 _index, bool _newStatus) external;\n\n    /// @notice Changes the operator stopped validator count\n    /// @dev Only callable by the administrator\n    /// @param _index The operator index\n    /// @param _newStoppedValidatorCount The new stopped validator count of the operator\n    function setOperatorStoppedValidatorCount(uint256 _index, uint256 _newStoppedValidatorCount) external;\n\n    /// @notice Changes the operator staking limit\n    /// @dev Only callable by the administrator\n    /// @dev The operator indexes must be in increasing order and contain no duplicate\n    /// @dev The limit cannot exceed the total key count of the operator\n    /// @dev The _indexes and _newLimits must have the same length.\n    /// @dev Each limit value is applied to the operator index at the same index in the _indexes array.\n    /// @param _operatorIndexes The operator indexes, in increasing order and duplicate free\n    /// @param _newLimits The new staking limit of the operators\n    /// @param _snapshotBlock The block number at which the snapshot was computed\n    function setOperatorLimits(\n        uint256[] calldata _operatorIndexes,\n        uint256[] calldata _newLimits,\n        uint256 _snapshotBlock\n    ) external;\n\n    /// @notice Adds new keys for an operator\n    /// @dev Only callable by the administrator or the operator address\n    /// @param _index The operator index\n    /// @param _keyCount The amount of keys provided\n    /// @param _publicKeysAndSignatures Public keys of the validator, concatenated\n    function addValidators(uint256 _index, uint256 _keyCount, bytes calldata _publicKeysAndSignatures) external;\n\n    /// @notice Remove validator keys\n    /// @dev Only callable by the administrator or the operator address\n    /// @dev The indexes must be provided sorted in decreasing order and duplicate-free, otherwise the method will revert\n    /// @dev The operator limit will be set to the lowest deleted key index if the operator's limit wasn't equal to its total key count\n    /// @dev The operator or the admin cannot remove funded keys\n    /// @dev When removing validators, the indexes of specific unfunded keys can be changed in order to properly\n    /// @dev remove the keys from the storage array. Beware of this specific behavior when chaining calls as the\n    /// @dev targeted public key indexes can point to a different key after a first call was made and performed\n    /// @dev some swaps\n    /// @param _index The operator index\n    /// @param _indexes The indexes of the keys to remove\n    function removeValidators(uint256 _index, uint256[] calldata _indexes) external;\n\n    /// @notice Retrieve validator keys based on operator statuses\n    /// @param _count Max amount of keys requested\n    /// @return publicKeys An array of public keys\n    /// @return signatures An array of signatures linked to the public keys\n    function pickNextValidators(uint256 _count)\n        external\n        returns (bytes[] memory publicKeys, bytes[] memory signatures);\n}\n"
    },
    "contracts/src/interfaces/IRiver.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"./components/IConsensusLayerDepositManager.1.sol\";\nimport \"./components/IOracleManager.1.sol\";\nimport \"./components/ISharesManager.1.sol\";\nimport \"./components/IUserDepositManager.1.sol\";\n\n/// @title River Interface (v1)\n/// @author Kiln\n/// @notice The main system interface\ninterface IRiverV1 is IConsensusLayerDepositManagerV1, IUserDepositManagerV1, ISharesManagerV1, IOracleManagerV1 {\n    /// @notice Funds have been pulled from the Execution Layer Fee Recipient\n    /// @param amount The amount pulled\n    event PulledELFees(uint256 amount);\n\n    /// @notice The stored Execution Layer Fee Recipient has been changed\n    /// @param elFeeRecipient The new Execution Layer Fee Recipient\n    event SetELFeeRecipient(address indexed elFeeRecipient);\n\n    /// @notice The stored Collector has been changed\n    /// @param collector The new Collector\n    event SetCollector(address indexed collector);\n\n    /// @notice The stored Allowlist has been changed\n    /// @param allowlist The new Allowlist\n    event SetAllowlist(address indexed allowlist);\n\n    /// @notice The stored Global Fee has been changed\n    /// @param fee The new Global Fee\n    event SetGlobalFee(uint256 fee);\n\n    /// @notice The stored Operators Registry has been changed\n    /// @param operatorRegistry The new Operators Registry\n    event SetOperatorsRegistry(address indexed operatorRegistry);\n\n    /// @notice The system underlying supply increased. This is a snapshot of the balances for accounting purposes\n    /// @param _collector The address of the collector during this event\n    /// @param _oldTotalUnderlyingBalance Old total ETH balance under management by River\n    /// @param _oldTotalSupply Old total supply in shares\n    /// @param _newTotalUnderlyingBalance New total ETH balance under management by River\n    /// @param _newTotalSupply New total supply in shares\n    event RewardsEarned(\n        address indexed _collector,\n        uint256 _oldTotalUnderlyingBalance,\n        uint256 _oldTotalSupply,\n        uint256 _newTotalUnderlyingBalance,\n        uint256 _newTotalSupply\n    );\n\n    /// @notice The computed amount of shares to mint is 0\n    error ZeroMintedShares();\n\n    /// @notice The access was denied\n    /// @param account The account that was denied\n    error Denied(address account);\n\n    /// @notice Initializes the River system\n    /// @param _depositContractAddress Address to make Consensus Layer deposits\n    /// @param _elFeeRecipientAddress Address that receives the execution layer fees\n    /// @param _withdrawalCredentials Credentials to use for every validator deposit\n    /// @param _oracleAddress The address of the Oracle contract\n    /// @param _systemAdministratorAddress Administrator address\n    /// @param _allowlistAddress Address of the allowlist contract\n    /// @param _operatorRegistryAddress Address of the operator registry\n    /// @param _collectorAddress Address receiving the the global fee on revenue\n    /// @param _globalFee Amount retained when the ETH balance increases and sent to the collector\n    function initRiverV1(\n        address _depositContractAddress,\n        address _elFeeRecipientAddress,\n        bytes32 _withdrawalCredentials,\n        address _oracleAddress,\n        address _systemAdministratorAddress,\n        address _allowlistAddress,\n        address _operatorRegistryAddress,\n        address _collectorAddress,\n        uint256 _globalFee\n    ) external;\n\n    /// @notice Get the current global fee\n    /// @return The global fee\n    function getGlobalFee() external view returns (uint256);\n\n    /// @notice Retrieve the allowlist address\n    /// @return The allowlist address\n    function getAllowlist() external view returns (address);\n\n    /// @notice Retrieve the collector address\n    /// @return The collector address\n    function getCollector() external view returns (address);\n\n    /// @notice Retrieve the execution layer fee recipient\n    /// @return The execution layer fee recipient address\n    function getELFeeRecipient() external view returns (address);\n\n    /// @notice Retrieve the operators registry\n    /// @return The operators registry address\n    function getOperatorsRegistry() external view returns (address);\n\n    /// @notice Changes the global fee parameter\n    /// @param newFee New fee value\n    function setGlobalFee(uint256 newFee) external;\n\n    /// @notice Changes the allowlist address\n    /// @param _newAllowlist New address for the allowlist\n    function setAllowlist(address _newAllowlist) external;\n\n    /// @notice Changes the collector address\n    /// @param _newCollector New address for the collector\n    function setCollector(address _newCollector) external;\n\n    /// @notice Changes the execution layer fee recipient\n    /// @param _newELFeeRecipient New address for the recipient\n    function setELFeeRecipient(address _newELFeeRecipient) external;\n\n    /// @notice Input for execution layer fee earnings\n    function sendELFees() external payable;\n}\n"
    },
    "contracts/src/interfaces/IELFeeRecipient.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\n/// @title Execution Layer Fee Recipient Interface (v1)\n/// @author Kiln\n/// @notice This interface exposes methods to receive all the execution layer fees from the proposed blocks + bribes\ninterface IELFeeRecipientV1 {\n    /// @notice The storage river address has changed\n    /// @param river The new river address\n    event SetRiver(address indexed river);\n\n    /// @notice The fallback has been triggered\n    error InvalidCall();\n\n    /// @notice Initialize the fee recipient with the required arguments\n    /// @param _riverAddress Address of River\n    function initELFeeRecipientV1(address _riverAddress) external;\n\n    /// @notice Pulls all the ETH to the River contract\n    /// @dev Only callable by the River contract\n    /// @param _maxAmount The maximum amount to pull into the system\n    function pullELFees(uint256 _maxAmount) external;\n\n    /// @notice Ether receiver\n    receive() external payable;\n\n    /// @notice Invalid fallback detector\n    fallback() external payable;\n}\n"
    },
    "contracts/src/components/ConsensusLayerDepositManager.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../interfaces/components/IConsensusLayerDepositManager.1.sol\";\nimport \"../interfaces/IDepositContract.sol\";\n\nimport \"../libraries/LibBytes.sol\";\nimport \"../libraries/LibUint256.sol\";\n\nimport \"../state/river/DepositContractAddress.sol\";\nimport \"../state/river/WithdrawalCredentials.sol\";\nimport \"../state/river/DepositedValidatorCount.sol\";\nimport \"../state/river/BalanceToDeposit.sol\";\n\n/// @title Consensus Layer Deposit Manager (v1)\n/// @author Kiln\n/// @notice This contract handles the interactions with the official deposit contract, funding all validators\n/// @notice Whenever a deposit to the consensus layer is requested, this contract computed the amount of keys\n/// @notice that could be deposited depending on the amount available in the contract. It then tries to retrieve\n/// @notice validator keys by calling its internal virtual method _getNextValidators. This method should be\n/// @notice overridden by the implementing contract to provide [0; _keyCount] keys when invoked.\nabstract contract ConsensusLayerDepositManagerV1 is IConsensusLayerDepositManagerV1 {\n    /// @notice Size of a BLS Public key in bytes\n    uint256 public constant PUBLIC_KEY_LENGTH = 48;\n    /// @notice Size of a BLS Signature in bytes\n    uint256 public constant SIGNATURE_LENGTH = 96;\n    /// @notice Size of a deposit in ETH\n    uint256 public constant DEPOSIT_SIZE = 32 ether;\n\n    /// @notice Handler called to retrieve the internal River admin address\n    /// @dev Must be overriden\n    function _getRiverAdmin() internal view virtual returns (address);\n\n    /// @notice Prevents unauthorized calls\n    modifier onlyAdmin_CDMV1() {\n        if (msg.sender != _getRiverAdmin()) {\n            revert LibErrors.Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    /// @notice Internal helper to retrieve validator keys ready to be funded\n    /// @dev Must be overridden\n    /// @param _keyCount The amount of keys (or less) to return.\n    function _getNextValidators(uint256 _keyCount)\n        internal\n        virtual\n        returns (bytes[] memory publicKeys, bytes[] memory signatures);\n\n    /// @notice Initializer to set the deposit contract address and the withdrawal credentials to use\n    /// @param _depositContractAddress The address of the deposit contract\n    /// @param _withdrawalCredentials The withdrawal credentials to apply to all deposits\n    function initConsensusLayerDepositManagerV1(address _depositContractAddress, bytes32 _withdrawalCredentials)\n        internal\n    {\n        DepositContractAddress.set(_depositContractAddress);\n        emit SetDepositContractAddress(_depositContractAddress);\n\n        WithdrawalCredentials.set(_withdrawalCredentials);\n        emit SetWithdrawalCredentials(_withdrawalCredentials);\n    }\n\n    /// @inheritdoc IConsensusLayerDepositManagerV1\n    function getBalanceToDeposit() external view returns (uint256) {\n        return BalanceToDeposit.get();\n    }\n\n    /// @inheritdoc IConsensusLayerDepositManagerV1\n    function getWithdrawalCredentials() external view returns (bytes32) {\n        return WithdrawalCredentials.get();\n    }\n\n    /// @inheritdoc IConsensusLayerDepositManagerV1\n    function getDepositedValidatorCount() external view returns (uint256) {\n        return DepositedValidatorCount.get();\n    }\n\n    /// @inheritdoc IConsensusLayerDepositManagerV1\n    function depositToConsensusLayer(uint256 _maxCount) external onlyAdmin_CDMV1 {\n        uint256 balanceToDeposit = BalanceToDeposit.get();\n        uint256 keyToDepositCount = LibUint256.min(balanceToDeposit / DEPOSIT_SIZE, _maxCount);\n\n        if (keyToDepositCount == 0) {\n            revert NotEnoughFunds();\n        }\n\n        (bytes[] memory publicKeys, bytes[] memory signatures) = _getNextValidators(keyToDepositCount);\n\n        uint256 receivedPublicKeyCount = publicKeys.length;\n\n        if (receivedPublicKeyCount == 0) {\n            revert NoAvailableValidatorKeys();\n        }\n\n        if (receivedPublicKeyCount > keyToDepositCount) {\n            revert InvalidPublicKeyCount();\n        }\n\n        uint256 receivedSignatureCount = signatures.length;\n\n        if (receivedSignatureCount != receivedPublicKeyCount) {\n            revert InvalidSignatureCount();\n        }\n\n        bytes32 withdrawalCredentials = WithdrawalCredentials.get();\n\n        if (withdrawalCredentials == 0) {\n            revert InvalidWithdrawalCredentials();\n        }\n\n        for (uint256 idx = 0; idx < receivedPublicKeyCount;) {\n            _depositValidator(publicKeys[idx], signatures[idx], withdrawalCredentials);\n            unchecked {\n                ++idx;\n            }\n        }\n        BalanceToDeposit.set(balanceToDeposit - DEPOSIT_SIZE * receivedPublicKeyCount);\n        DepositedValidatorCount.set(DepositedValidatorCount.get() + receivedPublicKeyCount);\n    }\n\n    /// @notice Deposits 32 ETH to the official Deposit contract\n    /// @param _publicKey The public key of the validator\n    /// @param _signature The signature provided by the operator\n    /// @param _withdrawalCredentials The withdrawal credentials provided by River\n    function _depositValidator(bytes memory _publicKey, bytes memory _signature, bytes32 _withdrawalCredentials)\n        internal\n    {\n        if (_publicKey.length != PUBLIC_KEY_LENGTH) {\n            revert InconsistentPublicKeys();\n        }\n\n        if (_signature.length != SIGNATURE_LENGTH) {\n            revert InconsistentSignatures();\n        }\n        uint256 value = DEPOSIT_SIZE;\n\n        uint256 depositAmount = value / 1 gwei;\n\n        bytes32 pubkeyRoot = sha256(bytes.concat(_publicKey, bytes16(0)));\n        bytes32 signatureRoot = sha256(\n            bytes.concat(\n                sha256(LibBytes.slice(_signature, 0, 64)),\n                sha256(bytes.concat(LibBytes.slice(_signature, 64, SIGNATURE_LENGTH - 64), bytes32(0)))\n            )\n        );\n\n        bytes32 depositDataRoot = sha256(\n            bytes.concat(\n                sha256(bytes.concat(pubkeyRoot, _withdrawalCredentials)),\n                sha256(bytes.concat(bytes32(LibUint256.toLittleEndian64(depositAmount)), signatureRoot))\n            )\n        );\n\n        uint256 targetBalance = address(this).balance - value;\n\n        IDepositContract(DepositContractAddress.get()).deposit{value: value}(\n            _publicKey, abi.encodePacked(_withdrawalCredentials), _signature, depositDataRoot\n        );\n        if (address(this).balance != targetBalance) {\n            revert ErrorOnDeposit();\n        }\n        emit FundedValidatorKey(_publicKey);\n    }\n}\n"
    },
    "contracts/src/components/UserDepositManager.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../interfaces/components/IUserDepositManager.1.sol\";\n\nimport \"../libraries/LibSanitize.sol\";\n\nimport \"../state/river/BalanceToDeposit.sol\";\n\n/// @title User Deposit Manager (v1)\n/// @author Kiln\n/// @notice This contract handles the inbound transfers cases or the explicit submissions\nabstract contract UserDepositManagerV1 is IUserDepositManagerV1 {\n    /// @notice Handler called whenever a user has sent funds to the contract\n    /// @dev Must be overridden\n    /// @param _depositor Address that made the deposit\n    /// @param _recipient Address that receives the minted shares\n    /// @param _amount Amount deposited\n    function _onDeposit(address _depositor, address _recipient, uint256 _amount) internal virtual;\n\n    /// @inheritdoc IUserDepositManagerV1\n    function deposit() external payable {\n        _deposit(msg.sender);\n    }\n\n    /// @inheritdoc IUserDepositManagerV1\n    function depositAndTransfer(address _recipient) external payable {\n        LibSanitize._notZeroAddress(_recipient);\n        _deposit(_recipient);\n    }\n\n    /// @inheritdoc IUserDepositManagerV1\n    receive() external payable {\n        _deposit(msg.sender);\n    }\n\n    /// @inheritdoc IUserDepositManagerV1\n    fallback() external payable {\n        revert LibErrors.InvalidCall();\n    }\n\n    /// @notice Internal utility calling the deposit handler and emitting the deposit details\n    /// @param _recipient The account receiving the minted shares\n    function _deposit(address _recipient) internal {\n        if (msg.value == 0) {\n            revert EmptyDeposit();\n        }\n\n        BalanceToDeposit.set(BalanceToDeposit.get() + msg.value);\n\n        _onDeposit(msg.sender, _recipient, msg.value);\n\n        emit UserDeposit(msg.sender, _recipient, msg.value);\n    }\n}\n"
    },
    "contracts/src/components/SharesManager.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../interfaces/components/ISharesManager.1.sol\";\n\nimport \"../libraries/LibSanitize.sol\";\n\nimport \"../state/river/Shares.sol\";\nimport \"../state/river/SharesPerOwner.sol\";\nimport \"../state/shared/ApprovalsPerOwner.sol\";\n\n/// @title Shares Manager (v1)\n/// @author Kiln\n/// @notice This contract handles the shares of the depositor and the ERC20 interface\nabstract contract SharesManagerV1 is ISharesManagerV1 {\n    /// @notice Internal hook triggered on the external transfer call\n    /// @dev Must be overridden\n    /// @param _from Address of the sender\n    /// @param _to Address of the recipient\n    function _onTransfer(address _from, address _to) internal view virtual;\n\n    /// @notice Internal method to override to provide the total underlying asset balance\n    /// @dev Must be overridden\n    /// @return The total asset balance of the system\n    function _assetBalance() internal view virtual returns (uint256);\n\n    /// @notice Modifier used to ensure that the transfer is allowed by using the internal hook to perform internal checks\n    /// @param _from Address of the sender\n    /// @param _to Address of the recipient\n    modifier transferAllowed(address _from, address _to) {\n        _onTransfer(_from, _to);\n        _;\n    }\n\n    /// @notice Modifier used to ensure the amount transferred is not 0\n    /// @param _value Amount to check\n    modifier isNotZero(uint256 _value) {\n        if (_value == 0) {\n            revert NullTransfer();\n        }\n        _;\n    }\n\n    /// @notice Modifier used to ensure that the sender has enough funds for the transfer\n    /// @param _owner Address of the sender\n    /// @param _value Value that is required to be sent\n    modifier hasFunds(address _owner, uint256 _value) {\n        if (_balanceOf(_owner) < _value) {\n            revert BalanceTooLow();\n        }\n        _;\n    }\n\n    /// @inheritdoc ISharesManagerV1\n    function name() external pure returns (string memory) {\n        return \"Liquid Staked ETH\";\n    }\n\n    /// @inheritdoc ISharesManagerV1\n    function symbol() external pure returns (string memory) {\n        return \"LsETH\";\n    }\n\n    /// @inheritdoc ISharesManagerV1\n    function decimals() external pure returns (uint8) {\n        return 18;\n    }\n\n    /// @inheritdoc ISharesManagerV1\n    function totalSupply() external view returns (uint256) {\n        return _totalSupply();\n    }\n\n    /// @inheritdoc ISharesManagerV1\n    function totalUnderlyingSupply() external view returns (uint256) {\n        return _assetBalance();\n    }\n\n    /// @inheritdoc ISharesManagerV1\n    function balanceOf(address _owner) external view returns (uint256) {\n        return _balanceOf(_owner);\n    }\n\n    /// @inheritdoc ISharesManagerV1\n    function balanceOfUnderlying(address _owner) public view returns (uint256) {\n        return _balanceFromShares(SharesPerOwner.get(_owner));\n    }\n\n    /// @inheritdoc ISharesManagerV1\n    function underlyingBalanceFromShares(uint256 _shares) external view returns (uint256) {\n        return _balanceFromShares(_shares);\n    }\n\n    /// @inheritdoc ISharesManagerV1\n    function sharesFromUnderlyingBalance(uint256 _underlyingAssetAmount) external view returns (uint256) {\n        return _sharesFromBalance(_underlyingAssetAmount);\n    }\n\n    /// @inheritdoc ISharesManagerV1\n    function allowance(address _owner, address _spender) external view returns (uint256) {\n        return ApprovalsPerOwner.get(_owner, _spender);\n    }\n\n    /// @inheritdoc ISharesManagerV1\n    function transfer(address _to, uint256 _value)\n        external\n        transferAllowed(msg.sender, _to)\n        isNotZero(_value)\n        hasFunds(msg.sender, _value)\n        returns (bool)\n    {\n        if (_to == address(0)) {\n            revert UnauthorizedTransfer(msg.sender, address(0));\n        }\n        return _transfer(msg.sender, _to, _value);\n    }\n\n    /// @inheritdoc ISharesManagerV1\n    function transferFrom(address _from, address _to, uint256 _value)\n        external\n        transferAllowed(_from, _to)\n        isNotZero(_value)\n        hasFunds(_from, _value)\n        returns (bool)\n    {\n        if (_to == address(0)) {\n            revert UnauthorizedTransfer(_from, address(0));\n        }\n        _spendAllowance(_from, _value);\n        return _transfer(_from, _to, _value);\n    }\n\n    /// @inheritdoc ISharesManagerV1\n    function approve(address _spender, uint256 _value) external returns (bool) {\n        _approve(msg.sender, _spender, _value);\n        return true;\n    }\n\n    /// @inheritdoc ISharesManagerV1\n    function increaseAllowance(address _spender, uint256 _additionalValue) external returns (bool) {\n        _approve(msg.sender, _spender, ApprovalsPerOwner.get(msg.sender, _spender) + _additionalValue);\n        return true;\n    }\n\n    /// @inheritdoc ISharesManagerV1\n    function decreaseAllowance(address _spender, uint256 _subtractableValue) external returns (bool) {\n        _approve(msg.sender, _spender, ApprovalsPerOwner.get(msg.sender, _spender) - _subtractableValue);\n        return true;\n    }\n\n    /// @notice Internal utility to spend the allowance of an account from the message sender\n    /// @param _from Address owning the allowance\n    /// @param _value Amount of allowance in shares to spend\n    function _spendAllowance(address _from, uint256 _value) internal {\n        uint256 currentAllowance = ApprovalsPerOwner.get(_from, msg.sender);\n        if (currentAllowance < _value) {\n            revert AllowanceTooLow(_from, msg.sender, currentAllowance, _value);\n        }\n        if (currentAllowance != type(uint256).max) {\n            _approve(_from, msg.sender, currentAllowance - _value);\n        }\n    }\n\n    /// @notice Internal utility to change the allowance of an owner to a spender\n    /// @param _owner The owner of the shares\n    /// @param _spender The allowed spender of the shares\n    /// @param _value The new allowance value\n    function _approve(address _owner, address _spender, uint256 _value) internal {\n        LibSanitize._notZeroAddress(_owner);\n        LibSanitize._notZeroAddress(_spender);\n        ApprovalsPerOwner.set(_owner, _spender, _value);\n        emit Approval(_owner, _spender, _value);\n    }\n\n    /// @notice Internal utility to retrieve the total supply of tokens\n    /// @return The total supply\n    function _totalSupply() internal view returns (uint256) {\n        return Shares.get();\n    }\n\n    /// @notice Internal utility to perform an unchecked transfer\n    /// @param _from Address sending the tokens\n    /// @param _to Address receiving the tokens\n    /// @param _value Amount of shares to be sent\n    /// @return True if success\n    function _transfer(address _from, address _to, uint256 _value) internal returns (bool) {\n        SharesPerOwner.set(_from, SharesPerOwner.get(_from) - _value);\n        SharesPerOwner.set(_to, SharesPerOwner.get(_to) + _value);\n\n        emit Transfer(_from, _to, _value);\n\n        return true;\n    }\n\n    /// @notice Internal utility to retrieve the underlying asset balance for the given shares\n    /// @param _shares Amount of shares to convert\n    /// @return The balance from the given shares\n    function _balanceFromShares(uint256 _shares) internal view returns (uint256) {\n        uint256 _totalSharesValue = Shares.get();\n\n        if (_totalSharesValue == 0) {\n            return 0;\n        }\n\n        return ((_shares * _assetBalance())) / _totalSharesValue;\n    }\n\n    /// @notice Internal utility to retrieve the shares count for a given underlying asset amount\n    /// @param _balance Amount of underlying asset balance to convert\n    /// @return The shares from the given balance\n    function _sharesFromBalance(uint256 _balance) internal view returns (uint256) {\n        uint256 _totalSharesValue = Shares.get();\n\n        if (_totalSharesValue == 0) {\n            return 0;\n        }\n\n        return (_balance * _totalSharesValue) / _assetBalance();\n    }\n\n    /// @notice Internal utility to mint shares for the specified user\n    /// @dev This method assumes that funds received are now part of the _assetBalance()\n    /// @param _owner Account that should receive the new shares\n    /// @param _underlyingAssetValue Value of underlying asset received, to convert into shares\n    /// @return sharesToMint The amnount of minted shares\n    function _mintShares(address _owner, uint256 _underlyingAssetValue) internal returns (uint256 sharesToMint) {\n        uint256 oldTotalAssetBalance = _assetBalance() - _underlyingAssetValue;\n\n        if (oldTotalAssetBalance == 0) {\n            sharesToMint = _underlyingAssetValue;\n            _mintRawShares(_owner, _underlyingAssetValue);\n        } else {\n            sharesToMint = (_underlyingAssetValue * _totalSupply()) / oldTotalAssetBalance;\n            _mintRawShares(_owner, sharesToMint);\n        }\n    }\n\n    /// @notice Internal utility to mint shares without any conversion, and emits a mint Transfer event\n    /// @param _owner Account that should receive the new shares\n    /// @param _value Amount of shares to mint\n    function _mintRawShares(address _owner, uint256 _value) internal {\n        Shares.set(Shares.get() + _value);\n        SharesPerOwner.set(_owner, SharesPerOwner.get(_owner) + _value);\n        emit Transfer(address(0), _owner, _value);\n    }\n\n    /// @notice Internal utility to retrieve the amount of shares per owner\n    /// @param _owner Account to be checked\n    /// @return The balance of the account in shares\n    function _balanceOf(address _owner) internal view returns (uint256) {\n        return SharesPerOwner.get(_owner);\n    }\n}\n"
    },
    "contracts/src/components/OracleManager.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../interfaces/components/IOracleManager.1.sol\";\n\nimport \"../state/river/OracleAddress.sol\";\nimport \"../state/river/LastOracleRoundId.sol\";\nimport \"../state/river/CLValidatorTotalBalance.sol\";\nimport \"../state/river/CLValidatorCount.sol\";\nimport \"../state/river/DepositedValidatorCount.sol\";\n\n/// @title Oracle Manager (v1)\n/// @author Kiln\n/// @notice This contract handles the inputs provided by the oracle\n/// @notice The Oracle contract is plugged to this contract and is in charge of pushing\n/// @notice data whenever a new report has been deemed valid. The report consists in two\n/// @notice values: the sum of all balances of all deposited validators and the count of\n/// @notice validators that have been activated on the consensus layer.\nabstract contract OracleManagerV1 is IOracleManagerV1 {\n    /// @notice Handler called if the delta between the last and new validator balance sum is positive\n    /// @dev Must be overridden\n    /// @param _profits The positive increase in the validator balance sum (staking rewards)\n    function _onEarnings(uint256 _profits) internal virtual;\n\n    /// @notice Handler called to pull the Execution layer fees from the recipient\n    /// @dev Must be overridden\n    /// @param _max The maximum amount to pull inside the system\n    /// @return The amount pulled inside the system\n    function _pullELFees(uint256 _max) internal virtual returns (uint256);\n\n    /// @notice Handler called to retrieve the system administrator address\n    /// @dev Must be overridden\n    /// @return The system administrator address\n    function _getRiverAdmin() internal view virtual returns (address);\n\n    /// @notice Prevents unauthorized calls\n    modifier onlyAdmin_OMV1() {\n        if (msg.sender != _getRiverAdmin()) {\n            revert LibErrors.Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    /// @notice Set the initial oracle address\n    /// @param _oracle Address of the oracle\n    function initOracleManagerV1(address _oracle) internal {\n        OracleAddress.set(_oracle);\n        emit SetOracle(_oracle);\n    }\n\n    /// @inheritdoc IOracleManagerV1\n    function getOracle() external view returns (address) {\n        return OracleAddress.get();\n    }\n\n    /// @inheritdoc IOracleManagerV1\n    function getCLValidatorTotalBalance() external view returns (uint256) {\n        return CLValidatorTotalBalance.get();\n    }\n\n    /// @inheritdoc IOracleManagerV1\n    function getCLValidatorCount() external view returns (uint256) {\n        return CLValidatorCount.get();\n    }\n\n    /// @inheritdoc IOracleManagerV1\n    function setOracle(address _oracleAddress) external onlyAdmin_OMV1 {\n        OracleAddress.set(_oracleAddress);\n        emit SetOracle(_oracleAddress);\n    }\n\n    /// @inheritdoc IOracleManagerV1\n    function setConsensusLayerData(\n        uint256 _validatorCount,\n        uint256 _validatorTotalBalance,\n        bytes32 _roundId,\n        uint256 _maxIncrease\n    ) external {\n        if (msg.sender != OracleAddress.get()) {\n            revert LibErrors.Unauthorized(msg.sender);\n        }\n\n        if (_validatorCount > DepositedValidatorCount.get()) {\n            revert InvalidValidatorCountReport(_validatorCount, DepositedValidatorCount.get());\n        }\n\n        uint256 newValidators = _validatorCount - CLValidatorCount.get();\n        uint256 previousValidatorTotalBalance = CLValidatorTotalBalance.get() + (newValidators * 32 ether);\n\n        CLValidatorTotalBalance.set(_validatorTotalBalance);\n        CLValidatorCount.set(_validatorCount);\n        LastOracleRoundId.set(_roundId);\n\n        uint256 executionLayerFees;\n\n        // if there's a margin left for pulling the execution layer fees that would leave our delta under the allowed maxIncrease value, do it\n        if ((_maxIncrease + previousValidatorTotalBalance) > _validatorTotalBalance) {\n            executionLayerFees = _pullELFees((_maxIncrease + previousValidatorTotalBalance) - _validatorTotalBalance);\n        }\n\n        if (previousValidatorTotalBalance < _validatorTotalBalance + executionLayerFees) {\n            _onEarnings((_validatorTotalBalance + executionLayerFees) - previousValidatorTotalBalance);\n        }\n\n        emit ConsensusLayerDataUpdate(_validatorCount, _validatorTotalBalance, _roundId);\n    }\n}\n"
    },
    "contracts/src/Initializable.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"./state/shared/Version.sol\";\n\n/// @title Initializable\n/// @author Kiln\n/// @notice This contract ensures that initializers are called only once per version\ncontract Initializable {\n    /// @notice An error occured during the initialization\n    /// @param version The version that was attempting to be initialized\n    /// @param expectedVersion The version that was expected\n    error InvalidInitialization(uint256 version, uint256 expectedVersion);\n\n    /// @notice Emitted when the contract is properly initialized\n    /// @param version New version of the contracts\n    /// @param cdata Complete calldata that was used during the initialization\n    event Initialize(uint256 version, bytes cdata);\n\n    /// @notice Use this modifier on initializers along with a hard-coded version number\n    /// @param _version Version to initialize\n    modifier init(uint256 _version) {\n        if (_version != Version.get()) {\n            revert InvalidInitialization(_version, Version.get());\n        }\n        Version.set(_version + 1); // prevents reentrency on the called method\n        _;\n        emit Initialize(_version, msg.data);\n    }\n}\n"
    },
    "contracts/src/state/river/AllowlistAddress.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\nimport \"../../libraries/LibSanitize.sol\";\n\n/// @title Allowlist Address Storage\n/// @notice Utility to manage the Allowlist Address in storage\nlibrary AllowlistAddress {\n    /// @notice Storage slot of the Allowlist Address\n    bytes32 internal constant ALLOWLIST_ADDRESS_SLOT = bytes32(uint256(keccak256(\"river.state.allowlistAddress\")) - 1);\n\n    /// @notice Retrieve the Allowlist Address\n    /// @return The Allowlist Address\n    function get() internal view returns (address) {\n        return LibUnstructuredStorage.getStorageAddress(ALLOWLIST_ADDRESS_SLOT);\n    }\n\n    /// @notice Sets the Allowlist Address\n    /// @param _newValue New Allowlist Address\n    function set(address _newValue) internal {\n        LibSanitize._notZeroAddress(_newValue);\n        LibUnstructuredStorage.setStorageAddress(ALLOWLIST_ADDRESS_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/river/OperatorsRegistryAddress.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\nimport \"../../libraries/LibSanitize.sol\";\n\n/// @title Operators Registry Address Storage\n/// @notice Utility to manage the Operators Registry Address in storage\nlibrary OperatorsRegistryAddress {\n    /// @notice Storage slot of the Operators Registry Address\n    bytes32 internal constant OPERATORS_REGISTRY_ADDRESS_SLOT =\n        bytes32(uint256(keccak256(\"river.state.operatorsRegistryAddress\")) - 1);\n\n    /// @notice Retrieve the Operators Registry Address\n    /// @return The Operators Registry Address\n    function get() internal view returns (address) {\n        return LibUnstructuredStorage.getStorageAddress(OPERATORS_REGISTRY_ADDRESS_SLOT);\n    }\n\n    /// @notice Sets the Operators Registry Address\n    /// @param _newValue New Operators Registry Address\n    function set(address _newValue) internal {\n        LibSanitize._notZeroAddress(_newValue);\n        LibUnstructuredStorage.setStorageAddress(OPERATORS_REGISTRY_ADDRESS_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/river/CollectorAddress.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\nimport \"../../libraries/LibSanitize.sol\";\n\n/// @title Collector Address Storage\n/// @notice Utility to manage the Collector Address in storage\nlibrary CollectorAddress {\n    /// @notice Storage slot of the Collector Address\n    bytes32 internal constant COLLECTOR_ADDRESS_SLOT = bytes32(uint256(keccak256(\"river.state.collectorAddress\")) - 1);\n\n    /// @notice Retrieve the Collector Address\n    /// @return The Collector Address\n    function get() internal view returns (address) {\n        return LibUnstructuredStorage.getStorageAddress(COLLECTOR_ADDRESS_SLOT);\n    }\n\n    /// @notice Sets the Collector Address\n    /// @param _newValue New Collector Address\n    function set(address _newValue) internal {\n        LibSanitize._notZeroAddress(_newValue);\n        LibUnstructuredStorage.setStorageAddress(COLLECTOR_ADDRESS_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/river/GlobalFee.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibSanitize.sol\";\nimport \"../../libraries/LibUnstructuredStorage.sol\";\n\n/// @title Global Fee Storage\n/// @notice Utility to manage the Global Fee in storage\nlibrary GlobalFee {\n    /// @notice Storage slot of the Global Fee\n    bytes32 internal constant GLOBAL_FEE_SLOT = bytes32(uint256(keccak256(\"river.state.globalFee\")) - 1);\n\n    /// @notice Retrieve the Global Fee\n    /// @return The Global Fee\n    function get() internal view returns (uint256) {\n        return LibUnstructuredStorage.getStorageUint256(GLOBAL_FEE_SLOT);\n    }\n\n    /// @notice Sets the Global Fee\n    /// @param _newValue New Global Fee\n    function set(uint256 _newValue) internal {\n        LibSanitize._validFee(_newValue);\n        LibUnstructuredStorage.setStorageUint256(GLOBAL_FEE_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/river/ELFeeRecipientAddress.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\n\n/// @title Execution Layer Fee Recipient Address Storage\n/// @notice Utility to manage the Execution Layer Fee Recipient Address in storage\nlibrary ELFeeRecipientAddress {\n    /// @notice Storage slot of the Execution Layer Fee Recipient Address\n    bytes32 internal constant EL_FEE_RECIPIENT_ADDRESS =\n        bytes32(uint256(keccak256(\"river.state.elFeeRecipientAddress\")) - 1);\n\n    /// @notice Retrieve the Execution Layer Fee Recipient Address\n    /// @return The Execution Layer Fee Recipient Address\n    function get() internal view returns (address) {\n        return LibUnstructuredStorage.getStorageAddress(EL_FEE_RECIPIENT_ADDRESS);\n    }\n\n    /// @notice Sets the Execution Layer Fee Recipient Address\n    /// @param _newValue New Execution Layer Fee Recipient Address\n    function set(address _newValue) internal {\n        LibUnstructuredStorage.setStorageAddress(EL_FEE_RECIPIENT_ADDRESS, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/operatorsRegistry/Operators.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibSanitize.sol\";\n\n/// @title Operators Storage\n/// @notice Utility to manage the Operators in storage\nlibrary Operators {\n    /// @notice Storage slot of the Operators\n    bytes32 internal constant OPERATORS_SLOT = bytes32(uint256(keccak256(\"river.state.operators\")) - 1);\n\n    /// @notice The Operator structure in storage\n    struct Operator {\n        /// @custom:attribute True if the operator is active and allowed to operate on River\n        bool active;\n        /// @custom:attribute Display name of the operator\n        string name;\n        /// @custom:attribute Address of the operator\n        address operator;\n        /// @dev The following values respect this invariant:\n        /// @dev     keys >= limit >= funded >= stopped\n\n        /// @custom:attribute Staking limit of the operator\n        uint256 limit;\n        /// @custom:attribute The count of funded validators\n        uint256 funded;\n        /// @custom:attribute The total count of keys of the operator\n        uint256 keys;\n        /// @custom:attribute The count of stopped validators. Stopped validators are validators\n        ///                   that exited the consensus layer (voluntary or slashed)\n        uint256 stopped;\n        uint256 latestKeysEditBlockNumber;\n    }\n\n    /// @notice The Operator structure when loaded in memory\n    struct CachedOperator {\n        /// @custom:attribute True if the operator is active and allowed to operate on River\n        bool active;\n        /// @custom:attribute Display name of the operator\n        string name;\n        /// @custom:attribute Address of the operator\n        address operator;\n        /// @custom:attribute Staking limit of the operator\n        uint256 limit;\n        /// @custom:attribute The count of funded validators\n        uint256 funded;\n        /// @custom:attribute The total count of keys of the operator\n        uint256 keys;\n        /// @custom:attribute The count of stopped validators\n        uint256 stopped;\n        /// @custom:attribute The count of stopped validators. Stopped validators are validators\n        ///                   that exited the consensus layer (voluntary or slashed)\n        uint256 index;\n        /// @custom:attribute The amount of picked keys, buffer used before changing funded in storage\n        uint256 picked;\n    }\n\n    /// @notice The structure at the storage slot\n    struct SlotOperator {\n        /// @custom:attribute Array containing all the operators\n        Operator[] value;\n    }\n\n    /// @notice The operator was not found\n    /// @param index The provided index\n    error OperatorNotFound(uint256 index);\n\n    /// @notice Retrieve the operator in storage\n    /// @param _index The index of the operator\n    /// @return The Operator structure\n    function get(uint256 _index) internal view returns (Operator storage) {\n        bytes32 slot = OPERATORS_SLOT;\n\n        SlotOperator storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        if (r.value.length <= _index) {\n            revert OperatorNotFound(_index);\n        }\n\n        return r.value[_index];\n    }\n\n    /// @notice Retrieve the operator count in storage\n    /// @return The count of operators in storage\n    function getCount() internal view returns (uint256) {\n        bytes32 slot = OPERATORS_SLOT;\n\n        SlotOperator storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value.length;\n    }\n\n    /// @notice Retrieve all the active operators\n    /// @return The list of active operator structures\n    function getAllActive() internal view returns (Operator[] memory) {\n        bytes32 slot = OPERATORS_SLOT;\n\n        SlotOperator storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        uint256 activeCount = 0;\n        uint256 operatorCount = r.value.length;\n\n        for (uint256 idx = 0; idx < operatorCount;) {\n            if (r.value[idx].active) {\n                unchecked {\n                    ++activeCount;\n                }\n            }\n            unchecked {\n                ++idx;\n            }\n        }\n\n        Operator[] memory activeOperators = new Operator[](activeCount);\n\n        uint256 activeIdx = 0;\n        for (uint256 idx = 0; idx < operatorCount;) {\n            if (r.value[idx].active) {\n                activeOperators[activeIdx] = r.value[idx];\n                unchecked {\n                    ++activeIdx;\n                }\n            }\n            unchecked {\n                ++idx;\n            }\n        }\n\n        return activeOperators;\n    }\n\n    /// @notice Retrieve all the active and fundable operators\n    /// @return The list of active and fundable operators\n    function getAllFundable() internal view returns (CachedOperator[] memory) {\n        bytes32 slot = OPERATORS_SLOT;\n\n        SlotOperator storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        uint256 activeCount = 0;\n        uint256 operatorCount = r.value.length;\n\n        for (uint256 idx = 0; idx < operatorCount;) {\n            if (_hasFundableKeys(r.value[idx])) {\n                unchecked {\n                    ++activeCount;\n                }\n            }\n            unchecked {\n                ++idx;\n            }\n        }\n\n        CachedOperator[] memory activeOperators = new CachedOperator[](activeCount);\n\n        uint256 activeIdx = 0;\n        for (uint256 idx = 0; idx < operatorCount;) {\n            Operator memory op = r.value[idx];\n            if (_hasFundableKeys(op)) {\n                activeOperators[activeIdx] = CachedOperator({\n                    active: op.active,\n                    name: op.name,\n                    operator: op.operator,\n                    limit: op.limit,\n                    funded: op.funded,\n                    keys: op.keys,\n                    stopped: op.stopped,\n                    index: idx,\n                    picked: 0\n                });\n                unchecked {\n                    ++activeIdx;\n                }\n            }\n            unchecked {\n                ++idx;\n            }\n        }\n\n        return activeOperators;\n    }\n\n    /// @notice Add a new operator in storage\n    /// @param _newOperator Value of the new operator\n    /// @return The size of the operator array after the operation\n    function push(Operator memory _newOperator) internal returns (uint256) {\n        LibSanitize._notZeroAddress(_newOperator.operator);\n        LibSanitize._notEmptyString(_newOperator.name);\n        bytes32 slot = OPERATORS_SLOT;\n\n        SlotOperator storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        r.value.push(_newOperator);\n\n        return r.value.length;\n    }\n\n    /// @notice Atomic operation to set the key count and update the latestKeysEditBlockNumber field at the same time\n    /// @param _index The operator index\n    /// @param _newKeys The new value for the key count\n    function setKeys(uint256 _index, uint256 _newKeys) internal {\n        Operator storage op = get(_index);\n\n        op.keys = _newKeys;\n        op.latestKeysEditBlockNumber = block.number;\n    }\n\n    /// @notice Checks if an operator is active and has fundable keys\n    /// @param _operator The operator details\n    /// @return True if active and fundable\n    function _hasFundableKeys(Operators.Operator memory _operator) internal pure returns (bool) {\n        return (_operator.active && _operator.limit > _operator.funded);\n    }\n}\n"
    },
    "contracts/src/interfaces/components/IConsensusLayerDepositManager.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\n/// @title Consensys Layer Deposit Manager Interface (v1)\n/// @author Kiln\n/// @notice This interface exposes methods to handle the interactions with the official deposit contract\ninterface IConsensusLayerDepositManagerV1 {\n    /// @notice A validator key got funded on the deposit contract\n    /// @param publicKey BLS Public key that got funded\n    event FundedValidatorKey(bytes publicKey);\n\n    /// @notice The stored deposit contract address changed\n    /// @param depositContract Address of the deposit contract\n    event SetDepositContractAddress(address indexed depositContract);\n\n    /// @notice The stored withdrawal credentials changed\n    /// @param withdrawalCredentials The withdrawal credentials to use for deposits\n    event SetWithdrawalCredentials(bytes32 withdrawalCredentials);\n\n    /// @notice Not enough funds to deposit one validator\n    error NotEnoughFunds();\n\n    /// @notice The length of the BLS Public key is invalid during deposit\n    error InconsistentPublicKeys();\n\n    /// @notice The length of the BLS Signature is invalid during deposit\n    error InconsistentSignatures();\n\n    /// @notice The internal key retrieval returned no keys\n    error NoAvailableValidatorKeys();\n\n    /// @notice The received count of public keys to deposit is invalid\n    error InvalidPublicKeyCount();\n\n    /// @notice The received count of signatures to deposit is invalid\n    error InvalidSignatureCount();\n\n    /// @notice The withdrawal credentials value is null\n    error InvalidWithdrawalCredentials();\n\n    /// @notice An error occured during the deposit\n    error ErrorOnDeposit();\n\n    /// @notice Returns the amount of pending ETH\n    /// @return The amount of pending ETH\n    function getBalanceToDeposit() external view returns (uint256);\n\n    /// @notice Retrieve the withdrawal credentials\n    /// @return The withdrawal credentials\n    function getWithdrawalCredentials() external view returns (bytes32);\n\n    /// @notice Get the deposited validator count (the count of deposits made by the contract)\n    /// @return The deposited validator count\n    function getDepositedValidatorCount() external view returns (uint256);\n\n    /// @notice Deposits current balance to the Consensus Layer by batches of 32 ETH\n    /// @param _maxCount The maximum amount of validator keys to fund\n    function depositToConsensusLayer(uint256 _maxCount) external;\n}\n"
    },
    "contracts/src/interfaces/components/IOracleManager.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\n/// @title Oracle Manager (v1)\n/// @author Kiln\n/// @notice This interface exposes methods to handle the inputs provided by the oracle\ninterface IOracleManagerV1 {\n    /// @notice The stored oracle address changed\n    /// @param oracleAddress The new oracle address\n    event SetOracle(address indexed oracleAddress);\n\n    /// @notice The consensus layer data provided by the oracle has been updated\n    /// @param validatorCount The new count of validators running on the consensus layer\n    /// @param validatorTotalBalance The new total balance sum of all validators\n    /// @param roundId Round identifier\n    event ConsensusLayerDataUpdate(uint256 validatorCount, uint256 validatorTotalBalance, bytes32 roundId);\n\n    /// @notice The reported validator count is invalid\n    /// @param providedValidatorCount The received validator count value\n    /// @param depositedValidatorCount The number of deposits performed by the system\n    error InvalidValidatorCountReport(uint256 providedValidatorCount, uint256 depositedValidatorCount);\n\n    /// @notice Get oracle address\n    /// @return The oracle address\n    function getOracle() external view returns (address);\n\n    /// @notice Get CL validator total balance\n    /// @return The CL Validator total balance\n    function getCLValidatorTotalBalance() external view returns (uint256);\n\n    /// @notice Get CL validator count (the amount of validator reported by the oracles)\n    /// @return The CL validator count\n    function getCLValidatorCount() external view returns (uint256);\n\n    /// @notice Set the oracle address\n    /// @param _oracleAddress Address of the oracle\n    function setOracle(address _oracleAddress) external;\n\n    /// @notice Sets the validator count and validator total balance sum reported by the oracle\n    /// @dev Can only be called by the oracle address\n    /// @dev The round id is a blackbox value that should only be used to identify unique reports\n    /// @dev When a report is performed, River computes the amount of fees that can be pulled\n    /// @dev from the execution layer fee recipient. This amount is capped by the max allowed\n    /// @dev increase provided during the report.\n    /// @dev If the total asset balance increases (from the reported total balance and the pulled funds)\n    /// @dev we then compute the share that must be taken for the collector on the positive delta.\n    /// @dev The execution layer fees are taken into account here because they are the product of\n    /// @dev node operator's work, just like consensus layer fees, and both should be handled in the\n    /// @dev same manner, as a single revenue stream for the users and the collector.\n    /// @param _validatorCount The number of active validators on the consensus layer\n    /// @param _validatorTotalBalance The balance sum of the active validators on the consensus layer\n    /// @param _roundId An identifier for this update\n    /// @param _maxIncrease The maximum allowed increase in the total balance\n    function setConsensusLayerData(\n        uint256 _validatorCount,\n        uint256 _validatorTotalBalance,\n        bytes32 _roundId,\n        uint256 _maxIncrease\n    ) external;\n}\n"
    },
    "contracts/src/interfaces/components/ISharesManager.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\n\n/// @title Shares Manager Interface (v1)\n/// @author Kiln\n/// @notice This interface exposes methods to handle the shares of the depositor and the ERC20 interface\ninterface ISharesManagerV1 is IERC20 {\n    /// @notice Balance too low to perform operation\n    error BalanceTooLow();\n\n    /// @notice Allowance too low to perform operation\n    /// @param _from Account where funds are sent from\n    /// @param _operator Account attempting the transfer\n    /// @param _allowance Current allowance\n    /// @param _value Requested transfer value in shares\n    error AllowanceTooLow(address _from, address _operator, uint256 _allowance, uint256 _value);\n\n    /// @notice Invalid empty transfer\n    error NullTransfer();\n\n    /// @notice Invalid transfer recipients\n    /// @param _from Account sending the funds in the invalid transfer\n    /// @param _to Account receiving the funds in the invalid transfer\n    error UnauthorizedTransfer(address _from, address _to);\n\n    /// @notice Retrieve the token name\n    /// @return The token name\n    function name() external pure returns (string memory);\n\n    /// @notice Retrieve the token symbol\n    /// @return The token symbol\n    function symbol() external pure returns (string memory);\n\n    /// @notice Retrieve the decimal count\n    /// @return The decimal count\n    function decimals() external pure returns (uint8);\n\n    /// @notice Retrieve the total token supply\n    /// @return The total supply in shares\n    function totalSupply() external view returns (uint256);\n\n    /// @notice Retrieve the total underlying asset supply\n    /// @return The total underlying asset supply\n    function totalUnderlyingSupply() external view returns (uint256);\n\n    /// @notice Retrieve the balance of an account\n    /// @param _owner Address to be checked\n    /// @return The balance of the account in shares\n    function balanceOf(address _owner) external view returns (uint256);\n\n    /// @notice Retrieve the underlying asset balance of an account\n    /// @param _owner Address to be checked\n    /// @return The underlying balance of the account\n    function balanceOfUnderlying(address _owner) external view returns (uint256);\n\n    /// @notice Retrieve the underlying asset balance from an amount of shares\n    /// @param _shares Amount of shares to convert\n    /// @return The underlying asset balance represented by the shares\n    function underlyingBalanceFromShares(uint256 _shares) external view returns (uint256);\n\n    /// @notice Retrieve the shares count from an underlying asset amount\n    /// @param _underlyingAssetAmount Amount of underlying asset to convert\n    /// @return The amount of shares worth the underlying asset amopunt\n    function sharesFromUnderlyingBalance(uint256 _underlyingAssetAmount) external view returns (uint256);\n\n    /// @notice Retrieve the allowance value for a spender\n    /// @param _owner Address that issued the allowance\n    /// @param _spender Address that received the allowance\n    /// @return The allowance in shares for a given spender\n    function allowance(address _owner, address _spender) external view returns (uint256);\n\n    /// @notice Performs a transfer from the message sender to the provided account\n    /// @param _to Address receiving the tokens\n    /// @param _value Amount of shares to be sent\n    /// @return True if success\n    function transfer(address _to, uint256 _value) external returns (bool);\n\n    /// @notice Performs a transfer between two recipients\n    /// @param _from Address sending the tokens\n    /// @param _to Address receiving the tokens\n    /// @param _value Amount of shares to be sent\n    /// @return True if success\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\n\n    /// @notice Approves an account for future spendings\n    /// @dev An approved account can use transferFrom to transfer funds on behalf of the token owner\n    /// @param _spender Address that is allowed to spend the tokens\n    /// @param _value The allowed amount in shares, will override previous value\n    /// @return True if success\n    function approve(address _spender, uint256 _value) external returns (bool);\n\n    /// @notice Increase allowance to another account\n    /// @param _spender Spender that receives the allowance\n    /// @param _additionalValue Amount of shares to add\n    /// @return True if success\n    function increaseAllowance(address _spender, uint256 _additionalValue) external returns (bool);\n\n    /// @notice Decrease allowance to another account\n    /// @param _spender Spender that receives the allowance\n    /// @param _subtractableValue Amount of shares to subtract\n    /// @return True if success\n    function decreaseAllowance(address _spender, uint256 _subtractableValue) external returns (bool);\n}\n"
    },
    "contracts/src/interfaces/components/IUserDepositManager.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\n/// @title User Deposit Manager (v1)\n/// @author Kiln\n/// @notice This interface exposes methods to handle the inbound transfers cases or the explicit submissions\ninterface IUserDepositManagerV1 {\n    /// @notice User deposited ETH in the system\n    /// @param depositor Address performing the deposit\n    /// @param recipient Address receiving the minted shares\n    /// @param amount Amount in ETH deposited\n    event UserDeposit(address indexed depositor, address indexed recipient, uint256 amount);\n\n    /// @notice And empty deposit attempt was made\n    error EmptyDeposit();\n\n    /// @notice Explicit deposit method to mint on msg.sender\n    function deposit() external payable;\n\n    /// @notice Explicit deposit method to mint on msg.sender and transfer to _recipient\n    /// @param _recipient Address receiving the minted LsETH\n    function depositAndTransfer(address _recipient) external payable;\n\n    /// @notice Implicit deposit method, when the user performs a regular transfer to the contract\n    receive() external payable;\n\n    /// @notice Invalid call, when the user sends a transaction with a data payload but no method matched\n    fallback() external payable;\n}\n"
    },
    "openzeppelin-contracts/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "contracts/src/interfaces/IDepositContract.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\n/// @title Deposit Contract Interface\n/// @notice This interface exposes methods to perform validator deposits\ninterface IDepositContract {\n    /// @notice Official deposit method to activate a validator on the consensus layer\n    /// @param pubkey The 48 bytes long BLS Public key representing the validator\n    /// @param withdrawalCredentials The 32 bytes long withdrawal credentials, configures the withdrawal recipient\n    /// @param signature The 96 bytes long BLS Signature performed by the pubkey's private key\n    /// @param depositDataRoot The root hash of the whole deposit data structure\n    function deposit(\n        bytes calldata pubkey,\n        bytes calldata withdrawalCredentials,\n        bytes calldata signature,\n        bytes32 depositDataRoot\n    ) external payable;\n}\n"
    },
    "contracts/src/libraries/LibBytes.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\n/// @title Lib Bytes\n/// @notice This library helps manipulating bytes\nlibrary LibBytes {\n    /// @notice The length overflows an uint\n    error SliceOverflow();\n\n    /// @notice The slice is outside of the initial bytes bounds\n    error SliceOutOfBounds();\n\n    /// @notice Slices the provided bytes\n    /// @param _bytes Bytes to slice\n    /// @param _start The starting index of the slice\n    /// @param _length The length of the slice\n    /// @return The slice of _bytes starting at _start of length _length\n    function slice(bytes memory _bytes, uint256 _start, uint256 _length) internal pure returns (bytes memory) {\n        unchecked {\n            if (_length + 31 < _length) {\n                revert SliceOverflow();\n            }\n        }\n        if (_bytes.length < _start + _length) {\n            revert SliceOutOfBounds();\n        }\n\n        bytes memory tempBytes;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } { mstore(mc, mload(cc)) }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n}\n"
    },
    "contracts/src/libraries/LibUint256.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\n/// @title Lib Uint256\n/// @notice Utilities to perform uint operations\nlibrary LibUint256 {\n    /// @notice Converts a value to little endian (64 bits)\n    /// @param _value The value to convert\n    /// @return result The converted value\n    function toLittleEndian64(uint256 _value) internal pure returns (uint256 result) {\n        result = 0;\n        uint256 tempValue = _value;\n        result = tempValue & 0xFF;\n        tempValue >>= 8;\n\n        result = (result << 8) | (tempValue & 0xFF);\n        tempValue >>= 8;\n\n        result = (result << 8) | (tempValue & 0xFF);\n        tempValue >>= 8;\n\n        result = (result << 8) | (tempValue & 0xFF);\n        tempValue >>= 8;\n\n        result = (result << 8) | (tempValue & 0xFF);\n        tempValue >>= 8;\n\n        result = (result << 8) | (tempValue & 0xFF);\n        tempValue >>= 8;\n\n        result = (result << 8) | (tempValue & 0xFF);\n        tempValue >>= 8;\n\n        result = (result << 8) | (tempValue & 0xFF);\n        tempValue >>= 8;\n\n        assert(0 == tempValue); // fully converted\n        result <<= (24 * 8);\n    }\n\n    /// @notice Returns the minimum value\n    /// @param _a First value\n    /// @param _b Second value\n    /// @return Smallest value between _a and _b\n    function min(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        return (_a > _b ? _b : _a);\n    }\n}\n"
    },
    "contracts/src/state/river/DepositContractAddress.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibSanitize.sol\";\nimport \"../../libraries/LibUnstructuredStorage.sol\";\n\n/// @title Deposit Contract Address Storage\n/// @notice Utility to manage the Deposit Contract Address in storage\nlibrary DepositContractAddress {\n    /// @notice Storage slot of the Deposit Contract Address\n    bytes32 internal constant DEPOSIT_CONTRACT_ADDRESS_SLOT =\n        bytes32(uint256(keccak256(\"river.state.depositContractAddress\")) - 1);\n\n    /// @notice Retrieve the Deposit Contract Address\n    /// @return The Deposit Contract Address\n    function get() internal view returns (address) {\n        return LibUnstructuredStorage.getStorageAddress(DEPOSIT_CONTRACT_ADDRESS_SLOT);\n    }\n\n    /// @notice Sets the Deposit Contract Address\n    /// @param _newValue New Deposit Contract Address\n    function set(address _newValue) internal {\n        LibSanitize._notZeroAddress(_newValue);\n        LibUnstructuredStorage.setStorageAddress(DEPOSIT_CONTRACT_ADDRESS_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/river/WithdrawalCredentials.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibErrors.sol\";\nimport \"../../libraries/LibUnstructuredStorage.sol\";\n\n/// @title Withdrawal Credentials Storage\n/// @notice Utility to manage the Withdrawal Credentials in storage\nlibrary WithdrawalCredentials {\n    /// @notice Storage slot of the Withdrawal Credentials\n    bytes32 internal constant WITHDRAWAL_CREDENTIALS_SLOT =\n        bytes32(uint256(keccak256(\"river.state.withdrawalCredentials\")) - 1);\n\n    /// @notice Retrieve the Withdrawal Credentials\n    /// @return The Withdrawal Credentials\n    function get() internal view returns (bytes32) {\n        return LibUnstructuredStorage.getStorageBytes32(WITHDRAWAL_CREDENTIALS_SLOT);\n    }\n\n    /// @notice Sets the Withdrawal Credentials\n    /// @param _newValue New Withdrawal Credentials\n    function set(bytes32 _newValue) internal {\n        if (_newValue == bytes32(0)) {\n            revert LibErrors.InvalidArgument();\n        }\n        LibUnstructuredStorage.setStorageBytes32(WITHDRAWAL_CREDENTIALS_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/river/DepositedValidatorCount.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\n\n/// @title Deposited Validator Count Storage\n/// @notice Utility to manage the Deposited Validator Count in storage\nlibrary DepositedValidatorCount {\n    /// @notice Storage slot of the Deposited Validator Count\n    bytes32 internal constant DEPOSITED_VALIDATOR_COUNT_SLOT =\n        bytes32(uint256(keccak256(\"river.state.depositedValidatorCount\")) - 1);\n\n    /// @notice Retrieve the Deposited Validator Count\n    /// @return The Deposited Validator Count\n    function get() internal view returns (uint256) {\n        return LibUnstructuredStorage.getStorageUint256(DEPOSITED_VALIDATOR_COUNT_SLOT);\n    }\n\n    /// @notice Sets the Deposited Validator Count\n    /// @param _newValue New Deposited Validator Count\n    function set(uint256 _newValue) internal {\n        LibUnstructuredStorage.setStorageUint256(DEPOSITED_VALIDATOR_COUNT_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/river/BalanceToDeposit.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\n\nlibrary BalanceToDeposit {\n    bytes32 internal constant BALANCE_TO_DEPOSIT_SLOT = bytes32(uint256(keccak256(\"river.state.balanceToDeposit\")) - 1);\n\n    function get() internal view returns (uint256) {\n        return LibUnstructuredStorage.getStorageUint256(BALANCE_TO_DEPOSIT_SLOT);\n    }\n\n    function set(uint256 newValue) internal {\n        LibUnstructuredStorage.setStorageUint256(BALANCE_TO_DEPOSIT_SLOT, newValue);\n    }\n}\n"
    },
    "contracts/src/state/river/Shares.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\n\n/// @title Shares Count Storage\n/// @notice Utility to manage the Shares Count in storage\nlibrary Shares {\n    /// @notice Storage slot of the Shares Count\n    bytes32 internal constant SHARES_SLOT = bytes32(uint256(keccak256(\"river.state.shares\")) - 1);\n\n    /// @notice Retrieve the Shares Count\n    /// @return The Shares Count\n    function get() internal view returns (uint256) {\n        return LibUnstructuredStorage.getStorageUint256(SHARES_SLOT);\n    }\n\n    /// @notice Sets the Shares Count\n    /// @param _newValue New Shares Count\n    function set(uint256 _newValue) internal {\n        LibUnstructuredStorage.setStorageUint256(SHARES_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/river/SharesPerOwner.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\n/// @title Shares Per Owner Storage\n/// @notice Utility to manage the Shares Per Owner in storage\nlibrary SharesPerOwner {\n    /// @notice Storage slot of the Shares Per Owner\n    bytes32 internal constant SHARES_PER_OWNER_SLOT = bytes32(uint256(keccak256(\"river.state.sharesPerOwner\")) - 1);\n\n    /// @notice Structure in storage\n    struct Slot {\n        /// @custom:attribute The mapping from an owner to its share count\n        mapping(address => uint256) value;\n    }\n\n    /// @notice Retrieve the share count for given owner\n    /// @param _owner The address to get the balance of\n    /// @return The amount of shares\n    function get(address _owner) internal view returns (uint256) {\n        bytes32 slot = SHARES_PER_OWNER_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value[_owner];\n    }\n\n    /// @notice Set the amount of shares for an owner\n    /// @param _owner The owner of the shares to edit\n    /// @param _newValue The new shares value for the owner\n    function set(address _owner, uint256 _newValue) internal {\n        bytes32 slot = SHARES_PER_OWNER_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        r.value[_owner] = _newValue;\n    }\n}\n"
    },
    "contracts/src/state/shared/ApprovalsPerOwner.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\n/// @title Approvals Per Owner Storage\n/// @notice Utility to manage the Approvals Per Owner in storage\nlibrary ApprovalsPerOwner {\n    /// @notice Storage slot of the Approvals Per Owner\n    bytes32 internal constant APPROVALS_PER_OWNER_SLOT =\n        bytes32(uint256(keccak256(\"river.state.approvalsPerOwner\")) - 1);\n\n    /// @notice The structure in storage\n    struct Slot {\n        /// @custom:attribute The mapping from an owner to an operator to the approval amount\n        mapping(address => mapping(address => uint256)) value;\n    }\n\n    /// @notice Retrieve the approval for an owner to an operator\n    /// @param _owner The account that gave the approval\n    /// @param _operator The account receiving the approval\n    /// @return The value of the approval\n    function get(address _owner, address _operator) internal view returns (uint256) {\n        bytes32 slot = APPROVALS_PER_OWNER_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value[_owner][_operator];\n    }\n\n    /// @notice Set the approval value for an owner to an operator\n    /// @param _owner The account that gives the approval\n    /// @param _operator The account receiving the approval\n    /// @param _newValue The value of the approval\n    function set(address _owner, address _operator, uint256 _newValue) internal {\n        bytes32 slot = APPROVALS_PER_OWNER_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        r.value[_owner][_operator] = _newValue;\n    }\n}\n"
    },
    "contracts/src/state/river/OracleAddress.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\nimport \"../../libraries/LibSanitize.sol\";\n\n/// @title Oracle Address Storage\n/// @notice Utility to manage the Oracle Address in storage\nlibrary OracleAddress {\n    /// @notice Storage slot of the Oracle Address\n    bytes32 internal constant ORACLE_ADDRESS_SLOT = bytes32(uint256(keccak256(\"river.state.oracleAddress\")) - 1);\n\n    /// @notice Retrieve the Oracle Address\n    /// @return The Oracle Address\n    function get() internal view returns (address) {\n        return LibUnstructuredStorage.getStorageAddress(ORACLE_ADDRESS_SLOT);\n    }\n\n    /// @notice Sets the Oracle Address\n    /// @param _newValue New Oracle Address\n    function set(address _newValue) internal {\n        LibSanitize._notZeroAddress(_newValue);\n        LibUnstructuredStorage.setStorageAddress(ORACLE_ADDRESS_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/river/LastOracleRoundId.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\n\n/// @title Last Oracle Round Id Storage\n/// @notice Utility to manage the Last Oracle Round Id in storage\nlibrary LastOracleRoundId {\n    /// @notice Storage slot of the Last Oracle Round Id\n    bytes32 internal constant LAST_ORACLE_ROUND_ID_SLOT =\n        bytes32(uint256(keccak256(\"river.state.lastOracleRoundId\")) - 1);\n\n    /// @notice Retrieve the Last Oracle Round Id\n    /// @return The Last Oracle Round Id\n    function get() internal view returns (bytes32) {\n        return LibUnstructuredStorage.getStorageBytes32(LAST_ORACLE_ROUND_ID_SLOT);\n    }\n\n    /// @notice Sets the Last Oracle Round Id\n    /// @param _newValue New Last Oracle Round Id\n    function set(bytes32 _newValue) internal {\n        LibUnstructuredStorage.setStorageBytes32(LAST_ORACLE_ROUND_ID_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/river/CLValidatorTotalBalance.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\n\n/// @title Consensus Layer Validator Total Balance Storage\n/// @notice Utility to manage the Consensus Layer Validator Total Balance in storage\nlibrary CLValidatorTotalBalance {\n    /// @notice Storage slot of the Consensus Layer Validator Total Balance\n    bytes32 internal constant CL_VALIDATOR_TOTAL_BALANCE_SLOT =\n        bytes32(uint256(keccak256(\"river.state.clValidatorTotalBalance\")) - 1);\n\n    /// @notice Retrieve the Consensus Layer Validator Total Balance\n    /// @return The Consensus Layer Validator Total Balance\n    function get() internal view returns (uint256) {\n        return LibUnstructuredStorage.getStorageUint256(CL_VALIDATOR_TOTAL_BALANCE_SLOT);\n    }\n\n    /// @notice Sets the Consensus Layer Validator Total Balance\n    /// @param _newValue New Consensus Layer Validator Total Balance\n    function set(uint256 _newValue) internal {\n        LibUnstructuredStorage.setStorageUint256(CL_VALIDATOR_TOTAL_BALANCE_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/river/CLValidatorCount.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\n\n/// @title Consensus Layer Validator Count Storage\n/// @notice Utility to manage the Consensus Layer Validator Count in storage\nlibrary CLValidatorCount {\n    /// @notice Storage slot of the Consensus Layer Validator Count\n    bytes32 internal constant CL_VALIDATOR_COUNT_SLOT = bytes32(uint256(keccak256(\"river.state.clValidatorCount\")) - 1);\n\n    /// @notice Retrieve the Consensus Layer Validator Count\n    /// @return The Consensus Layer Validator Count\n    function get() internal view returns (uint256) {\n        return LibUnstructuredStorage.getStorageUint256(CL_VALIDATOR_COUNT_SLOT);\n    }\n\n    /// @notice Sets the Consensus Layer Validator Count\n    /// @param _newValue New Consensus Layer Validator Count\n    function set(uint256 _newValue) internal {\n        LibUnstructuredStorage.setStorageUint256(CL_VALIDATOR_COUNT_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/shared/Version.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\n\n/// @title Version Storage\n/// @notice Utility to manage the Version in storage\nlibrary Version {\n    /// @notice Storage slot of the Version\n    bytes32 public constant VERSION_SLOT = bytes32(uint256(keccak256(\"river.state.version\")) - 1);\n\n    /// @notice Retrieve the Version\n    /// @return The Version\n    function get() internal view returns (uint256) {\n        return LibUnstructuredStorage.getStorageUint256(VERSION_SLOT);\n    }\n\n    /// @notice Sets the Version\n    /// @param _newValue New Version\n    function set(uint256 _newValue) internal {\n        LibUnstructuredStorage.setStorageUint256(VERSION_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/oracle/OracleMembers.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibSanitize.sol\";\n\n/// @title Oracle Members Storage\n/// @notice Utility to manage the Oracle Members in storage\n/// @dev There can only be up to 256 oracle members. This is due to how report statuses are stored in Reports Positions\nlibrary OracleMembers {\n    /// @notice Storage slot of the Oracle Members\n    bytes32 internal constant ORACLE_MEMBERS_SLOT = bytes32(uint256(keccak256(\"river.state.oracleMembers\")) - 1);\n\n    /// @notice The structure in storage\n    struct Slot {\n        /// @custom:attribute The array of oracle members\n        address[] value;\n    }\n\n    /// @notice Retrieve the list of oracle members\n    /// @return List of oracle members\n    function get() internal view returns (address[] memory) {\n        bytes32 slot = ORACLE_MEMBERS_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value;\n    }\n\n    /// @notice Add a new oracle member to the list\n    /// @param _newOracleMember Address of the new oracle member\n    function push(address _newOracleMember) internal {\n        LibSanitize._notZeroAddress(_newOracleMember);\n\n        bytes32 slot = ORACLE_MEMBERS_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        r.value.push(_newOracleMember);\n    }\n\n    /// @notice Set an address in the oracle member list\n    /// @param _index The index to edit\n    /// @param _newOracleAddress The new value of the oracle member\n    function set(uint256 _index, address _newOracleAddress) internal {\n        bytes32 slot = ORACLE_MEMBERS_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        r.value[_index] = _newOracleAddress;\n    }\n\n    /// @notice Retrieve the index of the oracle member\n    /// @param _memberAddress The address to lookup\n    /// @return The index of the member, -1 if not found\n    function indexOf(address _memberAddress) internal view returns (int256) {\n        bytes32 slot = ORACLE_MEMBERS_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        for (uint256 idx = 0; idx < r.value.length;) {\n            if (r.value[idx] == _memberAddress) {\n                return int256(idx);\n            }\n            unchecked {\n                ++idx;\n            }\n        }\n\n        return int256(-1);\n    }\n\n    /// @notice Delete the oracle member at the given index\n    /// @param _idx The index of the member to remove\n    function deleteItem(uint256 _idx) internal {\n        bytes32 slot = ORACLE_MEMBERS_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        uint256 lastIdx = r.value.length - 1;\n        if (lastIdx != _idx) {\n            r.value[_idx] = r.value[lastIdx];\n        }\n\n        r.value.pop();\n    }\n}\n"
    },
    "contracts/src/Oracle.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"./interfaces/IRiver.1.sol\";\nimport \"./interfaces/IOracle.1.sol\";\n\nimport \"./Administrable.sol\";\nimport \"./Initializable.sol\";\n\nimport \"./state/shared/RiverAddress.sol\";\nimport \"./state/oracle/OracleMembers.sol\";\nimport \"./state/oracle/Quorum.sol\";\nimport \"./state/oracle/ExpectedEpochId.sol\";\nimport \"./state/oracle/LastEpochId.sol\";\nimport \"./state/oracle/ReportsPositions.sol\";\nimport \"./state/oracle/ReportsVariants.sol\";\n\n/// @title Oracle (v1)\n/// @author Kiln\n/// @notice This contract handles the input from the allowed oracle members. Highly inspired by Lido's implementation.\ncontract OracleV1 is IOracleV1, Initializable, Administrable {\n    /// @notice One Year value\n    uint256 internal constant ONE_YEAR = 365 days;\n\n    /// @notice Received ETH input has only 9 decimals\n    uint128 internal constant DENOMINATION_OFFSET = 1e9;\n\n    /// @inheritdoc IOracleV1\n    function initOracleV1(\n        address _river,\n        address _administratorAddress,\n        uint64 _epochsPerFrame,\n        uint64 _slotsPerEpoch,\n        uint64 _secondsPerSlot,\n        uint64 _genesisTime,\n        uint256 _annualAprUpperBound,\n        uint256 _relativeLowerBound\n    ) external init(0) {\n        _setAdmin(_administratorAddress);\n        RiverAddress.set(_river);\n        emit SetRiver(_river);\n        CLSpec.set(\n            CLSpec.CLSpecStruct({\n                epochsPerFrame: _epochsPerFrame,\n                slotsPerEpoch: _slotsPerEpoch,\n                secondsPerSlot: _secondsPerSlot,\n                genesisTime: _genesisTime\n            })\n        );\n        emit SetSpec(_epochsPerFrame, _slotsPerEpoch, _secondsPerSlot, _genesisTime);\n        ReportBounds.set(\n            ReportBounds.ReportBoundsStruct({\n                annualAprUpperBound: _annualAprUpperBound,\n                relativeLowerBound: _relativeLowerBound\n            })\n        );\n        emit SetBounds(_annualAprUpperBound, _relativeLowerBound);\n        Quorum.set(0);\n        emit SetQuorum(0);\n    }\n\n    /// @inheritdoc IOracleV1\n    function getRiver() external view returns (address) {\n        return RiverAddress.get();\n    }\n\n    /// @inheritdoc IOracleV1\n    function getTime() external view returns (uint256) {\n        return _getTime();\n    }\n\n    /// @inheritdoc IOracleV1\n    function getExpectedEpochId() external view returns (uint256) {\n        return ExpectedEpochId.get();\n    }\n\n    /// @inheritdoc IOracleV1\n    function getMemberReportStatus(address _oracleMember) external view returns (bool) {\n        int256 memberIndex = OracleMembers.indexOf(_oracleMember);\n        return memberIndex != -1 && ReportsPositions.get(uint256(memberIndex));\n    }\n\n    /// @inheritdoc IOracleV1\n    function getGlobalReportStatus() external view returns (uint256) {\n        return ReportsPositions.getRaw();\n    }\n\n    /// @inheritdoc IOracleV1\n    function getReportVariantsCount() external view returns (uint256) {\n        return ReportsVariants.get().length;\n    }\n\n    /// @inheritdoc IOracleV1\n    function getReportVariant(uint256 _idx)\n        external\n        view\n        returns (uint64 _clBalance, uint32 _clValidators, uint16 _reportCount)\n    {\n        uint256 report = ReportsVariants.get()[_idx];\n        (_clBalance, _clValidators) = _decodeReport(report);\n        _reportCount = _getReportCount(report);\n    }\n\n    /// @inheritdoc IOracleV1\n    function getLastCompletedEpochId() external view returns (uint256) {\n        return LastEpochId.get();\n    }\n\n    /// @inheritdoc IOracleV1\n    function getCurrentEpochId() external view returns (uint256) {\n        CLSpec.CLSpecStruct memory clSpec = CLSpec.get();\n        return _getCurrentEpochId(clSpec);\n    }\n\n    /// @inheritdoc IOracleV1\n    function getQuorum() external view returns (uint256) {\n        return Quorum.get();\n    }\n\n    /// @inheritdoc IOracleV1\n    function getCLSpec() external view returns (CLSpec.CLSpecStruct memory) {\n        return CLSpec.get();\n    }\n\n    /// @inheritdoc IOracleV1\n    function getCurrentFrame() external view returns (uint256 _startEpochId, uint256 _startTime, uint256 _endTime) {\n        CLSpec.CLSpecStruct memory clSpec = CLSpec.get();\n        _startEpochId = _getFrameFirstEpochId(_getCurrentEpochId(clSpec), clSpec);\n        uint256 secondsPerEpoch = clSpec.secondsPerSlot * clSpec.slotsPerEpoch;\n        _startTime = clSpec.genesisTime + _startEpochId * secondsPerEpoch;\n        _endTime = _startTime + secondsPerEpoch * clSpec.epochsPerFrame - 1;\n    }\n\n    /// @inheritdoc IOracleV1\n    function getFrameFirstEpochId(uint256 _epochId) external view returns (uint256) {\n        CLSpec.CLSpecStruct memory clSpec = CLSpec.get();\n        return _getFrameFirstEpochId(_epochId, clSpec);\n    }\n\n    /// @inheritdoc IOracleV1\n    function getReportBounds() external view returns (ReportBounds.ReportBoundsStruct memory) {\n        return ReportBounds.get();\n    }\n\n    /// @inheritdoc IOracleV1\n    function getOracleMembers() external view returns (address[] memory) {\n        return OracleMembers.get();\n    }\n\n    /// @inheritdoc IOracleV1\n    function isMember(address _memberAddress) external view returns (bool) {\n        return OracleMembers.indexOf(_memberAddress) >= 0;\n    }\n\n    /// @inheritdoc IOracleV1\n    function addMember(address _newOracleMember, uint256 _newQuorum) external onlyAdmin {\n        int256 memberIdx = OracleMembers.indexOf(_newOracleMember);\n        if (memberIdx >= 0) {\n            revert AddressAlreadyInUse(_newOracleMember);\n        }\n        OracleMembers.push(_newOracleMember);\n        uint256 previousQuorum = Quorum.get();\n        _clearReportsAndSetQuorum(_newQuorum, previousQuorum);\n        emit AddMember(_newOracleMember);\n    }\n\n    /// @inheritdoc IOracleV1\n    function removeMember(address _oracleMember, uint256 _newQuorum) external onlyAdmin {\n        int256 memberIdx = OracleMembers.indexOf(_oracleMember);\n        if (memberIdx < 0) {\n            revert LibErrors.InvalidCall();\n        }\n        OracleMembers.deleteItem(uint256(memberIdx));\n        uint256 previousQuorum = Quorum.get();\n        _clearReportsAndSetQuorum(_newQuorum, previousQuorum);\n        emit RemoveMember(_oracleMember);\n    }\n\n    /// @inheritdoc IOracleV1\n    function setMember(address _oracleMember, address _newAddress) external onlyAdmin {\n        LibSanitize._notZeroAddress(_newAddress);\n        if (OracleMembers.indexOf(_newAddress) >= 0) {\n            revert AddressAlreadyInUse(_newAddress);\n        }\n        int256 memberIdx = OracleMembers.indexOf(_oracleMember);\n        if (memberIdx < 0) {\n            revert LibErrors.InvalidCall();\n        }\n        OracleMembers.set(uint256(memberIdx), _newAddress);\n        emit SetMember(_oracleMember, _newAddress);\n        _clearReports();\n    }\n\n    /// @inheritdoc IOracleV1\n    function setCLSpec(uint64 _epochsPerFrame, uint64 _slotsPerEpoch, uint64 _secondsPerSlot, uint64 _genesisTime)\n        external\n        onlyAdmin\n    {\n        CLSpec.set(\n            CLSpec.CLSpecStruct({\n                epochsPerFrame: _epochsPerFrame,\n                slotsPerEpoch: _slotsPerEpoch,\n                secondsPerSlot: _secondsPerSlot,\n                genesisTime: _genesisTime\n            })\n        );\n        emit SetSpec(_epochsPerFrame, _slotsPerEpoch, _secondsPerSlot, _genesisTime);\n    }\n\n    /// @inheritdoc IOracleV1\n    function setReportBounds(uint256 _annualAprUpperBound, uint256 _relativeLowerBound) external onlyAdmin {\n        ReportBounds.set(\n            ReportBounds.ReportBoundsStruct({\n                annualAprUpperBound: _annualAprUpperBound,\n                relativeLowerBound: _relativeLowerBound\n            })\n        );\n        emit SetBounds(_annualAprUpperBound, _relativeLowerBound);\n    }\n\n    /// @inheritdoc IOracleV1\n    function setQuorum(uint256 _newQuorum) external onlyAdmin {\n        uint256 previousQuorum = Quorum.get();\n        if (previousQuorum == _newQuorum) {\n            revert LibErrors.InvalidArgument();\n        }\n        _clearReportsAndSetQuorum(_newQuorum, previousQuorum);\n    }\n\n    /// @inheritdoc IOracleV1\n    function reportConsensusLayerData(uint256 _epochId, uint64 _clValidatorsBalance, uint32 _clValidatorCount)\n        external\n    {\n        int256 memberIndex = OracleMembers.indexOf(msg.sender);\n        if (memberIndex == -1) {\n            revert LibErrors.Unauthorized(msg.sender);\n        }\n\n        CLSpec.CLSpecStruct memory clSpec = CLSpec.get();\n        uint256 expectedEpochId = ExpectedEpochId.get();\n        if (_epochId < expectedEpochId) {\n            revert EpochTooOld(_epochId, expectedEpochId);\n        }\n\n        if (_epochId > expectedEpochId) {\n            uint256 frameFirstEpochId = _getFrameFirstEpochId(_getCurrentEpochId(clSpec), clSpec);\n            if (_epochId != frameFirstEpochId) {\n                revert NotFrameFirstEpochId(_epochId, frameFirstEpochId);\n            }\n            _clearReportsAndUpdateExpectedEpochId(_epochId);\n        }\n\n        if (ReportsPositions.get(uint256(memberIndex))) {\n            revert AlreadyReported(_epochId, msg.sender);\n        }\n        ReportsPositions.register(uint256(memberIndex));\n\n        uint128 clBalanceEth1 = DENOMINATION_OFFSET * uint128(_clValidatorsBalance);\n        emit CLReported(_epochId, clBalanceEth1, _clValidatorCount, msg.sender);\n\n        uint256 report = _encodeReport(_clValidatorsBalance, _clValidatorCount);\n        int256 reportIndex = ReportsVariants.indexOfReport(report);\n        uint256 quorum = Quorum.get();\n\n        if (reportIndex >= 0) {\n            uint256 registeredReport = ReportsVariants.get()[uint256(reportIndex)];\n            if (_getReportCount(registeredReport) + 1 >= quorum) {\n                _pushToRiver(_epochId, clBalanceEth1, _clValidatorCount, clSpec);\n            } else {\n                ReportsVariants.set(uint256(reportIndex), registeredReport + 1);\n            }\n        } else {\n            if (quorum == 1) {\n                _pushToRiver(_epochId, clBalanceEth1, _clValidatorCount, clSpec);\n            } else {\n                ReportsVariants.push(report + 1);\n            }\n        }\n    }\n\n    /// @notice Internal utility to clear all the reports and edit the quorum if a new value is provided\n    /// @dev Ensures that the quorum respects invariants\n    /// @dev The admin is in charge of providing a proper quorum based on the oracle member count\n    /// @dev The quorum value Q should respect the following invariant, where O is oracle member count\n    /// @dev (O / 2) + 1 <= Q <= O\n    /// @param _newQuorum New quorum value\n    /// @param _previousQuorum The old quorum value\n    function _clearReportsAndSetQuorum(uint256 _newQuorum, uint256 _previousQuorum) internal {\n        uint256 memberCount = OracleMembers.get().length;\n        if ((_newQuorum == 0 && memberCount > 0) || _newQuorum > memberCount) {\n            revert LibErrors.InvalidArgument();\n        }\n        _clearReports();\n        if (_newQuorum != _previousQuorum) {\n            Quorum.set(_newQuorum);\n            emit SetQuorum(_newQuorum);\n        }\n    }\n\n    /// @notice Retrieve the block timestamp\n    /// @return The block timestamp\n    function _getTime() internal view returns (uint256) {\n        return block.timestamp; // solhint-disable-line not-rely-on-time\n    }\n\n    /// @notice Retrieve the current epoch id based on block timestamp\n    /// @param _clSpec CL spec parameters\n    /// @return The current epoch id\n    function _getCurrentEpochId(CLSpec.CLSpecStruct memory _clSpec) internal view returns (uint256) {\n        return (_getTime() - _clSpec.genesisTime) / (_clSpec.slotsPerEpoch * _clSpec.secondsPerSlot);\n    }\n\n    /// @notice Retrieve the first epoch id of the frame of the provided epoch id\n    /// @param _epochId Epoch id used to get the frame\n    /// @param _clSpec CL spec parameters\n    /// @return The epoch id at the beginning of the frame\n    function _getFrameFirstEpochId(uint256 _epochId, CLSpec.CLSpecStruct memory _clSpec)\n        internal\n        pure\n        returns (uint256)\n    {\n        return (_epochId / _clSpec.epochsPerFrame) * _clSpec.epochsPerFrame;\n    }\n\n    /// @notice Clear reporting data\n    /// @param _epochId Next expected epoch id (first epoch of the next frame)\n    function _clearReportsAndUpdateExpectedEpochId(uint256 _epochId) internal {\n        _clearReports();\n        ExpectedEpochId.set(_epochId);\n        emit ExpectedEpochIdUpdated(_epochId);\n    }\n\n    /// @notice Internal utility to clear the reporting data\n    function _clearReports() internal {\n        ReportsPositions.clear();\n        ReportsVariants.clear();\n    }\n\n    /// @notice Encode report into one slot. Last 16 bits are free to use for vote counting.\n    /// @param _clBalance Total validator balance\n    /// @param _clValidators Total validator count\n    /// @return The encoded report value\n    function _encodeReport(uint64 _clBalance, uint32 _clValidators) internal pure returns (uint256) {\n        return (uint256(_clBalance) << 48) | (uint256(_clValidators) << 16);\n    }\n\n    /// @notice Decode report from one slot to two variables, ignoring the last 16 bits\n    /// @param _value Encoded report\n    function _decodeReport(uint256 _value) internal pure returns (uint64 _clBalance, uint32 _clValidators) {\n        _clBalance = uint64(_value >> 48);\n        _clValidators = uint32(_value >> 16);\n    }\n\n    /// @notice Retrieve the vote count from the encoded report (last 16 bits)\n    /// @param _report Encoded report\n    /// @return The report count\n    function _getReportCount(uint256 _report) internal pure returns (uint16) {\n        return uint16(_report);\n    }\n\n    /// @notice Compute the max allowed increase based on the previous total balance and the time elapsed\n    /// @param _prevTotalEth The previous total balance\n    /// @param _timeElapsed The time since last report\n    /// @return The maximum increase in balance allowed\n    function _maxIncrease(uint256 _prevTotalEth, uint256 _timeElapsed) internal view returns (uint256) {\n        uint256 annualAprUpperBound = ReportBounds.get().annualAprUpperBound;\n        return (_prevTotalEth * annualAprUpperBound * _timeElapsed) / (LibBasisPoints.BASIS_POINTS_MAX * ONE_YEAR);\n    }\n\n    /// @notice Performs sanity checks to prevent an erroneous update to the River system\n    /// @param _postTotalEth Total validator balance after update\n    /// @param _prevTotalEth Total validator balance before update\n    /// @param _timeElapsed Time since last update\n    function _sanityChecks(uint256 _postTotalEth, uint256 _prevTotalEth, uint256 _timeElapsed) internal view {\n        if (_postTotalEth >= _prevTotalEth) {\n            // increase                 = _postTotalPooledEther - _preTotalPooledEther,\n            // relativeIncrease         = increase / _preTotalPooledEther,\n            // annualRelativeIncrease   = relativeIncrease / (timeElapsed / 365 days),\n            // annualRelativeIncreaseBp = annualRelativeIncrease * 10000, in basis points 0.01% (1e-4)\n            uint256 annualAprUpperBound = ReportBounds.get().annualAprUpperBound;\n            // check that annualRelativeIncreaseBp <= allowedAnnualRelativeIncreaseBp\n            if (\n                LibBasisPoints.BASIS_POINTS_MAX * ONE_YEAR * (_postTotalEth - _prevTotalEth)\n                    > annualAprUpperBound * _prevTotalEth * _timeElapsed\n            ) {\n                revert TotalValidatorBalanceIncreaseOutOfBound(\n                    _prevTotalEth, _postTotalEth, _timeElapsed, annualAprUpperBound\n                );\n            }\n        } else {\n            // decrease           = _preTotalPooledEther - _postTotalPooledEther\n            // relativeDecrease   = decrease / _preTotalPooledEther\n            // relativeDecreaseBp = relativeDecrease * 10000, in basis points 0.01% (1e-4)\n            uint256 relativeLowerBound = ReportBounds.get().relativeLowerBound;\n            // check that relativeDecreaseBp <= allowedRelativeDecreaseBp\n            if (LibBasisPoints.BASIS_POINTS_MAX * (_prevTotalEth - _postTotalEth) > relativeLowerBound * _prevTotalEth)\n            {\n                revert TotalValidatorBalanceDecreaseOutOfBound(\n                    _prevTotalEth, _postTotalEth, _timeElapsed, relativeLowerBound\n                );\n            }\n        }\n    }\n\n    /// @notice Push the new cl data to the river system and performs sanity checks\n    /// @dev At this point, the maximum increase allowed to the previous total asset balance is computed and\n    /// @dev provided to River. It's then up to River to manage how extra funds are injected in the system\n    /// @dev and make sure the limit is not crossed. If the _totalBalance is already crossing this limit,\n    /// @dev then there is nothing River can do to prevent it.\n    /// @dev These extra funds are:\n    /// @dev - the execution layer fees\n    /// @param _epochId Id of the epoch\n    /// @param _totalBalance Total validator balance\n    /// @param _validatorCount Total validator count\n    /// @param _clSpec CL spec parameters\n    function _pushToRiver(\n        uint256 _epochId,\n        uint128 _totalBalance,\n        uint32 _validatorCount,\n        CLSpec.CLSpecStruct memory _clSpec\n    ) internal {\n        _clearReportsAndUpdateExpectedEpochId(_epochId + _clSpec.epochsPerFrame);\n\n        IRiverV1 river = IRiverV1(payable(RiverAddress.get()));\n        uint256 prevTotalEth = river.totalUnderlyingSupply();\n        uint256 timeElapsed = (_epochId - LastEpochId.get()) * _clSpec.slotsPerEpoch * _clSpec.secondsPerSlot;\n        uint256 maxIncrease = _maxIncrease(prevTotalEth, timeElapsed);\n        river.setConsensusLayerData(_validatorCount, _totalBalance, bytes32(_epochId), maxIncrease);\n        uint256 postTotalEth = river.totalUnderlyingSupply();\n\n        _sanityChecks(postTotalEth, prevTotalEth, timeElapsed);\n        LastEpochId.set(_epochId);\n\n        emit PostTotalShares(postTotalEth, prevTotalEth, timeElapsed, river.totalSupply());\n    }\n}\n"
    },
    "contracts/src/interfaces/IOracle.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../state/oracle/CLSpec.sol\";\nimport \"../state/oracle/ReportBounds.sol\";\n\n/// @title Oracle Interface (v1)\n/// @author Kiln\n/// @notice This interface exposes methods to handle the input from the allowed oracle members.\n/// @notice Highly inspired by Lido's implementation.\ninterface IOracleV1 {\n    /// @notice Consensus Layer data has been reported by an oracle member\n    /// @param epochId The epoch of the report\n    /// @param newCLBalance The new consensus layer balance\n    /// @param newCLValidatorCount The new consensus layer validator count\n    /// @param oracleMember The oracle member that reported\n    event CLReported(uint256 epochId, uint128 newCLBalance, uint32 newCLValidatorCount, address oracleMember);\n\n    /// @notice The storage quorum value has been changed\n    /// @param newQuorum The new quorum value\n    event SetQuorum(uint256 newQuorum);\n\n    /// @notice The expected epoch id has been changed\n    /// @param epochId The new expected epoch id\n    event ExpectedEpochIdUpdated(uint256 epochId);\n\n    /// @notice The report has been submitted to river\n    /// @param postTotalEth The new total ETH balance\n    /// @param prevTotalEth The previous total ETH balance\n    /// @param timeElapsed Time since last report\n    /// @param totalShares The new total amount of shares\n    event PostTotalShares(uint256 postTotalEth, uint256 prevTotalEth, uint256 timeElapsed, uint256 totalShares);\n\n    /// @notice A member has been added to the oracle member list\n    /// @param member The address of the member\n    event AddMember(address indexed member);\n\n    /// @notice A member has been removed from the oracle member list\n    /// @param member The address of the member\n    event RemoveMember(address indexed member);\n\n    /// @notice A member address has been edited\n    /// @param oldAddress The previous member address\n    /// @param newAddress The new member address\n    event SetMember(address indexed oldAddress, address indexed newAddress);\n\n    /// @notice The storage river address value has been changed\n    /// @param _river The new river address\n    event SetRiver(address _river);\n\n    /// @notice The consensus layer spec has been changed\n    /// @param epochsPerFrame The number of epochs inside a frame (225 = 24 hours)\n    /// @param slotsPerEpoch The number of slots inside an epoch (32 on ethereum mainnet)\n    /// @param secondsPerSlot The time between two slots (12 seconds on ethereum mainnet)\n    /// @param genesisTime The timestamp of block #0\n    event SetSpec(uint64 epochsPerFrame, uint64 slotsPerEpoch, uint64 secondsPerSlot, uint64 genesisTime);\n\n    /// @notice The report bounds have been changed\n    /// @param annualAprUpperBound The maximum allowed apr. 10% means increases in balance extrapolated to a year should not exceed 10%.\n    /// @param relativeLowerBound The maximum allowed balance decrease as a relative % of the total balance\n    event SetBounds(uint256 annualAprUpperBound, uint256 relativeLowerBound);\n\n    /// @notice The provided epoch is too old compared to the expected epoch id\n    /// @param providedEpochId The epoch id provided as input\n    /// @param minExpectedEpochId The minimum epoch id expected\n    error EpochTooOld(uint256 providedEpochId, uint256 minExpectedEpochId);\n\n    /// @notice The provided epoch is not at the beginning of its frame\n    /// @param providedEpochId The epoch id provided as input\n    /// @param expectedFrameFirstEpochId The frame first epoch id that was expected\n    error NotFrameFirstEpochId(uint256 providedEpochId, uint256 expectedFrameFirstEpochId);\n\n    /// @notice The member already reported on the given epoch id\n    /// @param epochId The epoch id provided as input\n    /// @param member The oracle member\n    error AlreadyReported(uint256 epochId, address member);\n\n    /// @notice The delta in balance is above the allowed upper bound\n    /// @param prevTotalEth The previous total balance\n    /// @param postTotalEth The new total balance\n    /// @param timeElapsed The time since last report\n    /// @param annualAprUpperBound The maximum apr allowed\n    error TotalValidatorBalanceIncreaseOutOfBound(\n        uint256 prevTotalEth, uint256 postTotalEth, uint256 timeElapsed, uint256 annualAprUpperBound\n    );\n\n    /// @notice The negative delta in balance is above the allowed lower bound\n    /// @param prevTotalEth The previous total balance\n    /// @param postTotalEth The new total balance\n    /// @param timeElapsed The time since last report\n    /// @param relativeLowerBound The maximum relative decrease allowed\n    error TotalValidatorBalanceDecreaseOutOfBound(\n        uint256 prevTotalEth, uint256 postTotalEth, uint256 timeElapsed, uint256 relativeLowerBound\n    );\n\n    /// @notice The address is already in use by an oracle member\n    /// @param newAddress The address already in use\n    error AddressAlreadyInUse(address newAddress);\n\n    /// @notice Initializes the oracle\n    /// @param _river Address of the River contract, able to receive oracle input data after quorum is met\n    /// @param _administratorAddress Address able to call administrative methods\n    /// @param _epochsPerFrame CL spec parameter. Number of epochs in a frame.\n    /// @param _slotsPerEpoch CL spec parameter. Number of slots in one epoch.\n    /// @param _secondsPerSlot CL spec parameter. Number of seconds between slots.\n    /// @param _genesisTime CL spec parameter. Timestamp of the genesis slot.\n    /// @param _annualAprUpperBound CL bound parameter. Maximum apr allowed for balance increase. Delta between updates is extrapolated on a year time frame.\n    /// @param _relativeLowerBound CL bound parameter. Maximum relative balance decrease.\n    function initOracleV1(\n        address _river,\n        address _administratorAddress,\n        uint64 _epochsPerFrame,\n        uint64 _slotsPerEpoch,\n        uint64 _secondsPerSlot,\n        uint64 _genesisTime,\n        uint256 _annualAprUpperBound,\n        uint256 _relativeLowerBound\n    ) external;\n\n    /// @notice Retrieve River address\n    /// @return The address of River\n    function getRiver() external view returns (address);\n\n    /// @notice Retrieve the block timestamp\n    /// @return The current timestamp from the EVM context\n    function getTime() external view returns (uint256);\n\n    /// @notice Retrieve expected epoch id\n    /// @return The current expected epoch id\n    function getExpectedEpochId() external view returns (uint256);\n\n    /// @notice Retrieve member report status\n    /// @param _oracleMember Address of member to check\n    /// @return True if member has reported\n    function getMemberReportStatus(address _oracleMember) external view returns (bool);\n\n    /// @notice Retrieve member report status\n    /// @return The raw report status value\n    function getGlobalReportStatus() external view returns (uint256);\n\n    /// @notice Retrieve report variants count\n    /// @return The count of report variants\n    function getReportVariantsCount() external view returns (uint256);\n\n    /// @notice Retrieve decoded report at provided index\n    /// @param _idx Index of report\n    /// @return _clBalance The reported consensus layer balance sum of River's validators\n    /// @return _clValidators The reported validator count\n    /// @return _reportCount The number of similar reports\n    function getReportVariant(uint256 _idx)\n        external\n        view\n        returns (uint64 _clBalance, uint32 _clValidators, uint16 _reportCount);\n\n    /// @notice Retrieve the last completed epoch id\n    /// @return The last completed epoch id\n    function getLastCompletedEpochId() external view returns (uint256);\n\n    /// @notice Retrieve the current epoch id based on block timestamp\n    /// @return The current epoch id\n    function getCurrentEpochId() external view returns (uint256);\n\n    /// @notice Retrieve the current quorum\n    /// @return The current quorum\n    function getQuorum() external view returns (uint256);\n\n    /// @notice Retrieve the current cl spec\n    /// @return The Consensus Layer Specification\n    function getCLSpec() external view returns (CLSpec.CLSpecStruct memory);\n\n    /// @notice Retrieve the current frame details\n    /// @return _startEpochId The epoch at the beginning of the frame\n    /// @return _startTime The timestamp of the beginning of the frame in seconds\n    /// @return _endTime The timestamp of the end of the frame in seconds\n    function getCurrentFrame() external view returns (uint256 _startEpochId, uint256 _startTime, uint256 _endTime);\n\n    /// @notice Retrieve the first epoch id of the frame of the provided epoch id\n    /// @param _epochId Epoch id used to get the frame\n    /// @return The first epoch id of the frame containing the given epoch id\n    function getFrameFirstEpochId(uint256 _epochId) external view returns (uint256);\n\n    /// @notice Retrieve the report bounds\n    /// @return The report bounds\n    function getReportBounds() external view returns (ReportBounds.ReportBoundsStruct memory);\n\n    /// @notice Retrieve the list of oracle members\n    /// @return The oracle members\n    function getOracleMembers() external view returns (address[] memory);\n\n    /// @notice Returns true if address is member\n    /// @dev Performs a naive search, do not call this on-chain, used as an off-chain helper\n    /// @param _memberAddress Address of the member\n    /// @return True if address is a member\n    function isMember(address _memberAddress) external view returns (bool);\n\n    /// @notice Adds new address as oracle member, giving the ability to push cl reports.\n    /// @dev Only callable by the adminstrator\n    /// @dev Modifying the quorum clears all the reporting data\n    /// @param _newOracleMember Address of the new member\n    /// @param _newQuorum New quorum value\n    function addMember(address _newOracleMember, uint256 _newQuorum) external;\n\n    /// @notice Removes an address from the oracle members.\n    /// @dev Only callable by the adminstrator\n    /// @dev Modifying the quorum clears all the reporting data\n    /// @dev Remaining members that have already voted should vote again for the same frame.\n    /// @param _oracleMember Address to remove\n    /// @param _newQuorum New quorum value\n    function removeMember(address _oracleMember, uint256 _newQuorum) external;\n\n    /// @notice Changes the address of an oracle member\n    /// @dev Only callable by the adminitrator\n    /// @dev Cannot use an address already in use\n    /// @dev This call will clear all the reporting data\n    /// @param _oracleMember Address to change\n    /// @param _newAddress New address for the member\n    function setMember(address _oracleMember, address _newAddress) external;\n\n    /// @notice Edits the cl spec parameters\n    /// @dev Only callable by the adminstrator\n    /// @param _epochsPerFrame Number of epochs in a frame.\n    /// @param _slotsPerEpoch Number of slots in one epoch.\n    /// @param _secondsPerSlot Number of seconds between slots.\n    /// @param _genesisTime Timestamp of the genesis slot.\n    function setCLSpec(uint64 _epochsPerFrame, uint64 _slotsPerEpoch, uint64 _secondsPerSlot, uint64 _genesisTime)\n        external;\n\n    /// @notice Edits the cl bounds parameters\n    /// @dev Only callable by the adminstrator\n    /// @param _annualAprUpperBound Maximum apr allowed for balance increase. Delta between updates is extrapolated on a year time frame.\n    /// @param _relativeLowerBound Maximum relative balance decrease.\n    function setReportBounds(uint256 _annualAprUpperBound, uint256 _relativeLowerBound) external;\n\n    /// @notice Edits the quorum required to forward cl data to River\n    /// @dev Modifying the quorum clears all the reporting data\n    /// @param _newQuorum New quorum parameter\n    function setQuorum(uint256 _newQuorum) external;\n\n    /// @notice Report cl chain data\n    /// @dev Only callable by an oracle member\n    /// @dev The epoch id is expected to be >= to the expected epoch id stored in the contract\n    /// @dev The epoch id is expected to be the first epoch of its frame\n    /// @dev The Consensus Layer Validator count is the amount of running validators managed by River.\n    /// @dev Until withdrawals are enabled, this count also takes into account any exited and slashed validator\n    /// @dev as funds are still locked on the consensus layer.\n    /// @param _epochId Epoch where the balance and validator count has been computed\n    /// @param _clValidatorsBalance Total balance of River validators\n    /// @param _clValidatorCount Total River validator count\n    function reportConsensusLayerData(uint256 _epochId, uint64 _clValidatorsBalance, uint32 _clValidatorCount)\n        external;\n}\n"
    },
    "contracts/src/state/shared/RiverAddress.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibSanitize.sol\";\nimport \"../../libraries/LibUnstructuredStorage.sol\";\n\n/// @title River Address Storage\n/// @notice Utility to manage the River Address in storage\nlibrary RiverAddress {\n    /// @notice Storage slot of the River Address\n    bytes32 internal constant RIVER_ADDRESS_SLOT = bytes32(uint256(keccak256(\"river.state.riverAddress\")) - 1);\n\n    /// @notice Retrieve the River Address\n    /// @return The River Address\n    function get() internal view returns (address) {\n        return LibUnstructuredStorage.getStorageAddress(RIVER_ADDRESS_SLOT);\n    }\n\n    /// @notice Sets the River Address\n    /// @param _newValue New River Address\n    function set(address _newValue) internal {\n        LibSanitize._notZeroAddress(_newValue);\n        LibUnstructuredStorage.setStorageAddress(RIVER_ADDRESS_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/oracle/Quorum.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\n\n/// @title Quorum Storage\n/// @notice Utility to manage the Quorum in storage\nlibrary Quorum {\n    /// @notice Storage slot of the Quorum\n    bytes32 internal constant QUORUM_SLOT = bytes32(uint256(keccak256(\"river.state.quorum\")) - 1);\n\n    /// @notice Retrieve the Quorum\n    /// @return The Quorum\n    function get() internal view returns (uint256) {\n        return LibUnstructuredStorage.getStorageUint256(QUORUM_SLOT);\n    }\n\n    /// @notice Sets the Quorum\n    /// @param _newValue New Quorum\n    function set(uint256 _newValue) internal {\n        return LibUnstructuredStorage.setStorageUint256(QUORUM_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/oracle/ExpectedEpochId.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\n\n/// @title Expected Epoch Id Storage\n/// @notice Utility to manage the Expected Epoch Id in storage\nlibrary ExpectedEpochId {\n    /// @notice Storage slot of the Expected Epoch Id\n    bytes32 internal constant EXPECTED_EPOCH_ID_SLOT = bytes32(uint256(keccak256(\"river.state.expectedEpochId\")) - 1);\n\n    /// @notice Retrieve the Expected Epoch Id\n    /// @return The Expected Epoch Id\n    function get() internal view returns (uint256) {\n        return LibUnstructuredStorage.getStorageUint256(EXPECTED_EPOCH_ID_SLOT);\n    }\n\n    /// @notice Sets the Expected Epoch Id\n    /// @param _newValue New Expected Epoch Id\n    function set(uint256 _newValue) internal {\n        LibUnstructuredStorage.setStorageUint256(EXPECTED_EPOCH_ID_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/oracle/LastEpochId.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\n\n/// @title Last Epoch Id Storage\n/// @notice Utility to manage the Last Epoch Id in storage\nlibrary LastEpochId {\n    /// @notice Storage slot of the Last Epoch Id\n    bytes32 internal constant LAST_EPOCH_ID_SLOT = bytes32(uint256(keccak256(\"river.state.lastEpochId\")) - 1);\n\n    /// @notice Retrieve the Last Epoch Id\n    /// @return The Last Epoch Id\n    function get() internal view returns (uint256) {\n        return LibUnstructuredStorage.getStorageUint256(LAST_EPOCH_ID_SLOT);\n    }\n\n    /// @notice Sets the Last Epoch Id\n    /// @param _newValue New Last Epoch Id\n    function set(uint256 _newValue) internal {\n        LibUnstructuredStorage.setStorageUint256(LAST_EPOCH_ID_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/oracle/ReportsPositions.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\n\n/// @title Reports Positions Storage\n/// @notice Utility to manage the Reports Positions in storage\n/// @dev Each bit in the stored uint256 value tells if the member at a given index has reported\nlibrary ReportsPositions {\n    /// @notice Storage slot of the Reports Positions\n    bytes32 internal constant REPORTS_POSITIONS_SLOT = bytes32(uint256(keccak256(\"river.state.reportsPositions\")) - 1);\n\n    /// @notice Retrieve the Reports Positions at index\n    /// @param _idx The index to retrieve\n    /// @return True if already reported\n    function get(uint256 _idx) internal view returns (bool) {\n        uint256 mask = 1 << _idx;\n        return LibUnstructuredStorage.getStorageUint256(REPORTS_POSITIONS_SLOT) & mask == mask;\n    }\n\n    /// @notice Retrieve the raw Reports Positions from storage\n    /// @return Raw Reports Positions\n    function getRaw() internal view returns (uint256) {\n        return LibUnstructuredStorage.getStorageUint256(REPORTS_POSITIONS_SLOT);\n    }\n\n    /// @notice Register an index as reported\n    /// @param _idx The index to register\n    function register(uint256 _idx) internal {\n        uint256 mask = 1 << _idx;\n        return LibUnstructuredStorage.setStorageUint256(\n            REPORTS_POSITIONS_SLOT, LibUnstructuredStorage.getStorageUint256(REPORTS_POSITIONS_SLOT) | mask\n        );\n    }\n\n    /// @notice Clears all the report positions in storage\n    function clear() internal {\n        return LibUnstructuredStorage.setStorageUint256(REPORTS_POSITIONS_SLOT, 0);\n    }\n}\n"
    },
    "contracts/src/state/oracle/ReportsVariants.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\n/// @title Reports Variants Storage\n/// @notice Utility to manage the Reports Variants in storage\nlibrary ReportsVariants {\n    /// @notice Storage slot of the Reports Variants\n    bytes32 internal constant REPORTS_VARIANTS_SLOT = bytes32(uint256(keccak256(\"river.state.reportsVariants\")) - 1);\n\n    /// @notice Mask used to extra the report values from the variant\n    /// @notice This is the packing done inside the variant in storage\n    /// @notice\n    /// @notice [ 0,  16) : <voteCount>           oracle member's total vote count for the numbers below (uint16, 2 bytes)\n    /// @notice [16,  48) : <beaconValidators>    total number of beacon validators (uint32, 4 bytes)\n    /// @notice [48, 112) : <beaconBalance>       total balance of all the beacon validators (uint64, 6 bytes)\n    /// @notice\n    /// @notice So applying this mask, we can extra the voteCount out to perform comparisons on the report values\n    /// @notice\n    /// @notice xx...xx <beaconBalance> <beaconValidators> xxxx & COUNT_OUTMASK  ==\n    /// @notice 00...00 <beaconBalance> <beaconValidators> 0000\n    uint256 internal constant COUNT_OUTMASK = 0xFFFFFFFFFFFFFFFFFFFFFFFF0000;\n\n    /// @notice Structure in storage\n    struct Slot {\n        /// @custom:attribute The list of variants\n        uint256[] value;\n    }\n\n    /// @notice Retrieve the Reports Variants from storage\n    /// @return The Reports Variants\n    function get() internal view returns (uint256[] memory) {\n        bytes32 slot = REPORTS_VARIANTS_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value;\n    }\n\n    /// @notice Set the Reports Variants value at index\n    /// @param _idx The index to set\n    /// @param _val The value to set\n    function set(uint256 _idx, uint256 _val) internal {\n        bytes32 slot = REPORTS_VARIANTS_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        r.value[_idx] = _val;\n    }\n\n    /// @notice Add a new variant in the list\n    /// @param _variant The new variant to add\n    function push(uint256 _variant) internal {\n        bytes32 slot = REPORTS_VARIANTS_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        r.value.push(_variant);\n    }\n\n    /// @notice Retrieve the index of a specific variant, ignoring the count field\n    /// @param _variant Variant value to lookup\n    /// @return The index of the variant, -1 if not found\n    function indexOfReport(uint256 _variant) internal view returns (int256) {\n        bytes32 slot = REPORTS_VARIANTS_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        for (uint256 idx = 0; idx < r.value.length;) {\n            if (r.value[idx] & COUNT_OUTMASK == _variant) {\n                return int256(idx);\n            }\n            unchecked {\n                ++idx;\n            }\n        }\n\n        return int256(-1);\n    }\n\n    /// @notice Clear all variants from storage\n    function clear() internal {\n        bytes32 slot = REPORTS_VARIANTS_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        delete r.value;\n    }\n}\n"
    },
    "contracts/src/state/oracle/CLSpec.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\n/// @title Consensus Layer Spec Storage\n/// @notice Utility to manage the Consensus Layer Spec in storage\nlibrary CLSpec {\n    /// @notice Storage slot of the Consensus Layer Spec\n    bytes32 internal constant CL_SPEC_SLOT = bytes32(uint256(keccak256(\"river.state.clSpec\")) - 1);\n\n    /// @notice The Consensus Layer Spec structure\n    struct CLSpecStruct {\n        /// @custom:attribute The count of epochs per frame, 225 means 24h\n        uint64 epochsPerFrame;\n        /// @custom:attribute The count of slots in an epoch (32 on mainnet)\n        uint64 slotsPerEpoch;\n        /// @custom:attribute The seconds in a slot (12 on mainnet)\n        uint64 secondsPerSlot;\n        /// @custom:attribute The block timestamp of the first consensus layer block\n        uint64 genesisTime;\n    }\n\n    /// @notice The structure in storage\n    struct Slot {\n        /// @custom:attribute The structure in storage\n        CLSpecStruct value;\n    }\n\n    /// @notice Retrieve the Consensus Layer Spec from storage\n    /// @return The Consensus Layer Spec\n    function get() internal view returns (CLSpecStruct memory) {\n        bytes32 slot = CL_SPEC_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value;\n    }\n\n    /// @notice Set the Consensus Layer Spec value in storage\n    /// @param _newCLSpec The new value to set in storage\n    function set(CLSpecStruct memory _newCLSpec) internal {\n        bytes32 slot = CL_SPEC_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        r.value = _newCLSpec;\n    }\n}\n"
    },
    "contracts/src/state/oracle/ReportBounds.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\n/// @title Report Bounds Storage\n/// @notice Utility to manage the Report Bounds in storage\nlibrary ReportBounds {\n    /// @notice Storage slot of the Report Bounds\n    bytes32 internal constant REPORT_BOUNDS_SLOT = bytes32(uint256(keccak256(\"river.state.reportBounds\")) - 1);\n\n    /// @notice The Report Bounds structure\n    struct ReportBoundsStruct {\n        /// @custom:attribute The maximum allowed annual apr, checked before submitting a report to River\n        uint256 annualAprUpperBound;\n        /// @custom:attribute The maximum allowed balance decrease, also checked before submitting a report to River\n        uint256 relativeLowerBound;\n    }\n\n    /// @notice The structure in storage\n    struct Slot {\n        /// @custom:attribute The structure in storage\n        ReportBoundsStruct value;\n    }\n\n    /// @notice Retrieve the Report Bounds from storage\n    /// @return The Report Bounds\n    function get() internal view returns (ReportBoundsStruct memory) {\n        bytes32 slot = REPORT_BOUNDS_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value;\n    }\n\n    /// @notice Set the Report Bounds in storage\n    /// @param _newReportBounds The new Report Bounds value\n    function set(ReportBoundsStruct memory _newReportBounds) internal {\n        bytes32 slot = REPORT_BOUNDS_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        r.value = _newReportBounds;\n    }\n}\n"
    },
    "contracts/src/WLSETH.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\n\nimport \"./interfaces/IRiver.1.sol\";\nimport \"./interfaces/IWLSETH.1.sol\";\n\nimport \"./Initializable.sol\";\n\nimport \"./state/shared/RiverAddress.sol\";\nimport \"./state/shared/ApprovalsPerOwner.sol\";\nimport \"./state/wlseth/BalanceOf.sol\";\n\n/// @title Wrapped LsETH (v1)\n/// @author Kiln\n/// @notice This contract wraps the LsETH token into a rebase token, more suitable for some DeFi use-cases\n///         like stable swaps.\ncontract WLSETHV1 is IWLSETHV1, Initializable, ReentrancyGuard {\n    /// @notice Ensures that the value is not 0\n    /// @param _value Value that must be > 0\n    modifier isNotNull(uint256 _value) {\n        if (_value == 0) {\n            revert NullTransfer();\n        }\n        _;\n    }\n\n    /// @notice Ensures that the owner has enough funds\n    /// @param _owner Owner of the balance to verify\n    /// @param _value Minimum required value\n    modifier hasFunds(address _owner, uint256 _value) {\n        if (_balanceOf(_owner) < _value) {\n            revert BalanceTooLow();\n        }\n        _;\n    }\n\n    /// @inheritdoc IWLSETHV1\n    function initWLSETHV1(address _river) external init(0) {\n        RiverAddress.set(_river);\n        emit SetRiver(_river);\n    }\n\n    /// @inheritdoc IWLSETHV1\n    function name() external pure returns (string memory) {\n        return \"Wrapped Liquid Staked ETH\";\n    }\n\n    /// @inheritdoc IWLSETHV1\n    function symbol() external pure returns (string memory) {\n        return \"wLsETH\";\n    }\n\n    /// @inheritdoc IWLSETHV1\n    function decimals() external pure returns (uint8) {\n        return 18;\n    }\n\n    /// @inheritdoc IWLSETHV1\n    function totalSupply() external view returns (uint256) {\n        return IRiverV1(payable(RiverAddress.get())).balanceOfUnderlying(address(this));\n    }\n\n    /// @inheritdoc IWLSETHV1\n    function balanceOf(address _owner) external view returns (uint256) {\n        return _balanceOf(_owner);\n    }\n\n    /// @inheritdoc IWLSETHV1\n    function sharesOf(address _owner) external view returns (uint256) {\n        return BalanceOf.get(_owner);\n    }\n\n    /// @inheritdoc IWLSETHV1\n    function allowance(address _owner, address _spender) external view returns (uint256) {\n        return ApprovalsPerOwner.get(_owner, _spender);\n    }\n\n    /// @inheritdoc IWLSETHV1\n    function transfer(address _to, uint256 _value)\n        external\n        isNotNull(_value)\n        hasFunds(msg.sender, _value)\n        returns (bool)\n    {\n        if (_to == address(0)) {\n            revert UnauthorizedTransfer(msg.sender, address(0));\n        }\n        return _transfer(msg.sender, _to, _value);\n    }\n\n    /// @inheritdoc IWLSETHV1\n    function transferFrom(address _from, address _to, uint256 _value)\n        external\n        isNotNull(_value)\n        hasFunds(_from, _value)\n        returns (bool)\n    {\n        if (_to == address(0)) {\n            revert UnauthorizedTransfer(_from, address(0));\n        }\n        _spendAllowance(_from, _value);\n        return _transfer(_from, _to, _value);\n    }\n\n    /// @inheritdoc IWLSETHV1\n    function approve(address _spender, uint256 _value) external returns (bool) {\n        _approve(msg.sender, _spender, _value);\n        return true;\n    }\n\n    /// @inheritdoc IWLSETHV1\n    function increaseAllowance(address _spender, uint256 _additionalValue) external returns (bool) {\n        _approve(msg.sender, _spender, ApprovalsPerOwner.get(msg.sender, _spender) + _additionalValue);\n        return true;\n    }\n\n    /// @inheritdoc IWLSETHV1\n    function decreaseAllowance(address _spender, uint256 _subtractableValue) external returns (bool) {\n        _approve(msg.sender, _spender, ApprovalsPerOwner.get(msg.sender, _spender) - _subtractableValue);\n        return true;\n    }\n\n    /// @inheritdoc IWLSETHV1\n    function mint(address _recipient, uint256 _shares) external nonReentrant {\n        BalanceOf.set(_recipient, BalanceOf.get(_recipient) + _shares);\n        IRiverV1 river = IRiverV1(payable(RiverAddress.get()));\n        if (!river.transferFrom(msg.sender, address(this), _shares)) {\n            revert TokenTransferError();\n        }\n        emit Mint(_recipient, _shares);\n        emit Transfer(address(0), _recipient, river.underlyingBalanceFromShares(_shares));\n    }\n\n    /// @inheritdoc IWLSETHV1\n    function burn(address _recipient, uint256 _shares) external nonReentrant {\n        uint256 shares = BalanceOf.get(msg.sender);\n        if (_shares > shares) {\n            revert BalanceTooLow();\n        }\n        BalanceOf.set(msg.sender, shares - _shares);\n        IRiverV1 river = IRiverV1(payable(RiverAddress.get()));\n        if (!river.transfer(_recipient, _shares)) {\n            revert TokenTransferError();\n        }\n        emit Transfer(msg.sender, address(0), river.underlyingBalanceFromShares(_shares));\n        emit Burn(_recipient, _shares);\n    }\n\n    /// @notice Internal utility to spend the allowance of an account from the message sender\n    /// @param _from Address owning the allowance\n    /// @param _value Amount of allowance to spend\n    function _spendAllowance(address _from, uint256 _value) internal {\n        uint256 currentAllowance = ApprovalsPerOwner.get(_from, msg.sender);\n        if (currentAllowance < _value) {\n            revert AllowanceTooLow(_from, msg.sender, currentAllowance, _value);\n        }\n        if (currentAllowance != type(uint256).max) {\n            _approve(_from, msg.sender, currentAllowance - _value);\n        }\n    }\n\n    /// @notice Internal utility to change the allowance of an owner to a spender\n    /// @param _owner The owner of the wrapped tokens\n    /// @param _spender The allowed spender of the wrapped tokens\n    /// @param _value The new allowance value\n    function _approve(address _owner, address _spender, uint256 _value) internal {\n        LibSanitize._notZeroAddress(_owner);\n        LibSanitize._notZeroAddress(_spender);\n        ApprovalsPerOwner.set(_owner, _spender, _value);\n        emit Approval(_owner, _spender, _value);\n    }\n\n    /// @notice Internal utility to retrieve the amount of token per owner\n    /// @param _owner Account to be checked\n    /// @return The balance of the account\n    function _balanceOf(address _owner) internal view returns (uint256) {\n        return IRiverV1(payable(RiverAddress.get())).underlyingBalanceFromShares(BalanceOf.get(_owner));\n    }\n\n    /// @notice Internal utility to perform an unchecked transfer\n    /// @param _from Address sending the tokens\n    /// @param _to Address receiving the tokens\n    /// @param _value Amount to be sent\n    /// @return True if success\n    function _transfer(address _from, address _to, uint256 _value) internal returns (bool) {\n        uint256 valueToShares = IRiverV1(payable(RiverAddress.get())).sharesFromUnderlyingBalance(_value);\n        BalanceOf.set(_from, BalanceOf.get(_from) - valueToShares);\n        BalanceOf.set(_to, BalanceOf.get(_to) + valueToShares);\n\n        emit Transfer(_from, _to, _value);\n\n        return true;\n    }\n}\n"
    },
    "openzeppelin-contracts/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/src/interfaces/IWLSETH.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\n/// @title Wrapped LsETH Interface (v1)\n/// @author Kiln\n/// @notice This interface exposes methods to wrap the LsETH token into a rebase token.\ninterface IWLSETHV1 {\n    /// @notice A transfer has been made\n    /// @param from The transfer sender\n    /// @param to The transfer recipient\n    /// @param value The amount transfered\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /// @notice An approval has been made\n    /// @param owner The token owner\n    /// @param spender The account allowed by the owner\n    /// @param value The amount allowed\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice Tokens have been minted\n    /// @param recipient The account receiving the new tokens\n    /// @param shares The amount of LsETH provided\n    event Mint(address indexed recipient, uint256 shares);\n\n    /// @notice Tokens have been burned\n    /// @param recipient The account that receive the underlying LsETH\n    /// @param shares The amount of LsETH that got sent back\n    event Burn(address indexed recipient, uint256 shares);\n\n    /// @notice The stored value of river has been changed\n    /// @param river The new address of river\n    event SetRiver(address indexed river);\n\n    /// @notice The token transfer failed during the minting or burning process\n    error TokenTransferError();\n\n    /// @notice Balance too low to perform operation\n    error BalanceTooLow();\n\n    /// @notice Allowance too low to perform operation\n    /// @param _from Account where funds are sent from\n    /// @param _operator Account attempting the transfer\n    /// @param _allowance Current allowance\n    /// @param _value Requested transfer value\n    error AllowanceTooLow(address _from, address _operator, uint256 _allowance, uint256 _value);\n\n    /// @notice Invalid empty transfer\n    error NullTransfer();\n\n    /// @notice Invalid transfer recipients\n    /// @param _from Account sending the funds in the invalid transfer\n    /// @param _to Account receiving the funds in the invalid transfer\n    error UnauthorizedTransfer(address _from, address _to);\n\n    /// @notice Initializes the wrapped token contract\n    /// @param _river Address of the River contract\n    function initWLSETHV1(address _river) external;\n\n    /// @notice Retrieves the token full name\n    /// @return The name of the token\n    function name() external pure returns (string memory);\n\n    /// @notice Retrieves the token symbol\n    /// @return The symbol of the token\n    function symbol() external pure returns (string memory);\n\n    /// @notice Retrieves the token decimal count\n    /// @return The decimal count\n    function decimals() external pure returns (uint8);\n\n    /// @notice Retrieves the token total supply\n    /// @return The total supply\n    function totalSupply() external view returns (uint256);\n\n    /// @notice Retrieves the token balance of the specified user\n    /// @param _owner Owner to check the balance\n    /// @return The balance of the owner\n    function balanceOf(address _owner) external view returns (uint256);\n\n    /// @notice Retrieves the raw shares count of the user\n    /// @param _owner Owner to check the shares balance\n    /// @return The shares of the owner\n    function sharesOf(address _owner) external view returns (uint256);\n\n    /// @notice Retrieves the token allowance given from one address to another\n    /// @param _owner Owner that gave the allowance\n    /// @param _spender Spender that received the allowance\n    /// @return The allowance of the owner to the spender\n    function allowance(address _owner, address _spender) external view returns (uint256);\n\n    /// @notice Transfers tokens between the message sender and a recipient\n    /// @param _to Recipient of the transfer\n    /// @param _value Amount to transfer\n    /// @return True if success\n    function transfer(address _to, uint256 _value) external returns (bool);\n\n    /// @notice Transfers tokens between two accounts\n    /// @dev It is expected that _from has given at least _value allowance to msg.sender\n    /// @param _from Sender account\n    /// @param _to Recipient of the transfer\n    /// @param _value Amount to transfer\n    /// @return True if success\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\n\n    /// @notice Approves another account to transfer tokens\n    /// @param _spender Spender that receives the allowance\n    /// @param _value Amount to allow\n    /// @return True if success\n    function approve(address _spender, uint256 _value) external returns (bool);\n\n    /// @notice Increase allowance to another account\n    /// @param _spender Spender that receives the allowance\n    /// @param _additionalValue Amount to add\n    /// @return True if success\n    function increaseAllowance(address _spender, uint256 _additionalValue) external returns (bool);\n\n    /// @notice Decrease allowance to another account\n    /// @param _spender Spender that receives the allowance\n    /// @param _subtractableValue Amount to subtract\n    /// @return True if success\n    function decreaseAllowance(address _spender, uint256 _subtractableValue) external returns (bool);\n\n    /// @notice Mint tokens by providing LsETH tokens\n    /// @dev The message sender locks LsETH tokens and received wrapped LsETH tokens in exchange\n    /// @dev The message sender needs to approve the contract to mint the wrapped tokens\n    /// @dev The minted wrapped LsETH is sent to the specified recipient\n    /// @param _recipient The account receiving the new minted wrapped LsETH\n    /// @param _shares The amount of LsETH to wrap\n    function mint(address _recipient, uint256 _shares) external;\n\n    /// @notice Burn tokens and retrieve underlying LsETH tokens\n    /// @dev The message sender burns shares from its balance for the LsETH equivalent value\n    /// @dev The message sender doesn't need to approve the contract to burn the shares\n    /// @dev The freed LsETH is sent to the specified recipient\n    /// @param _recipient The account receiving the underlying LsETH tokens after shares are burned\n    /// @param _shares Amount of LsETH to free by burning wrapped LsETH\n    function burn(address _recipient, uint256 _shares) external;\n}\n"
    },
    "contracts/src/state/wlseth/BalanceOf.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\n/// @title Balance Storage\n/// @notice Utility to manage the Balance in storage\nlibrary BalanceOf {\n    /// @notice Storage slot of the Balance\n    bytes32 internal constant BALANCE_OF_SLOT = bytes32(uint256(keccak256(\"river.state.balanceOf\")) - 1);\n\n    /// @notice The structure in storage\n    struct Slot {\n        /// @custom:attribute The mapping from an owner to its balance\n        mapping(address => uint256) value;\n    }\n\n    /// @notice Retrieve balance of an owner\n    /// @param _owner The owner of the balance\n    /// @return The balance of the owner\n    function get(address _owner) internal view returns (uint256) {\n        bytes32 slot = BALANCE_OF_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value[_owner];\n    }\n\n    /// @notice Set the balance of an owner\n    /// @param _owner The owner to change the balance of\n    /// @param _newValue New balance value for the owner\n    function set(address _owner, uint256 _newValue) internal {\n        bytes32 slot = BALANCE_OF_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        r.value[_owner] = _newValue;\n    }\n}\n"
    },
    "contracts/src/OperatorsRegistry.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"./interfaces/IOperatorRegistry.1.sol\";\n\nimport \"./libraries/LibUint256.sol\";\n\nimport \"./Initializable.sol\";\nimport \"./Administrable.sol\";\n\nimport \"./state/operatorsRegistry/Operators.sol\";\nimport \"./state/operatorsRegistry/ValidatorKeys.sol\";\nimport \"./state/shared/RiverAddress.sol\";\n\n/// @title Operators Registry (v1)\n/// @author Kiln\n/// @notice This contract handles the list of operators and their keys\ncontract OperatorsRegistryV1 is IOperatorsRegistryV1, Initializable, Administrable {\n    /// @notice Maximum validators given to an operator per selection loop round\n    uint256 internal constant MAX_VALIDATOR_ATTRIBUTION_PER_ROUND = 5;\n\n    /// @inheritdoc IOperatorsRegistryV1\n    function initOperatorsRegistryV1(address _admin, address _river) external init(0) {\n        _setAdmin(_admin);\n        RiverAddress.set(_river);\n        emit SetRiver(_river);\n    }\n\n    /// @notice Prevent unauthorized calls\n    modifier onlyRiver() virtual {\n        if (msg.sender != RiverAddress.get()) {\n            revert LibErrors.Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    /// @notice Prevents anyone except the admin or the given operator to make the call. Also checks if operator is active\n    /// @notice The admin is able to call this method on behalf of any operator, even if inactive\n    /// @param _index The index identifying the operator\n    modifier onlyOperatorOrAdmin(uint256 _index) {\n        if (msg.sender == _getAdmin()) {\n            _;\n            return;\n        }\n        Operators.Operator storage operator = Operators.get(_index);\n        if (!operator.active) {\n            revert InactiveOperator(_index);\n        }\n        if (msg.sender != operator.operator) {\n            revert LibErrors.Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    /// @inheritdoc IOperatorsRegistryV1\n    function getRiver() external view returns (address) {\n        return RiverAddress.get();\n    }\n\n    /// @inheritdoc IOperatorsRegistryV1\n    function getOperator(uint256 _index) external view returns (Operators.Operator memory) {\n        return Operators.get(_index);\n    }\n\n    /// @inheritdoc IOperatorsRegistryV1\n    function getOperatorCount() external view returns (uint256) {\n        return Operators.getCount();\n    }\n\n    /// @inheritdoc IOperatorsRegistryV1\n    function getValidator(uint256 _operatorIndex, uint256 _validatorIndex)\n        external\n        view\n        returns (bytes memory publicKey, bytes memory signature, bool funded)\n    {\n        (publicKey, signature) = ValidatorKeys.get(_operatorIndex, _validatorIndex);\n        funded = _validatorIndex < Operators.get(_operatorIndex).funded;\n    }\n\n    /// @inheritdoc IOperatorsRegistryV1\n    function listActiveOperators() external view returns (Operators.Operator[] memory) {\n        return Operators.getAllActive();\n    }\n\n    /// @inheritdoc IOperatorsRegistryV1\n    function addOperator(string calldata _name, address _operator) external onlyAdmin returns (uint256) {\n        Operators.Operator memory newOperator = Operators.Operator({\n            active: true,\n            operator: _operator,\n            name: _name,\n            limit: 0,\n            funded: 0,\n            keys: 0,\n            stopped: 0,\n            latestKeysEditBlockNumber: block.number\n        });\n\n        uint256 operatorIndex = Operators.push(newOperator) - 1;\n\n        emit AddedOperator(operatorIndex, _name, _operator);\n        return operatorIndex;\n    }\n\n    /// @inheritdoc IOperatorsRegistryV1\n    function setOperatorAddress(uint256 _index, address _newOperatorAddress) external onlyOperatorOrAdmin(_index) {\n        LibSanitize._notZeroAddress(_newOperatorAddress);\n        Operators.Operator storage operator = Operators.get(_index);\n\n        operator.operator = _newOperatorAddress;\n\n        emit SetOperatorAddress(_index, _newOperatorAddress);\n    }\n\n    /// @inheritdoc IOperatorsRegistryV1\n    function setOperatorName(uint256 _index, string calldata _newName) external onlyOperatorOrAdmin(_index) {\n        LibSanitize._notEmptyString(_newName);\n        Operators.Operator storage operator = Operators.get(_index);\n        operator.name = _newName;\n\n        emit SetOperatorName(_index, _newName);\n    }\n\n    /// @inheritdoc IOperatorsRegistryV1\n    function setOperatorStatus(uint256 _index, bool _newStatus) external onlyAdmin {\n        Operators.Operator storage operator = Operators.get(_index);\n        operator.active = _newStatus;\n\n        emit SetOperatorStatus(_index, _newStatus);\n    }\n\n    /// @inheritdoc IOperatorsRegistryV1\n    function setOperatorStoppedValidatorCount(uint256 _index, uint256 _newStoppedValidatorCount) external onlyAdmin {\n        Operators.Operator storage operator = Operators.get(_index);\n\n        if (_newStoppedValidatorCount > operator.funded) {\n            revert LibErrors.InvalidArgument();\n        }\n\n        operator.stopped = _newStoppedValidatorCount;\n\n        emit SetOperatorStoppedValidatorCount(_index, _newStoppedValidatorCount);\n    }\n\n    /// @inheritdoc IOperatorsRegistryV1\n    function setOperatorLimits(\n        uint256[] calldata _operatorIndexes,\n        uint256[] calldata _newLimits,\n        uint256 _snapshotBlock\n    ) external onlyAdmin {\n        if (_operatorIndexes.length != _newLimits.length) {\n            revert InvalidArrayLengths();\n        }\n        if (_operatorIndexes.length == 0) {\n            revert InvalidEmptyArray();\n        }\n        for (uint256 idx = 0; idx < _operatorIndexes.length;) {\n            uint256 operatorIndex = _operatorIndexes[idx];\n            uint256 newLimit = _newLimits[idx];\n\n            // prevents duplicates\n            if (idx > 0 && !(operatorIndex > _operatorIndexes[idx - 1])) {\n                revert UnorderedOperatorList();\n            }\n\n            Operators.Operator storage operator = Operators.get(operatorIndex);\n\n            uint256 currentLimit = operator.limit;\n            if (newLimit == currentLimit) {\n                emit OperatorLimitUnchanged(operatorIndex, newLimit);\n                unchecked {\n                    ++idx;\n                }\n                continue;\n            }\n\n            // we enter this condition if the operator edited its keys after the off-chain key audit was made\n            // we will skip any limit update on that operator unless it was a decrease in the initial limit\n            if (_snapshotBlock < operator.latestKeysEditBlockNumber && newLimit > currentLimit) {\n                emit OperatorEditsAfterSnapshot(\n                    operatorIndex, currentLimit, newLimit, operator.latestKeysEditBlockNumber, _snapshotBlock\n                    );\n                unchecked {\n                    ++idx;\n                }\n                continue;\n            }\n\n            // otherwise, we check for limit invariants that shouldn't happen if the off-chain key audit\n            // was made properly, and if everything is respected, we update the limit\n\n            if (newLimit > operator.keys) {\n                revert OperatorLimitTooHigh(operatorIndex, newLimit, operator.keys);\n            }\n\n            if (newLimit < operator.funded) {\n                revert OperatorLimitTooLow(operatorIndex, newLimit, operator.funded);\n            }\n\n            operator.limit = newLimit;\n            emit SetOperatorLimit(operatorIndex, newLimit);\n\n            unchecked {\n                ++idx;\n            }\n        }\n    }\n\n    /// @inheritdoc IOperatorsRegistryV1\n    function addValidators(uint256 _index, uint256 _keyCount, bytes calldata _publicKeysAndSignatures)\n        external\n        onlyOperatorOrAdmin(_index)\n    {\n        if (_keyCount == 0) {\n            revert InvalidKeyCount();\n        }\n\n        if (\n            _publicKeysAndSignatures.length\n                != _keyCount * (ValidatorKeys.PUBLIC_KEY_LENGTH + ValidatorKeys.SIGNATURE_LENGTH)\n        ) {\n            revert InvalidKeysLength();\n        }\n\n        Operators.Operator storage operator = Operators.get(_index);\n\n        for (uint256 idx = 0; idx < _keyCount;) {\n            bytes memory publicKeyAndSignature = LibBytes.slice(\n                _publicKeysAndSignatures,\n                idx * (ValidatorKeys.PUBLIC_KEY_LENGTH + ValidatorKeys.SIGNATURE_LENGTH),\n                ValidatorKeys.PUBLIC_KEY_LENGTH + ValidatorKeys.SIGNATURE_LENGTH\n            );\n            ValidatorKeys.set(_index, operator.keys + idx, publicKeyAndSignature);\n            unchecked {\n                ++idx;\n            }\n        }\n        Operators.setKeys(_index, operator.keys + _keyCount);\n\n        emit AddedValidatorKeys(_index, _publicKeysAndSignatures);\n    }\n\n    /// @inheritdoc IOperatorsRegistryV1\n    function removeValidators(uint256 _index, uint256[] calldata _indexes) external onlyOperatorOrAdmin(_index) {\n        uint256 indexesLength = _indexes.length;\n        if (indexesLength == 0) {\n            revert InvalidKeyCount();\n        }\n\n        Operators.Operator storage operator = Operators.get(_index);\n\n        uint256 totalKeys = operator.keys;\n\n        if (!(_indexes[0] < totalKeys)) {\n            revert InvalidIndexOutOfBounds();\n        }\n\n        uint256 lastIndex = _indexes[indexesLength - 1];\n\n        if (lastIndex < operator.funded) {\n            revert InvalidFundedKeyDeletionAttempt();\n        }\n\n        bool limitEqualsKeyCount = operator.keys == operator.limit;\n        Operators.setKeys(_index, totalKeys - indexesLength);\n\n        uint256 idx;\n        for (; idx < indexesLength;) {\n            uint256 keyIndex = _indexes[idx];\n\n            if (idx > 0 && !(keyIndex < _indexes[idx - 1])) {\n                revert InvalidUnsortedIndexes();\n            }\n\n            unchecked {\n                ++idx;\n            }\n\n            uint256 lastKeyIndex = totalKeys - idx;\n\n            (bytes memory removedPublicKey,) = ValidatorKeys.get(_index, keyIndex);\n            (bytes memory lastPublicKeyAndSignature) = ValidatorKeys.getRaw(_index, lastKeyIndex);\n            ValidatorKeys.set(_index, keyIndex, lastPublicKeyAndSignature);\n            ValidatorKeys.set(_index, lastKeyIndex, new bytes(0));\n\n            emit RemovedValidatorKey(_index, removedPublicKey);\n        }\n\n        if (limitEqualsKeyCount) {\n            operator.limit = operator.keys;\n        } else if (lastIndex < operator.limit) {\n            operator.limit = lastIndex;\n        }\n    }\n\n    /// @inheritdoc IOperatorsRegistryV1\n    function pickNextValidators(uint256 _count)\n        external\n        onlyRiver\n        returns (bytes[] memory publicKeys, bytes[] memory signatures)\n    {\n        return _pickNextValidatorsFromActiveOperators(_count);\n    }\n\n    /// @notice Internal utility to concatenate bytes arrays together\n    /// @param _arr1 First array\n    /// @param _arr2 Second array\n    /// @return The result of the concatenation of _arr1 + _arr2\n    function _concatenateByteArrays(bytes[] memory _arr1, bytes[] memory _arr2)\n        internal\n        pure\n        returns (bytes[] memory)\n    {\n        bytes[] memory res = new bytes[](_arr1.length + _arr2.length);\n        for (uint256 idx = 0; idx < _arr1.length;) {\n            res[idx] = _arr1[idx];\n            unchecked {\n                ++idx;\n            }\n        }\n        for (uint256 idx = 0; idx < _arr2.length;) {\n            res[idx + _arr1.length] = _arr2[idx];\n            unchecked {\n                ++idx;\n            }\n        }\n        return res;\n    }\n\n    /// @notice Internal utility to verify if an operator has fundable keys during the selection process\n    /// @param _operator The Operator structure in memory\n    /// @return True if at least one fundable key is available\n    function _hasFundableKeys(Operators.CachedOperator memory _operator) internal pure returns (bool) {\n        return (_operator.funded + _operator.picked) < _operator.limit;\n    }\n\n    /// @notice Internal utility to get the count of active validators during the selection process\n    /// @param _operator The Operator structure in memory\n    /// @return The count of active validators for the operator\n    function _getActiveKeyCount(Operators.CachedOperator memory _operator) internal pure returns (uint256) {\n        return (_operator.funded + _operator.picked) - _operator.stopped;\n    }\n\n    /// @notice Internal utility to retrieve _count or lower fundable keys\n    /// @dev The selection process starts by retrieving the full list of active operators with at least one fundable key.\n    /// @dev\n    /// @dev An operator is considered to have at least one fundable key when their staking limit is higher than their funded key count.\n    /// @dev\n    /// @dev    isFundable = operator.active && operator.limit > operator.funded\n    /// @dev\n    /// @dev The internal utility will loop on all operators and select the operator with the lowest active validator count.\n    /// @dev The active validator count is computed by subtracting the stopped validator count to the funded validator count.\n    /// @dev\n    /// @dev    activeValidatorCount = operator.funded - operator.stopped\n    /// @dev\n    /// @dev During the selection process, we keep in memory all previously selected operators and the number of given validators inside a field\n    /// @dev called picked that only exists on the CachedOperator structure in memory.\n    /// @dev\n    /// @dev    isFundable = operator.active && operator.limit > (operator.funded + operator.picked)\n    /// @dev    activeValidatorCount = (operator.funded + operator.picked) - operator.stopped\n    /// @dev\n    /// @dev When we reach the requested key count or when all available keys are used, we perform a final loop on all the operators and extract keys\n    /// @dev if any operator has a positive picked count. We then update the storage counters and return the arrays with the public keys and signatures.\n    /// @param _count Amount of keys required. Contract is expected to send _count or lower.\n    /// @return publicKeys An array of fundable public keys\n    /// @return signatures An array of signatures linked to the public keys\n    function _pickNextValidatorsFromActiveOperators(uint256 _count)\n        internal\n        returns (bytes[] memory publicKeys, bytes[] memory signatures)\n    {\n        Operators.CachedOperator[] memory operators = Operators.getAllFundable();\n\n        if (operators.length == 0) {\n            return (new bytes[](0), new bytes[](0));\n        }\n\n        while (_count > 0) {\n            // loop on operators to find the first that has fundable keys, taking into account previous loop round attributions\n            uint256 selectedOperatorIndex = 0;\n            for (; selectedOperatorIndex < operators.length;) {\n                if (_hasFundableKeys(operators[selectedOperatorIndex])) {\n                    break;\n                }\n                unchecked {\n                    ++selectedOperatorIndex;\n                }\n            }\n\n            // if we reach the end, we have allocated all keys\n            if (selectedOperatorIndex == operators.length) {\n                break;\n            }\n\n            // we start from the next operator and we try to find one that has fundable keys but a lower (funded + picked) - stopped value\n            for (uint256 idx = selectedOperatorIndex + 1; idx < operators.length;) {\n                if (\n                    _getActiveKeyCount(operators[idx]) < _getActiveKeyCount(operators[selectedOperatorIndex])\n                        && _hasFundableKeys(operators[idx])\n                ) {\n                    selectedOperatorIndex = idx;\n                }\n                unchecked {\n                    ++idx;\n                }\n            }\n\n            // we take the smallest value between limit - (funded + picked), _requestedAmount and MAX_VALIDATOR_ATTRIBUTION_PER_ROUND\n            uint256 pickedKeyCount = LibUint256.min(\n                LibUint256.min(\n                    operators[selectedOperatorIndex].limit\n                        - (operators[selectedOperatorIndex].funded + operators[selectedOperatorIndex].picked),\n                    MAX_VALIDATOR_ATTRIBUTION_PER_ROUND\n                ),\n                _count\n            );\n\n            // we update the cached picked amount\n            operators[selectedOperatorIndex].picked += pickedKeyCount;\n\n            // we update the requested amount count\n            _count -= pickedKeyCount;\n        }\n\n        // we loop on all operators\n        for (uint256 idx = 0; idx < operators.length; ++idx) {\n            // if we picked keys on any operator, we extract the keys from storage and concatenate them in the result\n            // we then update the funded value\n            if (operators[idx].picked > 0) {\n                (bytes[] memory _publicKeys, bytes[] memory _signatures) =\n                    ValidatorKeys.getKeys(operators[idx].index, operators[idx].funded, operators[idx].picked);\n                publicKeys = _concatenateByteArrays(publicKeys, _publicKeys);\n                signatures = _concatenateByteArrays(signatures, _signatures);\n                (Operators.get(operators[idx].index)).funded += operators[idx].picked;\n            }\n        }\n    }\n}\n"
    },
    "contracts/src/state/operatorsRegistry/ValidatorKeys.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibBytes.sol\";\n\n/// @title Validator Keys Storage\n/// @notice Utility to manage the validator keys in storage\nlibrary ValidatorKeys {\n    /// @notice Storage slot of the Validator Keys\n    bytes32 internal constant VALIDATOR_KEYS_SLOT = bytes32(uint256(keccak256(\"river.state.validatorKeys\")) - 1);\n\n    /// @notice Length in bytes of a BLS Public Key used for validator deposits\n    uint256 internal constant PUBLIC_KEY_LENGTH = 48;\n\n    /// @notice Length in bytes of a BLS Signature used for validator deposits\n    uint256 internal constant SIGNATURE_LENGTH = 96;\n\n    /// @notice The provided public key is not matching the expected length\n    error InvalidPublicKey();\n\n    /// @notice The provided signature is not matching the expected length\n    error InvalidSignature();\n\n    /// @notice Structure of the Validator Keys in storage\n    struct Slot {\n        /// @custom:attribute The mapping from operator index to key index to key value\n        mapping(uint256 => mapping(uint256 => bytes)) value;\n    }\n\n    /// @notice Retrieve the Validator Key of an operator at a specific index\n    /// @param _operatorIndex The operator index\n    /// @param _idx the Validator Key index\n    /// @return publicKey The Validator Key public key\n    /// @return signature The Validator Key signature\n    function get(uint256 _operatorIndex, uint256 _idx)\n        internal\n        view\n        returns (bytes memory publicKey, bytes memory signature)\n    {\n        bytes32 slot = VALIDATOR_KEYS_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        bytes storage entry = r.value[_operatorIndex][_idx];\n\n        publicKey = LibBytes.slice(entry, 0, PUBLIC_KEY_LENGTH);\n        signature = LibBytes.slice(entry, PUBLIC_KEY_LENGTH, SIGNATURE_LENGTH);\n    }\n\n    /// @notice Retrieve the raw concatenated Validator Keys\n    /// @param _operatorIndex The operator index\n    /// @param _idx The Validator Key index\n    /// @return The concatenated public key and signature\n    function getRaw(uint256 _operatorIndex, uint256 _idx) internal view returns (bytes memory) {\n        bytes32 slot = VALIDATOR_KEYS_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value[_operatorIndex][_idx];\n    }\n\n    /// @notice Retrieve multiple keys of an operator starting at an index\n    /// @param _operatorIndex The operator index\n    /// @param _startIdx The starting index to retrieve the keys from\n    /// @param _amount The amount of keys to retrieve\n    /// @return publicKeys The public keys retrieved\n    /// @return signatures The signatures associated with the public keys\n    function getKeys(uint256 _operatorIndex, uint256 _startIdx, uint256 _amount)\n        internal\n        view\n        returns (bytes[] memory publicKeys, bytes[] memory signatures)\n    {\n        publicKeys = new bytes[](_amount);\n        signatures = new bytes[](_amount);\n\n        bytes32 slot = VALIDATOR_KEYS_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n        uint256 idx;\n        for (; idx < _amount;) {\n            bytes memory rawCredentials = r.value[_operatorIndex][idx + _startIdx];\n            publicKeys[idx] = LibBytes.slice(rawCredentials, 0, PUBLIC_KEY_LENGTH);\n            signatures[idx] = LibBytes.slice(rawCredentials, PUBLIC_KEY_LENGTH, SIGNATURE_LENGTH);\n            unchecked {\n                ++idx;\n            }\n        }\n    }\n\n    /// @notice Set the concatenated Validator Keys at an index for an operator\n    /// @param _operatorIndex The operator index\n    /// @param _idx The key index to write on\n    /// @param _publicKeyAndSignature The concatenated Validator Keys\n    function set(uint256 _operatorIndex, uint256 _idx, bytes memory _publicKeyAndSignature) internal {\n        bytes32 slot = VALIDATOR_KEYS_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        r.value[_operatorIndex][_idx] = _publicKeyAndSignature;\n    }\n}\n"
    },
    "contracts/src/ELFeeRecipient.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"./interfaces/IRiver.1.sol\";\nimport \"./interfaces/IELFeeRecipient.1.sol\";\n\nimport \"./libraries/LibUint256.sol\";\n\nimport \"./Initializable.sol\";\n\nimport \"./state/shared/RiverAddress.sol\";\n\n/// @title Execution Layer Fee Recipient (v1)\n/// @author Kiln\n/// @notice This contract receives all the execution layer fees from the proposed blocks + bribes\ncontract ELFeeRecipientV1 is Initializable, IELFeeRecipientV1 {\n    /// @inheritdoc IELFeeRecipientV1\n    function initELFeeRecipientV1(address _riverAddress) external init(0) {\n        RiverAddress.set(_riverAddress);\n        emit SetRiver(_riverAddress);\n    }\n\n    /// @inheritdoc IELFeeRecipientV1\n    function pullELFees(uint256 _maxAmount) external {\n        address river = RiverAddress.get();\n        if (msg.sender != river) {\n            revert LibErrors.Unauthorized(msg.sender);\n        }\n        uint256 amount = LibUint256.min(_maxAmount, address(this).balance);\n\n        IRiverV1(payable(river)).sendELFees{value: amount}();\n    }\n\n    /// @inheritdoc IELFeeRecipientV1\n    receive() external payable {\n        this;\n    }\n\n    /// @inheritdoc IELFeeRecipientV1\n    fallback() external payable {\n        revert InvalidCall();\n    }\n}\n"
    },
    "contracts/src/Allowlist.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"./interfaces/IAllowlist.1.sol\";\n\nimport \"./Initializable.sol\";\nimport \"./Administrable.sol\";\n\nimport \"./state/allowlist/AllowerAddress.sol\";\nimport \"./state/allowlist/Allowlist.sol\";\n\n/// @title Allowlist (v1)\n/// @author Kiln\n/// @notice This contract handles the list of allowed recipients.\n/// @notice All accounts have an uint256 value associated with their addresses where\n/// @notice each bit represents a right in the system. The DENY_MASK defined the mask\n/// @notice used to identify if the denied bit is on, preventing users from interacting\n/// @notice with the system\ncontract AllowlistV1 is IAllowlistV1, Initializable, Administrable {\n    /// @notice Mask used for denied accounts\n    uint256 internal constant DENY_MASK = 0x1 << 255;\n\n    /// @inheritdoc IAllowlistV1\n    function initAllowlistV1(address _admin, address _allower) external init(0) {\n        _setAdmin(_admin);\n        AllowerAddress.set(_allower);\n        emit SetAllower(_allower);\n    }\n\n    /// @inheritdoc IAllowlistV1\n    function getAllower() external view returns (address) {\n        return AllowerAddress.get();\n    }\n\n    /// @inheritdoc IAllowlistV1\n    function isAllowed(address _account, uint256 _mask) external view returns (bool) {\n        uint256 userPermissions = Allowlist.get(_account);\n        if (userPermissions & DENY_MASK == DENY_MASK) {\n            return false;\n        }\n        return userPermissions & _mask == _mask;\n    }\n\n    /// @inheritdoc IAllowlistV1\n    function isDenied(address _account) external view returns (bool) {\n        return Allowlist.get(_account) & DENY_MASK == DENY_MASK;\n    }\n\n    /// @inheritdoc IAllowlistV1\n    function hasPermission(address _account, uint256 _mask) external view returns (bool) {\n        return Allowlist.get(_account) & _mask == _mask;\n    }\n\n    /// @inheritdoc IAllowlistV1\n    function getPermissions(address _account) external view returns (uint256) {\n        return Allowlist.get(_account);\n    }\n\n    /// @inheritdoc IAllowlistV1\n    function onlyAllowed(address _account, uint256 _mask) external view {\n        uint256 userPermissions = Allowlist.get(_account);\n        if (userPermissions & DENY_MASK == DENY_MASK) {\n            revert Denied(_account);\n        }\n        if (userPermissions & _mask != _mask) {\n            revert LibErrors.Unauthorized(_account);\n        }\n    }\n\n    /// @inheritdoc IAllowlistV1\n    function setAllower(address _newAllowerAddress) external onlyAdmin {\n        AllowerAddress.set(_newAllowerAddress);\n        emit SetAllower(_newAllowerAddress);\n    }\n\n    /// @inheritdoc IAllowlistV1\n    function allow(address[] calldata _accounts, uint256[] calldata _permissions) external {\n        if (msg.sender != AllowerAddress.get() && msg.sender != _getAdmin()) {\n            revert LibErrors.Unauthorized(msg.sender);\n        }\n\n        if (_accounts.length == 0) {\n            revert InvalidAlloweeCount();\n        }\n\n        if (_accounts.length != _permissions.length) {\n            revert MismatchedAlloweeAndStatusCount();\n        }\n\n        for (uint256 i = 0; i < _accounts.length;) {\n            LibSanitize._notZeroAddress(_accounts[i]);\n            Allowlist.set(_accounts[i], _permissions[i]);\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit SetAllowlistPermissions(_accounts, _permissions);\n    }\n}\n"
    },
    "contracts/src/state/allowlist/AllowerAddress.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\nimport \"../../libraries/LibSanitize.sol\";\n\n/// @title Allower Address Storage\n/// @notice Utility to manage the Allower Address in storage\nlibrary AllowerAddress {\n    /// @notice Storage slot of the Allower Address\n    bytes32 internal constant ALLOWER_ADDRESS_SLOT = bytes32(uint256(keccak256(\"river.state.allowerAddress\")) - 1);\n\n    /// @notice Retrieve the Allower Address\n    /// @return The Allower Address\n    function get() internal view returns (address) {\n        return LibUnstructuredStorage.getStorageAddress(ALLOWER_ADDRESS_SLOT);\n    }\n\n    /// @notice Sets the Allower Address\n    /// @param _newValue New Allower Address\n    function set(address _newValue) internal {\n        LibSanitize._notZeroAddress(_newValue);\n        LibUnstructuredStorage.setStorageAddress(ALLOWER_ADDRESS_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/allowlist/Allowlist.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\n/// @title Allowlist Storage\n/// @notice Utility to manage the Allowlist mapping in storage\nlibrary Allowlist {\n    /// @notice Storage slot of the Allowlist mapping\n    bytes32 internal constant ALLOWLIST_SLOT = bytes32(uint256(keccak256(\"river.state.allowlist\")) - 1);\n\n    /// @notice Structure stored in storage slot\n    struct Slot {\n        /// @custom:attribute Mapping keeping track of permissions per account\n        mapping(address => uint256) value;\n    }\n\n    /// @notice Retrieve the Allowlist value of an account\n    /// @param _account The account to verify\n    /// @return The Allowlist value\n    function get(address _account) internal view returns (uint256) {\n        bytes32 slot = ALLOWLIST_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value[_account];\n    }\n\n    /// @notice Sets the Allowlist value of an account\n    /// @param _account The account value to set\n    /// @param _status The value to set\n    function set(address _account, uint256 _status) internal {\n        bytes32 slot = ALLOWLIST_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        r.value[_account] = _status;\n    }\n}\n"
    },
    "contracts/src/mock/DepositContractMock.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../interfaces/IDepositContract.sol\";\n\ncontract DepositContractMock is IDepositContract {\n    event DepositEvent(bytes pubkey, bytes withdrawal_credentials, bytes amount, bytes signature, bytes index);\n\n    uint256 public depositCount;\n    address public receiver;\n\n    constructor(address _receiver) {\n        receiver = _receiver;\n    }\n\n    function to_little_endian_64(uint64 value) internal pure returns (bytes memory ret) {\n        ret = new bytes(8);\n        bytes8 bytesValue = bytes8(value);\n        // Byteswapping during copying to bytes.\n        ret[0] = bytesValue[7];\n        ret[1] = bytesValue[6];\n        ret[2] = bytesValue[5];\n        ret[3] = bytesValue[4];\n        ret[4] = bytesValue[3];\n        ret[5] = bytesValue[2];\n        ret[6] = bytesValue[1];\n        ret[7] = bytesValue[0];\n    }\n\n    function deposit(bytes calldata pubkey, bytes calldata withdrawalCredentials, bytes calldata signature, bytes32)\n        external\n        payable\n    {\n        emit DepositEvent(\n            pubkey,\n            withdrawalCredentials,\n            to_little_endian_64(uint64(msg.value / 1 gwei)),\n            signature,\n            to_little_endian_64(uint64(depositCount))\n            );\n        depositCount += 1;\n        (bool sent,) = receiver.call{value: address(this).balance}(\"\");\n        require(sent, \"Fund transfer failed\");\n    }\n}\n"
    },
    "contracts/src/Firewall.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"./interfaces/IFirewall.sol\";\n\nimport \"./Administrable.sol\";\n\n/// @title Firewall\n/// @author Figment\n/// @notice This contract accepts calls to admin-level functions of an underlying contract, and\n///         ensures the caller holds an appropriate role for calling that function. There are two roles:\n///          - An Admin can call anything\n///          - An Executor can call specific functions. The list of function is customisable.\n///         Random callers cannot call anything through this contract, even if the underlying function\n///         is unpermissioned in the underlying contract.\n///         Calls to non-admin functions should be called at the underlying contract directly.\ncontract Firewall is IFirewall, Administrable {\n    /// @inheritdoc IFirewall\n    address public executor;\n\n    /// @inheritdoc IFirewall\n    address public destination;\n\n    /// @inheritdoc IFirewall\n    mapping(bytes4 => bool) public executorCanCall;\n\n    /// @param _admin Address of the administrator, that is able to perform all calls via the Firewall\n    /// @param _executor Address of the executor, that is able to perform only a subset of calls via the Firewall\n    /// @param _executorCallableSelectors Initial list of allowed selectors for the executor\n    constructor(address _admin, address _executor, address _destination, bytes4[] memory _executorCallableSelectors) {\n        LibSanitize._notZeroAddress(_executor);\n        LibSanitize._notZeroAddress(_destination);\n        _setAdmin(_admin);\n        executor = _executor;\n        destination = _destination;\n\n        emit SetExecutor(_executor);\n        emit SetDestination(_destination);\n\n        for (uint256 i; i < _executorCallableSelectors.length;) {\n            executorCanCall[_executorCallableSelectors[i]] = true;\n            emit SetExecutorPermissions(_executorCallableSelectors[i], true);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Prevents unauthorized calls\n    modifier onlyAdminOrExecutor() {\n        if (_getAdmin() != msg.sender && msg.sender != executor) {\n            revert LibErrors.Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    /// @inheritdoc IFirewall\n    function setExecutor(address _newExecutor) external onlyAdminOrExecutor {\n        LibSanitize._notZeroAddress(_newExecutor);\n        executor = _newExecutor;\n        emit SetExecutor(_newExecutor);\n    }\n\n    /// @inheritdoc IFirewall\n    function allowExecutor(bytes4 _functionSelector, bool _executorCanCall) external onlyAdmin {\n        executorCanCall[_functionSelector] = _executorCanCall;\n        emit SetExecutorPermissions(_functionSelector, _executorCanCall);\n    }\n\n    /// @inheritdoc IFirewall\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /// @inheritdoc IFirewall\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /// @notice Performs call checks to verify that the caller is able to perform the call\n    function _checkCallerRole() internal view {\n        if (msg.sender == _getAdmin() || (executorCanCall[msg.sig] && msg.sender == executor)) {\n            return;\n        }\n        revert LibErrors.Unauthorized(msg.sender);\n    }\n\n    /// @notice Forwards the current call parameters to the destination address\n    /// @param _destination Address on which the forwarded call is performed\n    /// @param _value Message value to attach to the call\n    function _forward(address _destination, uint256 _value) internal {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the destination.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := call(gas(), _destination, _value, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // call returns 0 on error.\n            case 0 { revert(0, returndatasize()) }\n            default { return(0, returndatasize()) }\n        }\n    }\n\n    /// @notice Internal utility to perform authorization checks and forward a call\n    function _fallback() internal virtual {\n        _checkCallerRole();\n        _forward(destination, msg.value);\n    }\n}\n"
    },
    "contracts/src/interfaces/IFirewall.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\n/// @title Firewall\n/// @author Figment\n/// @notice This interface exposes methods to accept calls to admin-level functions of an underlying contract.\ninterface IFirewall {\n    /// @notice The stored executor address has been changed\n    /// @param executor The new executor address\n    event SetExecutor(address indexed executor);\n\n    /// @notice The stored destination address has been changed\n    /// @param destination The new destination address\n    event SetDestination(address indexed destination);\n\n    /// @notice The storage permission for a selector has been changed\n    /// @param selector The 4 bytes method selector\n    /// @param status True if executor is allowed\n    event SetExecutorPermissions(bytes4 selector, bool status);\n\n    /// @notice Retrieve the executor address\n    /// @return The executor address\n    function executor() external view returns (address);\n\n    /// @notice Retrieve the destination address\n    /// @return The destination address\n    function destination() external view returns (address);\n\n    /// @notice Returns true if the executor is allowed to perform a call on the given selector\n    /// @param _selector The selector to verify\n    /// @return True if executor is allowed to call\n    function executorCanCall(bytes4 _selector) external view returns (bool);\n\n    /// @notice Sets the executor address\n    /// @param _newExecutor New address for the executor\n    function setExecutor(address _newExecutor) external;\n\n    /// @notice Sets the permission for a function selector\n    /// @param _functionSelector Method signature on which the permission is changed\n    /// @param _executorCanCall True if selector is callable by the executor\n    function allowExecutor(bytes4 _functionSelector, bool _executorCanCall) external;\n\n    /// @notice Fallback method. All its parameters are forwarded to the destination if caller is authorized\n    fallback() external payable;\n\n    /// @notice Receive fallback method. All its parameters are forwarded to the destination if caller is authorized\n    receive() external payable;\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 100
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "devdoc",
          "userdoc",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}