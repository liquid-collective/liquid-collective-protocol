{
  "language": "Solidity",
  "sources": {
    "contracts/src/Allowlist.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"./Initializable.sol\";\nimport \"./libraries/Errors.sol\";\nimport \"./libraries/LibOwnable.sol\";\n\nimport \"./state/allowlist/AllowerAddress.sol\";\nimport \"./state/allowlist/Allowlist.sol\";\n\nimport \"./interfaces/IAllowlist.1.sol\";\n\n/// @title Allowlist (v1)\n/// @author Kiln\n/// @notice This contract handles the list of allowed recipients.\ncontract AllowlistV1 is IAllowlistV1, Initializable {\n    uint256 internal constant DENY_MASK = 0x1 << 255;\n\n    /// @notice Initializes the allowlist\n    /// @param _admin Address of the Allowlist administrator\n    /// @param _allower Address of the allower\n    function initAllowlistV1(address _admin, address _allower) external init(0) {\n        LibOwnable._setAdmin(_admin);\n        AllowerAddress.set(_allower);\n    }\n\n    /// @notice Prevents unauthorized calls\n    modifier onlyAdmin() virtual {\n        if (msg.sender != LibOwnable._getAdmin()) {\n            revert Errors.Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    /// @notice Changes the allower address\n    /// @param _newAllowerAddress New address allowed to edit the allowlist\n    function setAllower(address _newAllowerAddress) external onlyAdmin {\n        AllowerAddress.set(_newAllowerAddress);\n    }\n\n    /// @notice Retrieves the allower address\n    function getAllower() external view returns (address) {\n        return AllowerAddress.get();\n    }\n\n    /// @notice Sets the allowlisting status for one or more accounts\n    /// @param _accounts Accounts with statuses to edit\n    /// @param _statuses Allowlist statuses for each account, in the same order as _accounts\n    function allow(address[] calldata _accounts, uint256[] calldata _statuses) external {\n        if (msg.sender != AllowerAddress.get() && msg.sender != AdministratorAddress.get()) {\n            revert Errors.Unauthorized(msg.sender);\n        }\n\n        if (_accounts.length == 0) {\n            revert InvalidAlloweeCount();\n        }\n\n        if (_accounts.length != _statuses.length) {\n            revert MismatchedAlloweeAndStatusCount();\n        }\n\n        for (uint256 i = 0; i < _accounts.length;) {\n            Allowlist.set(_accounts[i], _statuses[i]);\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit ChangedAllowlistStatuses(_accounts, _statuses);\n    }\n\n    /// @notice This method should be used as a modifier and is expected to revert\n    ///         if the user hasn't got the required permission or if the user is\n    ///         in the deny list.\n    /// @param _account Recipient to verify\n    /// @param _mask Combination of permissions to verify\n    function onlyAllowed(address _account, uint256 _mask) external view {\n        uint256 userPermissions = Allowlist.get(_account);\n        if (userPermissions & DENY_MASK == DENY_MASK) {\n            revert Denied(_account);\n        }\n        if (userPermissions & _mask != _mask) {\n            revert Unauthorized(_account);\n        }\n    }\n\n    /// @notice This method returns true if the user has the expected permission and\n    ///         is not in the deny list\n    /// @param _account Recipient to verify\n    /// @param _mask Combination of permissions to verify\n    function isAllowed(address _account, uint256 _mask) external view returns (bool) {\n        uint256 userPermissions = Allowlist.get(_account);\n        if (userPermissions & DENY_MASK == DENY_MASK) {\n            return false;\n        }\n        return userPermissions & _mask == _mask;\n    }\n\n    /// @notice This method returns true if the user is in the deny list\n    /// @param _account Recipient to verify\n    function isDenied(address _account) external view returns (bool) {\n        return Allowlist.get(_account) & DENY_MASK == DENY_MASK;\n    }\n\n    /// @notice This method returns true if the user has the expected permission\n    ///         ignoring any deny list membership\n    /// @param _account Recipient to verify\n    /// @param _mask Combination of permissions to verify\n    function hasPermission(address _account, uint256 _mask) external view returns (bool) {\n        return Allowlist.get(_account) & _mask == _mask;\n    }\n\n    /// @notice This method retrieves the raw permission value\n    /// @param _account Recipient to verify\n    function getPermissions(address _account) external view returns (uint256) {\n        return Allowlist.get(_account);\n    }\n}\n"
    },
    "contracts/src/Initializable.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"./state/shared/Version.sol\";\n\ncontract Initializable {\n    error InvalidInitialization(uint256 version, uint256 expectedVersion);\n\n    modifier init(uint256 version) {\n        if (version != Version.get()) {\n            revert InvalidInitialization(version, Version.get());\n        }\n        Version.set(version + 1); // prevents reentrency on the called method\n        _;\n    }\n}\n"
    },
    "contracts/src/libraries/Errors.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nlibrary Errors {\n    error Unauthorized(address caller);\n    error InvalidCall();\n    error InvalidArgument();\n    error InvalidZeroAddress();\n}\n"
    },
    "contracts/src/libraries/LibOwnable.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../state/shared/AdministratorAddress.sol\";\nimport \"../state/shared/PendingAdministratorAddress.sol\";\n\nlibrary LibOwnable {\n    function _setAdmin(address newAdmin) internal {\n        AdministratorAddress.set(newAdmin);\n    }\n\n    function _getAdmin() internal view returns (address) {\n        return AdministratorAddress.get();\n    }\n\n    function _setPendingAdmin(address newAdmin) internal {\n        PendingAdministratorAddress.set(newAdmin);\n    }\n\n    function _getPendingAdmin() internal view returns (address) {\n        return PendingAdministratorAddress.get();\n    }\n}\n"
    },
    "contracts/src/state/allowlist/AllowerAddress.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/UnstructuredStorage.sol\";\nimport \"../../libraries/Errors.sol\";\n\nlibrary AllowerAddress {\n    bytes32 internal constant ALLOWER_ADDRESS_SLOT = bytes32(uint256(keccak256(\"river.state.allowerAddress\")) - 1);\n\n    function get() internal view returns (address) {\n        return UnstructuredStorage.getStorageAddress(ALLOWER_ADDRESS_SLOT);\n    }\n\n    function set(address newValue) internal {\n        if (newValue == address(0)) {\n            revert Errors.InvalidZeroAddress();\n        }\n        UnstructuredStorage.setStorageAddress(ALLOWER_ADDRESS_SLOT, newValue);\n    }\n}\n"
    },
    "contracts/src/state/allowlist/Allowlist.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nlibrary Allowlist {\n    bytes32 internal constant ALLOWLIST_SLOT = bytes32(uint256(keccak256(\"river.state.allowlist\")) - 1);\n\n    struct Slot {\n        mapping(address => uint256) value;\n    }\n\n    function get(address account) internal view returns (uint256) {\n        bytes32 slot = ALLOWLIST_SLOT;\n\n        Slot storage r;\n\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value[account];\n    }\n\n    function set(address account, uint256 status) internal {\n        bytes32 slot = ALLOWLIST_SLOT;\n\n        Slot storage r;\n\n        assembly {\n            r.slot := slot\n        }\n\n        r.value[account] = status;\n    }\n}\n"
    },
    "contracts/src/interfaces/IAllowlist.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\ninterface IAllowlistV1 {\n    event ChangedAllowlistStatuses(address[] indexed accounts, uint256[] statuses);\n\n    error InvalidAlloweeCount();\n    error Denied(address _account);\n    error Unauthorized(address _account);\n    error MismatchedAlloweeAndStatusCount();\n\n    function initAllowlistV1(address _admin, address _allower) external;\n    function setAllower(address _newAllowerAddress) external;\n    function getAllower() external view returns (address);\n    function allow(address[] calldata _accounts, uint256[] calldata _statuses) external;\n    function onlyAllowed(address _account, uint256 _mask) external view;\n    function isAllowed(address _account, uint256 _mask) external view returns (bool);\n    function isDenied(address _account) external view returns (bool);\n    function hasPermission(address _account, uint256 _mask) external view returns (bool);\n    function getPermissions(address _account) external view returns (uint256);\n}\n"
    },
    "contracts/src/state/shared/Version.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/UnstructuredStorage.sol\";\n\nlibrary Version {\n    bytes32 public constant VERSION_SLOT = bytes32(uint256(keccak256(\"river.state.version\")) - 1);\n\n    function get() internal view returns (uint256) {\n        return UnstructuredStorage.getStorageUint256(VERSION_SLOT);\n    }\n\n    function set(uint256 newValue) internal {\n        UnstructuredStorage.setStorageUint256(VERSION_SLOT, newValue);\n    }\n}\n"
    },
    "contracts/src/libraries/UnstructuredStorage.sol": {
      "content": "/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity 0.8.10;\n\nlibrary UnstructuredStorage {\n    function getStorageBool(bytes32 position) internal view returns (bool data) {\n        assembly {\n            data := sload(position)\n        }\n    }\n\n    function getStorageAddress(bytes32 position) internal view returns (address data) {\n        assembly {\n            data := sload(position)\n        }\n    }\n\n    function getStorageBytes32(bytes32 position) internal view returns (bytes32 data) {\n        assembly {\n            data := sload(position)\n        }\n    }\n\n    function getStorageUint256(bytes32 position) internal view returns (uint256 data) {\n        assembly {\n            data := sload(position)\n        }\n    }\n\n    function setStorageBool(bytes32 position, bool data) internal {\n        assembly {\n            sstore(position, data)\n        }\n    }\n\n    function setStorageAddress(bytes32 position, address data) internal {\n        assembly {\n            sstore(position, data)\n        }\n    }\n\n    function setStorageBytes32(bytes32 position, bytes32 data) internal {\n        assembly {\n            sstore(position, data)\n        }\n    }\n\n    function setStorageUint256(bytes32 position, uint256 data) internal {\n        assembly {\n            sstore(position, data)\n        }\n    }\n}\n"
    },
    "contracts/src/state/shared/AdministratorAddress.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/UnstructuredStorage.sol\";\n\nlibrary AdministratorAddress {\n    bytes32 public constant ADMINISTRATOR_ADDRESS_SLOT =\n        bytes32(uint256(keccak256(\"river.state.administratorAddress\")) - 1);\n\n    function get() internal view returns (address) {\n        return UnstructuredStorage.getStorageAddress(ADMINISTRATOR_ADDRESS_SLOT);\n    }\n\n    function set(address newValue) internal {\n        UnstructuredStorage.setStorageAddress(ADMINISTRATOR_ADDRESS_SLOT, newValue);\n    }\n}\n"
    },
    "contracts/src/state/shared/PendingAdministratorAddress.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/UnstructuredStorage.sol\";\n\nlibrary PendingAdministratorAddress {\n    bytes32 public constant PENDING_ADMINISTRATOR_ADDRESS_SLOT =\n        bytes32(uint256(keccak256(\"river.state.pendingAdministratorAddress\")) - 1);\n\n    function get() internal view returns (address) {\n        return UnstructuredStorage.getStorageAddress(PENDING_ADMINISTRATOR_ADDRESS_SLOT);\n    }\n\n    function set(address newValue) internal {\n        UnstructuredStorage.setStorageAddress(PENDING_ADMINISTRATOR_ADDRESS_SLOT, newValue);\n    }\n}\n"
    },
    "contracts/src/River.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"./interfaces/IAllowlist.1.sol\";\nimport \"./interfaces/IOperatorRegistry.1.sol\";\nimport \"./interfaces/IRiver.1.sol\";\nimport \"./interfaces/IELFeeRecipient.1.sol\";\n\nimport \"./components/ConsensusLayerDepositManager.1.sol\";\nimport \"./components/UserDepositManager.1.sol\";\nimport \"./components/SharesManager.1.sol\";\nimport \"./components/OracleManager.1.sol\";\nimport \"./Initializable.sol\";\nimport \"./libraries/LibOwnable.sol\";\n\nimport \"./state/shared/AdministratorAddress.sol\";\nimport \"./state/river/AllowlistAddress.sol\";\nimport \"./state/river/OperatorsRegistryAddress.sol\";\nimport \"./state/river/TreasuryAddress.sol\";\nimport \"./state/river/OperatorRewardsShare.sol\";\nimport \"./state/river/GlobalFee.sol\";\nimport \"./state/river/ELFeeRecipientAddress.sol\";\n\n/// @title River (v1)\n/// @author Kiln\n/// @notice This contract merges all the manager contracts and implements all the virtual methods stitching all components together\ncontract RiverV1 is\n    ConsensusLayerDepositManagerV1,\n    UserDepositManagerV1,\n    SharesManagerV1,\n    OracleManagerV1,\n    Initializable,\n    IRiverV1\n{\n    uint256 public constant BASE = 100000;\n    uint256 internal constant DEPOSIT_MASK = 0x1;\n    uint256 internal constant TRANSFER_MASK = 0;\n    /// @notice Prevents unauthorized calls\n\n    modifier onlyAdmin() override (OracleManagerV1) {\n        if (msg.sender != LibOwnable._getAdmin()) {\n            revert Errors.Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    /// @notice Initializes the River system\n    /// @param _depositContractAddress Address to make Consensus Layer deposits\n    /// @param _elFeeRecipientAddress Address that receives the execution layer fees\n    /// @param _withdrawalCredentials Credentials to use for every validator deposit\n    /// @param _systemAdministratorAddress Administrator address\n    /// @param _allowlistAddress Address of the allowlist contract\n    /// @param _operatorRegistryAddress Address of the operator registry\n    /// @param _treasuryAddress Address receiving the fee minus the operator share\n    /// @param _globalFee Amount retained when the eth balance increases, splitted between the treasury and the operators\n    /// @param _operatorRewardsShare Share of the global fee used to reward node operators\n    function initRiverV1(\n        address _depositContractAddress,\n        address _elFeeRecipientAddress,\n        bytes32 _withdrawalCredentials,\n        address _oracleAddress,\n        address _systemAdministratorAddress,\n        address _allowlistAddress,\n        address _operatorRegistryAddress,\n        address _treasuryAddress,\n        uint256 _globalFee,\n        uint256 _operatorRewardsShare\n    )\n        external\n        init(0)\n    {\n        if (_systemAdministratorAddress == address(0)) {\n            // only check on initialization\n            revert Errors.InvalidZeroAddress();\n        }\n        LibOwnable._setAdmin(_systemAdministratorAddress);\n        TreasuryAddress.set(_treasuryAddress);\n        GlobalFee.set(_globalFee);\n        OperatorRewardsShare.set(_operatorRewardsShare);\n        ELFeeRecipientAddress.set(_elFeeRecipientAddress);\n\n        ConsensusLayerDepositManagerV1.initConsensusLayerDepositManagerV1(\n            _depositContractAddress, _withdrawalCredentials\n        );\n        OracleManagerV1.initOracleManagerV1(_oracleAddress);\n        AllowlistAddress.set(_allowlistAddress);\n        OperatorsRegistryAddress.set(_operatorRegistryAddress);\n    }\n\n    /// @notice Changes the global fee parameter\n    /// @param newFee New fee value\n    function setGlobalFee(uint256 newFee) external onlyAdmin {\n        if (newFee > BASE) {\n            revert Errors.InvalidArgument();\n        }\n\n        GlobalFee.set(newFee);\n    }\n\n    /// @notice Get the current global fee\n    function getGlobalFee() external view returns (uint256) {\n        return GlobalFee.get();\n    }\n\n    /// @notice Changes the operator rewards share.\n    /// @param newOperatorRewardsShare New share value\n    function setOperatorRewardsShare(uint256 newOperatorRewardsShare) external onlyAdmin {\n        if (newOperatorRewardsShare > BASE) {\n            revert Errors.InvalidArgument();\n        }\n\n        OperatorRewardsShare.set(newOperatorRewardsShare);\n    }\n\n    /// @notice Get the current operator rewards share\n    function getOperatorRewardsShare() external view returns (uint256) {\n        return OperatorRewardsShare.get();\n    }\n\n    /// @notice Changes the allowlist address\n    /// @param _newAllowlist New address for the allowlist\n    function setAllowlist(address _newAllowlist) external onlyAdmin {\n        AllowlistAddress.set(_newAllowlist);\n    }\n\n    /// @notice Retrieve the allowlist address\n    function getAllowlist() external view returns (address) {\n        return address(AllowlistAddress.get());\n    }\n\n    /// @notice Changes the treasury address\n    /// @param _newTreasury New address for the treasury\n    function setTreasury(address _newTreasury) external onlyAdmin {\n        TreasuryAddress.set(_newTreasury);\n    }\n\n    /// @notice Retrieve the treasury address\n    function getTreasury() external view returns (address) {\n        return TreasuryAddress.get();\n    }\n\n    /// @notice Changes the admin but waits for new admin approval\n    /// @param _newAdmin New address for the admin\n    function transferOwnership(address _newAdmin) external onlyAdmin {\n        LibOwnable._setPendingAdmin(_newAdmin);\n    }\n\n    /// @notice Accepts the ownership of the system\n    function acceptOwnership() external {\n        if (msg.sender != LibOwnable._getPendingAdmin()) {\n            revert Errors.Unauthorized(msg.sender);\n        }\n        LibOwnable._setAdmin(msg.sender);\n        LibOwnable._setPendingAdmin(address(0));\n    }\n\n    /// @notice Retrieve system administrator address\n    function getAdministrator() external view returns (address) {\n        return LibOwnable._getAdmin();\n    }\n\n    /// @notice Retrieve system pending administrator address\n    function getPendingAdministrator() external view returns (address) {\n        return LibOwnable._getPendingAdmin();\n    }\n\n    /// @notice Changes the execution layer fee recipient\n    /// @param _newELFeeRecipient New address for the recipient\n    function setELFeeRecipient(address _newELFeeRecipient) external onlyAdmin {\n        ELFeeRecipientAddress.set(_newELFeeRecipient);\n    }\n\n    /// @notice Retrieve the execution layer fee recipient\n    function getELFeeRecipient() external view returns (address) {\n        return ELFeeRecipientAddress.get();\n    }\n\n    /// @notice Input for execution layer fee earnings\n    function sendELFees() external payable {\n        if (msg.sender != ELFeeRecipientAddress.get()) {\n            revert Errors.Unauthorized(msg.sender);\n        }\n    }\n\n    /// @notice Handler called whenever a token transfer is triggered\n    /// @param _from Token sender\n    /// @param _to Token receiver\n    function _onTransfer(address _from, address _to) internal view override {\n        IAllowlistV1(AllowlistAddress.get()).onlyAllowed(_from, TRANSFER_MASK); // this call reverts if unauthorized or denied\n        IAllowlistV1(AllowlistAddress.get()).onlyAllowed(_to, TRANSFER_MASK); // this call reverts if unauthorized or denied\n    }\n\n    /// @notice Handler called whenever a user deposits ETH to the system. Mints the adequate amount of shares.\n    /// @param _depositor User address that made the deposit\n    /// @param _amount Amount of ETH deposited\n    function _onDeposit(address _depositor, address _recipient, uint256 _amount) internal override {\n        uint256 mintedShares = SharesManagerV1._mintShares(_depositor, _amount);\n        if (_depositor == _recipient) {\n            IAllowlistV1(AllowlistAddress.get()).onlyAllowed(_depositor, DEPOSIT_MASK); // this call reverts if unauthorized or denied\n        } else {\n            IAllowlistV1(AllowlistAddress.get()).onlyAllowed(_depositor, DEPOSIT_MASK + TRANSFER_MASK); // this call reverts if unauthorized or denied\n            IAllowlistV1(AllowlistAddress.get()).onlyAllowed(_recipient, TRANSFER_MASK);\n            _transfer(_depositor, _recipient, mintedShares);\n        }\n    }\n\n    /// @notice Handler called whenever a deposit to the consensus layer is made. Should retrieve _requestedAmount or lower keys\n    /// @param _requestedAmount Amount of keys required. Contract is expected to send _requestedAmount or lower.\n    function _getNextValidators(uint256 _requestedAmount)\n        internal\n        override\n        returns (bytes[] memory publicKeys, bytes[] memory signatures)\n    {\n        return IOperatorsRegistryV1(OperatorsRegistryAddress.get()).pickNextValidators(_requestedAmount);\n    }\n\n    /// @notice Internal utility managing reward distribution amongst node operators\n    /// @param _reward Amount of shares to split between operators\n    function _rewardOperators(uint256 _reward) internal returns (uint256) {\n        Operators.Operator[] memory operators =\n            IOperatorsRegistryV1(OperatorsRegistryAddress.get()).listActiveOperators();\n        uint256[] memory validatorCounts = new uint256[](operators.length);\n\n        uint256 totalActiveValidators = 0;\n        for (uint256 idx = 0; idx < operators.length;) {\n            uint256 operatorActiveValidatorCount = operators[idx].funded - operators[idx].stopped;\n            totalActiveValidators += operatorActiveValidatorCount;\n            validatorCounts[idx] = operatorActiveValidatorCount;\n            unchecked {\n                ++idx;\n            }\n        }\n\n        if (totalActiveValidators > 0) {\n            uint256 rewardsPerActiveValidator = _reward / totalActiveValidators;\n\n            for (uint256 idx = 0; idx < validatorCounts.length;) {\n                _mintRawShares(operators[idx].feeRecipient, validatorCounts[idx] * rewardsPerActiveValidator);\n                unchecked {\n                    ++idx;\n                }\n            }\n        } else {\n            _reward = 0;\n        }\n\n        return _reward;\n    }\n\n    /// @notice Internal utility to pull funds from the execution layer fee recipient to River and return the delta in the balance\n    function _pullELFees() internal override returns (uint256) {\n        address elFeeRecipient = ELFeeRecipientAddress.get();\n        if (elFeeRecipient == address(0)) {\n            return 0;\n        }\n        uint256 initialBalance = address(this).balance;\n        IELFeeRecipientV1(payable(elFeeRecipient)).pullELFees();\n        uint256 collectedELFees = address(this).balance - initialBalance;\n        emit PulledELFees(collectedELFees);\n        return collectedELFees;\n    }\n\n    /// @notice Handler called whenever the balance of ETH handled by the system increases. Splits funds between operators and treasury.\n    /// @param _amount Additional eth received\n    function _onEarnings(uint256 _amount) internal override {\n        uint256 currentTotalSupply = _totalSupply();\n        if (currentTotalSupply == 0) {\n            revert ZeroMintedShares();\n        }\n        uint256 globalFee = GlobalFee.get();\n        uint256 numerator = _amount * currentTotalSupply * globalFee;\n        uint256 denominator = (_assetBalance() * BASE) - (_amount * globalFee);\n        uint256 sharesToMint = denominator == 0 ? 0 : (numerator / denominator);\n\n        uint256 operatorRewards = (sharesToMint * OperatorRewardsShare.get()) / BASE;\n\n        uint256 mintedRewards = _rewardOperators(operatorRewards);\n\n        _mintRawShares(TreasuryAddress.get(), sharesToMint - mintedRewards);\n    }\n\n    /// @notice Handler called whenever the total balance of ETH is requested\n    function _assetBalance() internal view override returns (uint256) {\n        uint256 beaconValidatorCount = BeaconValidatorCount.get();\n        uint256 depositedValidatorCount = DepositedValidatorCount.get();\n        if (beaconValidatorCount < depositedValidatorCount) {\n            return BeaconValidatorBalanceSum.get() + address(this).balance\n                + (depositedValidatorCount - beaconValidatorCount) * ConsensusLayerDepositManagerV1.DEPOSIT_SIZE;\n        } else {\n            return BeaconValidatorBalanceSum.get() + address(this).balance;\n        }\n    }\n}\n"
    },
    "contracts/src/interfaces/IOperatorRegistry.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../state/operatorsRegistry/Operators.sol\";\n\ninterface IOperatorsRegistryV1 {\n    error OperatorAlreadyExists(string name);\n    error InactiveOperator(uint256 index);\n    error InvalidFundedKeyDeletionAttempt();\n    error InvalidUnsortedIndexes();\n    error InvalidArrayLengths();\n    error InvalidEmptyArray();\n    error InvalidKeyCount();\n    error InvalidPublicKeysLength();\n    error InvalidSignatureLength();\n    error InvalidIndexOutOfBounds();\n    error OperatorLimitTooHigh(uint256 limit, uint256 keyCount);\n\n    event AddedOperator(uint256 indexed index, string name, address operatorAddress, address feeRecipientAddress);\n    event SetOperatorStatus(uint256 indexed index, bool active);\n    event SetOperatorLimit(uint256 indexed index, uint256 newLimit);\n    event SetOperatorStoppedValidatorCount(uint256 indexed index, uint256 newStoppedValidatorCount);\n    event SetOperatorFeeRecipientAddress(uint256 indexed index, address newOperatorAddress);\n    event SetOperatorAddress(uint256 indexed index, address newOperatorAddress);\n    event SetOperatorName(uint256 indexed name, string newName);\n    event AddedValidatorKeys(uint256 indexed index, bytes publicKeys);\n    event RemovedValidatorKey(uint256 indexed index, bytes publicKey);\n\n    function initOperatorsRegistryV1(address _admin, address _river) external;\n    function listActiveOperators() external view returns (Operators.Operator[] memory);\n    function getRiver() external view returns (address);\n    function setRiver(address _newRiver) external;\n    function getOperatorDetails(string calldata _name)\n        external\n        view\n        returns (int256 _index, address _operatorAddress);\n    function addOperator(string calldata _name, address _operator, address _feeRecipient) external;\n    function setOperatorAddress(uint256 _index, address _newOperatorAddress) external;\n    function setOperatorFeeRecipientAddress(uint256 _index, address _newOperatorFeeRecipientAddress) external;\n    function setOperatorName(uint256 _index, string calldata _newName) external;\n    function setOperatorStatus(uint256 _index, bool _newStatus) external;\n    function setOperatorStoppedValidatorCount(uint256 _index, uint256 _newStoppedValidatorCount) external;\n    function setOperatorLimits(uint256[] calldata _operatorIndexes, uint256[] calldata _newLimits) external;\n    function addValidators(uint256 _index, uint256 _keyCount, bytes calldata _publicKeys, bytes calldata _signatures)\n        external;\n    function removeValidators(uint256 _index, uint256[] calldata _indexes) external;\n    function getOperator(uint256 _index) external view returns (Operators.Operator memory);\n    function getOperatorCount() external view returns (uint256);\n    function getValidator(uint256 _operatorIndex, uint256 _validatorIndex)\n        external\n        view\n        returns (bytes memory publicKey, bytes memory signature, bool funded);\n    function pickNextValidators(uint256 _requestedAmount)\n        external\n        returns (bytes[] memory publicKeys, bytes[] memory signatures);\n}\n"
    },
    "contracts/src/interfaces/IRiver.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"./components/IConsensusLayerDepositManager.1.sol\";\nimport \"./components/IOracleManager.1.sol\";\nimport \"./components/ISharesManager.1.sol\";\nimport \"./components/IUserDepositManager.1.sol\";\n\ninterface IRiverV1 is IConsensusLayerDepositManagerV1, IUserDepositManagerV1, ISharesManagerV1, IOracleManagerV1 {\n    error ZeroMintedShares();\n\n    event PulledELFees(uint256 amount);\n\n    function initRiverV1(\n        address _depositContractAddress,\n        address _elFeeRecipientAddress,\n        bytes32 _withdrawalCredentials,\n        address _oracleAddress,\n        address _systemAdministratorAddress,\n        address _allowlistAddress,\n        address _operatorRegistryAddress,\n        address _treasuryAddress,\n        uint256 _globalFee,\n        uint256 _operatorRewardsShare\n    )\n        external;\n\n    function setGlobalFee(uint256 newFee) external;\n    function getGlobalFee() external view returns (uint256);\n    function setOperatorRewardsShare(uint256 newOperatorRewardsShare) external;\n    function getOperatorRewardsShare() external view returns (uint256);\n    function setAllowlist(address _newAllowlist) external;\n    function getAllowlist() external view returns (address);\n    function setTreasury(address _newTreasury) external;\n    function getTreasury() external view returns (address);\n    function transferOwnership(address _newAdmin) external;\n    function acceptOwnership() external;\n    function getAdministrator() external view returns (address);\n    function getPendingAdministrator() external view returns (address);\n    function setELFeeRecipient(address _newELFeeRecipient) external;\n    function getELFeeRecipient() external view returns (address);\n    function sendELFees() external payable;\n}\n"
    },
    "contracts/src/interfaces/IELFeeRecipient.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\ninterface IELFeeRecipientV1 {\n    error InvalidCall();\n\n    function initELFeeRecipientV1(address _riverAddress) external;\n    function pullELFees() external;\n    receive() external payable;\n    fallback() external payable;\n}\n"
    },
    "contracts/src/components/ConsensusLayerDepositManager.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../interfaces/IDepositContract.sol\";\n\nimport \"../libraries/BytesLib.sol\";\nimport \"../libraries/Uint256Lib.sol\";\n\nimport \"../state/river/DepositContractAddress.sol\";\nimport \"../state/river/WithdrawalCredentials.sol\";\nimport \"../state/river/DepositedValidatorCount.sol\";\n\nimport \"../interfaces/components/IConsensusLayerDepositManager.1.sol\";\n\n/// @title Consensus Layer Deposit Manager (v1)\n/// @author Kiln\n/// @notice This contract handles the interactions with the official deposit contract, funding all validators\n/// @dev _onValidatorKeyRequest must be overriden.\nabstract contract ConsensusLayerDepositManagerV1 is IConsensusLayerDepositManagerV1 {\n    uint256 public constant PUBLIC_KEY_LENGTH = 48;\n    uint256 public constant SIGNATURE_LENGTH = 96;\n    uint256 public constant DEPOSIT_SIZE = 32 ether;\n\n    /// @notice Initializer to set the deposit contract address and the withdrawal credentials to use\n    /// @param _depositContractAddress The address of the deposit contract\n    /// @param _withdrawalCredentials The withdrawal credentials to apply to all deposits\n    function initConsensusLayerDepositManagerV1(address _depositContractAddress, bytes32 _withdrawalCredentials)\n        internal\n    {\n        DepositContractAddress.set(IDepositContract(_depositContractAddress));\n\n        WithdrawalCredentials.set(_withdrawalCredentials);\n    }\n\n    /// @notice Retrieve the withdrawal credentials\n    function getWithdrawalCredentials() external view returns (bytes32) {\n        return WithdrawalCredentials.get();\n    }\n\n    /// @notice Internal helper to retrieve validator keys ready to be funded\n    /// @dev Must be overriden with an implementation that provides keyCount or less keys upon call\n    /// @param _keyCount The amount of keys (or less) to return.\n    function _getNextValidators(uint256 _keyCount)\n        internal\n        virtual\n        returns (bytes[] memory publicKeys, bytes[] memory signatures);\n\n    /// @notice Deposits current balance to the Consensus Layer by batches of 32 ETH\n    /// @param _maxCount The maximum amount of validator keys to fund\n    function depositToConsensusLayer(uint256 _maxCount) external {\n        uint256 validatorsToDeposit = Uint256Lib.min(address(this).balance / DEPOSIT_SIZE, _maxCount);\n\n        if (validatorsToDeposit == 0) {\n            revert NotEnoughFunds();\n        }\n\n        (bytes[] memory publicKeys, bytes[] memory signatures) = _getNextValidators(validatorsToDeposit);\n\n        uint256 receivedPublicKeyCount = publicKeys.length;\n\n        if (receivedPublicKeyCount == 0) {\n            revert NoAvailableValidatorKeys();\n        }\n\n        if (receivedPublicKeyCount > validatorsToDeposit) {\n            revert InvalidPublicKeyCount();\n        }\n\n        uint256 receivedSignatureCount = signatures.length;\n\n        if (receivedSignatureCount != receivedPublicKeyCount) {\n            revert InvalidSignatureCount();\n        }\n\n        bytes32 withdrawalCredentials = WithdrawalCredentials.get();\n\n        if (withdrawalCredentials == 0) {\n            revert InvalidWithdrawalCredentials();\n        }\n\n        for (uint256 idx = 0; idx < receivedPublicKeyCount;) {\n            _depositValidator(publicKeys[idx], signatures[idx], withdrawalCredentials);\n            unchecked {\n                ++idx;\n            }\n        }\n\n        DepositedValidatorCount.set(DepositedValidatorCount.get() + receivedPublicKeyCount);\n    }\n\n    /// @notice Deposits 32 ETH to the official Deposit contract\n    /// @param _publicKey The public key of the validator\n    /// @param _signature The signature provided by the operator\n    /// @param _withdrawalCredentials The withdrawal credentials provided by River\n    function _depositValidator(bytes memory _publicKey, bytes memory _signature, bytes32 _withdrawalCredentials)\n        internal\n    {\n        if (_publicKey.length != PUBLIC_KEY_LENGTH) {\n            revert InconsistentPublicKeys();\n        }\n\n        if (_signature.length != SIGNATURE_LENGTH) {\n            revert InconsistentSignatures();\n        }\n        uint256 value = DEPOSIT_SIZE;\n\n        uint256 depositAmount = value / 1000000000 wei;\n\n        bytes32 pubkeyRoot = sha256(BytesLib.pad64(_publicKey));\n        bytes32 signatureRoot = sha256(\n            abi.encodePacked(\n                sha256(BytesLib.slice(_signature, 0, 64)),\n                sha256(BytesLib.pad64(BytesLib.slice(_signature, 64, SIGNATURE_LENGTH - 64)))\n            )\n        );\n\n        bytes32 depositDataRoot = sha256(\n            abi.encodePacked(\n                sha256(abi.encodePacked(pubkeyRoot, _withdrawalCredentials)),\n                sha256(abi.encodePacked(Uint256Lib.toLittleEndian64(depositAmount), signatureRoot))\n            )\n        );\n\n        uint256 targetBalance = address(this).balance - value;\n\n        DepositContractAddress.get().deposit{value: value}(\n            _publicKey, abi.encodePacked(_withdrawalCredentials), _signature, depositDataRoot\n        );\n        require(address(this).balance == targetBalance, \"EXPECTING_DEPOSIT_TO_HAPPEN\");\n        emit FundedValidatorKey(_publicKey);\n    }\n\n    /// @notice Get the deposited validator count (the count of deposits made by the contract)\n    function getDepositedValidatorCount() external view returns (uint256 depositedValidatorCount) {\n        depositedValidatorCount = DepositedValidatorCount.get();\n    }\n}\n"
    },
    "contracts/src/components/UserDepositManager.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../libraries/Errors.sol\";\n\nimport \"../interfaces/components/IUserDepositManager.1.sol\";\n\n/// @title User Deposit Manager (v1)\n/// @author Kiln\n/// @notice This contract handles the inbound transfers cases or the explicit submissions\nabstract contract UserDepositManagerV1 is IUserDepositManagerV1 {\n    /// @notice Handler called whenever a user has sent funds to the contract\n    /// @dev Must be overriden\n    /// @param _depositor Address that made the deposit\n    /// @param _recipient Address that receives the minted shares\n    /// @param _amount Amount deposited\n    function _onDeposit(address _depositor, address _recipient, uint256 _amount) internal virtual;\n\n    /// @notice Internal utility calling the deposit handler and emitting the deposit details\n    function _deposit(address _recipient) internal {\n        if (msg.value == 0) {\n            revert EmptyDeposit();\n        }\n\n        _onDeposit(msg.sender, _recipient, msg.value);\n\n        emit UserDeposit(msg.sender, _recipient, msg.value);\n    }\n\n    /// @notice Returns the amount of pending ETH\n    function getPendingEth() external view returns (uint256) {\n        return address(this).balance;\n    }\n\n    /// @notice Explicit deposit method to mint on msg.sender\n    function deposit() external payable {\n        _deposit(msg.sender);\n    }\n\n    /// @notice Explicit deposit method to mint on msg.sender and transfer to _recipient\n    /// @param _recipient Address receiving the minted lsETH\n    function depositAndTransfer(address _recipient) external payable {\n        _deposit(_recipient);\n    }\n\n    /// @notice Implicit deposit method, when the user performs a regular transfer to the contract\n    receive() external payable {\n        _deposit(msg.sender);\n    }\n\n    /// @notice Invalid call, when the user sends a transaction with a data payload but no method matched\n    fallback() external payable {\n        revert Errors.InvalidCall();\n    }\n}\n"
    },
    "contracts/src/components/SharesManager.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../libraries/Errors.sol\";\n\nimport \"../state/river/Shares.sol\";\nimport \"../state/river/SharesPerOwner.sol\";\nimport \"../state/shared/ApprovalsPerOwner.sol\";\n\nimport \"../interfaces/components/ISharesManager.1.sol\";\n\n/// @title Shares Manager (v1)\n/// @author Kiln\n/// @notice This contract handles the shares of the depositor and the rebasing effect depending on the oracle data\nabstract contract SharesManagerV1 is ISharesManagerV1 {\n    /// @notice Internal hook triggered on the external transfer call\n    /// @param _from Address of the sender\n    /// @param _to Address of the recipient\n    function _onTransfer(address _from, address _to) internal view virtual;\n\n    /// @notice Internal method to override to provide the total underlying asset balance\n    function _assetBalance() internal view virtual returns (uint256);\n\n    /// @notice Modifier used to ensure that the transfer is allowed by using the internal hook to perform internal checks\n    /// @param _from Address of the sender\n    /// @param _to Address of the recipient\n    modifier transferAllowed(address _from, address _to) {\n        _onTransfer(_from, _to);\n        _;\n    }\n\n    /// @notice Modifier used to ensure the amount transferred is not 0\n    /// @param _value Amount to check\n    modifier isNotZero(uint256 _value) {\n        if (_value == 0) {\n            revert NullTransfer();\n        }\n        _;\n    }\n\n    /// @notice Modifier used to ensure that the sender has enough funds for the transfer\n    /// @param _owner Address of the sender\n    /// @param _value Value that is required to be sent\n    modifier hasFunds(address _owner, uint256 _value) {\n        if (_balanceOf(_owner) < _value) {\n            revert BalanceTooLow();\n        }\n        _;\n    }\n\n    /// @notice Retrieve the token name\n    function name() external pure returns (string memory) {\n        return \"River Ether\";\n    }\n\n    /// @notice Retrieve the token symbol\n    function symbol() external pure returns (string memory) {\n        return \"lsETH\";\n    }\n\n    /// @notice Retrieve the decimal count\n    function decimals() external pure returns (uint8) {\n        return 18;\n    }\n\n    /// @notice Retrieve the total token supply\n    function totalSupply() external view returns (uint256) {\n        return _totalSupply();\n    }\n\n    /// @notice Retrieve the total underlying asset supply\n    function totalUnderlyingSupply() external view returns (uint256) {\n        return _assetBalance();\n    }\n\n    /// @notice Retrieve the balance of an account\n    /// @param _owner Address to be checked\n    function balanceOf(address _owner) external view returns (uint256 balance) {\n        return _balanceOf(_owner);\n    }\n\n    /// @notice Retrieve the underlying asset balance of an account\n    /// @param _owner Address to be checked\n    function balanceOfUnderlying(address _owner) public view returns (uint256 balance) {\n        return _balanceFromShares(SharesPerOwner.get(_owner));\n    }\n\n    function underlyingBalanceFromShares(uint256 shares) external view returns (uint256) {\n        return _balanceFromShares(shares);\n    }\n\n    function sharesFromUnderlyingBalance(uint256 underlyingBalance) external view returns (uint256) {\n        return _sharesFromBalance(underlyingBalance);\n    }\n\n    /// @notice Retrieve the allowance value for a spender\n    /// @notice _owner Address that issued the allowance\n    /// @notice _spender Address that received the allowance\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining) {\n        return ApprovalsPerOwner.get(_owner, _spender);\n    }\n\n    /// @notice Performs a transfer from the message sender to the provided account\n    /// @param _to Address receiving the tokens\n    /// @param _value Amount to be sent\n    function transfer(address _to, uint256 _value)\n        external\n        transferAllowed(msg.sender, _to)\n        isNotZero(_value)\n        hasFunds(msg.sender, _value)\n        returns (bool)\n    {\n        return _transfer(msg.sender, _to, _value);\n    }\n\n    /// @notice Performs a transfer between two recipients\n    /// @dev If the specified _from argument is the message sender, behaves like a regular transfer\n    /// @dev If the specified _from argument is not the message sender, checks that the message sender has been given enough allowance\n    /// @param _from Address sending the tokens\n    /// @param _to Address receiving the tokens\n    /// @param _value Amount to be sent\n    function transferFrom(address _from, address _to, uint256 _value)\n        external\n        transferAllowed(_from, _to)\n        isNotZero(_value)\n        hasFunds(_from, _value)\n        returns (bool)\n    {\n        if (_from != msg.sender) {\n            uint256 currentAllowance = ApprovalsPerOwner.get(_from, msg.sender);\n            if (currentAllowance < _value) {\n                revert AllowanceTooLow(_from, msg.sender, currentAllowance, _value);\n            }\n            ApprovalsPerOwner.set(_from, msg.sender, currentAllowance - _value);\n        }\n        return _transfer(_from, _to, _value);\n    }\n\n    /// @notice Approves an account for future spendings\n    /// @dev An approved account can use transferFrom to transfer funds on behalf of the token owner\n    /// @param _spender Address that is allowed to spend the tokens\n    /// @param _value The allowed amount, will override previous value\n    function approve(address _spender, uint256 _value) external returns (bool success) {\n        ApprovalsPerOwner.set(msg.sender, _spender, _value);\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    /// @notice Internal utility to retrieve the total supply of tokens\n    function _totalSupply() internal view returns (uint256) {\n        return Shares.get();\n    }\n\n    /// @notice Internal utility to perform an unchecked transfer\n    /// @param _from Address sending the tokens\n    /// @param _to Address receiving the tokens\n    /// @param _value Amount to be sent\n    function _transfer(address _from, address _to, uint256 _value) internal returns (bool) {\n        SharesPerOwner.set(_from, SharesPerOwner.get(_from) - _value);\n        SharesPerOwner.set(_to, SharesPerOwner.get(_to) + _value);\n\n        emit Transfer(_from, _to, _value);\n\n        return true;\n    }\n\n    /// @notice Internal utility to retrieve the underlying asset balance for the given shares\n    /// @param _shares Amount of shares to convert\n    function _balanceFromShares(uint256 _shares) internal view returns (uint256) {\n        uint256 _totalSharesValue = Shares.get();\n\n        if (_totalSharesValue == 0) {\n            return 0;\n        }\n\n        return ((_shares * _assetBalance())) / _totalSharesValue;\n    }\n\n    /// @notice Internal utility to retrieve the shares count for a given underlying asset amount\n    /// @param _balance Amount of underlying asset balance to convert\n    function _sharesFromBalance(uint256 _balance) internal view returns (uint256) {\n        uint256 _totalSharesValue = Shares.get();\n\n        if (_totalSharesValue == 0) {\n            return 0;\n        }\n\n        return (_balance * _totalSharesValue) / _assetBalance();\n    }\n\n    /// @notice Internal utility to mint shares for the specified user\n    /// @dev This method assumes that funds received are now part of the _assetBalance()\n    /// @param _owner Account that should receive the new shares\n    /// @param _underlyingAssetValue Value of underlying asset received, to convert into shares\n    function _mintShares(address _owner, uint256 _underlyingAssetValue) internal returns (uint256) {\n        uint256 oldTotalAssetBalance = _assetBalance() - _underlyingAssetValue;\n\n        if (oldTotalAssetBalance == 0) {\n            _mintRawShares(_owner, _underlyingAssetValue);\n            return _underlyingAssetValue;\n        } else {\n            uint256 sharesToMint = (_underlyingAssetValue * _totalSupply()) / oldTotalAssetBalance;\n            _mintRawShares(_owner, sharesToMint);\n            return sharesToMint;\n        }\n    }\n\n    /// @notice Internal utility to mint shares without any conversion, and emits a mint Transfer event\n    /// @param _owner Account that should receive the new shares\n    /// @param _value Amount of shares to mint\n    function _mintRawShares(address _owner, uint256 _value) internal {\n        Shares.set(Shares.get() + _value);\n        SharesPerOwner.set(_owner, SharesPerOwner.get(_owner) + _value);\n        emit Transfer(address(0), _owner, _value);\n    }\n\n    /// @notice Internal utility to retrieve the amount of shares per owner\n    /// @param _owner Account to be checked\n    function _balanceOf(address _owner) internal view returns (uint256 balance) {\n        return SharesPerOwner.get(_owner);\n    }\n}\n"
    },
    "contracts/src/components/OracleManager.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../libraries/Errors.sol\";\nimport \"../libraries/LibOwnable.sol\";\n\nimport \"../state/river/OracleAddress.sol\";\nimport \"../state/river/LastOracleRoundId.sol\";\nimport \"../state/river/BeaconValidatorBalanceSum.sol\";\nimport \"../state/river/BeaconValidatorCount.sol\";\nimport \"../state/river/DepositedValidatorCount.sol\";\n\nimport \"../interfaces/components/IOracleManager.1.sol\";\n\n/// @title Oracle Manager (v1)\n/// @author Kiln\n/// @notice This contract handles the inputs provided by the oracle\nabstract contract OracleManagerV1 is IOracleManagerV1 {\n    /// @notice Handler called if the delta between the last and new validator balance sum is positive\n    /// @dev Must be overriden\n    /// @param _profits The positive increase in the validator balance sum (staking rewards)\n    function _onEarnings(uint256 _profits) internal virtual;\n\n    function _pullELFees() internal virtual returns (uint256);\n\n    /// @notice Prevents unauthorized calls\n    modifier onlyAdmin() virtual {\n        if (msg.sender != LibOwnable._getAdmin()) {\n            revert Errors.Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    /// @notice Set the initial oracle address\n    /// @param _oracle Address of the oracle\n    function initOracleManagerV1(address _oracle) internal {\n        OracleAddress.set(_oracle);\n    }\n\n    /// @notice Sets the validator count and validator balance sum reported by the oracle\n    /// @dev Can only be called by the oracle address\n    /// @param _validatorCount The number of active validators on the consensus layer\n    /// @param _validatorBalanceSum The validator balance sum of the active validators on the consensus layer\n    /// @param _roundId An identifier for this update\n    function setBeaconData(uint256 _validatorCount, uint256 _validatorBalanceSum, bytes32 _roundId) external {\n        if (msg.sender != OracleAddress.get()) {\n            revert Errors.Unauthorized(msg.sender);\n        }\n\n        if (_validatorCount > DepositedValidatorCount.get()) {\n            revert InvalidValidatorCountReport(_validatorCount, DepositedValidatorCount.get());\n        }\n\n        uint256 newValidators = _validatorCount - BeaconValidatorCount.get();\n        uint256 previousValidatorBalanceSum = BeaconValidatorBalanceSum.get() + (newValidators * 32 ether);\n\n        BeaconValidatorBalanceSum.set(_validatorBalanceSum);\n        BeaconValidatorCount.set(_validatorCount);\n        LastOracleRoundId.set(_roundId);\n\n        uint256 executionLayerFees = _pullELFees();\n\n        if (previousValidatorBalanceSum < _validatorBalanceSum + executionLayerFees) {\n            _onEarnings((_validatorBalanceSum + executionLayerFees) - previousValidatorBalanceSum);\n        }\n\n        emit BeaconDataUpdate(_validatorCount, _validatorBalanceSum, _roundId);\n    }\n\n    /// @notice Get Oracle address\n    function getOracle() external view returns (address oracle) {\n        oracle = OracleAddress.get();\n    }\n\n    /// @notice Set Oracle address\n    /// @param _oracleAddress Address of the oracle\n    function setOracle(address _oracleAddress) external onlyAdmin {\n        OracleAddress.set(_oracleAddress);\n    }\n\n    /// @notice Get Beacon validator balance sum\n    function getBeaconValidatorBalanceSum() external view returns (uint256 beaconValidatorBalanceSum) {\n        beaconValidatorBalanceSum = BeaconValidatorBalanceSum.get();\n    }\n\n    /// @notice Get Beacon validator count (the amount of validator reported by the oracles)\n    function getBeaconValidatorCount() external view returns (uint256 beaconValidatorCount) {\n        beaconValidatorCount = BeaconValidatorCount.get();\n    }\n}\n"
    },
    "contracts/src/state/river/AllowlistAddress.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/UnstructuredStorage.sol\";\nimport \"../../libraries/Errors.sol\";\n\nlibrary AllowlistAddress {\n    bytes32 internal constant ALLOWLIST_ADDRESS_SLOT = bytes32(uint256(keccak256(\"river.state.allowlistAddress\")) - 1);\n\n    function get() internal view returns (address) {\n        return UnstructuredStorage.getStorageAddress(ALLOWLIST_ADDRESS_SLOT);\n    }\n\n    function set(address newValue) internal {\n        if (newValue == address(0)) {\n            revert Errors.InvalidZeroAddress();\n        }\n        UnstructuredStorage.setStorageAddress(ALLOWLIST_ADDRESS_SLOT, newValue);\n    }\n}\n"
    },
    "contracts/src/state/river/OperatorsRegistryAddress.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/UnstructuredStorage.sol\";\nimport \"../../libraries/Errors.sol\";\n\nlibrary OperatorsRegistryAddress {\n    bytes32 internal constant OPERATORS_REGISTRY_ADDRESS_SLOT =\n        bytes32(uint256(keccak256(\"river.state.operatorsRegistryAddress\")) - 1);\n\n    function get() internal view returns (address) {\n        return UnstructuredStorage.getStorageAddress(OPERATORS_REGISTRY_ADDRESS_SLOT);\n    }\n\n    function set(address newValue) internal {\n        if (newValue == address(0)) {\n            revert Errors.InvalidZeroAddress();\n        }\n        UnstructuredStorage.setStorageAddress(OPERATORS_REGISTRY_ADDRESS_SLOT, newValue);\n    }\n}\n"
    },
    "contracts/src/state/river/TreasuryAddress.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/UnstructuredStorage.sol\";\nimport \"../../libraries/Errors.sol\";\n\nlibrary TreasuryAddress {\n    bytes32 internal constant TREASURY_ADDRESS_SLOT = bytes32(uint256(keccak256(\"river.state.treasuryAddress\")) - 1);\n\n    function get() internal view returns (address) {\n        return UnstructuredStorage.getStorageAddress(TREASURY_ADDRESS_SLOT);\n    }\n\n    function set(address newValue) internal {\n        if (newValue == address(0)) {\n            revert Errors.InvalidZeroAddress();\n        }\n        UnstructuredStorage.setStorageAddress(TREASURY_ADDRESS_SLOT, newValue);\n    }\n}\n"
    },
    "contracts/src/state/river/OperatorRewardsShare.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/UnstructuredStorage.sol\";\n\nlibrary OperatorRewardsShare {\n    bytes32 internal constant OPERATOR_REWARDS_SHARE_SLOT =\n        bytes32(uint256(keccak256(\"river.state.operatorRewardsShare\")) - 1);\n\n    function get() internal view returns (uint256) {\n        return UnstructuredStorage.getStorageUint256(OPERATOR_REWARDS_SHARE_SLOT);\n    }\n\n    function set(uint256 newValue) internal {\n        UnstructuredStorage.setStorageUint256(OPERATOR_REWARDS_SHARE_SLOT, newValue);\n    }\n}\n"
    },
    "contracts/src/state/river/GlobalFee.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/UnstructuredStorage.sol\";\n\nlibrary GlobalFee {\n    bytes32 internal constant GLOBAL_FEE_SLOT = bytes32(uint256(keccak256(\"river.state.globalFee\")) - 1);\n\n    function get() internal view returns (uint256) {\n        return UnstructuredStorage.getStorageUint256(GLOBAL_FEE_SLOT);\n    }\n\n    function set(uint256 newValue) internal {\n        UnstructuredStorage.setStorageUint256(GLOBAL_FEE_SLOT, newValue);\n    }\n}\n"
    },
    "contracts/src/state/river/ELFeeRecipientAddress.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/UnstructuredStorage.sol\";\n\nlibrary ELFeeRecipientAddress {\n    bytes32 internal constant EL_FEE_RECIPIENT_ADDRESS =\n        bytes32(uint256(keccak256(\"river.state.elFeeRecipientAddress\")) - 1);\n\n    function get() internal view returns (address) {\n        return UnstructuredStorage.getStorageAddress(EL_FEE_RECIPIENT_ADDRESS);\n    }\n\n    function set(address newValue) internal {\n        UnstructuredStorage.setStorageAddress(EL_FEE_RECIPIENT_ADDRESS, newValue);\n    }\n}\n"
    },
    "contracts/src/state/operatorsRegistry/Operators.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/Errors.sol\";\n\nlibrary Operators {\n    bytes32 internal constant OPERATORS_SLOT = bytes32(uint256(keccak256(\"river.state.operators\")) - 1);\n\n    bytes32 internal constant OPERATORS_MAPPING_SLOT = bytes32(uint256(keccak256(\"river.state.operatorsMapping\")) - 1);\n\n    struct Operator {\n        bool active;\n        string name;\n        address operator;\n        address feeRecipient;\n        uint256 limit;\n        uint256 funded;\n        uint256 keys;\n        uint256 stopped;\n    }\n\n    struct CachedOperator {\n        bool active;\n        string name;\n        address operator;\n        address feeRecipient;\n        uint256 limit;\n        uint256 funded;\n        uint256 keys;\n        uint256 stopped;\n        uint256 index;\n    }\n\n    struct OperatorResolution {\n        bool active;\n        uint256 index;\n    }\n\n    struct SlotOperator {\n        Operator[] value;\n    }\n\n    struct SlotOperatorMapping {\n        mapping(string => OperatorResolution) value;\n    }\n\n    error OperatorNotFound(string name);\n    error OperatorNotFoundAtIndex(uint256 index);\n\n    function _getOperatorIndex(string memory name) internal view returns (uint256) {\n        bytes32 slot = OPERATORS_MAPPING_SLOT;\n\n        SlotOperatorMapping storage opm;\n\n        assembly {\n            opm.slot := slot\n        }\n\n        if (!opm.value[name].active) {\n            revert OperatorNotFound(name);\n        }\n\n        return opm.value[name].index;\n    }\n\n    function _getOperatorActive(string memory name) internal view returns (bool) {\n        bytes32 slot = OPERATORS_MAPPING_SLOT;\n\n        SlotOperatorMapping storage opm;\n\n        assembly {\n            opm.slot := slot\n        }\n        return opm.value[name].active;\n    }\n\n    function _setOperatorIndex(string memory name, bool active, uint256 index) internal {\n        bytes32 slot = OPERATORS_MAPPING_SLOT;\n\n        SlotOperatorMapping storage opm;\n\n        assembly {\n            opm.slot := slot\n        }\n        opm.value[name] = OperatorResolution({active: active, index: index});\n    }\n\n    function exists(string memory name) internal view returns (bool) {\n        return _getOperatorActive(name);\n    }\n\n    function indexOf(string memory name) internal view returns (int256) {\n        bytes32 slot = OPERATORS_MAPPING_SLOT;\n\n        SlotOperatorMapping storage opm;\n\n        assembly {\n            opm.slot := slot\n        }\n\n        if (!opm.value[name].active) {\n            return -1;\n        }\n\n        return int256(opm.value[name].index);\n    }\n\n    function get(string memory name) internal view returns (Operator storage) {\n        bytes32 slot = OPERATORS_SLOT;\n        uint256 index = _getOperatorIndex(name);\n\n        SlotOperator storage r;\n\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value[index];\n    }\n\n    function getByIndex(uint256 index) internal view returns (Operator storage) {\n        bytes32 slot = OPERATORS_SLOT;\n\n        SlotOperator storage r;\n\n        assembly {\n            r.slot := slot\n        }\n\n        if (r.value.length <= index) {\n            revert OperatorNotFoundAtIndex(index);\n        }\n\n        return r.value[index];\n    }\n\n    function getCount() internal view returns (uint256) {\n        bytes32 slot = OPERATORS_SLOT;\n\n        SlotOperator storage r;\n\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value.length;\n    }\n\n    function _hasFundableKeys(Operators.Operator memory operator) internal pure returns (bool) {\n        return (\n            operator.active && operator.keys > operator.funded - operator.stopped\n                && operator.limit > operator.funded - operator.stopped\n        );\n    }\n\n    function getAllActive() internal view returns (Operator[] memory) {\n        bytes32 slot = OPERATORS_SLOT;\n\n        SlotOperator storage r;\n\n        assembly {\n            r.slot := slot\n        }\n\n        uint256 activeCount = 0;\n\n        for (uint256 idx = 0; idx < r.value.length;) {\n            if (r.value[idx].active) {\n                unchecked {\n                    ++activeCount;\n                }\n            }\n            unchecked {\n                ++idx;\n            }\n        }\n\n        Operator[] memory activeOperators = new Operator[](activeCount);\n\n        uint256 activeIdx = 0;\n        for (uint256 idx = 0; idx < r.value.length;) {\n            if (r.value[idx].active) {\n                activeOperators[activeIdx] = r.value[idx];\n                unchecked {\n                    ++activeIdx;\n                }\n            }\n            unchecked {\n                ++idx;\n            }\n        }\n\n        return activeOperators;\n    }\n\n    function getAllFundable() internal view returns (CachedOperator[] memory) {\n        bytes32 slot = OPERATORS_SLOT;\n\n        SlotOperator storage r;\n\n        assembly {\n            r.slot := slot\n        }\n\n        uint256 activeCount = 0;\n\n        for (uint256 idx = 0; idx < r.value.length;) {\n            if (_hasFundableKeys(r.value[idx])) {\n                unchecked {\n                    ++activeCount;\n                }\n            }\n            unchecked {\n                ++idx;\n            }\n        }\n\n        CachedOperator[] memory activeOperators = new CachedOperator[](activeCount);\n\n        uint256 activeIdx = 0;\n        for (uint256 idx = 0; idx < r.value.length;) {\n            Operator memory op = r.value[idx];\n            if (_hasFundableKeys(op)) {\n                activeOperators[activeIdx] = CachedOperator({\n                    active: op.active,\n                    name: op.name,\n                    operator: op.operator,\n                    feeRecipient: op.feeRecipient,\n                    limit: op.limit,\n                    funded: op.funded,\n                    keys: op.keys,\n                    stopped: op.stopped,\n                    index: idx\n                });\n                unchecked {\n                    ++activeIdx;\n                }\n            }\n            unchecked {\n                ++idx;\n            }\n        }\n\n        return activeOperators;\n    }\n\n    function set(string memory name, Operator memory newValue) internal returns (uint256) {\n        if (newValue.operator == address(0) || newValue.feeRecipient == address(0)) {\n            revert Errors.InvalidZeroAddress();\n        }\n        bool opExists = _getOperatorActive(name);\n\n        bytes32 slot = OPERATORS_SLOT;\n\n        SlotOperator storage r;\n\n        assembly {\n            r.slot := slot\n        }\n\n        if (!opExists) {\n            r.value.push(newValue);\n            _setOperatorIndex(name, newValue.active, r.value.length - 1);\n            return (r.value.length - 1);\n        } else {\n            uint256 index = _getOperatorIndex(name);\n            r.value[index] = newValue;\n            if (opExists != newValue.active) {\n                _setOperatorIndex(name, newValue.active, index);\n            }\n            return (index);\n        }\n    }\n\n    function setOperatorName(uint256 index, string memory newName) internal {\n        bytes32 slot = OPERATORS_SLOT;\n\n        SlotOperator storage r;\n\n        assembly {\n            r.slot := slot\n        }\n\n        string memory oldName = r.value[index].name;\n        r.value[index].name = newName;\n\n        _setOperatorIndex(oldName, false, 0); // set storage to 0\n        _setOperatorIndex(newName, true, index);\n    }\n}\n"
    },
    "contracts/src/interfaces/components/IConsensusLayerDepositManager.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\ninterface IConsensusLayerDepositManagerV1 {\n    event FundedValidatorKey(bytes publicKey);\n\n    error NotEnoughFunds();\n    error InconsistentPublicKeys();\n    error InconsistentSignatures();\n    error NoAvailableValidatorKeys();\n    error InvalidPublicKeyCount();\n    error InvalidSignatureCount();\n    error InvalidWithdrawalCredentials();\n\n    function getWithdrawalCredentials() external view returns (bytes32);\n    function depositToConsensusLayer(uint256 _maxCount) external;\n    function getDepositedValidatorCount() external view returns (uint256 depositedValidatorCount);\n}\n"
    },
    "contracts/src/interfaces/components/IOracleManager.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\ninterface IOracleManagerV1 {\n    event BeaconDataUpdate(uint256 validatorCount, uint256 validatorBalanceSum, bytes32 roundId);\n\n    error InvalidValidatorCountReport(uint256 _providedValidatorCount, uint256 _depositedValidatorCount);\n\n    function setBeaconData(uint256 _validatorCount, uint256 _validatorBalanceSum, bytes32 _roundId) external;\n    function getOracle() external view returns (address oracle);\n    function setOracle(address _oracleAddress) external;\n    function getBeaconValidatorBalanceSum() external view returns (uint256 beaconValidatorBalanceSum);\n    function getBeaconValidatorCount() external view returns (uint256 beaconValidatorCount);\n}\n"
    },
    "contracts/src/interfaces/components/ISharesManager.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\n\ninterface ISharesManagerV1 is IERC20 {\n    error BalanceTooLow();\n    error AllowanceTooLow(address _from, address _operator, uint256 _allowance, uint256 _value);\n    error NullTransfer();\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint256);\n    function totalUnderlyingSupply() external view returns (uint256);\n    function balanceOf(address _owner) external view returns (uint256 balance);\n    function balanceOfUnderlying(address _owner) external view returns (uint256 balance);\n    function underlyingBalanceFromShares(uint256 shares) external view returns (uint256);\n    function sharesFromUnderlyingBalance(uint256 underlyingBalance) external view returns (uint256);\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\n    function transfer(address _to, uint256 _value) external returns (bool);\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\n    function approve(address _spender, uint256 _value) external returns (bool success);\n}\n"
    },
    "contracts/src/interfaces/components/IUserDepositManager.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\ninterface IUserDepositManagerV1 {\n    event UserDeposit(address indexed depositor, address indexed recipient, uint256 amount);\n\n    error EmptyDeposit();\n    error EmptyDonation();\n\n    function getPendingEth() external view returns (uint256);\n    function deposit() external payable;\n    function depositAndTransfer(address _recipient) external payable;\n    receive() external payable;\n    fallback() external payable;\n}\n"
    },
    "openzeppelin-contracts/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "contracts/src/interfaces/IDepositContract.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\ninterface IDepositContract {\n    function deposit(\n        bytes calldata pubkey,\n        bytes calldata withdrawalCredentials,\n        bytes calldata signature,\n        bytes32 depositDataRoot\n    )\n        external\n        payable;\n}\n"
    },
    "contracts/src/libraries/BytesLib.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nlibrary BytesLib {\n    function pad64(bytes memory _b) internal pure returns (bytes memory) {\n        assert(_b.length >= 32 && _b.length <= 64);\n        if (64 == _b.length) {\n            return _b;\n        }\n\n        bytes memory zero32 = new bytes(32);\n        assembly {\n            mstore(add(zero32, 0x20), 0)\n        }\n\n        if (32 == _b.length) {\n            return BytesLib.concat(_b, zero32);\n        } else {\n            return BytesLib.concat(_b, BytesLib.slice(zero32, 0, uint256(64) - _b.length));\n        }\n    }\n\n    function concat(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bytes memory) {\n        bytes memory tempBytes;\n\n        assembly {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n            // Store the length of the first bytes array at the beginning of\n            // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n            // Maintain a memory counter for the current write location in the\n            // temp bytes array by adding the 32 bytes for the array length to\n            // the starting location.\n            let mc := add(tempBytes, 0x20)\n            // Stop copying when the memory counter reaches the length of the\n            // first bytes array.\n            let end := add(mc, length)\n\n            for {\n                // Initialize a copy counter to the start of the _preBytes data,\n                // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                // Write the _preBytes data into the tempBytes memory 32 bytes\n                // at a time.\n                mstore(mc, mload(cc))\n            }\n\n            // Add the length of _postBytes to the current length of tempBytes\n            // and store it as the new length in the first 32 bytes of the\n            // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n            // Move the memory counter back from a multiple of 0x20 to the\n            // actual end of the _preBytes data.\n            mc := end\n            // Stop copying when the memory counter reaches the new combined\n            // length of the arrays.\n            end := add(mc, length)\n\n            for { let cc := add(_postBytes, 0x20) } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } { mstore(mc, mload(cc)) }\n\n            // Update the free-memory pointer by padding our last write location\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n            // next 32 byte block, then round down to the nearest multiple of\n            // 32. If the sum of the length of the two arrays is zero then add\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(\n                0x40,\n                and(\n                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n                    not(31) // Round down to the nearest 32 bytes.\n                )\n            )\n        }\n\n        return tempBytes;\n    }\n\n    function slice(bytes memory _bytes, uint256 _start, uint256 _length) internal pure returns (bytes memory) {\n        require(_length + 31 >= _length, \"slice_overflow\");\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } { mstore(mc, mload(cc)) }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n}\n"
    },
    "contracts/src/libraries/Uint256Lib.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nlibrary Uint256Lib {\n    function toLittleEndian64(uint256 _value) internal pure returns (uint256 result) {\n        result = 0;\n        uint256 temp_value = _value;\n        for (uint256 i = 0; i < 8;) {\n            result = (result << 8) | (temp_value & 0xFF);\n            temp_value >>= 8;\n            unchecked {\n                ++i;\n            }\n        }\n\n        assert(0 == temp_value); // fully converted\n        result <<= (24 * 8);\n    }\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256 max) {\n        return (a > b ? b : a);\n    }\n}\n"
    },
    "contracts/src/state/river/DepositContractAddress.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../interfaces/IDepositContract.sol\";\nimport \"../../libraries/Errors.sol\";\nimport \"../../libraries/UnstructuredStorage.sol\";\n\nlibrary DepositContractAddress {\n    bytes32 internal constant DEPOSIT_CONTRACT_ADDRESS_SLOT =\n        bytes32(uint256(keccak256(\"river.state.depositContractAddress\")) - 1);\n\n    function get() internal view returns (IDepositContract) {\n        return IDepositContract(UnstructuredStorage.getStorageAddress(DEPOSIT_CONTRACT_ADDRESS_SLOT));\n    }\n\n    function set(IDepositContract newValue) internal {\n        if (address(newValue) == address(0)) {\n            revert Errors.InvalidZeroAddress();\n        }\n        return UnstructuredStorage.setStorageAddress(DEPOSIT_CONTRACT_ADDRESS_SLOT, address(newValue));\n    }\n}\n"
    },
    "contracts/src/state/river/WithdrawalCredentials.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/UnstructuredStorage.sol\";\n\nlibrary WithdrawalCredentials {\n    bytes32 internal constant WITHDRAWAL_CREDENTIALS_SLOT =\n        bytes32(uint256(keccak256(\"river.state.withdrawalCredentials\")) - 1);\n\n    function get() internal view returns (bytes32) {\n        return UnstructuredStorage.getStorageBytes32(WITHDRAWAL_CREDENTIALS_SLOT);\n    }\n\n    function set(bytes32 newValue) internal {\n        UnstructuredStorage.setStorageBytes32(WITHDRAWAL_CREDENTIALS_SLOT, newValue);\n    }\n}\n"
    },
    "contracts/src/state/river/DepositedValidatorCount.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/UnstructuredStorage.sol\";\n\nlibrary DepositedValidatorCount {\n    bytes32 internal constant DEPOSITED_VALIDATOR_COUNT_SLOT =\n        bytes32(uint256(keccak256(\"river.state.depositedValidatorCount\")) - 1);\n\n    function get() internal view returns (uint256) {\n        return UnstructuredStorage.getStorageUint256(DEPOSITED_VALIDATOR_COUNT_SLOT);\n    }\n\n    function set(uint256 newValue) internal {\n        UnstructuredStorage.setStorageUint256(DEPOSITED_VALIDATOR_COUNT_SLOT, newValue);\n    }\n}\n"
    },
    "contracts/src/state/river/Shares.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/UnstructuredStorage.sol\";\n\nlibrary Shares {\n    bytes32 internal constant SHARES_SLOT = bytes32(uint256(keccak256(\"river.state.shares\")) - 1);\n\n    function get() internal view returns (uint256) {\n        return UnstructuredStorage.getStorageUint256(SHARES_SLOT);\n    }\n\n    function set(uint256 newValue) internal {\n        UnstructuredStorage.setStorageUint256(SHARES_SLOT, newValue);\n    }\n}\n"
    },
    "contracts/src/state/river/SharesPerOwner.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nlibrary SharesPerOwner {\n    bytes32 internal constant SHARES_SLOT = bytes32(uint256(keccak256(\"river.state.sharesPerOwner\")) - 1);\n\n    struct Slot {\n        mapping(address => uint256) value;\n    }\n\n    function get(address owner) internal view returns (uint256) {\n        bytes32 slot = SHARES_SLOT;\n\n        Slot storage r;\n\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value[owner];\n    }\n\n    function set(address owner, uint256 newValue) internal {\n        bytes32 slot = SHARES_SLOT;\n\n        Slot storage r;\n\n        assembly {\n            r.slot := slot\n        }\n\n        r.value[owner] = newValue;\n    }\n}\n"
    },
    "contracts/src/state/shared/ApprovalsPerOwner.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nlibrary ApprovalsPerOwner {\n    bytes32 internal constant APPROVALS_PER_OWNER_SLOT =\n        bytes32(uint256(keccak256(\"river.state.approvalsPerOwner\")) - 1);\n\n    struct Slot {\n        mapping(address => mapping(address => uint256)) value;\n    }\n\n    function get(address owner, address operator) internal view returns (uint256) {\n        bytes32 slot = APPROVALS_PER_OWNER_SLOT;\n\n        Slot storage r;\n\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value[owner][operator];\n    }\n\n    function set(address owner, address operator, uint256 newValue) internal {\n        bytes32 slot = APPROVALS_PER_OWNER_SLOT;\n\n        Slot storage r;\n\n        assembly {\n            r.slot := slot\n        }\n\n        r.value[owner][operator] = newValue;\n    }\n}\n"
    },
    "contracts/src/state/river/OracleAddress.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/UnstructuredStorage.sol\";\nimport \"../../libraries/Errors.sol\";\n\nlibrary OracleAddress {\n    bytes32 internal constant ORACLE_ADDRESS_SLOT = bytes32(uint256(keccak256(\"river.state.oracleAddress\")) - 1);\n\n    function get() internal view returns (address) {\n        return UnstructuredStorage.getStorageAddress(ORACLE_ADDRESS_SLOT);\n    }\n\n    function set(address newValue) internal {\n        if (newValue == address(0)) {\n            revert Errors.InvalidZeroAddress();\n        }\n        UnstructuredStorage.setStorageAddress(ORACLE_ADDRESS_SLOT, newValue);\n    }\n}\n"
    },
    "contracts/src/state/river/LastOracleRoundId.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/UnstructuredStorage.sol\";\n\nlibrary LastOracleRoundId {\n    bytes32 internal constant LAST_ORACLE_ROUND_ID_SLOT =\n        bytes32(uint256(keccak256(\"river.state.lastOracleRoundId\")) - 1);\n\n    function get() internal view returns (bytes32) {\n        return UnstructuredStorage.getStorageBytes32(LAST_ORACLE_ROUND_ID_SLOT);\n    }\n\n    function set(bytes32 newValue) internal {\n        UnstructuredStorage.setStorageBytes32(LAST_ORACLE_ROUND_ID_SLOT, newValue);\n    }\n}\n"
    },
    "contracts/src/state/river/BeaconValidatorBalanceSum.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/UnstructuredStorage.sol\";\n\nlibrary BeaconValidatorBalanceSum {\n    bytes32 internal constant VALIDATOR_BALANCE_SUM_SLOT =\n        bytes32(uint256(keccak256(\"river.state.beaconValidatorBalanceSum\")) - 1);\n\n    function get() internal view returns (uint256) {\n        return UnstructuredStorage.getStorageUint256(VALIDATOR_BALANCE_SUM_SLOT);\n    }\n\n    function set(uint256 newValue) internal {\n        UnstructuredStorage.setStorageUint256(VALIDATOR_BALANCE_SUM_SLOT, newValue);\n    }\n}\n"
    },
    "contracts/src/state/river/BeaconValidatorCount.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/UnstructuredStorage.sol\";\n\nlibrary BeaconValidatorCount {\n    bytes32 internal constant BEACON_VALIDATOR_COUNT_SLOT =\n        bytes32(uint256(keccak256(\"river.state.beaconValidatorCount\")) - 1);\n\n    function get() internal view returns (uint256) {\n        return UnstructuredStorage.getStorageUint256(BEACON_VALIDATOR_COUNT_SLOT);\n    }\n\n    function set(uint256 newValue) internal {\n        UnstructuredStorage.setStorageUint256(BEACON_VALIDATOR_COUNT_SLOT, newValue);\n    }\n}\n"
    },
    "contracts/src/Oracle.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"./Initializable.sol\";\nimport \"./libraries/Errors.sol\";\nimport \"./libraries/LibOwnable.sol\";\nimport \"./interfaces/IRiver.1.sol\";\n\nimport \"./state/shared/AdministratorAddress.sol\";\nimport \"./state/shared/RiverAddress.sol\";\nimport \"./state/oracle/OracleMembers.sol\";\nimport \"./state/oracle/Quorum.sol\";\nimport \"./state/oracle/BeaconSpec.sol\";\nimport \"./state/oracle/BeaconReportBounds.sol\";\nimport \"./state/oracle/ExpectedEpochId.sol\";\nimport \"./state/oracle/LastEpochId.sol\";\nimport \"./state/oracle/ReportsPositions.sol\";\nimport \"./state/oracle/ReportsVariants.sol\";\n\n/// @title Oracle (v1)\n/// @author Kiln\n/// @notice This contract handles the input from the allowed oracle members. Highly inspired by Lido's implementation.\ncontract OracleV1 is Initializable {\n    event QuorumChanged(uint256 _newQuorum);\n    event ExpectedEpochIdUpdated(uint256 _epochId);\n    event BeaconReported(\n        uint256 _epochId, uint128 _newBeaconBalance, uint32 _newBeaconValidatorCount, address _oracleMember\n    );\n    event PostTotalShares(uint256 _postTotalEth, uint256 _prevTotalEth, uint256 _timeElapsed, uint256 _totalShares);\n\n    error EpochTooOld(uint256 _providedEpochId, uint256 _minExpectedEpochId);\n    error NotFrameFirstEpochId(uint256 _providedEpochId, uint256 _expectedFrameFirstEpochId);\n    error AlreadyReported(uint256 _epochId, address _member);\n    error BeaconBalanceIncreaseOutOfBounds(\n        uint256 _prevTotalEth, uint256 _postTotalEth, uint256 _timeElapsed, uint256 _annualAprUpperBound\n    );\n    error BeaconBalanceDecreaseOutOfBounds(\n        uint256 _prevTotalEth, uint256 _postTotalEth, uint256 _timeElapsed, uint256 _relativeLowerBound\n    );\n\n    /// @notice Received ETH input has only 9 decimals\n    uint128 internal constant DENOMINATION_OFFSET = 1e9;\n\n    /// @notice Initializes the oracle\n    /// @param _riverContractAddress Address of the River contract, able to receive oracle input data after quorum is met\n    /// @param _administratorAddress Address able to call administrative methods\n    /// @param _epochsPerFrame Beacon spec parameter. Number of epochs in a frame.\n    /// @param _slotsPerEpoch Beacon spec parameter. Number of slots in one epoch.\n    /// @param _secondsPerSlot Beacon spec parameter. Number of seconds between slots.\n    /// @param _genesisTime Beacon spec parameter. Timestamp of the genesis slot.\n    /// @param _annualAprUpperBound Beacon bound parameter. Maximum apr allowed for balance increase. Delta between updates is extrapolated on a year time frame.\n    /// @param _relativeLowerBound Beacon bound parameter. Maximum relative balance decrease.\n    function initOracleV1(\n        address _riverContractAddress,\n        address _administratorAddress,\n        uint64 _epochsPerFrame,\n        uint64 _slotsPerEpoch,\n        uint64 _secondsPerSlot,\n        uint64 _genesisTime,\n        uint256 _annualAprUpperBound,\n        uint256 _relativeLowerBound\n    )\n        external\n        init(0)\n    {\n        LibOwnable._setAdmin(_administratorAddress);\n        RiverAddress.set(_riverContractAddress);\n        BeaconSpec.set(\n            BeaconSpec.BeaconSpecStruct({\n                epochsPerFrame: _epochsPerFrame,\n                slotsPerEpoch: _slotsPerEpoch,\n                secondsPerSlot: _secondsPerSlot,\n                genesisTime: _genesisTime\n            })\n        );\n        BeaconReportBounds.set(\n            BeaconReportBounds.BeaconReportBoundsStruct({\n                annualAprUpperBound: _annualAprUpperBound,\n                relativeLowerBound: _relativeLowerBound\n            })\n        );\n        Quorum.set(1);\n    }\n\n    /// @notice Retrieve system administrator address\n    function getAdministrator() external view returns (address) {\n        return LibOwnable._getAdmin();\n    }\n\n    /// @notice Retrieve River address\n    function getRiver() external view returns (address) {\n        return RiverAddress.get();\n    }\n\n    /// @notice Prevents unauthorized calls\n    modifier onlyAdmin() {\n        if (msg.sender != LibOwnable._getAdmin()) {\n            revert Errors.Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    /// @notice Retrieve the block timestamp\n    function getTime() external view returns (uint256) {\n        return _getTime();\n    }\n\n    /// @notice Retrieve expected epoch id\n    function getExpectedEpochId() external view returns (uint256) {\n        return ExpectedEpochId.get();\n    }\n\n    /// @notice Retrieve member report status\n    /// @param _oracleMember Address of member to check\n    function getMemberReportStatus(address _oracleMember) external view returns (bool) {\n        int256 memberIndex = OracleMembers.indexOf(_oracleMember);\n        return ReportsPositions.get(uint256(memberIndex));\n    }\n\n    /// @notice Retrieve member report status\n    function getGlobalReportStatus() external view returns (uint256) {\n        return ReportsPositions.getRaw();\n    }\n\n    /// @notice Retrieve report variants count\n    function getReportVariantsCount() external view returns (uint256) {\n        return ReportsVariants.get().length;\n    }\n\n    /// @notice Retrieve decoded report at provided index\n    /// @param _idx Index of report\n    function getReportVariant(uint256 _idx)\n        external\n        view\n        returns (uint64 _beaconBalance, uint32 _beaconValidators, uint16 _reportCount)\n    {\n        uint256 report = ReportsVariants.get()[_idx];\n        (_beaconBalance, _beaconValidators) = _decodeReport(report);\n        _reportCount = _getReportCount(report);\n    }\n\n    /// @notice Retrieve the last completed epoch id\n    function getLastCompletedEpochId() external view returns (uint256) {\n        return LastEpochId.get();\n    }\n\n    /// @notice Retrieve the current epoch id based on block timestamp\n    function getCurrentEpochId() external view returns (uint256) {\n        BeaconSpec.BeaconSpecStruct memory beaconSpec = BeaconSpec.get();\n        return _getCurrentEpochId(beaconSpec);\n    }\n\n    /// @notice Retrieve the current quorum\n    function getQuorum() external view returns (uint256) {\n        return Quorum.get();\n    }\n\n    /// @notice Retrieve the current beacon spec\n    function getBeaconSpec() external view returns (BeaconSpec.BeaconSpecStruct memory) {\n        return BeaconSpec.get();\n    }\n\n    /// @notice Retrieve the current frame details\n    function getCurrentFrame() external view returns (uint256 _startEpochId, uint256 _startTime, uint256 _endTime) {\n        BeaconSpec.BeaconSpecStruct memory beaconSpec = BeaconSpec.get();\n        _startEpochId = _getFrameFirstEpochId(_getCurrentEpochId(beaconSpec), beaconSpec);\n        _startTime = beaconSpec.genesisTime + _startEpochId * beaconSpec.secondsPerSlot * beaconSpec.slotsPerEpoch;\n        _endTime = _startTime + beaconSpec.secondsPerSlot * beaconSpec.slotsPerEpoch * beaconSpec.epochsPerFrame - 1;\n    }\n\n    /// @notice Retrieve the first epoch id of the frame of the provided epoch id\n    /// @param _epochId Epoch id used to get the frame\n    function getFrameFirstEpochId(uint256 _epochId) external view returns (uint256) {\n        BeaconSpec.BeaconSpecStruct memory beaconSpec = BeaconSpec.get();\n        return _getFrameFirstEpochId(_epochId, beaconSpec);\n    }\n\n    function getBeaconBounds() external view returns (BeaconReportBounds.BeaconReportBoundsStruct memory) {\n        return BeaconReportBounds.get();\n    }\n\n    function getOracleMembers() external view returns (address[] memory) {\n        return OracleMembers.get();\n    }\n\n    /// @notice Returns true if address is member\n    /// @dev Performs a naive search, do not call this on-chain, used as an off-chain helper\n    /// @param _memberAddress Address of the member\n    function isMember(address _memberAddress) external view returns (bool) {\n        address[] memory members = OracleMembers.get();\n        for (uint256 idx = 0; idx < members.length;) {\n            if (members[idx] == _memberAddress) {\n                return true;\n            }\n            unchecked {\n                ++idx;\n            }\n        }\n        return false;\n    }\n\n    /// @notice Adds new address as oracle member, giving the ability to push beacon reports.\n    /// @dev Only callable by the adminstrator\n    /// @param _newOracleMember Address of the new member\n    function addMember(address _newOracleMember) external onlyAdmin {\n        int256 memberIdx = OracleMembers.indexOf(_newOracleMember);\n        if (memberIdx >= 0) {\n            revert Errors.InvalidCall();\n        }\n        OracleMembers.push(_newOracleMember);\n    }\n\n    /// @notice Removes an address from the oracle members.\n    /// @dev Only callable by the adminstrator\n    /// @param _oracleMember Address to remove\n    function removeMember(address _oracleMember) external onlyAdmin {\n        int256 memberIdx = OracleMembers.indexOf(_oracleMember);\n        if (memberIdx < 0) {\n            revert Errors.InvalidCall();\n        }\n        OracleMembers.deleteItem(uint256(memberIdx));\n    }\n\n    /// @notice Edits the beacon spec parameters\n    /// @dev Only callable by the adminstrator\n    /// @param _epochsPerFrame Number of epochs in a frame.\n    /// @param _slotsPerEpoch Number of slots in one epoch.\n    /// @param _secondsPerSlot Number of seconds between slots.\n    /// @param _genesisTime Timestamp of the genesis slot.\n    function setBeaconSpec(uint64 _epochsPerFrame, uint64 _slotsPerEpoch, uint64 _secondsPerSlot, uint64 _genesisTime)\n        external\n        onlyAdmin\n    {\n        BeaconSpec.set(\n            BeaconSpec.BeaconSpecStruct({\n                epochsPerFrame: _epochsPerFrame,\n                slotsPerEpoch: _slotsPerEpoch,\n                secondsPerSlot: _secondsPerSlot,\n                genesisTime: _genesisTime\n            })\n        );\n    }\n\n    /// @notice Edits the beacon bounds parameters\n    /// @dev Only callable by the adminstrator\n    /// @param _annualAprUpperBound Maximum apr allowed for balance increase. Delta between updates is extrapolated on a year time frame.\n    /// @param _relativeLowerBound Maximum relative balance decrease.\n    function setBeaconBounds(uint256 _annualAprUpperBound, uint256 _relativeLowerBound) external onlyAdmin {\n        BeaconReportBounds.set(\n            BeaconReportBounds.BeaconReportBoundsStruct({\n                annualAprUpperBound: _annualAprUpperBound,\n                relativeLowerBound: _relativeLowerBound\n            })\n        );\n    }\n\n    /// @notice Edits the quorum required to forward beacon data to River\n    /// @dev Only callable by the adminstrator\n    /// @param _newQuorum New quorum parameter\n    function setQuorum(uint256 _newQuorum) external onlyAdmin {\n        if (_newQuorum == 0) {\n            revert Errors.InvalidArgument();\n        }\n        uint256 previousQuorum = Quorum.get();\n        if (_newQuorum == previousQuorum) {\n            revert Errors.InvalidCall();\n        }\n        Quorum.set(_newQuorum);\n        emit QuorumChanged(_newQuorum);\n        if (previousQuorum > _newQuorum) {\n            (bool isQuorum, uint256 report) = _getQuorumReport(_newQuorum);\n            if (isQuorum) {\n                (uint64 beaconBalance, uint32 beaconValidators) = _decodeReport(report);\n                _pushToRiver(\n                    ExpectedEpochId.get(),\n                    DENOMINATION_OFFSET * uint128(beaconBalance),\n                    beaconValidators,\n                    BeaconSpec.get()\n                );\n            }\n        }\n    }\n\n    /// @notice Report beacon chain data\n    /// @dev Only callable by an oracle member\n    /// @param _epochId Epoch where the balance and validator count has been computed\n    /// @param _beaconBalance Total balance of River validators\n    /// @param _beaconValidators Total River validator count\n    function reportBeacon(uint256 _epochId, uint64 _beaconBalance, uint32 _beaconValidators) external {\n        BeaconSpec.BeaconSpecStruct memory beaconSpec = BeaconSpec.get();\n        uint256 expectedEpochId = ExpectedEpochId.get();\n        if (_epochId < expectedEpochId) {\n            revert EpochTooOld(_epochId, expectedEpochId);\n        }\n\n        if (_epochId > expectedEpochId) {\n            uint256 frameFirstEpochId = _getFrameFirstEpochId(_getCurrentEpochId(beaconSpec), beaconSpec);\n            if (_epochId != frameFirstEpochId) {\n                revert NotFrameFirstEpochId(_epochId, frameFirstEpochId);\n            }\n            _clearReporting(_epochId);\n        }\n\n        uint128 beaconBalanceEth1 = DENOMINATION_OFFSET * uint128(_beaconBalance);\n        emit BeaconReported(_epochId, beaconBalanceEth1, _beaconValidators, msg.sender);\n\n        int256 memberIndex = OracleMembers.indexOf(msg.sender);\n        if (memberIndex == -1) {\n            revert Errors.Unauthorized(msg.sender);\n        }\n        if (ReportsPositions.get(uint256(memberIndex))) {\n            revert AlreadyReported(_epochId, msg.sender);\n        }\n        ReportsPositions.register(uint256(memberIndex));\n\n        uint256 report = _encodeReport(_beaconBalance, _beaconValidators);\n        int256 reportIndex = ReportsVariants.indexOfReport(report);\n        uint256 quorum = Quorum.get();\n\n        if (reportIndex >= 0) {\n            uint256 registeredReport = ReportsVariants.get()[uint256(reportIndex)];\n            if (_getReportCount(registeredReport) + 1 >= quorum) {\n                _pushToRiver(_epochId, beaconBalanceEth1, _beaconValidators, beaconSpec);\n            } else {\n                ReportsVariants.set(uint256(reportIndex), registeredReport + 1);\n            }\n        } else {\n            if (quorum == 1) {\n                _pushToRiver(_epochId, beaconBalanceEth1, _beaconValidators, beaconSpec);\n            } else {\n                ReportsVariants.push(report + 1);\n            }\n        }\n    }\n\n    /// @notice Retrieve the report that has the highest number of \"votes\"\n    /// @param _quorum The quorum used for the query\n    function _getQuorumReport(uint256 _quorum) internal view returns (bool isQuorum, uint256 report) {\n        // check most frequent cases first: all reports are the same or no reports yet\n        uint256[] memory variants = ReportsVariants.get();\n        if (variants.length == 1) {\n            return (_getReportCount(variants[0]) >= _quorum, variants[0]);\n        } else if (variants.length == 0) {\n            return (false, 0);\n        }\n\n        // if more than 2 kind of reports exist, choose the most frequent\n        uint256 maxind = 0;\n        uint256 repeat = 0;\n        uint16 maxval = 0;\n        uint16 cur = 0;\n        for (uint256 i = 0; i < variants.length;) {\n            cur = _getReportCount(variants[i]);\n            if (cur >= maxval) {\n                if (cur == maxval) {\n                    unchecked {\n                        ++repeat;\n                    }\n                } else {\n                    maxind = i;\n                    maxval = cur;\n                    repeat = 0;\n                }\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        return (maxval >= _quorum && repeat == 0, variants[maxind]);\n    }\n\n    /// @notice Retrieve the block timestamp\n    function _getTime() internal view returns (uint256) {\n        return block.timestamp; // solhint-disable-line not-rely-on-time\n    }\n\n    /// @notice Retrieve the current epoch id based on block timestamp\n    /// @param _beaconSpec Beacon spec parameters\n    function _getCurrentEpochId(BeaconSpec.BeaconSpecStruct memory _beaconSpec) internal view returns (uint256) {\n        return (_getTime() - _beaconSpec.genesisTime) / (_beaconSpec.slotsPerEpoch * _beaconSpec.secondsPerSlot);\n    }\n\n    /// @notice Retrieve the first epoch id of the frame of the provided epoch id\n    /// @param _epochId Epoch id used to get the frame\n    /// @param _beaconSpec Beacon spec parameters\n    function _getFrameFirstEpochId(uint256 _epochId, BeaconSpec.BeaconSpecStruct memory _beaconSpec)\n        internal\n        pure\n        returns (uint256)\n    {\n        return (_epochId / _beaconSpec.epochsPerFrame) * _beaconSpec.epochsPerFrame;\n    }\n\n    /// @notice Clear reporting data\n    /// @param _epochId Next expected epoch id (first epoch of the next frame)\n    function _clearReporting(uint256 _epochId) internal {\n        ReportsPositions.clear();\n        ReportsVariants.clear();\n        ExpectedEpochId.set(_epochId);\n        emit ExpectedEpochIdUpdated(_epochId);\n    }\n\n    /// @notice Encode report into one slot. Last 16 bits are free to use for vote counting.\n    /// @param _beaconBalance Total validator balance\n    /// @param _beaconValidators Total validator count\n    function _encodeReport(uint64 _beaconBalance, uint32 _beaconValidators) internal pure returns (uint256) {\n        return (uint256(_beaconBalance) << 48) | (uint256(_beaconValidators) << 16);\n    }\n\n    /// @notice Decode report from one slot to two variables, ignoring the last 16 bits\n    /// @param _value Encoded report\n    function _decodeReport(uint256 _value) internal pure returns (uint64 _beaconBalance, uint32 _beaconValidators) {\n        _beaconBalance = uint64(_value >> 48);\n        _beaconValidators = uint32(_value >> 16);\n    }\n\n    /// @notice Retrieve the vote count from the encoded report (last 16 bits)\n    /// @param _report Encoded report\n    function _getReportCount(uint256 _report) internal pure returns (uint16) {\n        return uint16(_report);\n    }\n\n    /// @notice Performs sanity checks to prevent an erroneous update to the River system\n    /// @param _postTotalEth Total validator balance after update\n    /// @param _prevTotalEth Total validator balance before update\n    /// @param _timeElapsed Time since last update\n    function _sanityChecks(uint256 _postTotalEth, uint256 _prevTotalEth, uint256 _timeElapsed) internal view {\n        if (_postTotalEth >= _prevTotalEth) {\n            // increase                 = _postTotalPooledEther - _preTotalPooledEther,\n            // relativeIncrease         = increase / _preTotalPooledEther,\n            // annualRelativeIncrease   = relativeIncrease / (timeElapsed / 365 days),\n            // annualRelativeIncreaseBp = annualRelativeIncrease * 10000, in basis points 0.01% (1e-4)\n            uint256 annualAprUpperBound = BeaconReportBounds.get().annualAprUpperBound;\n            // check that annualRelativeIncreaseBp <= allowedAnnualRelativeIncreaseBp\n            if (\n                uint256(10000 * 365 days) * (_postTotalEth - _prevTotalEth)\n                    > annualAprUpperBound * _prevTotalEth * _timeElapsed\n            ) {\n                revert BeaconBalanceIncreaseOutOfBounds(_prevTotalEth, _postTotalEth, _timeElapsed, annualAprUpperBound);\n            }\n        } else {\n            // decrease           = _preTotalPooledEther - _postTotalPooledEther\n            // relativeDecrease   = decrease / _preTotalPooledEther\n            // relativeDecreaseBp = relativeDecrease * 10000, in basis points 0.01% (1e-4)\n            uint256 relativeLowerBound = BeaconReportBounds.get().relativeLowerBound;\n            // check that relativeDecreaseBp <= allowedRelativeDecreaseBp\n            if (uint256(10000) * (_prevTotalEth - _postTotalEth) > relativeLowerBound * _prevTotalEth) {\n                revert BeaconBalanceDecreaseOutOfBounds(_prevTotalEth, _postTotalEth, _timeElapsed, relativeLowerBound);\n            }\n        }\n    }\n\n    /// @notice Push the new beacon data to the river system and performs sanity checks\n    /// @param _epochId Id of the epoch\n    /// @param _balanceSum Total validator balance\n    /// @param _validatorCount Total validator count\n    /// @param _beaconSpec Beacon spec parameters\n    function _pushToRiver(\n        uint256 _epochId,\n        uint128 _balanceSum,\n        uint32 _validatorCount,\n        BeaconSpec.BeaconSpecStruct memory _beaconSpec\n    )\n        internal\n    {\n        _clearReporting(_epochId + _beaconSpec.epochsPerFrame);\n\n        IRiverV1 riverAddress = IRiverV1(payable(RiverAddress.get()));\n        uint256 prevTotalEth = IRiverV1(payable(address(riverAddress))).totalUnderlyingSupply();\n        riverAddress.setBeaconData(_validatorCount, _balanceSum, bytes32(_epochId));\n        uint256 postTotalEth = IRiverV1(payable(address(riverAddress))).totalUnderlyingSupply();\n\n        uint256 timeElapsed = (_epochId - LastEpochId.get()) * _beaconSpec.slotsPerEpoch * _beaconSpec.secondsPerSlot;\n\n        _sanityChecks(postTotalEth, prevTotalEth, timeElapsed);\n        LastEpochId.set(_epochId);\n\n        emit PostTotalShares(\n            postTotalEth, prevTotalEth, timeElapsed, IRiverV1(payable(address(riverAddress))).totalSupply()\n            );\n    }\n}\n"
    },
    "contracts/src/state/shared/RiverAddress.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/UnstructuredStorage.sol\";\nimport \"../../libraries/Errors.sol\";\n\nlibrary RiverAddress {\n    bytes32 internal constant RIVER_ADDRESS_SLOT = bytes32(uint256(keccak256(\"river.state.riverAddress\")) - 1);\n\n    function get() internal view returns (address) {\n        return UnstructuredStorage.getStorageAddress(RIVER_ADDRESS_SLOT);\n    }\n\n    function set(address newValue) internal {\n        if (newValue == address(0)) {\n            revert Errors.InvalidZeroAddress();\n        }\n        UnstructuredStorage.setStorageAddress(RIVER_ADDRESS_SLOT, newValue);\n    }\n}\n"
    },
    "contracts/src/state/oracle/OracleMembers.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nlibrary OracleMembers {\n    bytes32 internal constant ORACLE_MEMBERS_SLOT = bytes32(uint256(keccak256(\"river.state.oracleMembers\")) - 1);\n\n    struct Slot {\n        address[] value;\n    }\n\n    function get() internal view returns (address[] memory) {\n        bytes32 slot = ORACLE_MEMBERS_SLOT;\n\n        Slot storage r;\n\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value;\n    }\n\n    function push(address newOracleMember) internal {\n        bytes32 slot = ORACLE_MEMBERS_SLOT;\n\n        Slot storage r;\n\n        assembly {\n            r.slot := slot\n        }\n\n        r.value.push(newOracleMember);\n    }\n\n    function indexOf(address memberAddress) internal view returns (int256) {\n        bytes32 slot = ORACLE_MEMBERS_SLOT;\n\n        Slot storage r;\n\n        assembly {\n            r.slot := slot\n        }\n\n        for (uint256 idx = 0; idx < r.value.length;) {\n            if (r.value[idx] == memberAddress) {\n                return int256(idx);\n            }\n            unchecked {\n                ++idx;\n            }\n        }\n\n        return int256(-1);\n    }\n\n    function deleteItem(uint256 idx) internal {\n        bytes32 slot = ORACLE_MEMBERS_SLOT;\n\n        Slot storage r;\n\n        assembly {\n            r.slot := slot\n        }\n\n        uint256 lastIdx = r.value.length - 1;\n        if (lastIdx != idx) {\n            r.value[idx] = r.value[lastIdx];\n        }\n\n        r.value.pop();\n    }\n}\n"
    },
    "contracts/src/state/oracle/Quorum.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/UnstructuredStorage.sol\";\n\nlibrary Quorum {\n    bytes32 internal constant QUORUM_SLOT = bytes32(uint256(keccak256(\"river.state.quorum\")) - 1);\n\n    function get() internal view returns (uint256) {\n        return UnstructuredStorage.getStorageUint256(QUORUM_SLOT);\n    }\n\n    function set(uint256 newValue) internal {\n        return UnstructuredStorage.setStorageUint256(QUORUM_SLOT, newValue);\n    }\n}\n"
    },
    "contracts/src/state/oracle/BeaconSpec.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nlibrary BeaconSpec {\n    // Lido Finance beacon spec data structure\n    struct BeaconSpecStruct {\n        uint64 epochsPerFrame;\n        uint64 slotsPerEpoch;\n        uint64 secondsPerSlot;\n        uint64 genesisTime;\n    }\n\n    bytes32 internal constant BEACON_SPEC_SLOT = bytes32(uint256(keccak256(\"river.state.beaconSpec\")) - 1);\n\n    struct Slot {\n        BeaconSpecStruct value;\n    }\n\n    function get() internal view returns (BeaconSpecStruct memory) {\n        bytes32 slot = BEACON_SPEC_SLOT;\n\n        Slot storage r;\n\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value;\n    }\n\n    function set(BeaconSpecStruct memory newBeaconSpec) internal {\n        bytes32 slot = BEACON_SPEC_SLOT;\n\n        Slot storage r;\n\n        assembly {\n            r.slot := slot\n        }\n\n        r.value = newBeaconSpec;\n    }\n}\n"
    },
    "contracts/src/state/oracle/BeaconReportBounds.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nlibrary BeaconReportBounds {\n    // Lido Finance beacon spec data structure\n    struct BeaconReportBoundsStruct {\n        uint256 annualAprUpperBound;\n        uint256 relativeLowerBound;\n    }\n\n    uint256 public constant DELTA_BASE = 10_000;\n\n    bytes32 internal constant BEACON_REPORT_BOUNDS_SLOT =\n        bytes32(uint256(keccak256(\"river.state.beaconReportBounds\")) - 1);\n\n    struct Slot {\n        BeaconReportBoundsStruct value;\n    }\n\n    function get() internal view returns (BeaconReportBoundsStruct memory) {\n        bytes32 slot = BEACON_REPORT_BOUNDS_SLOT;\n\n        Slot storage r;\n\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value;\n    }\n\n    function set(BeaconReportBoundsStruct memory newBeaconReportBounds) internal {\n        bytes32 slot = BEACON_REPORT_BOUNDS_SLOT;\n\n        Slot storage r;\n\n        assembly {\n            r.slot := slot\n        }\n\n        r.value = newBeaconReportBounds;\n    }\n}\n"
    },
    "contracts/src/state/oracle/ExpectedEpochId.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/UnstructuredStorage.sol\";\n\nlibrary ExpectedEpochId {\n    bytes32 internal constant EXPECTED_EPOCH_ID_SLOT = bytes32(uint256(keccak256(\"river.state.expectedEpochId\")) - 1);\n\n    function get() internal view returns (uint256) {\n        return UnstructuredStorage.getStorageUint256(EXPECTED_EPOCH_ID_SLOT);\n    }\n\n    function set(uint256 newValue) internal {\n        UnstructuredStorage.setStorageUint256(EXPECTED_EPOCH_ID_SLOT, newValue);\n    }\n}\n"
    },
    "contracts/src/state/oracle/LastEpochId.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/UnstructuredStorage.sol\";\n\nlibrary LastEpochId {\n    bytes32 internal constant LAST_EPOCH_ID_SLOT = bytes32(uint256(keccak256(\"river.state.lastEpochId\")) - 1);\n\n    function get() internal view returns (uint256) {\n        return UnstructuredStorage.getStorageUint256(LAST_EPOCH_ID_SLOT);\n    }\n\n    function set(uint256 newValue) internal {\n        UnstructuredStorage.setStorageUint256(LAST_EPOCH_ID_SLOT, newValue);\n    }\n}\n"
    },
    "contracts/src/state/oracle/ReportsPositions.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/UnstructuredStorage.sol\";\n\nlibrary ReportsPositions {\n    bytes32 internal constant REPORTS_POSITIONS_SLOT = bytes32(uint256(keccak256(\"river.state.reportsPositions\")) - 1);\n\n    function get(uint256 idx) internal view returns (bool) {\n        uint256 mask = 1 << idx;\n        return UnstructuredStorage.getStorageUint256(REPORTS_POSITIONS_SLOT) & mask == mask;\n    }\n\n    function getRaw() internal view returns (uint256) {\n        return UnstructuredStorage.getStorageUint256(REPORTS_POSITIONS_SLOT);\n    }\n\n    function register(uint256 idx) internal {\n        uint256 mask = 1 << idx;\n        return UnstructuredStorage.setStorageUint256(\n            REPORTS_POSITIONS_SLOT, UnstructuredStorage.getStorageUint256(REPORTS_POSITIONS_SLOT) | mask\n        );\n    }\n\n    function clear() internal {\n        return UnstructuredStorage.setStorageUint256(REPORTS_POSITIONS_SLOT, 0);\n    }\n}\n"
    },
    "contracts/src/state/oracle/ReportsVariants.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nlibrary ReportsVariants {\n    uint256 internal constant COUNT_OUTMASK = 0xFFFFFFFFFFFFFFFFFFFFFFFF0000;\n\n    bytes32 internal constant REPORTS_VARIANTS_SLOT = bytes32(uint256(keccak256(\"river.state.reportsVariants\")) - 1);\n\n    struct Slot {\n        uint256[] value;\n    }\n\n    function get() internal view returns (uint256[] memory) {\n        bytes32 slot = REPORTS_VARIANTS_SLOT;\n\n        Slot storage r;\n\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value;\n    }\n\n    function set(uint256 idx, uint256 val) internal {\n        bytes32 slot = REPORTS_VARIANTS_SLOT;\n\n        Slot storage r;\n\n        assembly {\n            r.slot := slot\n        }\n\n        r.value[idx] = val;\n    }\n\n    function push(uint256 variant) internal {\n        bytes32 slot = REPORTS_VARIANTS_SLOT;\n\n        Slot storage r;\n\n        assembly {\n            r.slot := slot\n        }\n\n        r.value.push(variant);\n    }\n\n    function indexOfReport(uint256 variant) internal view returns (int256) {\n        bytes32 slot = REPORTS_VARIANTS_SLOT;\n\n        Slot storage r;\n\n        assembly {\n            r.slot := slot\n        }\n\n        for (uint256 idx = 0; idx < r.value.length;) {\n            if (r.value[idx] & COUNT_OUTMASK == variant) {\n                return int256(idx);\n            }\n            unchecked {\n                ++idx;\n            }\n        }\n\n        return int256(-1);\n    }\n\n    function clear() internal {\n        bytes32 slot = REPORTS_VARIANTS_SLOT;\n\n        Slot storage r;\n\n        assembly {\n            r.slot := slot\n        }\n\n        delete r.value;\n    }\n}\n"
    },
    "contracts/src/WLSETH.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"./Initializable.sol\";\nimport \"./interfaces/IRiver.1.sol\";\n\nimport \"./state/shared/RiverAddress.sol\";\nimport \"./state/shared/ApprovalsPerOwner.sol\";\nimport \"./state/wlseth/BalanceOf.sol\";\n\nimport \"openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\n\n/// @title Wrapped lsETH v1\n/// @author Kiln\n/// @notice This contract wraps the lsETH token into a rebase token, more suitable for some DeFi use-cases\n///         like stable swaps.\ncontract WLSETHV1 is Initializable, ReentrancyGuard {\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    error BalanceTooLow();\n    error UnauthorizedOperation();\n    error AllowanceTooLow(address _from, address _operator, uint256 _allowance, uint256 _value);\n    error NullTransfer();\n    error TokenTransferError();\n\n    modifier isNotNull(uint256 _value) {\n        if (_value == 0) {\n            revert NullTransfer();\n        }\n        _;\n    }\n\n    modifier hasFunds(address _owner, uint256 _value) {\n        if (_balanceOf(_owner) < _value) {\n            revert BalanceTooLow();\n        }\n        _;\n    }\n\n    /// @notice Initializes the wrapped token contract\n    /// @param _river Address of the River contract\n    function initWLSETHV1(address _river) external init(0) {\n        RiverAddress.set(_river);\n    }\n\n    /// @notice Retrieves the token full name\n    function name() external pure returns (string memory) {\n        return \"Wrapped Alluvial Ether\";\n    }\n\n    /// @notice Retrieves the token ticker\n    function symbol() external pure returns (string memory) {\n        return \"wlsETH\";\n    }\n\n    /// @notice Retrieves the token decimal count\n    function decimals() external pure returns (uint8) {\n        return 18;\n    }\n\n    /// @notice Retrieves the token total supply\n    function totalSupply() external view returns (uint256) {\n        return IRiverV1(payable(RiverAddress.get())).balanceOfUnderlying(address(this));\n    }\n\n    /// @notice Retrieves the token balance of the specified user\n    /// @param _owner Owner to check the balance\n    function balanceOf(address _owner) external view returns (uint256 balance) {\n        return _balanceOf(_owner);\n    }\n\n    /// @notice Retrieves the token allowance given from one address to another\n    /// @param _owner Owner that gave the allowance\n    /// @param _spender Spender that received the allowance\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining) {\n        return ApprovalsPerOwner.get(_owner, _spender);\n    }\n\n    /// @notice Transfers tokens between the message sender and a recipient\n    /// @param _to Recipient of the transfer\n    /// @param _value Amount to transfer\n    function transfer(address _to, uint256 _value)\n        external\n        isNotNull(_value)\n        hasFunds(msg.sender, _value)\n        returns (bool)\n    {\n        return _transfer(msg.sender, _to, _value);\n    }\n\n    /// @notice Transfers tokens between two accounts\n    /// @dev If _from is not the message sender, then it is expected that _from has given at leave _value allowance to msg.sender\n    /// @param _from Sender account\n    /// @param _to Recipient of the transfer\n    /// @param _value Amount to transfer\n    function transferFrom(address _from, address _to, uint256 _value)\n        external\n        isNotNull(_value)\n        hasFunds(_from, _value)\n        returns (bool)\n    {\n        if (_from != msg.sender) {\n            uint256 currentAllowance = ApprovalsPerOwner.get(_from, msg.sender);\n            if (currentAllowance < _value) {\n                revert AllowanceTooLow(_from, msg.sender, currentAllowance, _value);\n            }\n            ApprovalsPerOwner.set(_from, msg.sender, currentAllowance - _value);\n        }\n        return _transfer(_from, _to, _value);\n    }\n\n    /// @notice Approves another account to transfer tokens\n    /// @param _spender Spender that receives the allowance\n    /// @param _value Amount to allow\n    function approve(address _spender, uint256 _value) external returns (bool success) {\n        ApprovalsPerOwner.set(msg.sender, _spender, _value);\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    /// @notice Mint tokens by providing River tokens\n    /// @dev Minted tokens are sent to recipient but are minted from the message sender balance\n    /// @dev It is expected that the message sender approves _value amount of River token to\n    /// @dev this contract before calling\n    /// @param _recipient Spender that receives the allowance\n    /// @param _value Amount of river token to give to the mint\n    function mint(address _recipient, uint256 _value) external nonReentrant {\n        BalanceOf.set(_recipient, BalanceOf.get(_recipient) + _value);\n        if (!IRiverV1(payable(RiverAddress.get())).transferFrom(msg.sender, address(this), _value)) {\n            revert TokenTransferError();\n        }\n    }\n\n    /// @notice Burn tokens and retrieve underlying River tokens\n    /// @dev Burned tokens are sent to recipient but are minted from the message sender balance\n    /// @dev No approval required from the message sender\n    /// @param _recipient Spender that receives the allowance\n    /// @param _value Amount of wrapped token to give to the burn\n    function burn(address _recipient, uint256 _value) external nonReentrant {\n        uint256 callerUnderlyingBalance =\n            IRiverV1(payable(RiverAddress.get())).underlyingBalanceFromShares(BalanceOf.get(msg.sender));\n        if (_value > callerUnderlyingBalance) {\n            revert BalanceTooLow();\n        }\n        uint256 sharesAmount = IRiverV1(payable(RiverAddress.get())).sharesFromUnderlyingBalance(_value);\n        BalanceOf.set(msg.sender, BalanceOf.get(msg.sender) - sharesAmount);\n        if (!IRiverV1(payable(RiverAddress.get())).transfer(_recipient, sharesAmount)) {\n            revert TokenTransferError();\n        }\n    }\n\n    function _balanceOf(address _owner) internal view returns (uint256 balance) {\n        return IRiverV1(payable(RiverAddress.get())).underlyingBalanceFromShares(BalanceOf.get(_owner));\n    }\n\n    function _transfer(address _from, address _to, uint256 _value) internal returns (bool) {\n        uint256 valueToShares = IRiverV1(payable(RiverAddress.get())).sharesFromUnderlyingBalance(_value);\n        BalanceOf.set(_from, BalanceOf.get(_from) - valueToShares);\n        BalanceOf.set(_to, BalanceOf.get(_to) + valueToShares);\n\n        emit Transfer(_from, _to, _value);\n\n        return true;\n    }\n}\n"
    },
    "contracts/src/state/wlseth/BalanceOf.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nlibrary BalanceOf {\n    bytes32 internal constant BALANCE_OF_SLOT = bytes32(uint256(keccak256(\"river.state.balanceOf\")) - 1);\n\n    struct Slot {\n        mapping(address => uint256) value;\n    }\n\n    function get(address owner) internal view returns (uint256) {\n        bytes32 slot = BALANCE_OF_SLOT;\n\n        Slot storage r;\n\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value[owner];\n    }\n\n    function set(address owner, uint256 newValue) internal {\n        bytes32 slot = BALANCE_OF_SLOT;\n\n        Slot storage r;\n\n        assembly {\n            r.slot := slot\n        }\n\n        r.value[owner] = newValue;\n    }\n}\n"
    },
    "openzeppelin-contracts/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/src/mock/DepositContractMock.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../interfaces/IDepositContract.sol\";\n\ncontract DepositContractMock is IDepositContract {\n    event DepositEvent(bytes pubkey, bytes withdrawal_credentials, bytes amount, bytes signature, bytes index);\n\n    uint256 public depositCount;\n    address public receiver;\n\n    constructor(address _receiver) {\n        receiver = _receiver;\n    }\n\n    function to_little_endian_64(uint64 value) internal pure returns (bytes memory ret) {\n        ret = new bytes(8);\n        bytes8 bytesValue = bytes8(value);\n        // Byteswapping during copying to bytes.\n        ret[0] = bytesValue[7];\n        ret[1] = bytesValue[6];\n        ret[2] = bytesValue[5];\n        ret[3] = bytesValue[4];\n        ret[4] = bytesValue[3];\n        ret[5] = bytesValue[2];\n        ret[6] = bytesValue[1];\n        ret[7] = bytesValue[0];\n    }\n\n    function deposit(bytes calldata pubkey, bytes calldata withdrawalCredentials, bytes calldata signature, bytes32)\n        external\n        payable\n    {\n        emit DepositEvent(\n            pubkey,\n            withdrawalCredentials,\n            to_little_endian_64(uint64(msg.value / 1 gwei)),\n            signature,\n            to_little_endian_64(uint64(depositCount))\n            );\n        depositCount += 1;\n        (bool sent,) = receiver.call{value: address(this).balance}(\"\");\n        require(sent, \"Fund transfer failed\");\n    }\n}\n"
    },
    "contracts/src/OperatorsRegistry.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"./Initializable.sol\";\n\nimport \"./libraries/Errors.sol\";\nimport \"./libraries/Uint256Lib.sol\";\nimport \"./libraries/LibOwnable.sol\";\n\nimport \"./state/operatorsRegistry/Operators.sol\";\nimport \"./state/operatorsRegistry/ValidatorKeys.sol\";\nimport \"./state/shared/RiverAddress.sol\";\n\nimport \"./interfaces/IOperatorRegistry.1.sol\";\n\n/// @title OperatorsRegistry (v1)\n/// @author Kiln\n/// @notice This contract handles the list of operators and their keys\ncontract OperatorsRegistryV1 is IOperatorsRegistryV1, Initializable {\n    /// @notice Initializes the operators registry\n    /// @param _admin Admin in charge of managing operators\n    /// @param _river Address of River system\n    function initOperatorsRegistryV1(address _admin, address _river) external init(0) {\n        LibOwnable._setAdmin(_admin);\n        RiverAddress.set(_river);\n    }\n\n    /// @notice Prevents unauthorized calls\n    modifier onlyAdmin() virtual {\n        if (msg.sender != LibOwnable._getAdmin()) {\n            revert Errors.Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    modifier onlyRiver() virtual {\n        if (msg.sender != RiverAddress.get()) {\n            revert Errors.Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    /// @notice Prevents anyone except the admin or the given operator fee recipient to make the call. Also checks if operator is active\n    /// @param _index The name identifying the operator\n    modifier operatorFeeRecipientOrAdmin(uint256 _index) {\n        if (msg.sender == LibOwnable._getAdmin()) {\n            _;\n            return;\n        }\n        Operators.Operator storage operator = Operators.getByIndex(_index);\n        if (!operator.active) {\n            revert InactiveOperator(_index);\n        }\n        if (msg.sender != operator.feeRecipient) {\n            revert Errors.Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    /// @notice Prevents anyone except the admin or the given operator to make the call. Also checks if operator is active\n    /// @param _index The name identifying the operator\n    modifier operatorOrAdmin(uint256 _index) {\n        if (msg.sender == LibOwnable._getAdmin()) {\n            _;\n            return;\n        }\n        Operators.Operator storage operator = Operators.getByIndex(_index);\n        if (!operator.active) {\n            revert InactiveOperator(_index);\n        }\n        if (msg.sender != operator.operator) {\n            revert Errors.Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    /// @notice Retrieve the River address\n    function getRiver() external view returns (address) {\n        return RiverAddress.get();\n    }\n\n    /// @notice Change the River address\n    /// @param _newRiver New address for the river system\n    function setRiver(address _newRiver) external onlyAdmin {\n        RiverAddress.set(_newRiver);\n    }\n\n    /// @notice Changes the admin but waits for new admin approval\n    /// @param _newAdmin New address for the admin\n    function transferOwnership(address _newAdmin) external onlyAdmin {\n        LibOwnable._setPendingAdmin(_newAdmin);\n    }\n\n    /// @notice Accepts the ownership of the system\n    function acceptOwnership() external {\n        if (msg.sender != LibOwnable._getPendingAdmin()) {\n            revert Errors.Unauthorized(msg.sender);\n        }\n        LibOwnable._setAdmin(msg.sender);\n        LibOwnable._setPendingAdmin(address(0));\n    }\n\n    /// @notice Retrieve system administrator address\n    function getAdministrator() external view returns (address) {\n        return LibOwnable._getAdmin();\n    }\n\n    /// @notice Retrieve system pending administrator address\n    function getPendingAdministrator() external view returns (address) {\n        return LibOwnable._getPendingAdmin();\n    }\n\n    /// @notice Prevents the call from working if the operator is not active\n    /// @param _index The name identifying the operator\n    modifier active(uint256 _index) {\n        if (!Operators.getByIndex(_index).active) {\n            revert InactiveOperator(_index);\n        }\n        _;\n    }\n\n    /// @notice Retrieve the operator details from the operator name\n    /// @param _name Name of the operator\n    function getOperatorDetails(string calldata _name)\n        external\n        view\n        returns (int256 _index, address _operatorAddress)\n    {\n        _index = Operators.indexOf(_name);\n        _operatorAddress = Operators.get(_name).operator;\n    }\n\n    /// @notice Retrieve the active operator set\n    function listActiveOperators() external view returns (Operators.Operator[] memory) {\n        return Operators.getAllActive();\n    }\n\n    /// @notice Adds an operator to the registry\n    /// @dev Only callable by the administrator\n    /// @param _name The name identifying the operator\n    /// @param _operator The address representing the operator, receiving the rewards\n    /// @param _feeRecipient The address where the rewards are sent\n    function addOperator(string calldata _name, address _operator, address _feeRecipient) external onlyAdmin {\n        if (Operators.exists(_name)) {\n            revert OperatorAlreadyExists(_name);\n        }\n\n        Operators.Operator memory newOperator = Operators.Operator({\n            active: true,\n            operator: _operator,\n            feeRecipient: _feeRecipient,\n            name: _name,\n            limit: 0,\n            funded: 0,\n            keys: 0,\n            stopped: 0\n        });\n\n        uint256 operatorIndex = Operators.set(_name, newOperator);\n\n        emit AddedOperator(operatorIndex, newOperator.name, newOperator.operator, newOperator.feeRecipient);\n    }\n\n    /// @notice Changes the operator address of an operator\n    /// @dev Only callable by the administrator or the previous operator address\n    /// @param _index The operator index\n    /// @param _newOperatorAddress The new address of the operator\n    function setOperatorAddress(uint256 _index, address _newOperatorAddress) external operatorOrAdmin(_index) {\n        Operators.Operator storage operator = Operators.getByIndex(_index);\n\n        operator.operator = _newOperatorAddress;\n\n        emit SetOperatorAddress(_index, _newOperatorAddress);\n    }\n\n    /// @notice Changes the operator fee recipient address\n    /// @dev Only callable by the administrator or the previous operator fee recipient address\n    /// @param _index The operator index\n    /// @param _newOperatorFeeRecipientAddress The new fee recipient address of the operator\n    function setOperatorFeeRecipientAddress(uint256 _index, address _newOperatorFeeRecipientAddress)\n        external\n        operatorFeeRecipientOrAdmin(_index)\n    {\n        Operators.Operator storage operator = Operators.getByIndex(_index);\n\n        operator.feeRecipient = _newOperatorFeeRecipientAddress;\n\n        emit SetOperatorFeeRecipientAddress(_index, _newOperatorFeeRecipientAddress);\n    }\n\n    /// @notice Changes the operator name\n    /// @dev Only callable by the administrator or the operator\n    /// @dev No name conflict can exist\n    /// @param _index The operator index\n    /// @param _newName The new operator name\n    function setOperatorName(uint256 _index, string calldata _newName) external operatorOrAdmin(_index) {\n        if (Operators.exists(_newName) == true) {\n            revert OperatorAlreadyExists(_newName);\n        }\n\n        Operators.setOperatorName(_index, _newName);\n\n        emit SetOperatorName(_index, _newName);\n    }\n\n    /// @notice Changes the operator status\n    /// @dev Only callable by the administrator\n    /// @param _index The operator index\n    /// @param _newStatus The new status of the operator\n    function setOperatorStatus(uint256 _index, bool _newStatus) external onlyAdmin {\n        Operators.Operator storage operator = Operators.getByIndex(_index);\n\n        operator.active = _newStatus;\n\n        emit SetOperatorStatus(_index, _newStatus);\n    }\n\n    /// @notice Changes the operator stopped validator cound\n    /// @dev Only callable by the administrator\n    /// @param _index The operator index\n    /// @param _newStoppedValidatorCount The new stopped validator count of the operator\n    function setOperatorStoppedValidatorCount(uint256 _index, uint256 _newStoppedValidatorCount) external onlyAdmin {\n        Operators.Operator storage operator = Operators.getByIndex(_index);\n\n        if (_newStoppedValidatorCount > operator.funded) {\n            revert Errors.InvalidArgument();\n        }\n\n        operator.stopped = _newStoppedValidatorCount;\n\n        emit SetOperatorStoppedValidatorCount(_index, operator.stopped);\n    }\n\n    /// @notice Changes the operator staking limit\n    /// @dev Only callable by the administrator\n    /// @dev The limit cannot exceed the total key count of the operator\n    /// @dev The _indexes and _newLimits must have the same length.\n    /// @dev Each limit value is applied to the operator index at the same index in the _indexes array.\n    /// @param _operatorIndexes The operator indexes\n    /// @param _newLimits The new staking limit of the operators\n    function setOperatorLimits(uint256[] calldata _operatorIndexes, uint256[] calldata _newLimits) external onlyAdmin {\n        if (_operatorIndexes.length != _newLimits.length) {\n            revert InvalidArrayLengths();\n        }\n        if (_operatorIndexes.length == 0) {\n            revert InvalidEmptyArray();\n        }\n        for (uint256 idx = 0; idx < _operatorIndexes.length;) {\n            Operators.Operator storage operator = Operators.getByIndex(_operatorIndexes[idx]);\n            if (_newLimits[idx] > operator.keys) {\n                revert OperatorLimitTooHigh(_newLimits[idx], operator.keys);\n            }\n\n            operator.limit = _newLimits[idx];\n\n            emit SetOperatorLimit(_operatorIndexes[idx], operator.limit);\n\n            unchecked {\n                ++idx;\n            }\n        }\n    }\n\n    /// @notice Adds new keys for an operator\n    /// @dev Only callable by the administrator or the operator address\n    /// @param _index The operator index\n    /// @param _keyCount The amount of keys provided\n    /// @param _publicKeys Public keys of the validator, concatenated\n    /// @param _signatures Signatures of the validator keys, concatenated\n    function addValidators(uint256 _index, uint256 _keyCount, bytes calldata _publicKeys, bytes calldata _signatures)\n        external\n        operatorOrAdmin(_index)\n    {\n        if (_keyCount == 0) {\n            revert InvalidKeyCount();\n        }\n\n        if (_publicKeys.length != _keyCount * ValidatorKeys.PUBLIC_KEY_LENGTH) {\n            revert InvalidPublicKeysLength();\n        }\n\n        if (_signatures.length != _keyCount * ValidatorKeys.SIGNATURE_LENGTH) {\n            revert InvalidSignatureLength();\n        }\n\n        Operators.Operator storage operator = Operators.getByIndex(_index);\n\n        for (uint256 idx = 0; idx < _keyCount;) {\n            bytes memory publicKey =\n                BytesLib.slice(_publicKeys, idx * ValidatorKeys.PUBLIC_KEY_LENGTH, ValidatorKeys.PUBLIC_KEY_LENGTH);\n            bytes memory signature =\n                BytesLib.slice(_signatures, idx * ValidatorKeys.SIGNATURE_LENGTH, ValidatorKeys.SIGNATURE_LENGTH);\n            ValidatorKeys.set(_index, operator.keys + idx, publicKey, signature);\n            unchecked {\n                ++idx;\n            }\n        }\n\n        operator.keys += _keyCount;\n\n        emit AddedValidatorKeys(_index, _publicKeys);\n    }\n\n    /// @notice Remove validator keys\n    /// @dev Only callable by the administrator or the operator address\n    /// @dev The indexes must be provided sorted in decreasing order, otherwise the method will revert\n    /// @dev The operator limit will be set to the lowest deleted key index\n    /// @param _index The operator index\n    /// @param _indexes The indexes of the keys to remove\n    function removeValidators(uint256 _index, uint256[] calldata _indexes) external operatorOrAdmin(_index) {\n        Operators.Operator storage operator = Operators.getByIndex(_index);\n\n        if (_indexes.length == 0) {\n            revert InvalidKeyCount();\n        }\n\n        for (uint256 idx = 0; idx < _indexes.length;) {\n            uint256 keyIndex = _indexes[idx];\n\n            if (keyIndex < operator.funded) {\n                revert InvalidFundedKeyDeletionAttempt();\n            }\n\n            if (keyIndex >= operator.keys) {\n                revert InvalidIndexOutOfBounds();\n            }\n\n            if (idx > 0 && _indexes[idx] >= _indexes[idx - 1]) {\n                revert InvalidUnsortedIndexes();\n            }\n\n            uint256 lastKeyIndex = operator.keys - 1;\n            (bytes memory removedPublicKey,) = ValidatorKeys.get(_index, keyIndex);\n            (bytes memory lastPublicKey, bytes memory lastSignature) = ValidatorKeys.get(_index, lastKeyIndex);\n            ValidatorKeys.set(_index, keyIndex, lastPublicKey, lastSignature);\n            ValidatorKeys.set(_index, lastKeyIndex, new bytes(0), new bytes(0));\n            operator.keys -= 1;\n            emit RemovedValidatorKey(_index, removedPublicKey);\n            unchecked {\n                ++idx;\n            }\n        }\n\n        if (_indexes[_indexes.length - 1] < operator.limit) {\n            operator.limit = _indexes[_indexes.length - 1];\n        }\n    }\n\n    /// @notice Get operator details\n    /// @param _index The index of the operator\n    function getOperator(uint256 _index) external view returns (Operators.Operator memory) {\n        return Operators.getByIndex(_index);\n    }\n\n    /// @notice Get operator count\n    function getOperatorCount() external view returns (uint256) {\n        return Operators.getCount();\n    }\n\n    /// @notice Get the details of a validator\n    /// @param _operatorIndex The index of the operator\n    /// @param _validatorIndex The index of the validator\n    function getValidator(uint256 _operatorIndex, uint256 _validatorIndex)\n        external\n        view\n        returns (bytes memory publicKey, bytes memory signature, bool funded)\n    {\n        (publicKey, signature) = ValidatorKeys.get(_operatorIndex, _validatorIndex);\n        funded = _validatorIndex < Operators.getByIndex(_operatorIndex).funded;\n    }\n\n    /// @notice Retrieve validator keys based on operator statuses\n    /// @param _requestedAmount Max amount of keys requested\n    function pickNextValidators(uint256 _requestedAmount)\n        external\n        onlyRiver\n        returns (bytes[] memory publicKeys, bytes[] memory signatures)\n    {\n        return _getNextValidatorsFromActiveOperators(_requestedAmount);\n    }\n\n    /// @notice Internal utility to concatenate bytes arrays together\n    function _concatenateByteArrays(bytes[] memory arr1, bytes[] memory arr2)\n        internal\n        pure\n        returns (bytes[] memory res)\n    {\n        res = new bytes[](arr1.length + arr2.length);\n        for (uint256 idx = 0; idx < arr1.length;) {\n            res[idx] = arr1[idx];\n            unchecked {\n                ++idx;\n            }\n        }\n        for (uint256 idx = 0; idx < arr2.length;) {\n            res[idx + arr1.length] = arr2[idx];\n            unchecked {\n                ++idx;\n            }\n        }\n    }\n\n    /// @notice Handler called whenever a deposit to the consensus layer is made. Should retrieve _requestedAmount or lower keys\n    /// @param _requestedAmount Amount of keys required. Contract is expected to send _requestedAmount or lower.\n    function _getNextValidatorsFromActiveOperators(uint256 _requestedAmount)\n        internal\n        returns (bytes[] memory publicKeys, bytes[] memory signatures)\n    {\n        Operators.CachedOperator[] memory operators = Operators.getAllFundable();\n\n        if (operators.length == 0) {\n            return (new bytes[](0), new bytes[](0));\n        }\n\n        uint256 selectedOperatorIndex = 0;\n        for (uint256 idx = 1; idx < operators.length;) {\n            if (\n                operators[idx].funded - operators[idx].stopped\n                    < operators[selectedOperatorIndex].funded - operators[selectedOperatorIndex].stopped\n            ) {\n                selectedOperatorIndex = idx;\n            }\n            unchecked {\n                ++idx;\n            }\n        }\n\n        uint256 selectedOperatorAvailableKeys = Uint256Lib.min(\n            operators[selectedOperatorIndex].keys, operators[selectedOperatorIndex].limit\n        ) - operators[selectedOperatorIndex].funded;\n\n        if (selectedOperatorAvailableKeys == 0) {\n            return (new bytes[](0), new bytes[](0));\n        }\n\n        Operators.Operator storage operator = Operators.get(operators[selectedOperatorIndex].name);\n        if (selectedOperatorAvailableKeys >= _requestedAmount) {\n            (publicKeys, signatures) = ValidatorKeys.getKeys(\n                operators[selectedOperatorIndex].index, operators[selectedOperatorIndex].funded, _requestedAmount\n            );\n            operator.funded += _requestedAmount;\n        } else {\n            (publicKeys, signatures) = ValidatorKeys.getKeys(\n                operators[selectedOperatorIndex].index,\n                operators[selectedOperatorIndex].funded,\n                selectedOperatorAvailableKeys\n            );\n            operator.funded += selectedOperatorAvailableKeys;\n            (bytes[] memory additionalPublicKeys, bytes[] memory additionalSignatures) =\n                _getNextValidatorsFromActiveOperators(_requestedAmount - selectedOperatorAvailableKeys);\n            publicKeys = _concatenateByteArrays(publicKeys, additionalPublicKeys);\n            signatures = _concatenateByteArrays(signatures, additionalSignatures);\n        }\n    }\n}\n"
    },
    "contracts/src/state/operatorsRegistry/ValidatorKeys.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/BytesLib.sol\";\n\nlibrary ValidatorKeys {\n    uint256 internal constant PUBLIC_KEY_LENGTH = 48;\n    uint256 internal constant SIGNATURE_LENGTH = 96;\n\n    error InvalidPublicKey();\n    error InvalidSignature();\n\n    bytes32 internal constant VALIDATOR_KEYS_SLOT = bytes32(uint256(keccak256(\"river.state.validatorKeys\")) - 1);\n\n    struct Slot {\n        mapping(uint256 => mapping(uint256 => bytes)) value;\n    }\n\n    function get(uint256 operatorIndex, uint256 idx)\n        internal\n        view\n        returns (bytes memory publicKey, bytes memory signature)\n    {\n        bytes32 slot = VALIDATOR_KEYS_SLOT;\n\n        Slot storage r;\n\n        assembly {\n            r.slot := slot\n        }\n\n        bytes storage entry = r.value[operatorIndex][idx];\n\n        publicKey = BytesLib.slice(entry, 0, PUBLIC_KEY_LENGTH);\n        signature = BytesLib.slice(entry, PUBLIC_KEY_LENGTH, SIGNATURE_LENGTH);\n    }\n\n    function getKeys(uint256 operatorIndex, uint256 startIdx, uint256 amount)\n        internal\n        view\n        returns (bytes[] memory publicKey, bytes[] memory signatures)\n    {\n        publicKey = new bytes[](amount);\n        signatures = new bytes[](amount);\n\n        bytes32 slot = VALIDATOR_KEYS_SLOT;\n\n        Slot storage r;\n\n        assembly {\n            r.slot := slot\n        }\n\n        for (uint256 idx = startIdx; idx < startIdx + amount;) {\n            bytes memory rawCredentials = r.value[operatorIndex][idx];\n            publicKey[idx - startIdx] = BytesLib.slice(rawCredentials, 0, PUBLIC_KEY_LENGTH);\n            signatures[idx - startIdx] = BytesLib.slice(rawCredentials, PUBLIC_KEY_LENGTH, SIGNATURE_LENGTH);\n            unchecked {\n                ++idx;\n            }\n        }\n    }\n\n    function set(uint256 operatorIndex, uint256 idx, bytes memory publicKey, bytes memory signature) internal {\n        bytes memory concatenatedKeys = BytesLib.concat(publicKey, signature);\n\n        bytes32 slot = VALIDATOR_KEYS_SLOT;\n\n        Slot storage r;\n\n        assembly {\n            r.slot := slot\n        }\n\n        r.value[operatorIndex][idx] = concatenatedKeys;\n    }\n}\n"
    },
    "contracts/src/ELFeeRecipient.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"./Initializable.sol\";\nimport \"./libraries/Errors.sol\";\nimport \"./libraries/LibOwnable.sol\";\nimport \"./interfaces/IRiver.1.sol\";\nimport \"./interfaces/IELFeeRecipient.1.sol\";\n\nimport \"./state/shared/RiverAddress.sol\";\n\n/// @title Execution Layer Fee Recipient\n/// @author Kiln\n/// @notice This contract receives all the execution layer fees from the proposed blocks + bribes\ncontract ELFeeRecipientV1 is Initializable, IELFeeRecipientV1 {\n    /// @notice Initialize the fee recipient with the required arguments\n    /// @param _riverAddress Address of River\n    function initELFeeRecipientV1(address _riverAddress) external init(0) {\n        RiverAddress.set(_riverAddress);\n    }\n\n    /// @notice Pulls all the ETH to the River contract\n    /// @dev Only callable by the River contract\n    function pullELFees() external {\n        address river = RiverAddress.get();\n        if (msg.sender != river) {\n            revert Errors.Unauthorized(msg.sender);\n        }\n\n        IRiverV1(payable(river)).sendELFees{value: address(this).balance}();\n    }\n\n    /// @notice Ether receiver\n    receive() external payable {\n        this;\n    }\n\n    /// @notice Invalid fallback detector\n    fallback() external payable {\n        revert InvalidCall();\n    }\n}\n"
    },
    "contracts/src/Firewall.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"./libraries/Errors.sol\";\nimport \"./interfaces/IFirewall.sol\";\n\n/// @title Firewall\n/// @author Figment\n/// @notice This contract accepts calls to admin-level functions of an underlying contract, and\n///         ensures the caller holds an appropriate role for calling that function. There are two roles:\n///          - A Governor can call anything\n///          - An Executor can call specific functions specified at construction\n///         Random callers cannot call anything through this contract, even if the underlying function\n///         is unpermissioned in the underlying contract.\n///         Calls to non-admin functions should be called at the underlying contract directly.\ncontract Firewall is IFirewall {\n    mapping(bytes4 => bool) internal executorCanCall;\n\n    address public governor;\n    address public executor;\n    address internal destination;\n\n    // governor_ should be the most trustworthy entity in the underlying protocol - often, a DAO governor\n    // executor_ should be a trustworthy entity that takes care of time-sensitive actions in the underlying protocol\n    constructor(\n        address governor_,\n        address executor_,\n        address destination_,\n        bytes4[] memory executorCallableSelectors_\n    ) {\n        governor = governor_;\n        executor = executor_;\n        destination = destination_;\n        for (uint256 i; i < executorCallableSelectors_.length;) {\n            executorCanCall[executorCallableSelectors_[i]] = true;\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    modifier ifGovernor() {\n        if (msg.sender == governor) {\n            _;\n        } else {\n            revert Errors.Unauthorized(msg.sender);\n        }\n    }\n\n    modifier ifGovernorOrExecutor() {\n        if (msg.sender == governor || msg.sender == executor) {\n            _;\n        } else {\n            revert Errors.Unauthorized(msg.sender);\n        }\n    }\n\n    /// @dev Change the governor\n    function setGovernor(address newGovernor) external ifGovernor {\n        governor = newGovernor;\n    }\n\n    /// @dev Change the executor\n    function setExecutor(address newExecutor) external ifGovernorOrExecutor {\n        executor = newExecutor;\n    }\n\n    /// @dev make a function either only callable by the governor, or callable by gov and executor.\n    function allowExecutor(bytes4 functionSelector, bool executorCanCall_) external ifGovernor {\n        executorCanCall[functionSelector] = executorCanCall_;\n    }\n\n    /// @dev Validate that the caller is allowed to make the call in msg.sig\n    function _checkCallerRole() internal view {\n        if (msg.sender == governor || (executorCanCall[msg.sig] && msg.sender == executor)) {\n            return;\n        }\n        revert Errors.Unauthorized(msg.sender);\n    }\n\n    /// @dev Forwards the current call to `destination`.\n    ///      This function does not return to its internal call site, it will return directly to the external caller.\n    function _forward(address destination_, uint256 value) internal {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the destination.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := call(gas(), destination_, value, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // call returns 0 on error.\n            case 0 { revert(0, returndatasize()) }\n            default { return(0, returndatasize()) }\n        }\n    }\n\n    function _fallback() internal virtual {\n        _checkCallerRole();\n        _forward(destination, msg.value);\n    }\n\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    receive() external payable virtual {\n        _fallback();\n    }\n}\n"
    },
    "contracts/src/interfaces/IFirewall.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\ninterface IFirewall {\n    function setGovernor(address newGovernor) external;\n    function setExecutor(address newExecutor) external;\n    function allowExecutor(bytes4 functionSelector, bool executorCanCall_) external;\n    fallback() external payable;\n    receive() external payable;\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 100
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "devdoc",
          "userdoc",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}