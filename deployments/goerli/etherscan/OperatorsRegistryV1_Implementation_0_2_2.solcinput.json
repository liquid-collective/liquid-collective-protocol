{
  "language": "Solidity",
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 100
    }
  },
  "sources": {
    "contracts/src/Administrable.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"./interfaces/IAdministrable.sol\";\n\nimport \"./libraries/LibAdministrable.sol\";\nimport \"./libraries/LibSanitize.sol\";\n\n/// @title Administrable\n/// @author Kiln\n/// @notice This contract handles the administration of the contracts\nabstract contract Administrable is IAdministrable {\n    /// @notice Prevents unauthorized calls\n    modifier onlyAdmin() {\n        if (msg.sender != LibAdministrable._getAdmin()) {\n            revert LibErrors.Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    /// @notice Prevents unauthorized calls\n    modifier onlyPendingAdmin() {\n        if (msg.sender != LibAdministrable._getPendingAdmin()) {\n            revert LibErrors.Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    /// @inheritdoc IAdministrable\n    function getAdmin() external view returns (address) {\n        return LibAdministrable._getAdmin();\n    }\n\n    /// @inheritdoc IAdministrable\n    function getPendingAdmin() external view returns (address) {\n        return LibAdministrable._getPendingAdmin();\n    }\n\n    /// @inheritdoc IAdministrable\n    function proposeAdmin(address _newAdmin) external onlyAdmin {\n        _setPendingAdmin(_newAdmin);\n    }\n\n    /// @inheritdoc IAdministrable\n    function acceptAdmin() external onlyPendingAdmin {\n        _setAdmin(LibAdministrable._getPendingAdmin());\n        _setPendingAdmin(address(0));\n    }\n\n    /// @notice Internal utility to set the admin address\n    /// @param _admin Address to set as admin\n    function _setAdmin(address _admin) internal {\n        LibSanitize._notZeroAddress(_admin);\n        LibAdministrable._setAdmin(_admin);\n        emit SetAdmin(_admin);\n    }\n\n    /// @notice Internal utility to set the pending admin address\n    /// @param _pendingAdmin Address to set as pending admin\n    function _setPendingAdmin(address _pendingAdmin) internal {\n        LibAdministrable._setPendingAdmin(_pendingAdmin);\n        emit SetPendingAdmin(_pendingAdmin);\n    }\n\n    /// @notice Internal utility to retrieve the address of the current admin\n    /// @return The address of admin\n    function _getAdmin() internal view returns (address) {\n        return LibAdministrable._getAdmin();\n    }\n}\n"
    },
    "contracts/src/Initializable.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"./state/shared/Version.sol\";\n\n/// @title Initializable\n/// @author Kiln\n/// @notice This contract ensures that initializers are called only once per version\ncontract Initializable {\n    /// @notice An error occured during the initialization\n    /// @param version The version that was attempting to be initialized\n    /// @param expectedVersion The version that was expected\n    error InvalidInitialization(uint256 version, uint256 expectedVersion);\n\n    /// @notice Emitted when the contract is properly initialized\n    /// @param version New version of the contracts\n    /// @param cdata Complete calldata that was used during the initialization\n    event Initialize(uint256 version, bytes cdata);\n\n    /// @notice Use this modifier on initializers along with a hard-coded version number\n    /// @param _version Version to initialize\n    modifier init(uint256 _version) {\n        if (_version != Version.get()) {\n            revert InvalidInitialization(_version, Version.get());\n        }\n        Version.set(_version + 1); // prevents reentrency on the called method\n        _;\n        emit Initialize(_version, msg.data);\n    }\n}\n"
    },
    "contracts/src/OperatorsRegistry.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"./interfaces/IOperatorRegistry.1.sol\";\n\nimport \"./libraries/LibUint256.sol\";\n\nimport \"./Initializable.sol\";\nimport \"./Administrable.sol\";\n\nimport \"./state/operatorsRegistry/Operators.sol\";\nimport \"./state/operatorsRegistry/ValidatorKeys.sol\";\nimport \"./state/shared/RiverAddress.sol\";\n\n/// @title Operators Registry (v1)\n/// @author Kiln\n/// @notice This contract handles the list of operators and their keys\ncontract OperatorsRegistryV1 is IOperatorsRegistryV1, Initializable, Administrable {\n    /// @notice Maximum validators given to an operator per selection loop round\n    uint256 internal constant MAX_VALIDATOR_ATTRIBUTION_PER_ROUND = 5;\n\n    /// @inheritdoc IOperatorsRegistryV1\n    function initOperatorsRegistryV1(address _admin, address _river) external init(0) {\n        _setAdmin(_admin);\n        RiverAddress.set(_river);\n        emit SetRiver(_river);\n    }\n\n    /// @notice Prevent unauthorized calls\n    modifier onlyRiver() virtual {\n        if (msg.sender != RiverAddress.get()) {\n            revert LibErrors.Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    /// @notice Prevents anyone except the admin or the given operator to make the call. Also checks if operator is active\n    /// @notice The admin is able to call this method on behalf of any operator, even if inactive\n    /// @param _index The index identifying the operator\n    modifier onlyOperatorOrAdmin(uint256 _index) {\n        if (msg.sender == _getAdmin()) {\n            _;\n            return;\n        }\n        Operators.Operator storage operator = Operators.get(_index);\n        if (!operator.active) {\n            revert InactiveOperator(_index);\n        }\n        if (msg.sender != operator.operator) {\n            revert LibErrors.Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    /// @inheritdoc IOperatorsRegistryV1\n    function getRiver() external view returns (address) {\n        return RiverAddress.get();\n    }\n\n    /// @inheritdoc IOperatorsRegistryV1\n    function getOperator(uint256 _index) external view returns (Operators.Operator memory) {\n        return Operators.get(_index);\n    }\n\n    /// @inheritdoc IOperatorsRegistryV1\n    function getOperatorCount() external view returns (uint256) {\n        return Operators.getCount();\n    }\n\n    /// @inheritdoc IOperatorsRegistryV1\n    function getValidator(uint256 _operatorIndex, uint256 _validatorIndex)\n        external\n        view\n        returns (bytes memory publicKey, bytes memory signature, bool funded)\n    {\n        (publicKey, signature) = ValidatorKeys.get(_operatorIndex, _validatorIndex);\n        funded = _validatorIndex \u003c Operators.get(_operatorIndex).funded;\n    }\n\n    /// @inheritdoc IOperatorsRegistryV1\n    function listActiveOperators() external view returns (Operators.Operator[] memory) {\n        return Operators.getAllActive();\n    }\n\n    /// @inheritdoc IOperatorsRegistryV1\n    function addOperator(string calldata _name, address _operator) external onlyAdmin returns (uint256) {\n        Operators.Operator memory newOperator = Operators.Operator({\n            active: true,\n            operator: _operator,\n            name: _name,\n            limit: 0,\n            funded: 0,\n            keys: 0,\n            stopped: 0,\n            latestKeysEditBlockNumber: block.number\n        });\n\n        uint256 operatorIndex = Operators.push(newOperator) - 1;\n\n        emit AddedOperator(operatorIndex, newOperator.name, newOperator.operator);\n        return operatorIndex;\n    }\n\n    /// @inheritdoc IOperatorsRegistryV1\n    function setOperatorAddress(uint256 _index, address _newOperatorAddress) external onlyOperatorOrAdmin(_index) {\n        LibSanitize._notZeroAddress(_newOperatorAddress);\n        Operators.Operator storage operator = Operators.get(_index);\n\n        operator.operator = _newOperatorAddress;\n\n        emit SetOperatorAddress(_index, _newOperatorAddress);\n    }\n\n    /// @inheritdoc IOperatorsRegistryV1\n    function setOperatorName(uint256 _index, string calldata _newName) external onlyOperatorOrAdmin(_index) {\n        LibSanitize._notEmptyString(_newName);\n        Operators.Operator storage operator = Operators.get(_index);\n        operator.name = _newName;\n\n        emit SetOperatorName(_index, _newName);\n    }\n\n    /// @inheritdoc IOperatorsRegistryV1\n    function setOperatorStatus(uint256 _index, bool _newStatus) external onlyAdmin {\n        Operators.Operator storage operator = Operators.get(_index);\n        operator.active = _newStatus;\n\n        emit SetOperatorStatus(_index, _newStatus);\n    }\n\n    /// @inheritdoc IOperatorsRegistryV1\n    function setOperatorStoppedValidatorCount(uint256 _index, uint256 _newStoppedValidatorCount) external onlyAdmin {\n        Operators.Operator storage operator = Operators.get(_index);\n\n        if (_newStoppedValidatorCount \u003e operator.funded) {\n            revert LibErrors.InvalidArgument();\n        }\n\n        operator.stopped = _newStoppedValidatorCount;\n\n        emit SetOperatorStoppedValidatorCount(_index, operator.stopped);\n    }\n\n    /// @inheritdoc IOperatorsRegistryV1\n    function setOperatorLimits(\n        uint256[] calldata _operatorIndexes,\n        uint256[] calldata _newLimits,\n        uint256 _snapshotBlock\n    ) external onlyAdmin {\n        if (_operatorIndexes.length != _newLimits.length) {\n            revert InvalidArrayLengths();\n        }\n        if (_operatorIndexes.length == 0) {\n            revert InvalidEmptyArray();\n        }\n        for (uint256 idx = 0; idx \u003c _operatorIndexes.length;) {\n            uint256 operatorIndex = _operatorIndexes[idx];\n            uint256 newLimit = _newLimits[idx];\n\n            // prevents duplicates\n            if (idx \u003e 0 \u0026\u0026 !(operatorIndex \u003e _operatorIndexes[idx - 1])) {\n                revert UnorderedOperatorList();\n            }\n\n            Operators.Operator storage operator = Operators.get(operatorIndex);\n\n            uint256 currentLimit = operator.limit;\n            if (newLimit == currentLimit) {\n                emit OperatorLimitUnchanged(operatorIndex, newLimit);\n                unchecked {\n                    ++idx;\n                }\n                continue;\n            }\n\n            // we enter this condition if the operator edited its keys after the off-chain key audit was made\n            // we will skip any limit update on that operator unless it was a decrease in the initial limit\n            if (_snapshotBlock \u003c operator.latestKeysEditBlockNumber \u0026\u0026 newLimit \u003e currentLimit) {\n                emit OperatorEditsAfterSnapshot(\n                    operatorIndex, currentLimit, newLimit, operator.latestKeysEditBlockNumber, _snapshotBlock\n                    );\n                unchecked {\n                    ++idx;\n                }\n                continue;\n            }\n\n            // otherwise, we check for limit invariants that shouldn't happen if the off-chain key audit\n            // was made properly, and if everything is respected, we update the limit\n\n            if (newLimit \u003e operator.keys) {\n                revert OperatorLimitTooHigh(operatorIndex, newLimit, operator.keys);\n            }\n\n            if (newLimit \u003c operator.funded) {\n                revert OperatorLimitTooLow(operatorIndex, newLimit, operator.funded);\n            }\n\n            operator.limit = newLimit;\n            emit SetOperatorLimit(operatorIndex, newLimit);\n\n            unchecked {\n                ++idx;\n            }\n        }\n    }\n\n    /// @inheritdoc IOperatorsRegistryV1\n    function addValidators(uint256 _index, uint256 _keyCount, bytes calldata _publicKeysAndSignatures)\n        external\n        onlyOperatorOrAdmin(_index)\n    {\n        if (_keyCount == 0) {\n            revert InvalidKeyCount();\n        }\n\n        if (\n            _publicKeysAndSignatures.length\n                != _keyCount * (ValidatorKeys.PUBLIC_KEY_LENGTH + ValidatorKeys.SIGNATURE_LENGTH)\n        ) {\n            revert InvalidKeysLength();\n        }\n\n        Operators.Operator storage operator = Operators.get(_index);\n\n        for (uint256 idx = 0; idx \u003c _keyCount;) {\n            bytes memory publicKeyAndSignature = LibBytes.slice(\n                _publicKeysAndSignatures,\n                idx * (ValidatorKeys.PUBLIC_KEY_LENGTH + ValidatorKeys.SIGNATURE_LENGTH),\n                ValidatorKeys.PUBLIC_KEY_LENGTH + ValidatorKeys.SIGNATURE_LENGTH\n            );\n            ValidatorKeys.set(_index, operator.keys + idx, publicKeyAndSignature);\n            unchecked {\n                ++idx;\n            }\n        }\n        Operators.setKeys(_index, operator.keys + _keyCount);\n\n        emit AddedValidatorKeys(_index, _publicKeysAndSignatures);\n    }\n\n    /// @inheritdoc IOperatorsRegistryV1\n    function removeValidators(uint256 _index, uint256[] calldata _indexes) external onlyOperatorOrAdmin(_index) {\n        uint256 indexesLength = _indexes.length;\n        if (indexesLength == 0) {\n            revert InvalidKeyCount();\n        }\n\n        Operators.Operator storage operator = Operators.get(_index);\n\n        uint256 totalKeys = operator.keys;\n\n        if (!(_indexes[0] \u003c totalKeys)) {\n            revert InvalidIndexOutOfBounds();\n        }\n\n        uint256 lastIndex = _indexes[indexesLength - 1];\n\n        if (lastIndex \u003c operator.funded) {\n            revert InvalidFundedKeyDeletionAttempt();\n        }\n\n        bool limitEqualsKeyCount = operator.keys == operator.limit;\n        Operators.setKeys(_index, totalKeys - indexesLength);\n\n        uint256 idx;\n        for (; idx \u003c indexesLength;) {\n            uint256 keyIndex = _indexes[idx];\n\n            if (idx \u003e 0 \u0026\u0026 !(keyIndex \u003c _indexes[idx - 1])) {\n                revert InvalidUnsortedIndexes();\n            }\n\n            unchecked {\n                ++idx;\n            }\n\n            uint256 lastKeyIndex = totalKeys - idx;\n\n            (bytes memory removedPublicKey,) = ValidatorKeys.get(_index, keyIndex);\n            (bytes memory lastPublicKeyAndSignature) = ValidatorKeys.getRaw(_index, lastKeyIndex);\n            ValidatorKeys.set(_index, keyIndex, lastPublicKeyAndSignature);\n            ValidatorKeys.set(_index, lastKeyIndex, new bytes(0));\n\n            emit RemovedValidatorKey(_index, removedPublicKey);\n        }\n\n        if (limitEqualsKeyCount) {\n            operator.limit = operator.keys;\n        } else if (lastIndex \u003c operator.limit) {\n            operator.limit = lastIndex;\n        }\n    }\n\n    /// @inheritdoc IOperatorsRegistryV1\n    function pickNextValidators(uint256 _count)\n        external\n        onlyRiver\n        returns (bytes[] memory publicKeys, bytes[] memory signatures)\n    {\n        return _pickNextValidatorsFromActiveOperators(_count);\n    }\n\n    /// @notice Internal utility to concatenate bytes arrays together\n    /// @param _arr1 First array\n    /// @param _arr2 Second array\n    /// @return The result of the concatenation of _arr1 + _arr2\n    function _concatenateByteArrays(bytes[] memory _arr1, bytes[] memory _arr2)\n        internal\n        pure\n        returns (bytes[] memory)\n    {\n        bytes[] memory res = new bytes[](_arr1.length + _arr2.length);\n        for (uint256 idx = 0; idx \u003c _arr1.length;) {\n            res[idx] = _arr1[idx];\n            unchecked {\n                ++idx;\n            }\n        }\n        for (uint256 idx = 0; idx \u003c _arr2.length;) {\n            res[idx + _arr1.length] = _arr2[idx];\n            unchecked {\n                ++idx;\n            }\n        }\n        return res;\n    }\n\n    /// @notice Internal utility to verify if an operator has fundable keys during the selection process\n    /// @param _operator The Operator structure in memory\n    /// @return True if at least one fundable key is available\n    function _hasFundableKeys(Operators.CachedOperator memory _operator) internal pure returns (bool) {\n        return (_operator.funded + _operator.picked) \u003c _operator.limit;\n    }\n\n    /// @notice Internal utility to get the count of active validators during the selection process\n    /// @param _operator The Operator structure in memory\n    /// @return The count of active validators for the operator\n    function _getActiveKeyCount(Operators.CachedOperator memory _operator) internal pure returns (uint256) {\n        return (_operator.funded + _operator.picked) - _operator.stopped;\n    }\n\n    /// @notice Internal utility to retrieve _count or lower fundable keys\n    /// @dev The selection process starts by retrieving the full list of active operators with at least one fundable key.\n    /// @dev\n    /// @dev An operator is considered to have at least one fundable key when their staking limit is higher than their funded key count.\n    /// @dev\n    /// @dev    isFundable = operator.active \u0026\u0026 operator.limit \u003e operator.funded\n    /// @dev\n    /// @dev The internal utility will loop on all operators and select the operator with the lowest active validator count.\n    /// @dev The active validator count is computed by subtracting the stopped validator count to the funded validator count.\n    /// @dev\n    /// @dev    activeValidatorCount = operator.funded - operator.stopped\n    /// @dev\n    /// @dev During the selection process, we keep in memory all previously selected operators and the number of given validators inside a field\n    /// @dev called picked that only exists on the CachedOperator structure in memory.\n    /// @dev\n    /// @dev    isFundable = operator.active \u0026\u0026 operator.limit \u003e (operator.funded + operator.picked)\n    /// @dev    activeValidatorCount = (operator.funded + operator.picked) - operator.stopped\n    /// @dev\n    /// @dev When we reach the requested key count or when all available keys are used, we perform a final loop on all the operators and extract keys\n    /// @dev if any operator has a positive picked count. We then update the storage counters and return the arrays with the public keys and signatures.\n    /// @param _count Amount of keys required. Contract is expected to send _count or lower.\n    /// @return publicKeys An array of fundable public keys\n    /// @return signatures An array of signatures linked to the public keys\n    function _pickNextValidatorsFromActiveOperators(uint256 _count)\n        internal\n        returns (bytes[] memory publicKeys, bytes[] memory signatures)\n    {\n        Operators.CachedOperator[] memory operators = Operators.getAllFundable();\n\n        if (operators.length == 0) {\n            return (new bytes[](0), new bytes[](0));\n        }\n\n        while (_count \u003e 0) {\n            // loop on operators to find the first that has fundable keys, taking into account previous loop round attributions\n            uint256 selectedOperatorIndex = 0;\n            for (; selectedOperatorIndex \u003c operators.length;) {\n                if (_hasFundableKeys(operators[selectedOperatorIndex])) {\n                    break;\n                }\n                unchecked {\n                    ++selectedOperatorIndex;\n                }\n            }\n\n            // if we reach the end, we have allocated all keys\n            if (selectedOperatorIndex == operators.length) {\n                break;\n            }\n\n            // we start from the next operator and we try to find one that has fundable keys but a lower (funded + picked) - stopped value\n            for (uint256 idx = selectedOperatorIndex + 1; idx \u003c operators.length;) {\n                if (\n                    _getActiveKeyCount(operators[idx]) \u003c _getActiveKeyCount(operators[selectedOperatorIndex])\n                        \u0026\u0026 _hasFundableKeys(operators[idx])\n                ) {\n                    selectedOperatorIndex = idx;\n                }\n                unchecked {\n                    ++idx;\n                }\n            }\n\n            // we take the smallest value between limit - (funded + picked), _requestedAmount and MAX_VALIDATOR_ATTRIBUTION_PER_ROUND\n            uint256 pickedKeyCount = LibUint256.min(\n                LibUint256.min(\n                    operators[selectedOperatorIndex].limit\n                        - (operators[selectedOperatorIndex].funded + operators[selectedOperatorIndex].picked),\n                    MAX_VALIDATOR_ATTRIBUTION_PER_ROUND\n                ),\n                _count\n            );\n\n            // we update the cached picked amount\n            operators[selectedOperatorIndex].picked += pickedKeyCount;\n\n            // we update the requested amount count\n            _count -= pickedKeyCount;\n        }\n\n        // we loop on all operators\n        for (uint256 idx = 0; idx \u003c operators.length; ++idx) {\n            // if we picked keys on any operator, we extract the keys from storage and concatenate them in the result\n            // we then update the funded value\n            if (operators[idx].picked \u003e 0) {\n                (bytes[] memory _publicKeys, bytes[] memory _signatures) =\n                    ValidatorKeys.getKeys(operators[idx].index, operators[idx].funded, operators[idx].picked);\n                publicKeys = _concatenateByteArrays(publicKeys, _publicKeys);\n                signatures = _concatenateByteArrays(signatures, _signatures);\n                (Operators.get(operators[idx].index)).funded += operators[idx].picked;\n            }\n        }\n    }\n}\n"
    },
    "contracts/src/interfaces/IAdministrable.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\n/// @title Administrable Interface\n/// @author Kiln\n/// @notice This interface exposes methods to handle the ownership of the contracts\ninterface IAdministrable {\n    /// @notice The pending admin address changed\n    /// @param pendingAdmin New pending admin address\n    event SetPendingAdmin(address indexed pendingAdmin);\n\n    /// @notice The admin address changed\n    /// @param admin New admin address\n    event SetAdmin(address indexed admin);\n\n    /// @notice Retrieves the current admin address\n    /// @return The admin address\n    function getAdmin() external view returns (address);\n\n    /// @notice Retrieve the current pending admin address\n    /// @return The pending admin address\n    function getPendingAdmin() external view returns (address);\n\n    /// @notice Proposes a new address as admin\n    /// @dev This security prevents setting an invalid address as an admin. The pending\n    /// @dev admin has to claim its ownership of the contract, and prove that the new\n    /// @dev address is able to perform regular transactions.\n    /// @param _newAdmin New admin address\n    function proposeAdmin(address _newAdmin) external;\n\n    /// @notice Accept the transfer of ownership\n    /// @dev Only callable by the pending admin. Resets the pending admin if succesful.\n    function acceptAdmin() external;\n}\n"
    },
    "contracts/src/interfaces/IOperatorRegistry.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../state/operatorsRegistry/Operators.sol\";\n\n/// @title Operators Registry Interface (v1)\n/// @author Kiln\n/// @notice This interface exposes methods to handle the list of operators and their keys\ninterface IOperatorsRegistryV1 {\n    /// @notice A new operator has been added to the registry\n    /// @param index The operator index\n    /// @param name The operator display name\n    /// @param operatorAddress The operator address\n    event AddedOperator(uint256 indexed index, string name, address indexed operatorAddress);\n\n    /// @notice The operator status has been changed\n    /// @param index The operator index\n    /// @param active True if the operator is active\n    event SetOperatorStatus(uint256 indexed index, bool active);\n\n    /// @notice The operator limit has been changed\n    /// @param index The operator index\n    /// @param newLimit The new operator staking limit\n    event SetOperatorLimit(uint256 indexed index, uint256 newLimit);\n\n    /// @notice The operator stopped validator count has been changed\n    /// @param index The operator index\n    /// @param newStoppedValidatorCount The new stopped validator count\n    event SetOperatorStoppedValidatorCount(uint256 indexed index, uint256 newStoppedValidatorCount);\n\n    /// @notice The operator address has been changed\n    /// @param index The operator index\n    /// @param newOperatorAddress The new operator address\n    event SetOperatorAddress(uint256 indexed index, address indexed newOperatorAddress);\n\n    /// @notice The operator display name has been changed\n    /// @param index The operator index\n    /// @param newName The new display name\n    event SetOperatorName(uint256 indexed index, string newName);\n\n    /// @notice The operator or the admin added new validator keys and signatures\n    /// @dev The public keys and signatures are concatenated\n    /// @dev A public key is 48 bytes long\n    /// @dev A signature is 96 bytes long\n    /// @dev [P1, S1, P2, S2, ..., PN, SN] where N is the bytes length divided by (96 + 48)\n    /// @param index The operator index\n    /// @param publicKeysAndSignatures The concatenated public keys and signatures\n    event AddedValidatorKeys(uint256 indexed index, bytes publicKeysAndSignatures);\n\n    /// @notice The operator or the admin removed a public key and its signature from the registry\n    /// @param index The operator index\n    /// @param publicKey The BLS public key that has been removed\n    event RemovedValidatorKey(uint256 indexed index, bytes publicKey);\n\n    /// @notice The stored river address has been changed\n    /// @param river The new river address\n    event SetRiver(address indexed river);\n\n    /// @notice The operator edited its keys after the snapshot block\n    /// @dev This means that we cannot assume that its key set is checked by the snapshot\n    /// @dev This happens only if the limit was meant to be increased\n    /// @param index The operator index\n    /// @param currentLimit The current operator limit\n    /// @param newLimit The new operator limit that was attempted to be set\n    /// @param latestKeysEditBlockNumber The last block number at which the operator changed its keys\n    /// @param snapshotBlock The block number of the snapshot\n    event OperatorEditsAfterSnapshot(\n        uint256 indexed index,\n        uint256 currentLimit,\n        uint256 newLimit,\n        uint256 indexed latestKeysEditBlockNumber,\n        uint256 indexed snapshotBlock\n    );\n\n    /// @notice The call didn't alter the limit of the operator\n    /// @param index The operator index\n    /// @param limit The limit of the operator\n    event OperatorLimitUnchanged(uint256 indexed index, uint256 limit);\n\n    /// @notice The calling operator is inactive\n    /// @param index The operator index\n    error InactiveOperator(uint256 index);\n\n    /// @notice A funded key deletion has been attempted\n    error InvalidFundedKeyDeletionAttempt();\n\n    /// @notice The index provided are not sorted properly (descending order)\n    error InvalidUnsortedIndexes();\n\n    /// @notice The provided operator and limits array have different lengths\n    error InvalidArrayLengths();\n\n    /// @notice The provided operator and limits array are empty\n    error InvalidEmptyArray();\n\n    /// @notice The provided key count is 0\n    error InvalidKeyCount();\n\n    /// @notice The provided concatenated keys do not have the expected length\n    error InvalidKeysLength();\n\n    /// @notice The index that is removed is out of bounds\n    error InvalidIndexOutOfBounds();\n\n    /// @notice The value for the operator limit is too high\n    /// @param index The operator index\n    /// @param limit The new limit provided\n    /// @param keyCount The operator key count\n    error OperatorLimitTooHigh(uint256 index, uint256 limit, uint256 keyCount);\n\n    /// @notice The value for the limit is too low\n    /// @param index The operator index\n    /// @param limit The new limit provided\n    /// @param fundedKeyCount The operator funded key count\n    error OperatorLimitTooLow(uint256 index, uint256 limit, uint256 fundedKeyCount);\n\n    /// @notice The provided list of operators is not in increasing order\n    error UnorderedOperatorList();\n\n    /// @notice Initializes the operators registry\n    /// @param _admin Admin in charge of managing operators\n    /// @param _river Address of River system\n    function initOperatorsRegistryV1(address _admin, address _river) external;\n\n    /// @notice Retrieve the River address\n    /// @return The address of River\n    function getRiver() external view returns (address);\n\n    /// @notice Get operator details\n    /// @param _index The index of the operator\n    /// @return The details of the operator\n    function getOperator(uint256 _index) external view returns (Operators.Operator memory);\n\n    /// @notice Get operator count\n    /// @return The operator count\n    function getOperatorCount() external view returns (uint256);\n\n    /// @notice Get the details of a validator\n    /// @param _operatorIndex The index of the operator\n    /// @param _validatorIndex The index of the validator\n    /// @return publicKey The public key of the validator\n    /// @return signature The signature used during deposit\n    /// @return funded True if validator has been funded\n    function getValidator(uint256 _operatorIndex, uint256 _validatorIndex)\n        external\n        view\n        returns (bytes memory publicKey, bytes memory signature, bool funded);\n\n    /// @notice Retrieve the active operator set\n    /// @return The list of active operators and their details\n    function listActiveOperators() external view returns (Operators.Operator[] memory);\n\n    /// @notice Adds an operator to the registry\n    /// @dev Only callable by the administrator\n    /// @param _name The name identifying the operator\n    /// @param _operator The address representing the operator, receiving the rewards\n    /// @return The index of the new operator\n    function addOperator(string calldata _name, address _operator) external returns (uint256);\n\n    /// @notice Changes the operator address of an operator\n    /// @dev Only callable by the administrator or the previous operator address\n    /// @param _index The operator index\n    /// @param _newOperatorAddress The new address of the operator\n    function setOperatorAddress(uint256 _index, address _newOperatorAddress) external;\n\n    /// @notice Changes the operator name\n    /// @dev Only callable by the administrator or the operator\n    /// @param _index The operator index\n    /// @param _newName The new operator name\n    function setOperatorName(uint256 _index, string calldata _newName) external;\n\n    /// @notice Changes the operator status\n    /// @dev Only callable by the administrator\n    /// @param _index The operator index\n    /// @param _newStatus The new status of the operator\n    function setOperatorStatus(uint256 _index, bool _newStatus) external;\n\n    /// @notice Changes the operator stopped validator count\n    /// @dev Only callable by the administrator\n    /// @param _index The operator index\n    /// @param _newStoppedValidatorCount The new stopped validator count of the operator\n    function setOperatorStoppedValidatorCount(uint256 _index, uint256 _newStoppedValidatorCount) external;\n\n    /// @notice Changes the operator staking limit\n    /// @dev Only callable by the administrator\n    /// @dev The operator indexes must be in increasing order and contain no duplicate\n    /// @dev The limit cannot exceed the total key count of the operator\n    /// @dev The _indexes and _newLimits must have the same length.\n    /// @dev Each limit value is applied to the operator index at the same index in the _indexes array.\n    /// @param _operatorIndexes The operator indexes, in increasing order and duplicate free\n    /// @param _newLimits The new staking limit of the operators\n    /// @param _snapshotBlock The block number at which the snapshot was computed\n    function setOperatorLimits(\n        uint256[] calldata _operatorIndexes,\n        uint256[] calldata _newLimits,\n        uint256 _snapshotBlock\n    ) external;\n\n    /// @notice Adds new keys for an operator\n    /// @dev Only callable by the administrator or the operator address\n    /// @param _index The operator index\n    /// @param _keyCount The amount of keys provided\n    /// @param _publicKeysAndSignatures Public keys of the validator, concatenated\n    function addValidators(uint256 _index, uint256 _keyCount, bytes calldata _publicKeysAndSignatures) external;\n\n    /// @notice Remove validator keys\n    /// @dev Only callable by the administrator or the operator address\n    /// @dev The indexes must be provided sorted in decreasing order and duplicate-free, otherwise the method will revert\n    /// @dev The operator limit will be set to the lowest deleted key index if the operator's limit wasn't equal to its total key count\n    /// @dev The operator or the admin cannot remove funded keys\n    /// @param _index The operator index\n    /// @param _indexes The indexes of the keys to remove\n    function removeValidators(uint256 _index, uint256[] calldata _indexes) external;\n\n    /// @notice Retrieve validator keys based on operator statuses\n    /// @param _count Max amount of keys requested\n    /// @return publicKeys An array of public keys\n    /// @return signatures An array of signatures linked to the public keys\n    function pickNextValidators(uint256 _count)\n        external\n        returns (bytes[] memory publicKeys, bytes[] memory signatures);\n}\n"
    },
    "contracts/src/libraries/LibAdministrable.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"../state/shared/AdministratorAddress.sol\";\nimport \"../state/shared/PendingAdministratorAddress.sol\";\n\n/// @title Lib Administrable\n/// @author Kiln\n/// @notice This library handles the admin and pending admin storage vars\nlibrary LibAdministrable {\n    /// @notice Retrieve the system admin\n    /// @return The address of the system admin\n    function _getAdmin() internal view returns (address) {\n        return AdministratorAddress.get();\n    }\n\n    /// @notice Retrieve the pending system admin\n    /// @return The adress of the pending system admin\n    function _getPendingAdmin() internal view returns (address) {\n        return PendingAdministratorAddress.get();\n    }\n\n    /// @notice Sets the system admin\n    /// @param _admin New system admin\n    function _setAdmin(address _admin) internal {\n        AdministratorAddress.set(_admin);\n    }\n\n    /// @notice Sets the pending system admin\n    /// @param _pendingAdmin New pending system admin\n    function _setPendingAdmin(address _pendingAdmin) internal {\n        PendingAdministratorAddress.set(_pendingAdmin);\n    }\n}\n"
    },
    "contracts/src/libraries/LibBasisPoints.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\n/// @title Lib Basis Points\n/// @notice Holds the basis points max value\nlibrary LibBasisPoints {\n    /// @notice The max value for basis points (represents 100%)\n    uint256 internal constant BASIS_POINTS_MAX = 10_000;\n}\n"
    },
    "contracts/src/libraries/LibBytes.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\n/// @title Lib Bytes\n/// @notice This library helps manipulating bytes\nlibrary LibBytes {\n    /// @notice The length overflows an uint\n    error SliceOverflow();\n\n    /// @notice The slice is outside of the initial bytes bounds\n    error SliceOutOfBounds();\n\n    /// @notice Slices the provided bytes\n    /// @param _bytes Bytes to slice\n    /// @param _start The starting index of the slice\n    /// @param _length The length of the slice\n    /// @return The slice of _bytes starting at _start of length _length\n    function slice(bytes memory _bytes, uint256 _start, uint256 _length) internal pure returns (bytes memory) {\n        unchecked {\n            if (_length + 31 \u003c _length) {\n                revert SliceOverflow();\n            }\n        }\n        if (_bytes.length \u003c _start + _length) {\n            revert SliceOutOfBounds();\n        }\n\n        bytes memory tempBytes;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } { mstore(mc, mload(cc)) }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n}\n"
    },
    "contracts/src/libraries/LibErrors.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\n/// @title Lib Errors\n/// @notice Library of common errors\nlibrary LibErrors {\n    /// @notice The operator is unauthorized for the caller\n    /// @param caller Addres performing the call\n    error Unauthorized(address caller);\n\n    /// @notice The call was invalid\n    error InvalidCall();\n\n    /// @notice The argument was invalid\n    error InvalidArgument();\n\n    /// @notice The address is zero\n    error InvalidZeroAddress();\n\n    /// @notice The string is empty\n    error InvalidEmptyString();\n\n    /// @notice The fee is invalid\n    error InvalidFee();\n}\n"
    },
    "contracts/src/libraries/LibSanitize.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"./LibErrors.sol\";\nimport \"./LibBasisPoints.sol\";\n\n/// @title Lib Sanitize\n/// @notice Utilities to sanitize input values\nlibrary LibSanitize {\n    /// @notice Reverts if address is 0\n    /// @param _address Address to check\n    function _notZeroAddress(address _address) internal pure {\n        if (_address == address(0)) {\n            revert LibErrors.InvalidZeroAddress();\n        }\n    }\n\n    /// @notice Reverts if string is empty\n    /// @param _string String to check\n    function _notEmptyString(string memory _string) internal pure {\n        if (bytes(_string).length == 0) {\n            revert LibErrors.InvalidEmptyString();\n        }\n    }\n\n    /// @notice Reverts if fee is invalid\n    /// @param _fee Fee to check\n    function _validFee(uint256 _fee) internal pure {\n        if (_fee \u003e LibBasisPoints.BASIS_POINTS_MAX) {\n            revert LibErrors.InvalidFee();\n        }\n    }\n}\n"
    },
    "contracts/src/libraries/LibUint256.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\n/// @title Lib Uint256\n/// @notice Utilities to perform uint operations\nlibrary LibUint256 {\n    /// @notice Converts a value to little endian (64 bits)\n    /// @param _value The value to convert\n    /// @return result The converted value\n    function toLittleEndian64(uint256 _value) internal pure returns (uint256 result) {\n        result = 0;\n        uint256 tempValue = _value;\n        result = tempValue \u0026 0xFF;\n        tempValue \u003e\u003e= 8;\n\n        result = (result \u003c\u003c 8) | (tempValue \u0026 0xFF);\n        tempValue \u003e\u003e= 8;\n\n        result = (result \u003c\u003c 8) | (tempValue \u0026 0xFF);\n        tempValue \u003e\u003e= 8;\n\n        result = (result \u003c\u003c 8) | (tempValue \u0026 0xFF);\n        tempValue \u003e\u003e= 8;\n\n        result = (result \u003c\u003c 8) | (tempValue \u0026 0xFF);\n        tempValue \u003e\u003e= 8;\n\n        result = (result \u003c\u003c 8) | (tempValue \u0026 0xFF);\n        tempValue \u003e\u003e= 8;\n\n        result = (result \u003c\u003c 8) | (tempValue \u0026 0xFF);\n        tempValue \u003e\u003e= 8;\n\n        result = (result \u003c\u003c 8) | (tempValue \u0026 0xFF);\n        tempValue \u003e\u003e= 8;\n\n        assert(0 == tempValue); // fully converted\n        result \u003c\u003c= (24 * 8);\n    }\n\n    /// @notice Returns the minimum value\n    /// @param _a First value\n    /// @param _b Second value\n    /// @return Smallest value between _a and _b\n    function min(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        return (_a \u003e _b ? _b : _a);\n    }\n}\n"
    },
    "contracts/src/libraries/LibUnstructuredStorage.sol": {
      "content": "// SPDX-License-Identifier:    MIT\n\npragma solidity 0.8.10;\n\n/// @title Lib Unstructured Storage\n/// @notice Utilities to work with unstructured storage\nlibrary LibUnstructuredStorage {\n    /// @notice Retrieve a bool value at a storage slot\n    /// @param _position The storage slot to retrieve\n    /// @return data The bool value\n    function getStorageBool(bytes32 _position) internal view returns (bool data) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            data := sload(_position)\n        }\n    }\n\n    /// @notice Retrieve an address value at a storage slot\n    /// @param _position The storage slot to retrieve\n    /// @return data The address value\n    function getStorageAddress(bytes32 _position) internal view returns (address data) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            data := sload(_position)\n        }\n    }\n\n    /// @notice Retrieve a bytes32 value at a storage slot\n    /// @param _position The storage slot to retrieve\n    /// @return data The bytes32 value\n    function getStorageBytes32(bytes32 _position) internal view returns (bytes32 data) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            data := sload(_position)\n        }\n    }\n\n    /// @notice Retrieve an uint256 value at a storage slot\n    /// @param _position The storage slot to retrieve\n    /// @return data The uint256 value\n    function getStorageUint256(bytes32 _position) internal view returns (uint256 data) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            data := sload(_position)\n        }\n    }\n\n    /// @notice Sets a bool value at a storage slot\n    /// @param _position The storage slot to set\n    /// @param _data The bool value to set\n    function setStorageBool(bytes32 _position, bool _data) internal {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(_position, _data)\n        }\n    }\n\n    /// @notice Sets an address value at a storage slot\n    /// @param _position The storage slot to set\n    /// @param _data The address value to set\n    function setStorageAddress(bytes32 _position, address _data) internal {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(_position, _data)\n        }\n    }\n\n    /// @notice Sets a bytes32 value at a storage slot\n    /// @param _position The storage slot to set\n    /// @param _data The bytes32 value to set\n    function setStorageBytes32(bytes32 _position, bytes32 _data) internal {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(_position, _data)\n        }\n    }\n\n    /// @notice Sets an uint256 value at a storage slot\n    /// @param _position The storage slot to set\n    /// @param _data The uint256 value to set\n    function setStorageUint256(bytes32 _position, uint256 _data) internal {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(_position, _data)\n        }\n    }\n}\n"
    },
    "contracts/src/state/operatorsRegistry/Operators.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibSanitize.sol\";\n\n/// @title Operators Storage\n/// @notice Utility to manage the Operators in storage\nlibrary Operators {\n    /// @notice Storage slot of the Operators\n    bytes32 internal constant OPERATORS_SLOT = bytes32(uint256(keccak256(\"river.state.operators\")) - 1);\n\n    /// @notice The Operator structure in storage\n    struct Operator {\n        /// @custom:attribute True if the operator is active and allowed to operate on River\n        bool active;\n        /// @custom:attribute Display name of the operator\n        string name;\n        /// @custom:attribute Address of the operator\n        address operator;\n        /// @dev The following values respect this invariant:\n        /// @dev     keys \u003e= limit \u003e= funded \u003e= stopped\n\n        /// @custom:attribute Staking limit of the operator\n        uint256 limit;\n        /// @custom:attribute The count of funded validators\n        uint256 funded;\n        /// @custom:attribute The total count of keys of the operator\n        uint256 keys;\n        /// @custom:attribute The count of stopped validators. Stopped validators are validators\n        ///                   that exited the consensus layer (voluntary or slashed)\n        uint256 stopped;\n        uint256 latestKeysEditBlockNumber;\n    }\n\n    /// @notice The Operator structure when loaded in memory\n    struct CachedOperator {\n        /// @custom:attribute True if the operator is active and allowed to operate on River\n        bool active;\n        /// @custom:attribute Display name of the operator\n        string name;\n        /// @custom:attribute Address of the operator\n        address operator;\n        /// @custom:attribute Staking limit of the operator\n        uint256 limit;\n        /// @custom:attribute The count of funded validators\n        uint256 funded;\n        /// @custom:attribute The total count of keys of the operator\n        uint256 keys;\n        /// @custom:attribute The count of stopped validators\n        uint256 stopped;\n        /// @custom:attribute The count of stopped validators. Stopped validators are validators\n        ///                   that exited the consensus layer (voluntary or slashed)\n        uint256 index;\n        /// @custom:attribute The amount of picked keys, buffer used before changing funded in storage\n        uint256 picked;\n    }\n\n    /// @notice The structure at the storage slot\n    struct SlotOperator {\n        /// @custom:attribute Array containing all the operators\n        Operator[] value;\n    }\n\n    /// @notice The operator was not found\n    /// @param index The provided index\n    error OperatorNotFound(uint256 index);\n\n    /// @notice Retrieve the operator in storage\n    /// @param _index The index of the operator\n    /// @return The Operator structure\n    function get(uint256 _index) internal view returns (Operator storage) {\n        bytes32 slot = OPERATORS_SLOT;\n\n        SlotOperator storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        if (r.value.length \u003c= _index) {\n            revert OperatorNotFound(_index);\n        }\n\n        return r.value[_index];\n    }\n\n    /// @notice Retrieve the operator count in storage\n    /// @return The count of operators in storage\n    function getCount() internal view returns (uint256) {\n        bytes32 slot = OPERATORS_SLOT;\n\n        SlotOperator storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value.length;\n    }\n\n    /// @notice Retrieve all the active operators\n    /// @return The list of active operator structures\n    function getAllActive() internal view returns (Operator[] memory) {\n        bytes32 slot = OPERATORS_SLOT;\n\n        SlotOperator storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        uint256 activeCount = 0;\n        uint256 operatorCount = r.value.length;\n\n        for (uint256 idx = 0; idx \u003c operatorCount;) {\n            if (r.value[idx].active) {\n                unchecked {\n                    ++activeCount;\n                }\n            }\n            unchecked {\n                ++idx;\n            }\n        }\n\n        Operator[] memory activeOperators = new Operator[](activeCount);\n\n        uint256 activeIdx = 0;\n        for (uint256 idx = 0; idx \u003c operatorCount;) {\n            if (r.value[idx].active) {\n                activeOperators[activeIdx] = r.value[idx];\n                unchecked {\n                    ++activeIdx;\n                }\n            }\n            unchecked {\n                ++idx;\n            }\n        }\n\n        return activeOperators;\n    }\n\n    /// @notice Retrieve all the active and fundable operators\n    /// @return The list of active and fundable operators\n    function getAllFundable() internal view returns (CachedOperator[] memory) {\n        bytes32 slot = OPERATORS_SLOT;\n\n        SlotOperator storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        uint256 activeCount = 0;\n        uint256 operatorCount = r.value.length;\n\n        for (uint256 idx = 0; idx \u003c operatorCount;) {\n            if (_hasFundableKeys(r.value[idx])) {\n                unchecked {\n                    ++activeCount;\n                }\n            }\n            unchecked {\n                ++idx;\n            }\n        }\n\n        CachedOperator[] memory activeOperators = new CachedOperator[](activeCount);\n\n        uint256 activeIdx = 0;\n        for (uint256 idx = 0; idx \u003c operatorCount;) {\n            Operator memory op = r.value[idx];\n            if (_hasFundableKeys(op)) {\n                activeOperators[activeIdx] = CachedOperator({\n                    active: op.active,\n                    name: op.name,\n                    operator: op.operator,\n                    limit: op.limit,\n                    funded: op.funded,\n                    keys: op.keys,\n                    stopped: op.stopped,\n                    index: idx,\n                    picked: 0\n                });\n                unchecked {\n                    ++activeIdx;\n                }\n            }\n            unchecked {\n                ++idx;\n            }\n        }\n\n        return activeOperators;\n    }\n\n    /// @notice Add a new operator in storage\n    /// @param _newOperator Value of the new operator\n    /// @return The size of the operator array after the operation\n    function push(Operator memory _newOperator) internal returns (uint256) {\n        LibSanitize._notZeroAddress(_newOperator.operator);\n        LibSanitize._notEmptyString(_newOperator.name);\n        bytes32 slot = OPERATORS_SLOT;\n\n        SlotOperator storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        r.value.push(_newOperator);\n\n        return r.value.length;\n    }\n\n    /// @notice Atomic operation to set the key count and update the latestKeysEditBlockNumber field at the same time\n    /// @param _index The operator index\n    /// @param _newKeys The new value for the key count\n    function setKeys(uint256 _index, uint256 _newKeys) internal {\n        Operator storage op = get(_index);\n\n        op.keys = _newKeys;\n        op.latestKeysEditBlockNumber = block.number;\n    }\n\n    /// @notice Checks if an operator is active and has fundable keys\n    /// @param _operator The operator details\n    /// @return True if active and fundable\n    function _hasFundableKeys(Operators.Operator memory _operator) internal pure returns (bool) {\n        return (_operator.active \u0026\u0026 _operator.limit \u003e _operator.funded);\n    }\n}\n"
    },
    "contracts/src/state/operatorsRegistry/ValidatorKeys.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibBytes.sol\";\n\n/// @title Validator Keys Storage\n/// @notice Utility to manage the validator keys in storage\nlibrary ValidatorKeys {\n    /// @notice Storage slot of the Validator Keys\n    bytes32 internal constant VALIDATOR_KEYS_SLOT = bytes32(uint256(keccak256(\"river.state.validatorKeys\")) - 1);\n\n    /// @notice Length in bytes of a BLS Public Key used for validator deposits\n    uint256 internal constant PUBLIC_KEY_LENGTH = 48;\n\n    /// @notice Length in bytes of a BLS Signature used for validator deposits\n    uint256 internal constant SIGNATURE_LENGTH = 96;\n\n    /// @notice The provided public key is not matching the expected length\n    error InvalidPublicKey();\n\n    /// @notice The provided signature is not matching the expected length\n    error InvalidSignature();\n\n    /// @notice Structure of the Validator Keys in storage\n    struct Slot {\n        /// @custom:attribute The mapping from operator index to key index to key value\n        mapping(uint256 =\u003e mapping(uint256 =\u003e bytes)) value;\n    }\n\n    /// @notice Retrieve the Validator Key of an operator at a specific index\n    /// @param _operatorIndex The operator index\n    /// @param _idx the Validator Key index\n    /// @return publicKey The Validator Key public key\n    /// @return signature The Validator Key signature\n    function get(uint256 _operatorIndex, uint256 _idx)\n        internal\n        view\n        returns (bytes memory publicKey, bytes memory signature)\n    {\n        bytes32 slot = VALIDATOR_KEYS_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        bytes storage entry = r.value[_operatorIndex][_idx];\n\n        publicKey = LibBytes.slice(entry, 0, PUBLIC_KEY_LENGTH);\n        signature = LibBytes.slice(entry, PUBLIC_KEY_LENGTH, SIGNATURE_LENGTH);\n    }\n\n    /// @notice Retrieve the raw concatenated Validator Keys\n    /// @param _operatorIndex The operator index\n    /// @param _idx The Validator Key index\n    /// @return The concatenated public key and signature\n    function getRaw(uint256 _operatorIndex, uint256 _idx) internal view returns (bytes memory) {\n        bytes32 slot = VALIDATOR_KEYS_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value[_operatorIndex][_idx];\n    }\n\n    /// @notice Retrieve multiple keys of an operator starting at an index\n    /// @param _operatorIndex The operator index\n    /// @param _startIdx The starting index to retrieve the keys from\n    /// @param _amount The amount of keys to retrieve\n    /// @return publicKeys The public keys retrieved\n    /// @return signatures The signatures associated with the public keys\n    function getKeys(uint256 _operatorIndex, uint256 _startIdx, uint256 _amount)\n        internal\n        view\n        returns (bytes[] memory publicKeys, bytes[] memory signatures)\n    {\n        publicKeys = new bytes[](_amount);\n        signatures = new bytes[](_amount);\n\n        bytes32 slot = VALIDATOR_KEYS_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n        uint256 idx;\n        for (; idx \u003c _amount;) {\n            bytes memory rawCredentials = r.value[_operatorIndex][idx + _startIdx];\n            publicKeys[idx] = LibBytes.slice(rawCredentials, 0, PUBLIC_KEY_LENGTH);\n            signatures[idx] = LibBytes.slice(rawCredentials, PUBLIC_KEY_LENGTH, SIGNATURE_LENGTH);\n            unchecked {\n                ++idx;\n            }\n        }\n    }\n\n    /// @notice Set the concatenated Validator Keys at an index for an operator\n    /// @param _operatorIndex The operator index\n    /// @param _idx The key index to write on\n    /// @param _publicKeyAndSignature The concatenated Validator Keys\n    function set(uint256 _operatorIndex, uint256 _idx, bytes memory _publicKeyAndSignature) internal {\n        bytes32 slot = VALIDATOR_KEYS_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        r.value[_operatorIndex][_idx] = _publicKeyAndSignature;\n    }\n}\n"
    },
    "contracts/src/state/shared/AdministratorAddress.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\nimport \"../../libraries/LibSanitize.sol\";\n\n/// @title Administrator Address Storage\n/// @notice Utility to manage the Administrator Address in storage\nlibrary AdministratorAddress {\n    /// @notice Storage slot of the Administrator Address\n    bytes32 public constant ADMINISTRATOR_ADDRESS_SLOT =\n        bytes32(uint256(keccak256(\"river.state.administratorAddress\")) - 1);\n\n    /// @notice Retrieve the Administrator Address\n    /// @return The Administrator Address\n    function get() internal view returns (address) {\n        return LibUnstructuredStorage.getStorageAddress(ADMINISTRATOR_ADDRESS_SLOT);\n    }\n\n    /// @notice Sets the Administrator Address\n    /// @param _newValue New Administrator Address\n    function set(address _newValue) internal {\n        LibSanitize._notZeroAddress(_newValue);\n        LibUnstructuredStorage.setStorageAddress(ADMINISTRATOR_ADDRESS_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/shared/PendingAdministratorAddress.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\n\n/// @title Pending Administrator Address Storage\n/// @notice Utility to manage the Pending Administrator Address in storage\nlibrary PendingAdministratorAddress {\n    /// @notice Storage slot of the Pending Administrator Address\n    bytes32 public constant PENDING_ADMINISTRATOR_ADDRESS_SLOT =\n        bytes32(uint256(keccak256(\"river.state.pendingAdministratorAddress\")) - 1);\n\n    /// @notice Retrieve the Pending Administrator Address\n    /// @return The Pending Administrator Address\n    function get() internal view returns (address) {\n        return LibUnstructuredStorage.getStorageAddress(PENDING_ADMINISTRATOR_ADDRESS_SLOT);\n    }\n\n    /// @notice Sets the Pending Administrator Address\n    /// @param _newValue New Pending Administrator Address\n    function set(address _newValue) internal {\n        LibUnstructuredStorage.setStorageAddress(PENDING_ADMINISTRATOR_ADDRESS_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/shared/RiverAddress.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibSanitize.sol\";\nimport \"../../libraries/LibUnstructuredStorage.sol\";\n\n/// @title River Address Storage\n/// @notice Utility to manage the River Address in storage\nlibrary RiverAddress {\n    /// @notice Storage slot of the River Address\n    bytes32 internal constant RIVER_ADDRESS_SLOT = bytes32(uint256(keccak256(\"river.state.riverAddress\")) - 1);\n\n    /// @notice Retrieve the River Address\n    /// @return The River Address\n    function get() internal view returns (address) {\n        return LibUnstructuredStorage.getStorageAddress(RIVER_ADDRESS_SLOT);\n    }\n\n    /// @notice Sets the River Address\n    /// @param _newValue New River Address\n    function set(address _newValue) internal {\n        LibSanitize._notZeroAddress(_newValue);\n        LibUnstructuredStorage.setStorageAddress(RIVER_ADDRESS_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/shared/Version.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\n\n/// @title Version Storage\n/// @notice Utility to manage the Version in storage\nlibrary Version {\n    /// @notice Storage slot of the Version\n    bytes32 public constant VERSION_SLOT = bytes32(uint256(keccak256(\"river.state.version\")) - 1);\n\n    /// @notice Retrieve the Version\n    /// @return The Version\n    function get() internal view returns (uint256) {\n        return LibUnstructuredStorage.getStorageUint256(VERSION_SLOT);\n    }\n\n    /// @notice Sets the Version\n    /// @param _newValue New Version\n    function set(uint256 _newValue) internal {\n        LibUnstructuredStorage.setStorageUint256(VERSION_SLOT, _newValue);\n    }\n}\n"
    }
  }
}