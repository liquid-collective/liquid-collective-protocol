{
  "language": "Solidity",
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 100
    }
  },
  "sources": {
    "contracts/src/Initializable.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"./state/shared/Version.sol\";\n\n/// @title Initializable\n/// @author Kiln\n/// @notice This contract ensures that initializers are called only once per version\ncontract Initializable {\n    /// @notice Disable initialization on implementations\n    constructor() {\n        Version.set(type(uint256).max);\n        emit Initialize(type(uint256).max, msg.data);\n    }\n\n    /// @notice An error occured during the initialization\n    /// @param version The version that was attempting to be initialized\n    /// @param expectedVersion The version that was expected\n    error InvalidInitialization(uint256 version, uint256 expectedVersion);\n\n    /// @notice Emitted when the contract is properly initialized\n    /// @param version New version of the contracts\n    /// @param cdata Complete calldata that was used during the initialization\n    event Initialize(uint256 version, bytes cdata);\n\n    /// @notice Use this modifier on initializers along with a hard-coded version number\n    /// @param _version Version to initialize\n    modifier init(uint256 _version) {\n        if (_version != Version.get()) {\n            revert InvalidInitialization(_version, Version.get());\n        }\n        Version.set(_version + 1); // prevents reentrency on the called method\n        _;\n        emit Initialize(_version, msg.data);\n    }\n}\n"
    },
    "contracts/src/RedeemManager.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"./interfaces/IAllowlist.1.sol\";\nimport \"./interfaces/IRiver.1.sol\";\nimport \"./interfaces/IRedeemManager.1.sol\";\nimport \"./libraries/LibAllowlistMasks.sol\";\nimport \"./libraries/LibUint256.sol\";\nimport \"./Initializable.sol\";\n\nimport \"./state/shared/RiverAddress.sol\";\nimport \"./state/redeemManager/RedeemQueue.sol\";\nimport \"./state/redeemManager/WithdrawalStack.sol\";\nimport \"./state/redeemManager/BufferedExceedingEth.sol\";\nimport \"./state/redeemManager/RedeemDemand.sol\";\n\n/// @title Redeem Manager (v1)\n/// @author Kiln\n/// @notice This contract handles the redeem requests of all users\ncontract RedeemManagerV1 is Initializable, IRedeemManagerV1 {\n    /// @notice Value returned when resolving a redeem request that is unsatisfied\n    int64 internal constant RESOLVE_UNSATISFIED = -1;\n    /// @notice Value returned when resolving a redeem request that is out of bounds\n    int64 internal constant RESOLVE_OUT_OF_BOUNDS = -2;\n    /// @notice Value returned when resolving a redeem request that is already claimed\n    int64 internal constant RESOLVE_FULLY_CLAIMED = -3;\n\n    /// @notice Status value returned when fully claiming a redeem request\n    uint8 internal constant CLAIM_FULLY_CLAIMED = 0;\n    /// @notice Status value returned when partially claiming a redeem request\n    uint8 internal constant CLAIM_PARTIALLY_CLAIMED = 1;\n    /// @notice Status value returned when a redeem request is already claimed and skipped during a claim\n    uint8 internal constant CLAIM_SKIPPED = 2;\n\n    modifier onlyRiver() {\n        if (msg.sender != RiverAddress.get()) {\n            revert LibErrors.Unauthorized(msg.sender);\n        }\n        _;\n    }\n\n    modifier onlyRedeemerOrRiver() {\n        {\n            IRiverV1 river = _castedRiver();\n            if (msg.sender != address(river)) {\n                IAllowlistV1(river.getAllowlist()).onlyAllowed(msg.sender, LibAllowlistMasks.REDEEM_MASK);\n            }\n        }\n        _;\n    }\n\n    modifier onlyRedeemer() {\n        {\n            IRiverV1 river = _castedRiver();\n            IAllowlistV1(river.getAllowlist()).onlyAllowed(msg.sender, LibAllowlistMasks.REDEEM_MASK);\n        }\n        _;\n    }\n\n    /// @inheritdoc IRedeemManagerV1\n    function initializeRedeemManagerV1(address _river) external init(0) {\n        RiverAddress.set(_river);\n        emit SetRiver(_river);\n    }\n\n    /// @inheritdoc IRedeemManagerV1\n    function getRedeemRequestCount() external view returns (uint256) {\n        return RedeemQueue.get().length;\n    }\n\n    /// @inheritdoc IRedeemManagerV1\n    function getRedeemRequestDetails(uint32 _redeemRequestId)\n        external\n        view\n        returns (RedeemQueue.RedeemRequest memory)\n    {\n        return RedeemQueue.get()[_redeemRequestId];\n    }\n\n    /// @inheritdoc IRedeemManagerV1\n    function getWithdrawalEventCount() external view returns (uint256) {\n        return WithdrawalStack.get().length;\n    }\n\n    /// @inheritdoc IRedeemManagerV1\n    function getWithdrawalEventDetails(uint32 _withdrawalEventId)\n        external\n        view\n        returns (WithdrawalStack.WithdrawalEvent memory)\n    {\n        return WithdrawalStack.get()[_withdrawalEventId];\n    }\n\n    /// @inheritdoc IRedeemManagerV1\n    function getBufferedExceedingEth() external view returns (uint256) {\n        return BufferedExceedingEth.get();\n    }\n\n    /// @inheritdoc IRedeemManagerV1\n    function getRedeemDemand() external view returns (uint256) {\n        return RedeemDemand.get();\n    }\n\n    /// @inheritdoc IRedeemManagerV1\n    function resolveRedeemRequests(uint32[] calldata _redeemRequestIds)\n        external\n        view\n        returns (int64[] memory withdrawalEventIds)\n    {\n        withdrawalEventIds = new int64[](_redeemRequestIds.length);\n        WithdrawalStack.WithdrawalEvent memory lastWithdrawalEvent;\n        WithdrawalStack.WithdrawalEvent[] storage withdrawalEvents = WithdrawalStack.get();\n        uint256 withdrawalEventsLength = withdrawalEvents.length;\n        if (withdrawalEventsLength \u003e 0) {\n            lastWithdrawalEvent = withdrawalEvents[withdrawalEventsLength - 1];\n        }\n        for (uint256 idx = 0; idx \u003c _redeemRequestIds.length; ++idx) {\n            withdrawalEventIds[idx] = _resolveRedeemRequestId(_redeemRequestIds[idx], lastWithdrawalEvent);\n        }\n    }\n\n    /// @inheritdoc IRedeemManagerV1\n    function requestRedeem(uint256 _lsETHAmount, address _recipient)\n        external\n        onlyRedeemerOrRiver\n        returns (uint32 redeemRequestId)\n    {\n        return _requestRedeem(_lsETHAmount, _recipient);\n    }\n\n    /// @inheritdoc IRedeemManagerV1\n    function requestRedeem(uint256 _lsETHAmount) external onlyRedeemer returns (uint32 redeemRequestId) {\n        return _requestRedeem(_lsETHAmount, msg.sender);\n    }\n\n    /// @inheritdoc IRedeemManagerV1\n    function claimRedeemRequests(\n        uint32[] calldata redeemRequestIds,\n        uint32[] calldata withdrawalEventIds,\n        bool skipAlreadyClaimed,\n        uint16 _depth\n    ) external returns (uint8[] memory claimStatuses) {\n        return _claimRedeemRequests(redeemRequestIds, withdrawalEventIds, skipAlreadyClaimed, _depth);\n    }\n\n    /// @inheritdoc IRedeemManagerV1\n    function claimRedeemRequests(uint32[] calldata _redeemRequestIds, uint32[] calldata _withdrawalEventIds)\n        external\n        returns (uint8[] memory claimStatuses)\n    {\n        return _claimRedeemRequests(_redeemRequestIds, _withdrawalEventIds, true, type(uint16).max);\n    }\n\n    /// @inheritdoc IRedeemManagerV1\n    function reportWithdraw(uint256 _lsETHWithdrawable) external payable onlyRiver {\n        uint256 redeemDemand = RedeemDemand.get();\n        if (_lsETHWithdrawable \u003e redeemDemand) {\n            revert WithdrawalExceedsRedeemDemand(_lsETHWithdrawable, redeemDemand);\n        }\n        WithdrawalStack.WithdrawalEvent[] storage withdrawalEvents = WithdrawalStack.get();\n        uint32 withdrawalEventId = uint32(withdrawalEvents.length);\n        uint256 height = 0;\n        uint256 msgValue = msg.value;\n        if (withdrawalEventId != 0) {\n            WithdrawalStack.WithdrawalEvent memory previousWithdrawalEvent = withdrawalEvents[withdrawalEventId - 1];\n            height = previousWithdrawalEvent.height + previousWithdrawalEvent.amount;\n        }\n        withdrawalEvents.push(\n            WithdrawalStack.WithdrawalEvent({height: height, amount: _lsETHWithdrawable, withdrawnEth: msgValue})\n        );\n        _setRedeemDemand(redeemDemand - _lsETHWithdrawable);\n        emit ReportedWithdrawal(height, _lsETHWithdrawable, msgValue, withdrawalEventId);\n    }\n\n    /// @inheritdoc IRedeemManagerV1\n    function pullExceedingEth(uint256 _max) external onlyRiver {\n        uint256 amountToSend = LibUint256.min(BufferedExceedingEth.get(), _max);\n        if (amountToSend \u003e 0) {\n            BufferedExceedingEth.set(BufferedExceedingEth.get() - amountToSend);\n            _castedRiver().sendRedeemManagerExceedingFunds{value: amountToSend}();\n        }\n    }\n\n    /// @notice Internal utility to load and cast the River address\n    /// @return The casted river address\n    function _castedRiver() internal view returns (IRiverV1) {\n        return IRiverV1(payable(RiverAddress.get()));\n    }\n\n    /// @notice Internal utility to verify if a redeem request and a withdrawal event are matching\n    /// @param _redeemRequest The loaded redeem request\n    /// @param _withdrawalEvent The load withdrawal event\n    /// @return True if matching\n    function _isMatch(\n        RedeemQueue.RedeemRequest memory _redeemRequest,\n        WithdrawalStack.WithdrawalEvent memory _withdrawalEvent\n    ) internal pure returns (bool) {\n        return (\n            _redeemRequest.height \u003c _withdrawalEvent.height + _withdrawalEvent.amount\n                \u0026\u0026 _redeemRequest.height \u003e= _withdrawalEvent.height\n        );\n    }\n\n    /// @notice Internal utility to perform a dichotomic search of the withdrawal event to use to claim the redeem request\n    /// @param _redeemRequest The redeem request to resolve\n    /// @return The matching withdrawal event\n    function _performDichotomicResolution(RedeemQueue.RedeemRequest memory _redeemRequest)\n        internal\n        view\n        returns (int64)\n    {\n        WithdrawalStack.WithdrawalEvent[] storage withdrawalEvents = WithdrawalStack.get();\n\n        int64 max = int64(int256(WithdrawalStack.get().length - 1));\n\n        if (_isMatch(_redeemRequest, withdrawalEvents[uint64(max)])) {\n            return max;\n        }\n\n        int64 min = 0;\n\n        if (_isMatch(_redeemRequest, withdrawalEvents[uint64(min)])) {\n            return min;\n        }\n\n        // we start a dichotomic search between min and max\n        while (min != max) {\n            int64 mid = (min + max) / 2;\n\n            // we identify and verify that the middle element is not matching\n            WithdrawalStack.WithdrawalEvent memory midWithdrawalEvent = withdrawalEvents[uint64(mid)];\n            if (_isMatch(_redeemRequest, midWithdrawalEvent)) {\n                return mid;\n            }\n\n            // depending on the position of the middle element, we update max or min to get our min max range\n            // closer to our redeem request position\n            if (_redeemRequest.height \u003c midWithdrawalEvent.height) {\n                max = mid;\n            } else {\n                min = mid;\n            }\n        }\n        return min;\n    }\n\n    /// @notice Internal utility to resolve a redeem request and retrieve its satisfying withdrawal event id, or identify possible errors\n    /// @param _redeemRequestId The redeem request id\n    /// @param _lastWithdrawalEvent The last withdrawal event loaded in memory\n    /// @return withdrawalEventId The id of the withdrawal event matching the redeem request or error code\n    function _resolveRedeemRequestId(\n        uint32 _redeemRequestId,\n        WithdrawalStack.WithdrawalEvent memory _lastWithdrawalEvent\n    ) internal view returns (int64 withdrawalEventId) {\n        RedeemQueue.RedeemRequest[] storage redeemRequests = RedeemQueue.get();\n        // if the redeem request id is \u003e= than the size of requests, we know it's out of bounds and doesn't exist\n        if (_redeemRequestId \u003e= redeemRequests.length) {\n            return RESOLVE_OUT_OF_BOUNDS;\n        }\n        RedeemQueue.RedeemRequest memory redeemRequest = redeemRequests[_redeemRequestId];\n        // if the redeem request remaining amount is 0, we know that the request has been entirely claimed\n        if (redeemRequest.amount == 0) {\n            return RESOLVE_FULLY_CLAIMED;\n        }\n        // if there are no existing withdrawal events or if the height of the redeem request is higher than the height and\n        // amount of the last withdrawal element, we know that the redeem request is not yet satisfied\n        if (\n            WithdrawalStack.get().length == 0\n                || (_lastWithdrawalEvent.height + _lastWithdrawalEvent.amount) \u003c= redeemRequest.height\n        ) {\n            return RESOLVE_UNSATISFIED;\n        }\n        // we know for sure that the redeem request has funds yet to be claimed and there is a withdrawal event we need to identify\n        // that would allow the user to claim the redeem request\n        return _performDichotomicResolution(redeemRequest);\n    }\n\n    /// @notice Perform a new redeem request for the specified recipient\n    /// @param _lsETHAmount The amount of LsETH to redeem\n    /// @param _recipient The recipient owning the request\n    /// @return redeemRequestId The id of the newly created redeem request\n    function _requestRedeem(uint256 _lsETHAmount, address _recipient) internal returns (uint32 redeemRequestId) {\n        LibSanitize._notZeroAddress(_recipient);\n        if (_lsETHAmount == 0) {\n            revert InvalidZeroAmount();\n        }\n        if (!_castedRiver().transferFrom(msg.sender, address(this), _lsETHAmount)) {\n            revert TransferError();\n        }\n        RedeemQueue.RedeemRequest[] storage redeemRequests = RedeemQueue.get();\n        redeemRequestId = uint32(redeemRequests.length);\n        uint256 height = 0;\n        if (redeemRequestId != 0) {\n            RedeemQueue.RedeemRequest memory previousRedeemRequest = redeemRequests[redeemRequestId - 1];\n            height = previousRedeemRequest.height + previousRedeemRequest.amount;\n        }\n\n        uint256 maxRedeemableEth = _castedRiver().underlyingBalanceFromShares(_lsETHAmount);\n\n        redeemRequests.push(\n            RedeemQueue.RedeemRequest({\n                height: height,\n                amount: _lsETHAmount,\n                owner: _recipient,\n                maxRedeemableEth: maxRedeemableEth\n            })\n        );\n\n        _setRedeemDemand(RedeemDemand.get() + _lsETHAmount);\n\n        emit RequestedRedeem(_recipient, height, _lsETHAmount, maxRedeemableEth, redeemRequestId);\n    }\n\n    /// @notice Internal structure used to optimize stack usage in _claimRedeemRequest\n    struct ClaimRedeemRequestParameters {\n        /// @custom:attribute The id of the redeem request to claim\n        uint32 redeemRequestId;\n        /// @custom:attribute The structure of the redeem request to claim\n        RedeemQueue.RedeemRequest redeemRequest;\n        /// @custom:attribute The id of the withdrawal event to use to claim the redeem request\n        uint32 withdrawalEventId;\n        /// @custom:attribute The structure of the withdrawal event to use to claim the redeem request\n        WithdrawalStack.WithdrawalEvent withdrawalEvent;\n        /// @custom:attribute The count of withdrawal events\n        uint32 withdrawalEventCount;\n        /// @custom:attribute The current depth of the recursive call\n        uint16 depth;\n        /// @custom:attribute The amount of LsETH redeemed/matched, needs to be reset to 0 for each call/before calling the recursive function\n        uint256 lsETHAmount;\n        /// @custom:attribute The amount of eth redeemed/matched, needs to be rest to 0 for each call/before calling the recursive function\n        uint256 ethAmount;\n    }\n\n    /// @notice Internal structure used to optimize stack usage in _claimRedeemRequest\n    struct ClaimRedeemRequestInternalVariables {\n        /// @custom:attribute The eth amount claimed by the user\n        uint256 ethAmount;\n        /// @custom:attribute The amount of LsETH matched during this step\n        uint256 matchingAmount;\n        /// @custom:attribute The amount of eth redirected to the exceeding eth buffer\n        uint256 exceedingEthAmount;\n    }\n\n    /// @notice Internal utility to save a redeem request to storage\n    /// @param _params The parameters of the claim redeem request call\n    function _saveRedeemRequest(ClaimRedeemRequestParameters memory _params) internal {\n        RedeemQueue.RedeemRequest[] storage redeemRequests = RedeemQueue.get();\n        redeemRequests[_params.redeemRequestId].height = _params.redeemRequest.height;\n        redeemRequests[_params.redeemRequestId].amount = _params.redeemRequest.amount;\n        redeemRequests[_params.redeemRequestId].maxRedeemableEth = _params.redeemRequest.maxRedeemableEth;\n    }\n\n    /// @notice Internal utility to claim a redeem request if possible\n    /// @dev Will call itself recursively if the redeem requests overflows its matching withdrawal event\n    /// @param _params The parameters of the claim redeem request call\n    function _claimRedeemRequest(ClaimRedeemRequestParameters memory _params) internal {\n        ClaimRedeemRequestInternalVariables memory vars;\n        {\n            uint256 withdrawalEventEndPosition = _params.withdrawalEvent.height + _params.withdrawalEvent.amount;\n\n            // it can occur that the redeem request is overlapping the provided withdrawal event\n            // the amount that is matched in the withdrawal event is adapted depending on this\n            vars.matchingAmount =\n                LibUint256.min(_params.redeemRequest.amount, withdrawalEventEndPosition - _params.redeemRequest.height);\n            // we can now compute the equivalent eth amount based on the withdrawal event details\n            vars.ethAmount =\n                (vars.matchingAmount * _params.withdrawalEvent.withdrawnEth) / _params.withdrawalEvent.amount;\n\n            // as each request has a maximum withdrawable amount, we verify that the eth amount is not exceeding this amount, pro rata\n            // the amount that is matched\n            uint256 maxRedeemableEthAmount =\n                (vars.matchingAmount * _params.redeemRequest.maxRedeemableEth) / _params.redeemRequest.amount;\n\n            if (maxRedeemableEthAmount \u003c vars.ethAmount) {\n                vars.exceedingEthAmount = vars.ethAmount - maxRedeemableEthAmount;\n                BufferedExceedingEth.set(BufferedExceedingEth.get() + vars.exceedingEthAmount);\n                vars.ethAmount = maxRedeemableEthAmount;\n            }\n\n            // height and amount are updated to reflect the amount that was matched.\n            // we will always keep this invariant true oldRequest.height + oldRequest.amount == newRequest.height + newRequest.amount\n            // this also means that if the request wasn't entirely matched, it will now be automatically be assigned to the next\n            // withdrawal event in the queue, because height is updated based on the amount matched and is now equal to the height\n            // of the next withdrawal event\n            // the end position of a redeem request (height + amount) is an invariant that never changes throughout the lifetime of a request\n            // this end position is used to define the starting position of the next redeem request\n            _params.redeemRequest.height += vars.matchingAmount;\n            _params.redeemRequest.amount -= vars.matchingAmount;\n            _params.redeemRequest.maxRedeemableEth -= vars.ethAmount;\n\n            _params.lsETHAmount += vars.matchingAmount;\n            _params.ethAmount += vars.ethAmount;\n\n            // this event signals that an amount has been matched from a redeem request on a withdrawal event\n            // this event can be triggered several times for the same redeem request, depending on its size and\n            // how many withdrawal events it overlaps.\n            emit SatisfiedRedeemRequest(\n                _params.redeemRequestId,\n                _params.withdrawalEventId,\n                vars.matchingAmount,\n                vars.ethAmount,\n                _params.redeemRequest.amount,\n                vars.exceedingEthAmount\n            );\n        }\n\n        // in the case where we haven't claimed all the redeem request AND that there are other withdrawal events\n        // available next in the stack, we load the next withdrawal event and call this method recursively\n        // also we stop the claim process if the claim depth is about to be 0\n        if (\n            _params.redeemRequest.amount \u003e 0 \u0026\u0026 _params.withdrawalEventId + 1 \u003c _params.withdrawalEventCount\n                \u0026\u0026 _params.depth \u003e 0\n        ) {\n            WithdrawalStack.WithdrawalEvent[] storage withdrawalEvents = WithdrawalStack.get();\n\n            ++_params.withdrawalEventId;\n            _params.withdrawalEvent = withdrawalEvents[_params.withdrawalEventId];\n            --_params.depth;\n\n            _claimRedeemRequest(_params);\n        } else {\n            // if we end up here, we either claimed everything or we reached the end of the withdrawal event stack\n            // in this case we save the current redeem request state to storage and return the status according to the\n            // remaining claimable amount on the redeem request\n            _saveRedeemRequest(_params);\n        }\n    }\n\n    /// @notice Internal utility to claim several redeem requests at once\n    /// @param _redeemRequestIds The list of redeem requests to claim\n    /// @param _withdrawalEventIds The list of withdrawal events to use for each redeem request. Should have the same length.\n    /// @param _skipAlreadyClaimed True if the system should skip redeem requests already claimed, otherwise will revert\n    /// @param _depth The depth of the recursion to use when claiming a redeem request\n    /// @return claimStatuses The claim statuses for each redeem request\n    function _claimRedeemRequests(\n        uint32[] calldata _redeemRequestIds,\n        uint32[] calldata _withdrawalEventIds,\n        bool _skipAlreadyClaimed,\n        uint16 _depth\n    ) internal returns (uint8[] memory claimStatuses) {\n        uint256 redeemRequestIdsLength = _redeemRequestIds.length;\n        if (redeemRequestIdsLength != _withdrawalEventIds.length) {\n            revert IncompatibleArrayLengths();\n        }\n        claimStatuses = new uint8[](redeemRequestIdsLength);\n\n        RedeemQueue.RedeemRequest[] storage redeemRequests = RedeemQueue.get();\n        WithdrawalStack.WithdrawalEvent[] storage withdrawalEvents = WithdrawalStack.get();\n\n        ClaimRedeemRequestParameters memory params;\n        params.withdrawalEventCount = uint32(withdrawalEvents.length);\n        uint32 redeemRequestCount = uint32(redeemRequests.length);\n\n        for (uint256 idx = 0; idx \u003c redeemRequestIdsLength;) {\n            // both ids are loaded into params\n            params.redeemRequestId = _redeemRequestIds[idx];\n            params.withdrawalEventId = _withdrawalEventIds[idx];\n\n            // we start by checking that the id is not out of bounds for the redeem requests\n            if (params.redeemRequestId \u003e= redeemRequestCount) {\n                revert RedeemRequestOutOfBounds(params.redeemRequestId);\n            }\n\n            // we check that the withdrawal event id is not out of bounds\n            if (params.withdrawalEventId \u003e= params.withdrawalEventCount) {\n                revert WithdrawalEventOutOfBounds(params.withdrawalEventId);\n            }\n\n            // we load the redeem request in memory\n            params.redeemRequest = redeemRequests[_redeemRequestIds[idx]];\n\n            // we check that the redeem request is not already claimed\n            if (params.redeemRequest.amount == 0) {\n                if (_skipAlreadyClaimed) {\n                    claimStatuses[idx] = CLAIM_SKIPPED;\n                    unchecked {\n                        ++idx;\n                    }\n                    continue;\n                }\n                revert RedeemRequestAlreadyClaimed(params.redeemRequestId);\n            }\n\n            // we load the withdrawal event in memory\n            params.withdrawalEvent = withdrawalEvents[_withdrawalEventIds[idx]];\n\n            // now that both entities are loaded in memory, we verify that they indeed match, otherwise we revert\n            if (!_isMatch(params.redeemRequest, params.withdrawalEvent)) {\n                revert DoesNotMatch(params.redeemRequestId, params.withdrawalEventId);\n            }\n\n            params.depth = _depth;\n            params.ethAmount = 0;\n            params.lsETHAmount = 0;\n\n            _claimRedeemRequest(params);\n\n            claimStatuses[idx] = params.redeemRequest.amount == 0 ? CLAIM_FULLY_CLAIMED : CLAIM_PARTIALLY_CLAIMED;\n\n            {\n                (bool success, bytes memory rdata) = params.redeemRequest.owner.call{value: params.ethAmount}(\"\");\n                if (!success) {\n                    revert ClaimRedeemFailed(params.redeemRequest.owner, rdata);\n                }\n            }\n            emit ClaimedRedeemRequest(\n                _redeemRequestIds[idx],\n                params.redeemRequest.owner,\n                params.ethAmount,\n                params.lsETHAmount,\n                params.redeemRequest.amount\n            );\n\n            unchecked {\n                ++idx;\n            }\n        }\n    }\n\n    /// @notice Internal utility to set the redeem demand\n    /// @param _newValue The new value to set\n    function _setRedeemDemand(uint256 _newValue) internal {\n        emit SetRedeemDemand(RedeemDemand.get(), _newValue);\n        RedeemDemand.set(_newValue);\n    }\n}\n"
    },
    "contracts/src/interfaces/IAllowlist.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\n/// @title Allowlist Interface (v1)\n/// @author Kiln\n/// @notice This interface exposes methods to handle the list of allowed recipients.\ninterface IAllowlistV1 {\n    /// @notice The permissions of several accounts have changed\n    /// @param accounts List of accounts\n    /// @param permissions New permissions for each account at the same index\n    event SetAllowlistPermissions(address[] accounts, uint256[] permissions);\n\n    /// @notice The stored allower address has been changed\n    /// @param allower The new allower address\n    event SetAllower(address indexed allower);\n\n    /// @notice The provided accounts list is empty\n    error InvalidAlloweeCount();\n\n    /// @notice The account is denied access\n    /// @param _account The denied account\n    error Denied(address _account);\n\n    /// @notice The provided accounts and permissions list have different lengths\n    error MismatchedAlloweeAndStatusCount();\n\n    /// @notice Initializes the allowlist\n    /// @param _admin Address of the Allowlist administrator\n    /// @param _allower Address of the allower\n    function initAllowlistV1(address _admin, address _allower) external;\n\n    /// @notice Retrieves the allower address\n    /// @return The address of the allower\n    function getAllower() external view returns (address);\n\n    /// @notice This method returns true if the user has the expected permission and\n    ///         is not in the deny list\n    /// @param _account Recipient to verify\n    /// @param _mask Combination of permissions to verify\n    /// @return True if mask is respected and user is allowed\n    function isAllowed(address _account, uint256 _mask) external view returns (bool);\n\n    /// @notice This method returns true if the user is in the deny list\n    /// @param _account Recipient to verify\n    /// @return True if user is denied access\n    function isDenied(address _account) external view returns (bool);\n\n    /// @notice This method returns true if the user has the expected permission\n    ///         ignoring any deny list membership\n    /// @param _account Recipient to verify\n    /// @param _mask Combination of permissions to verify\n    /// @return True if mask is respected\n    function hasPermission(address _account, uint256 _mask) external view returns (bool);\n\n    /// @notice This method retrieves the raw permission value\n    /// @param _account Recipient to verify\n    /// @return The raw permissions value of the account\n    function getPermissions(address _account) external view returns (uint256);\n\n    /// @notice This method should be used as a modifier and is expected to revert\n    ///         if the user hasn't got the required permission or if the user is\n    ///         in the deny list.\n    /// @param _account Recipient to verify\n    /// @param _mask Combination of permissions to verify\n    function onlyAllowed(address _account, uint256 _mask) external view;\n\n    /// @notice Changes the allower address\n    /// @param _newAllowerAddress New address allowed to edit the allowlist\n    function setAllower(address _newAllowerAddress) external;\n\n    /// @notice Sets the allowlisting status for one or more accounts\n    /// @dev The permission value is overridden and not updated\n    /// @param _accounts Accounts with statuses to edit\n    /// @param _permissions Allowlist permissions for each account, in the same order as _accounts\n    function allow(address[] calldata _accounts, uint256[] calldata _permissions) external;\n}\n"
    },
    "contracts/src/interfaces/IRedeemManager.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../state/redeemManager/RedeemQueue.sol\";\nimport \"../state/redeemManager/WithdrawalStack.sol\";\n\n/// @title Redeem Manager Interface (v1)\n/// @author Kiln\n/// @notice This contract handles the redeem requests of all users\ninterface IRedeemManagerV1 {\n    /// @notice Emitted when a redeem request is created\n    /// @param owner The owner of the redeem request\n    /// @param height The height of the redeem request in LsETH\n    /// @param amount The amount of the redeem request in LsETH\n    /// @param maxRedeemableEth The maximum amount of eth that can be redeemed from this request\n    /// @param id The id of the new redeem request\n    event RequestedRedeem(address indexed owner, uint256 height, uint256 amount, uint256 maxRedeemableEth, uint32 id);\n\n    /// @notice Emitted when a withdrawal event is created\n    /// @param height The height of the withdrawal event in LsETH\n    /// @param amount The amount of the withdrawal event in LsETH\n    /// @param ethAmount The amount of eth to distrubute to claimers\n    /// @param id The id of the withdrawal event\n    event ReportedWithdrawal(uint256 height, uint256 amount, uint256 ethAmount, uint32 id);\n\n    /// @notice Emitted when a redeem request has been satisfied and filled (even partially) from a withdrawal event\n    /// @param redeemRequestId The id of the redeem request\n    /// @param withdrawalEventId The id of the withdrawal event used to fill the request\n    /// @param lsEthAmountSatisfied The amount of LsETH filled\n    /// @param ethAmountSatisfied The amount of ETH filled\n    /// @param lsEthAmountRemaining The amount of LsETH remaining\n    /// @param ethAmountExceeding The amount of eth added to the exceeding buffer\n    event SatisfiedRedeemRequest(\n        uint32 indexed redeemRequestId,\n        uint32 indexed withdrawalEventId,\n        uint256 lsEthAmountSatisfied,\n        uint256 ethAmountSatisfied,\n        uint256 lsEthAmountRemaining,\n        uint256 ethAmountExceeding\n    );\n\n    /// @notice Emitted when a redeem request claim has been processed and matched at least once and funds are sent to the recipient\n    /// @param redeemRequestId The id of the redeem request\n    /// @param recipient The address receiving the redeem request funds\n    /// @param ethAmount The amount of eth retrieved\n    /// @param lsEthAmount The total amount of LsETH used to redeem the eth\n    /// @param remainingLsEthAmount The amount of LsETH remaining\n    event ClaimedRedeemRequest(\n        uint32 indexed redeemRequestId,\n        address indexed recipient,\n        uint256 ethAmount,\n        uint256 lsEthAmount,\n        uint256 remainingLsEthAmount\n    );\n\n    /// @notice Emitted when the redeem demand is set\n    /// @param oldRedeemDemand The old redeem demand\n    /// @param newRedeemDemand The new redeem demand\n    event SetRedeemDemand(uint256 oldRedeemDemand, uint256 newRedeemDemand);\n\n    /// @notice Emitted when the River address is set\n    /// @param river The new river address\n    event SetRiver(address river);\n\n    /// @notice Thrown When a zero value is provided\n    error InvalidZeroAmount();\n\n    /// @notice Thrown when a transfer error occured with LsETH\n    error TransferError();\n\n    /// @notice Thrown when the provided arrays don't have matching lengths\n    error IncompatibleArrayLengths();\n\n    /// @notice Thrown when the provided redeem request id is out of bounds\n    /// @param id The redeem request id\n    error RedeemRequestOutOfBounds(uint256 id);\n\n    /// @notice Thrown when the withdrawal request id if out of bounds\n    /// @param id The withdrawal event id\n    error WithdrawalEventOutOfBounds(uint256 id);\n\n    /// @notice Thrown when\tthe redeem request id is already claimed\n    /// @param id The redeem request id\n    error RedeemRequestAlreadyClaimed(uint256 id);\n\n    /// @notice Thrown when the redeem request and withdrawal event are not matching during claim\n    /// @param redeemRequestId The provided redeem request id\n    /// @param withdrawalEventId The provided associated withdrawal event id\n    error DoesNotMatch(uint256 redeemRequestId, uint256 withdrawalEventId);\n\n    /// @notice Thrown when the provided withdrawal event exceeds the redeem demand\n    /// @param withdrawalAmount The amount of the withdrawal event\n    /// @param redeemDemand The current redeem demand\n    error WithdrawalExceedsRedeemDemand(uint256 withdrawalAmount, uint256 redeemDemand);\n\n    /// @notice Thrown when the payment after a claim failed\n    /// @param recipient The recipient of the payment\n    /// @param rdata The revert data\n    error ClaimRedeemFailed(address recipient, bytes rdata);\n\n    /// @param _river The address of the River contract\n    function initializeRedeemManagerV1(address _river) external;\n\n    /// @notice Retrieve the global count of redeem requests\n    function getRedeemRequestCount() external view returns (uint256);\n\n    /// @notice Retrieve the details of a specific redeem request\n    /// @param _redeemRequestId The id of the request\n    /// @return The redeem request details\n    function getRedeemRequestDetails(uint32 _redeemRequestId)\n        external\n        view\n        returns (RedeemQueue.RedeemRequest memory);\n\n    /// @notice Retrieve the global count of withdrawal events\n    function getWithdrawalEventCount() external view returns (uint256);\n\n    /// @notice Retrieve the details of a specific withdrawal event\n    /// @param _withdrawalEventId The id of the withdrawal event\n    /// @return The withdrawal event details\n    function getWithdrawalEventDetails(uint32 _withdrawalEventId)\n        external\n        view\n        returns (WithdrawalStack.WithdrawalEvent memory);\n\n    /// @notice Retrieve the amount of redeemed LsETH pending to be supplied with withdrawn ETH\n    /// @return The amount of eth in the buffer\n    function getBufferedExceedingEth() external view returns (uint256);\n\n    /// @notice Retrieve the amount of LsETH waiting to be exited\n    /// @return The amount of LsETH waiting to be exited\n    function getRedeemDemand() external view returns (uint256);\n\n    /// @notice Resolves the provided list of redeem request ids\n    /// @dev The result is an array of equal length with ids or error code\n    /// @dev -1 means that the request is not satisfied yet\n    /// @dev -2 means that the request is out of bounds\n    /// @dev -3 means that the request has already been claimed\n    /// @dev This call was created to be called by an off-chain interface, the output could then be used to perform the claimRewards call in a regular transaction\n    /// @param _redeemRequestIds The list of redeem requests to resolve\n    /// @return withdrawalEventIds The list of withdrawal events matching every redeem request (or error codes)\n    function resolveRedeemRequests(uint32[] calldata _redeemRequestIds)\n        external\n        view\n        returns (int64[] memory withdrawalEventIds);\n\n    /// @notice Creates a redeem request\n    /// @param _lsETHAmount The amount of LsETH to redeem\n    /// @param _recipient The recipient owning the redeem request\n    /// @return redeemRequestId The id of the redeem request\n    function requestRedeem(uint256 _lsETHAmount, address _recipient) external returns (uint32 redeemRequestId);\n\n    /// @notice Creates a redeem request using msg.sender as recipient\n    /// @param _lsETHAmount The amount of LsETH to redeem\n    /// @return redeemRequestId The id of the redeem request\n    function requestRedeem(uint256 _lsETHAmount) external returns (uint32 redeemRequestId);\n\n    /// @notice Claims the rewards of the provided redeem request ids\n    /// @param _redeemRequestIds The list of redeem requests to claim\n    /// @param _withdrawalEventIds The list of withdrawal events to use for every redeem request claim\n    /// @param _skipAlreadyClaimed True if the call should not revert on claiming of already claimed requests\n    /// @param _depth The maximum recursive depth for the resolution of the redeem requests\n    /// @return claimStatuses The list of claim statuses. 0 for fully claimed, 1 for partially claimed, 2 for skipped\n    function claimRedeemRequests(\n        uint32[] calldata _redeemRequestIds,\n        uint32[] calldata _withdrawalEventIds,\n        bool _skipAlreadyClaimed,\n        uint16 _depth\n    ) external returns (uint8[] memory claimStatuses);\n\n    /// @notice Claims the rewards of the provided redeem request ids\n    /// @param _redeemRequestIds The list of redeem requests to claim\n    /// @param _withdrawalEventIds The list of withdrawal events to use for every redeem request claim\n    /// @return claimStatuses The list of claim statuses. 0 for fully claimed, 1 for partially claimed, 2 for skipped\n    function claimRedeemRequests(uint32[] calldata _redeemRequestIds, uint32[] calldata _withdrawalEventIds)\n        external\n        returns (uint8[] memory claimStatuses);\n\n    /// @notice Reports a withdraw event from River\n    /// @param _lsETHWithdrawable The amount of LsETH that can be redeemed due to this new withdraw event\n    function reportWithdraw(uint256 _lsETHWithdrawable) external payable;\n\n    /// @notice Pulls exceeding buffer eth\n    /// @param _max The maximum amount that should be pulled\n    function pullExceedingEth(uint256 _max) external;\n}\n"
    },
    "contracts/src/interfaces/IRiver.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../state/river/DailyCommittableLimits.sol\";\n\nimport \"./components/IConsensusLayerDepositManager.1.sol\";\nimport \"./components/IOracleManager.1.sol\";\nimport \"./components/ISharesManager.1.sol\";\nimport \"./components/IUserDepositManager.1.sol\";\n\n/// @title River Interface (v1)\n/// @author Kiln\n/// @notice The main system interface\ninterface IRiverV1 is IConsensusLayerDepositManagerV1, IUserDepositManagerV1, ISharesManagerV1, IOracleManagerV1 {\n    /// @notice Funds have been pulled from the Execution Layer Fee Recipient\n    /// @param amount The amount pulled\n    event PulledELFees(uint256 amount);\n\n    /// @notice Funds have been pulled from the Coverage Fund\n    /// @param amount The amount pulled\n    event PulledCoverageFunds(uint256 amount);\n\n    /// @notice Emitted when funds are pulled from the redeem manager\n    /// @param amount The amount pulled\n    event PulledRedeemManagerExceedingEth(uint256 amount);\n\n    /// @notice Emitted when funds are pulled from the CL recipient\n    /// @param pulledSkimmedEthAmount The amount of skimmed ETH pulled\n    /// @param pullExitedEthAmount The amount of exited ETH pulled\n    event PulledCLFunds(uint256 pulledSkimmedEthAmount, uint256 pullExitedEthAmount);\n\n    /// @notice The stored Execution Layer Fee Recipient has been changed\n    /// @param elFeeRecipient The new Execution Layer Fee Recipient\n    event SetELFeeRecipient(address indexed elFeeRecipient);\n\n    /// @notice The stored Coverage Fund has been changed\n    /// @param coverageFund The new Coverage Fund\n    event SetCoverageFund(address indexed coverageFund);\n\n    /// @notice The stored Collector has been changed\n    /// @param collector The new Collector\n    event SetCollector(address indexed collector);\n\n    /// @notice The stored Allowlist has been changed\n    /// @param allowlist The new Allowlist\n    event SetAllowlist(address indexed allowlist);\n\n    /// @notice The stored Global Fee has been changed\n    /// @param fee The new Global Fee\n    event SetGlobalFee(uint256 fee);\n\n    /// @notice The stored Operators Registry has been changed\n    /// @param operatorRegistry The new Operators Registry\n    event SetOperatorsRegistry(address indexed operatorRegistry);\n\n    /// @notice The stored Metadata URI string has been changed\n    /// @param metadataURI The new Metadata URI string\n    event SetMetadataURI(string metadataURI);\n\n    /// @notice The system underlying supply increased. This is a snapshot of the balances for accounting purposes\n    /// @param _collector The address of the collector during this event\n    /// @param _oldTotalUnderlyingBalance Old total ETH balance under management by River\n    /// @param _oldTotalSupply Old total supply in shares\n    /// @param _newTotalUnderlyingBalance New total ETH balance under management by River\n    /// @param _newTotalSupply New total supply in shares\n    event RewardsEarned(\n        address indexed _collector,\n        uint256 _oldTotalUnderlyingBalance,\n        uint256 _oldTotalSupply,\n        uint256 _newTotalUnderlyingBalance,\n        uint256 _newTotalSupply\n    );\n\n    /// @notice Emitted when the daily committable limits are changed\n    /// @param minNetAmount The minimum amount that must be used as the daily committable amount\n    /// @param maxRelativeAmount The maximum amount that can be used as the daily committable amount, relative to the total underlying supply\n    event SetMaxDailyCommittableAmounts(uint256 minNetAmount, uint256 maxRelativeAmount);\n\n    /// @notice Emitted when the redeem manager address is changed\n    /// @param redeemManager The address of the redeem manager\n    event SetRedeemManager(address redeemManager);\n\n    /// @notice Emitted when the balance to deposit is updated\n    /// @param oldAmount The old balance to deposit\n    /// @param newAmount The new balance to deposit\n    event SetBalanceToDeposit(uint256 oldAmount, uint256 newAmount);\n\n    /// @notice Emitted when the balance to redeem is updated\n    /// @param oldAmount The old balance to redeem\n    /// @param newAmount The new balance to redeem\n    event SetBalanceToRedeem(uint256 oldAmount, uint256 newAmount);\n\n    /// @notice Emitted when the balance committed to deposit\n    /// @param oldAmount The old balance committed to deposit\n    /// @param newAmount The new balance committed to deposit\n    event SetBalanceCommittedToDeposit(uint256 oldAmount, uint256 newAmount);\n\n    /// @notice Emitted when the redeem manager received a withdraw event report\n    /// @param redeemManagerDemand The total demand in LsETH of the redeem manager\n    /// @param suppliedRedeemManagerDemand The amount of LsETH demand actually supplied\n    /// @param suppliedRedeemManagerDemandInEth The amount in ETH of the supplied demand\n    event ReportedRedeemManager(\n        uint256 redeemManagerDemand, uint256 suppliedRedeemManagerDemand, uint256 suppliedRedeemManagerDemandInEth\n    );\n\n    /// @notice Thrown when the amount received from the Withdraw contract doe not match the requested amount\n    /// @param requested The amount that was requested\n    /// @param received The amount that was received\n    error InvalidPulledClFundsAmount(uint256 requested, uint256 received);\n\n    /// @notice The computed amount of shares to mint is 0\n    error ZeroMintedShares();\n\n    /// @notice The access was denied\n    /// @param account The account that was denied\n    error Denied(address account);\n\n    /// @notice Initializes the River system\n    /// @param _depositContractAddress Address to make Consensus Layer deposits\n    /// @param _elFeeRecipientAddress Address that receives the execution layer fees\n    /// @param _withdrawalCredentials Credentials to use for every validator deposit\n    /// @param _oracleAddress The address of the Oracle contract\n    /// @param _systemAdministratorAddress Administrator address\n    /// @param _allowlistAddress Address of the allowlist contract\n    /// @param _operatorRegistryAddress Address of the operator registry\n    /// @param _collectorAddress Address receiving the the global fee on revenue\n    /// @param _globalFee Amount retained when the ETH balance increases and sent to the collector\n    function initRiverV1(\n        address _depositContractAddress,\n        address _elFeeRecipientAddress,\n        bytes32 _withdrawalCredentials,\n        address _oracleAddress,\n        address _systemAdministratorAddress,\n        address _allowlistAddress,\n        address _operatorRegistryAddress,\n        address _collectorAddress,\n        uint256 _globalFee\n    ) external;\n\n    /// @notice Initialized version 1.1 of the River System\n    /// @param _redeemManager The redeem manager address\n    /// @param _epochsPerFrame The amounts of epochs in a frame\n    /// @param _slotsPerEpoch The slots inside an epoch\n    /// @param _secondsPerSlot The seconds inside a slot\n    /// @param _genesisTime The genesis timestamp\n    /// @param _epochsToAssumedFinality The number of epochs before an epoch is considered final on-chain\n    /// @param _annualAprUpperBound The reporting upper bound\n    /// @param _relativeLowerBound The reporting lower bound\n    /// @param _maxDailyNetCommittableAmount_ The net daily committable limit\n    /// @param _maxDailyRelativeCommittableAmount_ The relative daily committable limit\n    function initRiverV1_1(\n        address _redeemManager,\n        uint64 _epochsPerFrame,\n        uint64 _slotsPerEpoch,\n        uint64 _secondsPerSlot,\n        uint64 _genesisTime,\n        uint64 _epochsToAssumedFinality,\n        uint256 _annualAprUpperBound,\n        uint256 _relativeLowerBound,\n        uint128 _maxDailyNetCommittableAmount_,\n        uint128 _maxDailyRelativeCommittableAmount_\n    ) external;\n\n    /// @notice Get the current global fee\n    /// @return The global fee\n    function getGlobalFee() external view returns (uint256);\n\n    /// @notice Retrieve the allowlist address\n    /// @return The allowlist address\n    function getAllowlist() external view returns (address);\n\n    /// @notice Retrieve the collector address\n    /// @return The collector address\n    function getCollector() external view returns (address);\n\n    /// @notice Retrieve the execution layer fee recipient\n    /// @return The execution layer fee recipient address\n    function getELFeeRecipient() external view returns (address);\n\n    /// @notice Retrieve the coverage fund\n    /// @return The coverage fund address\n    function getCoverageFund() external view returns (address);\n\n    /// @notice Retrieve the redeem manager\n    /// @return The redeem manager address\n    function getRedeemManager() external view returns (address);\n\n    /// @notice Retrieve the operators registry\n    /// @return The operators registry address\n    function getOperatorsRegistry() external view returns (address);\n\n    /// @notice Retrieve the metadata uri string value\n    /// @return The metadata uri string value\n    function getMetadataURI() external view returns (string memory);\n\n    /// @notice Retrieve the configured daily committable limits\n    /// @return The daily committable limits structure\n    function getDailyCommittableLimits()\n        external\n        view\n        returns (DailyCommittableLimits.DailyCommittableLimitsStruct memory);\n\n    /// @notice Resolves the provided redeem requests by calling the redeem manager\n    /// @param _redeemRequestIds The list of redeem requests to resolve\n    /// @return withdrawalEventIds The list of matching withdrawal events, or error codes\n    function resolveRedeemRequests(uint32[] calldata _redeemRequestIds)\n        external\n        view\n        returns (int64[] memory withdrawalEventIds);\n\n    /// @notice Set the daily committable limits\n    /// @param _dcl The Daily Committable Limits structure\n    function setDailyCommittableLimits(DailyCommittableLimits.DailyCommittableLimitsStruct memory _dcl) external;\n\n    /// @notice Retrieve the current balance to redeem\n    /// @return The current balance to redeem\n    function getBalanceToRedeem() external view returns (uint256);\n\n    /// @notice Performs a redeem request on the redeem manager\n    /// @param _lsETHAmount The amount of LsETH to redeem\n    /// @param _recipient The address that will own the redeem request\n    /// @return redeemRequestId The ID of the newly created redeem request\n    function requestRedeem(uint256 _lsETHAmount, address _recipient) external returns (uint32 redeemRequestId);\n\n    /// @notice Claims several redeem requests\n    /// @param _redeemRequestIds The list of redeem requests to claim\n    /// @param _withdrawalEventIds The list of resolved withdrawal event ids\n    /// @return claimStatuses The operation status results\n    function claimRedeemRequests(uint32[] calldata _redeemRequestIds, uint32[] calldata _withdrawalEventIds)\n        external\n        returns (uint8[] memory claimStatuses);\n\n    /// @notice Changes the global fee parameter\n    /// @param _newFee New fee value\n    function setGlobalFee(uint256 _newFee) external;\n\n    /// @notice Changes the allowlist address\n    /// @param _newAllowlist New address for the allowlist\n    function setAllowlist(address _newAllowlist) external;\n\n    /// @notice Changes the collector address\n    /// @param _newCollector New address for the collector\n    function setCollector(address _newCollector) external;\n\n    /// @notice Changes the execution layer fee recipient\n    /// @param _newELFeeRecipient New address for the recipient\n    function setELFeeRecipient(address _newELFeeRecipient) external;\n\n    /// @notice Changes the coverage fund\n    /// @param _newCoverageFund New address for the fund\n    function setCoverageFund(address _newCoverageFund) external;\n\n    /// @notice Sets the metadata uri string value\n    /// @param _metadataURI The new metadata uri string value\n    function setMetadataURI(string memory _metadataURI) external;\n\n    /// @notice Input for execution layer fee earnings\n    function sendELFees() external payable;\n\n    /// @notice Input for consensus layer funds, containing both exit and skimming\n    function sendCLFunds() external payable;\n\n    /// @notice Input for coverage funds\n    function sendCoverageFunds() external payable;\n\n    /// @notice Input for the redeem manager funds\n    function sendRedeemManagerExceedingFunds() external payable;\n}\n"
    },
    "contracts/src/interfaces/components/IConsensusLayerDepositManager.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\n/// @title Consensys Layer Deposit Manager Interface (v1)\n/// @author Kiln\n/// @notice This interface exposes methods to handle the interactions with the official deposit contract\ninterface IConsensusLayerDepositManagerV1 {\n    /// @notice The stored deposit contract address changed\n    /// @param depositContract Address of the deposit contract\n    event SetDepositContractAddress(address indexed depositContract);\n\n    /// @notice The stored withdrawal credentials changed\n    /// @param withdrawalCredentials The withdrawal credentials to use for deposits\n    event SetWithdrawalCredentials(bytes32 withdrawalCredentials);\n\n    /// @notice Emitted when the deposited validator count is updated\n    /// @param oldDepositedValidatorCount The old deposited validator count value\n    /// @param newDepositedValidatorCount The new deposited validator count value\n    event SetDepositedValidatorCount(uint256 oldDepositedValidatorCount, uint256 newDepositedValidatorCount);\n\n    /// @notice Not enough funds to deposit one validator\n    error NotEnoughFunds();\n\n    /// @notice The length of the BLS Public key is invalid during deposit\n    error InconsistentPublicKeys();\n\n    /// @notice The length of the BLS Signature is invalid during deposit\n    error InconsistentSignatures();\n\n    /// @notice The internal key retrieval returned no keys\n    error NoAvailableValidatorKeys();\n\n    /// @notice The received count of public keys to deposit is invalid\n    error InvalidPublicKeyCount();\n\n    /// @notice The received count of signatures to deposit is invalid\n    error InvalidSignatureCount();\n\n    /// @notice The withdrawal credentials value is null\n    error InvalidWithdrawalCredentials();\n\n    /// @notice An error occured during the deposit\n    error ErrorOnDeposit();\n\n    /// @notice Returns the amount of ETH not yet committed for deposit\n    /// @return The amount of ETH not yet committed for deposit\n    function getBalanceToDeposit() external view returns (uint256);\n\n    /// @notice Returns the amount of ETH committed for deposit\n    /// @return The amount of ETH committed for deposit\n    function getCommittedBalance() external view returns (uint256);\n\n    /// @notice Retrieve the withdrawal credentials\n    /// @return The withdrawal credentials\n    function getWithdrawalCredentials() external view returns (bytes32);\n\n    /// @notice Get the deposited validator count (the count of deposits made by the contract)\n    /// @return The deposited validator count\n    function getDepositedValidatorCount() external view returns (uint256);\n\n    /// @notice Deposits current balance to the Consensus Layer by batches of 32 ETH\n    /// @param _maxCount The maximum amount of validator keys to fund\n    function depositToConsensusLayer(uint256 _maxCount) external;\n}\n"
    },
    "contracts/src/interfaces/components/IOracleManager.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../state/river/CLSpec.sol\";\nimport \"../../state/river/ReportBounds.sol\";\n\n/// @title Oracle Manager (v1)\n/// @author Kiln\n/// @notice This interface exposes methods to handle the inputs provided by the oracle\ninterface IOracleManagerV1 {\n    /// @notice The stored oracle address changed\n    /// @param oracleAddress The new oracle address\n    event SetOracle(address indexed oracleAddress);\n\n    /// @notice The consensus layer data provided by the oracle has been updated\n    /// @param validatorCount The new count of validators running on the consensus layer\n    /// @param validatorTotalBalance The new total balance sum of all validators\n    /// @param roundId Round identifier\n    event ConsensusLayerDataUpdate(uint256 validatorCount, uint256 validatorTotalBalance, bytes32 roundId);\n\n    /// @notice The Consensus Layer Spec is changed\n    /// @param epochsPerFrame The number of epochs inside a frame\n    /// @param slotsPerEpoch The number of slots inside an epoch\n    /// @param secondsPerSlot The number of seconds inside a slot\n    /// @param genesisTime The genesis timestamp\n    /// @param epochsToAssumedFinality The number of epochs before an epoch is considered final\n    event SetSpec(\n        uint64 epochsPerFrame,\n        uint64 slotsPerEpoch,\n        uint64 secondsPerSlot,\n        uint64 genesisTime,\n        uint64 epochsToAssumedFinality\n    );\n\n    /// @notice The Report Bounds are changed\n    /// @param annualAprUpperBound The reporting upper bound\n    /// @param relativeLowerBound The reporting lower bound\n    event SetBounds(uint256 annualAprUpperBound, uint256 relativeLowerBound);\n\n    /// @notice The provided report has beend processed\n    /// @param report The report that was provided\n    /// @param trace The trace structure providing more insights on internals\n    event ProcessedConsensusLayerReport(\n        IOracleManagerV1.ConsensusLayerReport report, ConsensusLayerDataReportingTrace trace\n    );\n\n    /// @notice The reported validator count is invalid\n    /// @param providedValidatorCount The received validator count value\n    /// @param depositedValidatorCount The number of deposits performed by the system\n    /// @param lastReportedValidatorCount The last reported validator count\n    error InvalidValidatorCountReport(\n        uint256 providedValidatorCount, uint256 depositedValidatorCount, uint256 lastReportedValidatorCount\n    );\n\n    /// @notice Thrown when an invalid epoch was reported\n    /// @param epoch Invalid epoch\n    error InvalidEpoch(uint256 epoch);\n\n    /// @notice The balance increase is higher than the maximum allowed by the upper bound\n    /// @param prevTotalEthIncludingExited The previous total balance, including all exited balance\n    /// @param postTotalEthIncludingExited The post-report total balance, including all exited balance\n    /// @param timeElapsed The time in seconds since last report\n    /// @param annualAprUpperBound The upper bound value that was used\n    error TotalValidatorBalanceIncreaseOutOfBound(\n        uint256 prevTotalEthIncludingExited,\n        uint256 postTotalEthIncludingExited,\n        uint256 timeElapsed,\n        uint256 annualAprUpperBound\n    );\n\n    /// @notice The balance decrease is higher than the maximum allowed by the lower bound\n    /// @param prevTotalEthIncludingExited The previous total balance, including all exited balance\n    /// @param postTotalEthIncludingExited The post-report total balance, including all exited balance\n    /// @param timeElapsed The time in seconds since last report\n    /// @param relativeLowerBound The lower bound value that was used\n    error TotalValidatorBalanceDecreaseOutOfBound(\n        uint256 prevTotalEthIncludingExited,\n        uint256 postTotalEthIncludingExited,\n        uint256 timeElapsed,\n        uint256 relativeLowerBound\n    );\n\n    /// @notice The total exited balance decreased\n    /// @param currentValidatorsExitedBalance The current exited balance\n    /// @param newValidatorsExitedBalance The new exited balance\n    error InvalidDecreasingValidatorsExitedBalance(\n        uint256 currentValidatorsExitedBalance, uint256 newValidatorsExitedBalance\n    );\n\n    /// @notice The total skimmed balance decreased\n    /// @param currentValidatorsSkimmedBalance The current exited balance\n    /// @param newValidatorsSkimmedBalance The new exited balance\n    error InvalidDecreasingValidatorsSkimmedBalance(\n        uint256 currentValidatorsSkimmedBalance, uint256 newValidatorsSkimmedBalance\n    );\n\n    /// @notice Trace structure emitted via logs during reporting\n    struct ConsensusLayerDataReportingTrace {\n        uint256 rewards;\n        uint256 pulledELFees;\n        uint256 pulledRedeemManagerExceedingEthBuffer;\n        uint256 pulledCoverageFunds;\n    }\n\n    /// @notice The format of the oracle report\n    struct ConsensusLayerReport {\n        // this is the epoch at which the report was performed\n        // data should be fetched up to the state of this epoch by the oracles\n        uint256 epoch;\n        // the sum of all the validator balances on the consensus layer\n        // when a validator enters the exit queue, the validator is considered stopped, its balance is accounted in both validatorsExitingBalance and validatorsBalance\n        // when a validator leaves the exit queue and the funds are sweeped onto the execution layer, the balance is only accounted in validatorsExitedBalance and not in validatorsBalance\n        // this value can decrease between reports\n        uint256 validatorsBalance;\n        // the sum of all the skimmings performed on the validators\n        // these values can be found in the execution layer block bodies under the withdrawals field\n        // a withdrawal is considered skimming if\n        // - the epoch at which it happened is \u003c validator.withdrawableEpoch\n        // - the epoch at which it happened is \u003e= validator.withdrawableEpoch and in that case we only account for what would be above 32 eth as skimming\n        // this value cannot decrease over reports\n        uint256 validatorsSkimmedBalance;\n        // the sum of all the exits performed on the validators\n        // these values can be found in the execution layer block bodies under the withdrawals field\n        // a withdrawal is considered exit if\n        // - the epoch at which it happened is \u003e= validator.withdrawableEpoch and in that case we only account for what would be \u003c= 32 eth as exit\n        // this value cannot decrease over reports\n        uint256 validatorsExitedBalance;\n        // the sum of all the exiting balance, which is all the validators on their way to get sweeped and exited\n        // this includes voluntary exits and slashings\n        // this value can decrease between reports\n        uint256 validatorsExitingBalance;\n        // the count of activated validators\n        // even validators that are exited are still accounted\n        // this value cannot decrease over reports\n        uint32 validatorsCount;\n        // an array containing the count of stopped validators per operator\n        // the first element of the array is the sum of all stopped validators\n        // then index 1 would be operator 0\n        // these values cannot decrease over reports\n        uint32[] stoppedValidatorCountPerOperator;\n        // flag enabled by the oracles when the buffer rebalancing is activated\n        // the activation logic is written in the oracle specification and all oracle members must agree on the activation\n        // when active, the eth in the deposit buffer can be used to pay for exits in the redeem manager\n        bool rebalanceDepositToRedeemMode;\n        // flag enabled by the oracles when the slashing containment is activated\n        // the activation logic is written in the oracle specification and all oracle members must agree on the activation\n        // This flag is activated when a pre-defined threshold of slashed validators in our set of validators is reached\n        // This flag is deactivated when a bottom threshold is met, this means that when we reach the upper threshold and activate the flag, we will deactivate it when we reach the bottom threshold and not before\n        // when active, no more validator exits can be requested by the protocol\n        bool slashingContainmentMode;\n    }\n\n    /// @notice The format of the oracle report in storage\n    /// @notice These fields have the exact same function as the ones in ConsensusLayerReport, but this struct is optimized for storage\n    struct StoredConsensusLayerReport {\n        uint256 epoch;\n        uint256 validatorsBalance;\n        uint256 validatorsSkimmedBalance;\n        uint256 validatorsExitedBalance;\n        uint256 validatorsExitingBalance;\n        uint32 validatorsCount;\n        bool rebalanceDepositToRedeemMode;\n        bool slashingContainmentMode;\n    }\n\n    /// @notice Get oracle address\n    /// @return The oracle address\n    function getOracle() external view returns (address);\n\n    /// @notice Get CL validator total balance\n    /// @return The CL Validator total balance\n    function getCLValidatorTotalBalance() external view returns (uint256);\n\n    /// @notice Get CL validator count (the amount of validator reported by the oracles)\n    /// @return The CL validator count\n    function getCLValidatorCount() external view returns (uint256);\n\n    /// @notice Verifies if the provided epoch is valid\n    /// @param epoch The epoch to lookup\n    /// @return True if valid\n    function isValidEpoch(uint256 epoch) external view returns (bool);\n\n    /// @notice Retrieve the block timestamp\n    /// @return The current timestamp from the EVM context\n    function getTime() external view returns (uint256);\n\n    /// @notice Retrieve expected epoch id\n    /// @return The current expected epoch id\n    function getExpectedEpochId() external view returns (uint256);\n\n    /// @notice Retrieve the last completed epoch id\n    /// @return The last completed epoch id\n    function getLastCompletedEpochId() external view returns (uint256);\n\n    /// @notice Retrieve the current epoch id based on block timestamp\n    /// @return The current epoch id\n    function getCurrentEpochId() external view returns (uint256);\n\n    /// @notice Retrieve the current cl spec\n    /// @return The Consensus Layer Specification\n    function getCLSpec() external view returns (CLSpec.CLSpecStruct memory);\n\n    /// @notice Retrieve the current frame details\n    /// @return _startEpochId The epoch at the beginning of the frame\n    /// @return _startTime The timestamp of the beginning of the frame in seconds\n    /// @return _endTime The timestamp of the end of the frame in seconds\n    function getCurrentFrame() external view returns (uint256 _startEpochId, uint256 _startTime, uint256 _endTime);\n\n    /// @notice Retrieve the first epoch id of the frame of the provided epoch id\n    /// @param _epochId Epoch id used to get the frame\n    /// @return The first epoch id of the frame containing the given epoch id\n    function getFrameFirstEpochId(uint256 _epochId) external view returns (uint256);\n\n    /// @notice Retrieve the report bounds\n    /// @return The report bounds\n    function getReportBounds() external view returns (ReportBounds.ReportBoundsStruct memory);\n\n    /// @notice Retrieve the last consensus layer report\n    /// @return The stored consensus layer report\n    function getLastConsensusLayerReport() external view returns (IOracleManagerV1.StoredConsensusLayerReport memory);\n\n    /// @notice Set the oracle address\n    /// @param _oracleAddress Address of the oracle\n    function setOracle(address _oracleAddress) external;\n\n    /// @notice Set the consensus layer spec\n    /// @param _newValue The new consensus layer spec value\n    function setCLSpec(CLSpec.CLSpecStruct calldata _newValue) external;\n\n    /// @notice Set the report bounds\n    /// @param _newValue The new report bounds value\n    function setReportBounds(ReportBounds.ReportBoundsStruct calldata _newValue) external;\n\n    /// @notice Performs all the reporting logics\n    /// @param _report The consensus layer report structure\n    function setConsensusLayerData(ConsensusLayerReport calldata _report) external;\n}\n"
    },
    "contracts/src/interfaces/components/ISharesManager.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\n\n/// @title Shares Manager Interface (v1)\n/// @author Kiln\n/// @notice This interface exposes methods to handle the shares of the depositor and the ERC20 interface\ninterface ISharesManagerV1 is IERC20 {\n    /// @notice Emitted when the total supply is changed\n    event SetTotalSupply(uint256 totalSupply);\n\n    /// @notice Balance too low to perform operation\n    error BalanceTooLow();\n\n    /// @notice Allowance too low to perform operation\n    /// @param _from Account where funds are sent from\n    /// @param _operator Account attempting the transfer\n    /// @param _allowance Current allowance\n    /// @param _value Requested transfer value in shares\n    error AllowanceTooLow(address _from, address _operator, uint256 _allowance, uint256 _value);\n\n    /// @notice Invalid empty transfer\n    error NullTransfer();\n\n    /// @notice Invalid transfer recipients\n    /// @param _from Account sending the funds in the invalid transfer\n    /// @param _to Account receiving the funds in the invalid transfer\n    error UnauthorizedTransfer(address _from, address _to);\n\n    /// @notice Retrieve the token name\n    /// @return The token name\n    function name() external pure returns (string memory);\n\n    /// @notice Retrieve the token symbol\n    /// @return The token symbol\n    function symbol() external pure returns (string memory);\n\n    /// @notice Retrieve the decimal count\n    /// @return The decimal count\n    function decimals() external pure returns (uint8);\n\n    /// @notice Retrieve the total token supply\n    /// @return The total supply in shares\n    function totalSupply() external view returns (uint256);\n\n    /// @notice Retrieve the total underlying asset supply\n    /// @return The total underlying asset supply\n    function totalUnderlyingSupply() external view returns (uint256);\n\n    /// @notice Retrieve the balance of an account\n    /// @param _owner Address to be checked\n    /// @return The balance of the account in shares\n    function balanceOf(address _owner) external view returns (uint256);\n\n    /// @notice Retrieve the underlying asset balance of an account\n    /// @param _owner Address to be checked\n    /// @return The underlying balance of the account\n    function balanceOfUnderlying(address _owner) external view returns (uint256);\n\n    /// @notice Retrieve the underlying asset balance from an amount of shares\n    /// @param _shares Amount of shares to convert\n    /// @return The underlying asset balance represented by the shares\n    function underlyingBalanceFromShares(uint256 _shares) external view returns (uint256);\n\n    /// @notice Retrieve the shares count from an underlying asset amount\n    /// @param _underlyingAssetAmount Amount of underlying asset to convert\n    /// @return The amount of shares worth the underlying asset amopunt\n    function sharesFromUnderlyingBalance(uint256 _underlyingAssetAmount) external view returns (uint256);\n\n    /// @notice Retrieve the allowance value for a spender\n    /// @param _owner Address that issued the allowance\n    /// @param _spender Address that received the allowance\n    /// @return The allowance in shares for a given spender\n    function allowance(address _owner, address _spender) external view returns (uint256);\n\n    /// @notice Performs a transfer from the message sender to the provided account\n    /// @param _to Address receiving the tokens\n    /// @param _value Amount of shares to be sent\n    /// @return True if success\n    function transfer(address _to, uint256 _value) external returns (bool);\n\n    /// @notice Performs a transfer between two recipients\n    /// @param _from Address sending the tokens\n    /// @param _to Address receiving the tokens\n    /// @param _value Amount of shares to be sent\n    /// @return True if success\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\n\n    /// @notice Approves an account for future spendings\n    /// @dev An approved account can use transferFrom to transfer funds on behalf of the token owner\n    /// @param _spender Address that is allowed to spend the tokens\n    /// @param _value The allowed amount in shares, will override previous value\n    /// @return True if success\n    function approve(address _spender, uint256 _value) external returns (bool);\n\n    /// @notice Increase allowance to another account\n    /// @param _spender Spender that receives the allowance\n    /// @param _additionalValue Amount of shares to add\n    /// @return True if success\n    function increaseAllowance(address _spender, uint256 _additionalValue) external returns (bool);\n\n    /// @notice Decrease allowance to another account\n    /// @param _spender Spender that receives the allowance\n    /// @param _subtractableValue Amount of shares to subtract\n    /// @return True if success\n    function decreaseAllowance(address _spender, uint256 _subtractableValue) external returns (bool);\n}\n"
    },
    "contracts/src/interfaces/components/IUserDepositManager.1.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\n/// @title User Deposit Manager (v1)\n/// @author Kiln\n/// @notice This interface exposes methods to handle the inbound transfers cases or the explicit submissions\ninterface IUserDepositManagerV1 {\n    /// @notice User deposited ETH in the system\n    /// @param depositor Address performing the deposit\n    /// @param recipient Address receiving the minted shares\n    /// @param amount Amount in ETH deposited\n    event UserDeposit(address indexed depositor, address indexed recipient, uint256 amount);\n\n    /// @notice And empty deposit attempt was made\n    error EmptyDeposit();\n\n    /// @notice Explicit deposit method to mint on msg.sender\n    function deposit() external payable;\n\n    /// @notice Explicit deposit method to mint on msg.sender and transfer to _recipient\n    /// @param _recipient Address receiving the minted LsETH\n    function depositAndTransfer(address _recipient) external payable;\n\n    /// @notice Implicit deposit method, when the user performs a regular transfer to the contract\n    receive() external payable;\n\n    /// @notice Invalid call, when the user sends a transaction with a data payload but no method matched\n    fallback() external payable;\n}\n"
    },
    "contracts/src/libraries/LibAllowlistMasks.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\n/// @title Lib Allowlist Masks\n/// @notice Holds all the mask values\nlibrary LibAllowlistMasks {\n    /// @notice Mask used for denied accounts\n    uint256 internal constant DENY_MASK = 0x1 \u003c\u003c 255;\n    /// @notice The mask for the deposit right\n    uint256 internal constant DEPOSIT_MASK = 0x1;\n    /// @notice The mask for the donation right\n    uint256 internal constant DONATE_MASK = 0x1 \u003c\u003c 1;\n    /// @notice The mask for the redeem right\n    uint256 internal constant REDEEM_MASK = 0x1 \u003c\u003c 2;\n}\n"
    },
    "contracts/src/libraries/LibBasisPoints.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\n/// @title Lib Basis Points\n/// @notice Holds the basis points max value\nlibrary LibBasisPoints {\n    /// @notice The max value for basis points (represents 100%)\n    uint256 internal constant BASIS_POINTS_MAX = 10_000;\n}\n"
    },
    "contracts/src/libraries/LibErrors.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\n/// @title Lib Errors\n/// @notice Library of common errors\nlibrary LibErrors {\n    /// @notice The operator is unauthorized for the caller\n    /// @param caller Address performing the call\n    error Unauthorized(address caller);\n\n    /// @notice The call was invalid\n    error InvalidCall();\n\n    /// @notice The argument was invalid\n    error InvalidArgument();\n\n    /// @notice The address is zero\n    error InvalidZeroAddress();\n\n    /// @notice The string is empty\n    error InvalidEmptyString();\n\n    /// @notice The fee is invalid\n    error InvalidFee();\n}\n"
    },
    "contracts/src/libraries/LibSanitize.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"./LibErrors.sol\";\nimport \"./LibBasisPoints.sol\";\n\n/// @title Lib Sanitize\n/// @notice Utilities to sanitize input values\nlibrary LibSanitize {\n    /// @notice Reverts if address is 0\n    /// @param _address Address to check\n    function _notZeroAddress(address _address) internal pure {\n        if (_address == address(0)) {\n            revert LibErrors.InvalidZeroAddress();\n        }\n    }\n\n    /// @notice Reverts if string is empty\n    /// @param _string String to check\n    function _notEmptyString(string memory _string) internal pure {\n        if (bytes(_string).length == 0) {\n            revert LibErrors.InvalidEmptyString();\n        }\n    }\n\n    /// @notice Reverts if fee is invalid\n    /// @param _fee Fee to check\n    function _validFee(uint256 _fee) internal pure {\n        if (_fee \u003e LibBasisPoints.BASIS_POINTS_MAX) {\n            revert LibErrors.InvalidFee();\n        }\n    }\n}\n"
    },
    "contracts/src/libraries/LibUint256.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\n/// @title Lib Uint256\n/// @notice Utilities to perform uint operations\nlibrary LibUint256 {\n    /// @notice Converts a value to little endian (64 bits)\n    /// @param _value The value to convert\n    /// @return result The converted value\n    function toLittleEndian64(uint256 _value) internal pure returns (uint256 result) {\n        result = 0;\n        uint256 tempValue = _value;\n        result = tempValue \u0026 0xFF;\n        tempValue \u003e\u003e= 8;\n\n        result = (result \u003c\u003c 8) | (tempValue \u0026 0xFF);\n        tempValue \u003e\u003e= 8;\n\n        result = (result \u003c\u003c 8) | (tempValue \u0026 0xFF);\n        tempValue \u003e\u003e= 8;\n\n        result = (result \u003c\u003c 8) | (tempValue \u0026 0xFF);\n        tempValue \u003e\u003e= 8;\n\n        result = (result \u003c\u003c 8) | (tempValue \u0026 0xFF);\n        tempValue \u003e\u003e= 8;\n\n        result = (result \u003c\u003c 8) | (tempValue \u0026 0xFF);\n        tempValue \u003e\u003e= 8;\n\n        result = (result \u003c\u003c 8) | (tempValue \u0026 0xFF);\n        tempValue \u003e\u003e= 8;\n\n        result = (result \u003c\u003c 8) | (tempValue \u0026 0xFF);\n        tempValue \u003e\u003e= 8;\n\n        assert(0 == tempValue); // fully converted\n        result \u003c\u003c= (24 * 8);\n    }\n\n    /// @notice Returns the minimum value\n    /// @param _a First value\n    /// @param _b Second value\n    /// @return Smallest value between _a and _b\n    function min(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        return (_a \u003e _b ? _b : _a);\n    }\n\n    /// @notice Returns the max value\n    /// @param _a First value\n    /// @param _b Second value\n    /// @return Highest value between _a and _b\n    function max(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        return (_a \u003c _b ? _b : _a);\n    }\n\n    /// @notice Performs a ceiled division\n    /// @param _a Numerator\n    /// @param _b Denominator\n    /// @return ceil(_a / _b)\n    function ceil(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        return (_a / _b) + (_a % _b \u003e 0 ? 1 : 0);\n    }\n}\n"
    },
    "contracts/src/libraries/LibUnstructuredStorage.sol": {
      "content": "// SPDX-License-Identifier:    MIT\n\npragma solidity 0.8.10;\n\n/// @title Lib Unstructured Storage\n/// @notice Utilities to work with unstructured storage\nlibrary LibUnstructuredStorage {\n    /// @notice Retrieve a bool value at a storage slot\n    /// @param _position The storage slot to retrieve\n    /// @return data The bool value\n    function getStorageBool(bytes32 _position) internal view returns (bool data) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            data := sload(_position)\n        }\n    }\n\n    /// @notice Retrieve an address value at a storage slot\n    /// @param _position The storage slot to retrieve\n    /// @return data The address value\n    function getStorageAddress(bytes32 _position) internal view returns (address data) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            data := sload(_position)\n        }\n    }\n\n    /// @notice Retrieve a bytes32 value at a storage slot\n    /// @param _position The storage slot to retrieve\n    /// @return data The bytes32 value\n    function getStorageBytes32(bytes32 _position) internal view returns (bytes32 data) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            data := sload(_position)\n        }\n    }\n\n    /// @notice Retrieve an uint256 value at a storage slot\n    /// @param _position The storage slot to retrieve\n    /// @return data The uint256 value\n    function getStorageUint256(bytes32 _position) internal view returns (uint256 data) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            data := sload(_position)\n        }\n    }\n\n    /// @notice Sets a bool value at a storage slot\n    /// @param _position The storage slot to set\n    /// @param _data The bool value to set\n    function setStorageBool(bytes32 _position, bool _data) internal {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(_position, _data)\n        }\n    }\n\n    /// @notice Sets an address value at a storage slot\n    /// @param _position The storage slot to set\n    /// @param _data The address value to set\n    function setStorageAddress(bytes32 _position, address _data) internal {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(_position, _data)\n        }\n    }\n\n    /// @notice Sets a bytes32 value at a storage slot\n    /// @param _position The storage slot to set\n    /// @param _data The bytes32 value to set\n    function setStorageBytes32(bytes32 _position, bytes32 _data) internal {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(_position, _data)\n        }\n    }\n\n    /// @notice Sets an uint256 value at a storage slot\n    /// @param _position The storage slot to set\n    /// @param _data The uint256 value to set\n    function setStorageUint256(bytes32 _position, uint256 _data) internal {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(_position, _data)\n        }\n    }\n}\n"
    },
    "contracts/src/state/redeemManager/BufferedExceedingEth.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\n\n/// @title Buffered Exceeding Eth storage\n/// @notice Redeen Manager utility to manage the exceeding ETH with a redeem request\nlibrary BufferedExceedingEth {\n    /// @notice Storage slot of the Redeem Buffered Eth\n    bytes32 internal constant BUFFERED_EXCEEDING_ETH_SLOT =\n        bytes32(uint256(keccak256(\"river.state.bufferedExceedingEth\")) - 1);\n\n    /// @notice Retrieve the Redeem Buffered Eth Value\n    /// @return The Redeem Buffered Eth Value\n    function get() internal view returns (uint256) {\n        return LibUnstructuredStorage.getStorageUint256(BUFFERED_EXCEEDING_ETH_SLOT);\n    }\n\n    /// @notice Sets the Redeem Buffered Eth Value\n    /// @param newValue The new value\n    function set(uint256 newValue) internal {\n        LibUnstructuredStorage.setStorageUint256(BUFFERED_EXCEEDING_ETH_SLOT, newValue);\n    }\n}\n"
    },
    "contracts/src/state/redeemManager/RedeemDemand.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\n\n/// @title Redeem Demand storage\n/// @notice Redeem Manager utility to store the current demand in LsETH\nlibrary RedeemDemand {\n    /// @notice Storage slot of the Redeem Demand\n    bytes32 internal constant REDEEM_DEMAND_SLOT = bytes32(uint256(keccak256(\"river.state.redeemDemand\")) - 1);\n\n    /// @notice Retrieve the Redeem Demand Value\n    /// @return The Redeem Demand Value\n    function get() internal view returns (uint256) {\n        return LibUnstructuredStorage.getStorageUint256(REDEEM_DEMAND_SLOT);\n    }\n\n    /// @notice Sets the Redeem Demand Value\n    /// @param newValue The new value\n    function set(uint256 newValue) internal {\n        LibUnstructuredStorage.setStorageUint256(REDEEM_DEMAND_SLOT, newValue);\n    }\n}\n"
    },
    "contracts/src/state/redeemManager/RedeemQueue.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\n/// @title Redeem Manager Redeem Queue storage\n/// @notice Utility to manage the Redeem Queue in the Redeem Manager\nlibrary RedeemQueue {\n    /// @notice Storage slot of the Redeem Queue\n    bytes32 internal constant REDEEM_QUEUE_ID_SLOT = bytes32(uint256(keccak256(\"river.state.redeemQueue\")) - 1);\n\n    /// @notice The Redeemer structure represents the redeem request made by a user\n    struct RedeemRequest {\n        /// @custom:attribute The amount of the redeem request in LsETH\n        uint256 amount;\n        /// @custom:attribute The maximum amount of ETH redeemable by this request\n        uint256 maxRedeemableEth;\n        /// @custom:attribute The owner of the redeem request\n        address owner;\n        /// @custom:attribute The height is the cumulative sum of all the sizes of preceding redeem requests\n        uint256 height;\n    }\n\n    /// @notice Retrieve the Redeem Queue array storage pointer\n    /// @return data The Redeem Queue array storage pointer\n    function get() internal pure returns (RedeemRequest[] storage data) {\n        bytes32 position = REDEEM_QUEUE_ID_SLOT;\n        assembly {\n            data.slot := position\n        }\n    }\n}\n"
    },
    "contracts/src/state/redeemManager/WithdrawalStack.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\n/// @title Redeem Manager Withdrawal Stack storage\n/// @notice Utility to manage the Withdrawal Stack in the Redeem Manager\nlibrary WithdrawalStack {\n    /// @notice Storage slot of the Withdrawal Stack\n    bytes32 internal constant WITHDRAWAL_STACK_ID_SLOT = bytes32(uint256(keccak256(\"river.state.withdrawalStack\")) - 1);\n\n    /// @notice The Redeemer structure represents the withdrawal events made by River\n    struct WithdrawalEvent {\n        /// @custom:attribute The amount of the withdrawal event in LsETH\n        uint256 amount;\n        /// @custom:attribute The amount of the withdrawal event in ETH\n        uint256 withdrawnEth;\n        /// @custom:attribute The height is the cumulative sum of all the sizes of preceding withdrawal events\n        uint256 height;\n    }\n\n    /// @notice Retrieve the Withdrawal Stack array storage pointer\n    /// @return data The Withdrawal Stack array storage pointer\n    function get() internal pure returns (WithdrawalEvent[] storage data) {\n        bytes32 position = WITHDRAWAL_STACK_ID_SLOT;\n        assembly {\n            data.slot := position\n        }\n    }\n}\n"
    },
    "contracts/src/state/river/CLSpec.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\n/// @title Consensus Layer Spec Storage\n/// @notice Utility to manage the Consensus Layer Spec in storage\nlibrary CLSpec {\n    /// @notice Storage slot of the Consensus Layer Spec\n    bytes32 internal constant CL_SPEC_SLOT = bytes32(uint256(keccak256(\"river.state.clSpec\")) - 1);\n\n    /// @notice The Consensus Layer Spec structure\n    struct CLSpecStruct {\n        /// @custom:attribute The count of epochs per frame, 225 means 24h\n        uint64 epochsPerFrame;\n        /// @custom:attribute The count of slots in an epoch (32 on mainnet)\n        uint64 slotsPerEpoch;\n        /// @custom:attribute The seconds in a slot (12 on mainnet)\n        uint64 secondsPerSlot;\n        /// @custom:attribute The block timestamp of the first consensus layer block\n        uint64 genesisTime;\n        /// @custom:attribute The count of epochs before considering an epoch final on-chain\n        uint64 epochsToAssumedFinality;\n    }\n\n    /// @notice The structure in storage\n    struct Slot {\n        /// @custom:attribute The structure in storage\n        CLSpecStruct value;\n    }\n\n    /// @notice Retrieve the Consensus Layer Spec from storage\n    /// @return The Consensus Layer Spec\n    function get() internal view returns (CLSpecStruct memory) {\n        bytes32 slot = CL_SPEC_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value;\n    }\n\n    /// @notice Set the Consensus Layer Spec value in storage\n    /// @param _newCLSpec The new value to set in storage\n    function set(CLSpecStruct memory _newCLSpec) internal {\n        bytes32 slot = CL_SPEC_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        r.value = _newCLSpec;\n    }\n}\n"
    },
    "contracts/src/state/river/DailyCommittableLimits.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibSanitize.sol\";\n\n/// @title Daily Committable Limits storage\n/// @notice Utility to manage the Daily Committable Limits in storage\nlibrary DailyCommittableLimits {\n    /// @notice Storage slot of the Daily Committable Limits storage\n    bytes32 internal constant DAILY_COMMITTABLE_LIMITS_SLOT =\n        bytes32(uint256(keccak256(\"river.state.dailyCommittableLimits\")) - 1);\n\n    /// @notice The daily committable limits structure\n    struct DailyCommittableLimitsStruct {\n        uint128 minDailyNetCommittableAmount;\n        uint128 maxDailyRelativeCommittableAmount;\n    }\n\n    /// @notice The structure in storage\n    struct Slot {\n        /// @custom:attribute The structure in storage\n        DailyCommittableLimitsStruct value;\n    }\n\n    /// @notice Retrieve the Daily Committable Limits from storage\n    /// @return The Daily Committable Limits\n    function get() internal view returns (DailyCommittableLimitsStruct memory) {\n        bytes32 slot = DAILY_COMMITTABLE_LIMITS_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value;\n    }\n\n    /// @notice Set the Daily Committable Limits value in storage\n    /// @param _newValue The new value to set in storage\n    function set(DailyCommittableLimitsStruct memory _newValue) internal {\n        bytes32 slot = DAILY_COMMITTABLE_LIMITS_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        r.value = _newValue;\n    }\n}\n"
    },
    "contracts/src/state/river/ReportBounds.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\n/// @title Report Bounds Storage\n/// @notice Utility to manage the Report Bounds in storage\nlibrary ReportBounds {\n    /// @notice Storage slot of the Report Bounds\n    bytes32 internal constant REPORT_BOUNDS_SLOT = bytes32(uint256(keccak256(\"river.state.reportBounds\")) - 1);\n\n    /// @notice The Report Bounds structure\n    struct ReportBoundsStruct {\n        /// @custom:attribute The maximum allowed annual apr, checked before submitting a report to River\n        uint256 annualAprUpperBound;\n        /// @custom:attribute The maximum allowed balance decrease, also checked before submitting a report to River\n        uint256 relativeLowerBound;\n    }\n\n    /// @notice The structure in storage\n    struct Slot {\n        /// @custom:attribute The structure in storage\n        ReportBoundsStruct value;\n    }\n\n    /// @notice Retrieve the Report Bounds from storage\n    /// @return The Report Bounds\n    function get() internal view returns (ReportBoundsStruct memory) {\n        bytes32 slot = REPORT_BOUNDS_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        return r.value;\n    }\n\n    /// @notice Set the Report Bounds in storage\n    /// @param _newReportBounds The new Report Bounds value\n    function set(ReportBoundsStruct memory _newReportBounds) internal {\n        bytes32 slot = REPORT_BOUNDS_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        r.value = _newReportBounds;\n    }\n}\n"
    },
    "contracts/src/state/shared/RiverAddress.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibSanitize.sol\";\nimport \"../../libraries/LibUnstructuredStorage.sol\";\n\n/// @title River Address Storage\n/// @notice Utility to manage the River Address in storage\nlibrary RiverAddress {\n    /// @notice Storage slot of the River Address\n    bytes32 internal constant RIVER_ADDRESS_SLOT = bytes32(uint256(keccak256(\"river.state.riverAddress\")) - 1);\n\n    /// @notice Retrieve the River Address\n    /// @return The River Address\n    function get() internal view returns (address) {\n        return LibUnstructuredStorage.getStorageAddress(RIVER_ADDRESS_SLOT);\n    }\n\n    /// @notice Sets the River Address\n    /// @param _newValue New River Address\n    function set(address _newValue) internal {\n        LibSanitize._notZeroAddress(_newValue);\n        LibUnstructuredStorage.setStorageAddress(RIVER_ADDRESS_SLOT, _newValue);\n    }\n}\n"
    },
    "contracts/src/state/shared/Version.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../libraries/LibUnstructuredStorage.sol\";\n\n/// @title Version Storage\n/// @notice Utility to manage the Version in storage\nlibrary Version {\n    /// @notice Storage slot of the Version\n    bytes32 public constant VERSION_SLOT = bytes32(uint256(keccak256(\"river.state.version\")) - 1);\n\n    /// @notice Retrieve the Version\n    /// @return The Version\n    function get() internal view returns (uint256) {\n        return LibUnstructuredStorage.getStorageUint256(VERSION_SLOT);\n    }\n\n    /// @notice Sets the Version\n    /// @param _newValue New Version\n    function set(uint256 _newValue) internal {\n        LibUnstructuredStorage.setStorageUint256(VERSION_SLOT, _newValue);\n    }\n}\n"
    },
    "openzeppelin-contracts/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    }
  }
}